# SDK了解

这是一个基于RISC-V架构处理器的音频设备固件项目，主要包含两个产品方案：

1. ``earphone`` - 耳机方案
2. ``esop8`` - 充电仓方案

项目的主要特点：

- 使用RISC-V架构(rv32imacxbs1)的处理器
- 支持蓝牙功能，包括TWS(真无线立体声)配对
- 包含多种外设支持：
  - LED控制(包括呼吸灯效果)
  - 按键检测
  - 电池管理
  - 音频处理(DAC/EQ等)
  - 充电管理

项目结构：

- ``platform`` - 基础平台代码，包含BSP和通用功能
- ``projects``具体产品方案
  - 每个方案都有自己的配置文件(``config.h``)和插件模块
- 使用CodeBlocks IDE进行开发
- 编译后生成``.rv32``文件，然后通过后处理生成最终的``.bin``和``.dcf``文件

这个SDK看起来主要用于开发蓝牙音频相关的消费电子产品，具有完整的硬件抽象层和功能模块。

### 耳机方案 (Earphone)

这是一个TWS蓝牙耳机的方案，主要特点包括：

- 支持TWS（真无线立体声）功能，可以**实现左右耳机配对使用**
- 支持**蓝牙音乐播放（A2DP）**和**通话（HFP）功能**
- 支持入耳检测功能
- 支持触摸控制（TouchKey）
- 支持充电仓功能
- 支持ANC（主动降噪）功能（可配置）
- 支持语音提示功能
- 支持LED指示灯控制

### 充电仓方案 (ESOP8)

这是一个智能充电仓的方案，主要特点包括：

- 支持**为TWS耳机充电**
- 支持与耳机的通信（通过VUSB_SMART_VBAT_HOUSE_EN功能）
- 支持电池电量检测和管理
- 支持LED指示灯显示充电状态
- 支持按键控制功能

这两个方案是配套使用的，一个用于耳机本身，一个用于充电仓。从配置文件和项目结构来看，这是一个完整的TWS蓝牙耳机解决方案，包含了耳机和充电仓两部分。

耳机方案更加复杂，包含了音频处理、蓝牙连接、触摸控制等多种功能；而充电仓方案相对简单，主要负责为耳机充电和提供基本的状态指示。

两个方案都支持蓝牙功能，**但用途不同：耳机方案的蓝牙主要用于与手机等设备连接以及TWS配对；充电仓方案的蓝牙主要用于与耳机通信，实现智能充电仓功能。**

# 耳机方案

## 启动流程

### 系统初始化阶段

#### 入口点：main函数

```c
int main(void)
{
    printf("Hello AB565XA3: %x\n", LVDCON);
    bsp_sys_init();    // 系统初始化
    func_run();        // 功能运行
    return 0;
}
```

#### 系统初始化：bsp_sys_init()

```c
void bsp_sys_init(void)
{
    /// config
    bsp_xcfg_init();

    // io init
    bsp_io_init();

    // var init
    bsp_var_init();

    // power init
    pmu_init(BUCK_MODE_EN*xcfg_cb.buck_mode_en);

    // clock init
    adpll_init(DAC_OUT_SPR);                                //要放在pmu_init之后
    sys_clk_set(SYS_CLK_SEL);

    // peripheral init
    rtc_init();
#if SYS_PARAM_EEPROM
    eeprom_init();
#endif // SYS_PARAM_EEPROM
    param_init(sys_cb.rtc_first_pwron);

#if IODM_TEST_MODE
    iodm_init();
    iodm_reflash_bt_name();
#endif

    sw_reset_flag_get();
    tws_lr_xcfg_sel();                                      //TWS声道初始化, 放在param_init之后
    plugin_popup_auto_config();                             //popup初始化，放在param_init之后
    x26m_cap_tune();                                        //26M晶振电容配置

    clkgate_configure();

#if CHARGE_EN
    if (xcfg_cb.charge_en) {
        bsp_charge_init();
    }
#endif // CHARGE_EN

#if SYS_SUPPORT_DONGLE_EN
    dongle_check_key();
#endif

#if LINEIN_2_PWRDOWN_EN
    if (sys_cb.sleep_dac_en) {
        dac_power_off_pulldown_daclr();
    }
#endif

    led_init();
    key_init();

#if LED_188LED_DISP_EN
    bsp_188led_gpio_init();
    bsp_188led_var_init();
#endif

#if PWM_RGB_EN
    pwm_init();
#endif // PWM_RGB_EN
    plugin_init();

    /// enable user timer for display & dac
    user_tmr_set_enable(1, 1);

    led_power_up();
    motor_enable(MOTOR_PWRON, T_MOTOR_PWRON_SEL);         //开机马达振动

#if BT_LIGHTNINIG_EN
    if (xcfg_cb.lt_sa_en) {
        lt_uart_tx_auth_start();
        if (xcfg_cb.lt_chg_en) {
            lt_charge_init();
        }
    }
#endif

    bt_init();
    bt_work_mode_init();
    if (!xcfg_cb.bt_init_fast_dis) {                    //是否蓝牙提前初始化，可以加速回连
        func_bt_init();
    }
    dac_init();
#if VUSB_TBOX_QTEST_EN
    qtest_create_env();
#endif

#if ANC_EN
    bsp_anc_init();
	bsp_anc_set_mode(1);
#endif

    bsp_change_volume(sys_cb.vol);

#if LINEIN_2_PWRDOWN_EN
    if (xcfg_cb.linein_2_pwrdown_en) {
        delay_5ms(60);
        if (device_is_online(DEV_LINEIN)) {
            sys_cb.pwrdwn_tone_en = LINEIN_2_PWRDOWN_TONE_EN;
            func_cb.sta = FUNC_PWROFF;
            return;
        }
    }
#endif // LINEIN_2_PWRDOWN_EN

#if WARNING_POWER_ON
    if ((xcfg_cb.bt_outbox_voice_pwron_en) || (!sys_cb.outbox_pwron_flag)) {
        mic_bias_trim_w4_done_do();
        sys_warning_play(T_WARNING_POWER_ON, PIANO_POWER_ON);
    }
    sys_cb.outbox_pwron_flag = 0;
#endif // WARNING_POWER_ON

#if FUNC_AUX_EN
    if ((xcfg_cb.func_aux_en) && (!xcfg_cb.linein_2_pwrdown_en)) {
        if (device_is_online(DEV_LINEIN)) {
            func_cb.sta = FUNC_AUX;
            return;
        }
    }
#endif // FUNC_AUX_EN

    func_cb.sta = FUNC_BT;

#if EQ_DBG_IN_UART || EQ_DBG_IN_SPP
    eq_dbg_init();
#endif // EQ_DBG_IN_UART

}
```

系统初始化函数`bsp_sys_init()`是整个启动流程的核心，它完成了以下工作：

1. 配置初始化：`bsp_xcfg_init()`

   - 初始化电压Trim值
   - 设置默认配置
   - 更新蓝牙名称

2. IO初始化：`bsp_io_init()`

   - 配置GPIO端口

3. 变量初始化：`bsp_var_init()`

   - 初始化系统控制块`sys_cb`
   - 初始化音量设置
   - 初始化各种功能模块的变量

4. 电源初始化：`pmu_init()`

   - 根据配置初始化电源管理单元

5. 时钟初始化：

   - `adpll_init()`：初始化音频PLL
   - `sys_clk_set()`：设置系统时钟

6. 外设初始化：

   - `rtc_init()`：实时时钟初始化
   - `eeprom_init()`：EEPROM初始化（如果启用）
   - `param_init()`：参数初始化，包括音量、语言等

7. TWS声道初始化：

   `tws_lr_xcfg_sel()`

   - 初始化TWS左右声道配置

8. **充电初始化**：`bsp_charge_init()`（如果启用）

9. LED和按键初始化：

   - `led_init()`
   - `key_init()`

10. 定时器启用：

    `user_tmr_set_enable(1, 1)`

    - 启用5ms和1ms定时器

11. 蓝牙初始化：

    - `bt_init()`：初始化蓝牙核心
    - `bt_work_mode_init()`：初始化蓝牙工作模式
    - `func_bt_init()`：初始化蓝牙功能（如果未禁用快速初始化）

12. **DAC初始化**：`dac_init()`

13. ANC初始化（如果启用）：

    - `bsp_anc_init()`
    - `bsp_anc_set_mode(1)`

14. **音量设置**：`bsp_change_volume(sys_cb.vol)`

15. 开机提示音播放（如果启用）：

    - `sys_warning_play(T_WARNING_POWER_ON, PIANO_POWER_ON)`

16. 设置初始功能模式：

    - 默认设置为蓝牙模式：`func_cb.sta = FUNC_BT`
    - 如果检测到AUX设备在线，则设置为AUX模式（如果启用）

### 功能运行阶段：func_run()

`func_run()`函数是一个无限循环，根据`func_cb.sta`的值来决定执行哪个功能模式：

`app\platform\functions\func.c`

**这一些宏都在config.h中配置。**

```c
void func_run(void)
{
    printf("%s\n", __func__);

    func_bt_chk_off();
    while (1) {
        func_clear();

        switch (func_cb.sta) {
#if FUNC_BT_EN
        case FUNC_BT:
            func_bt();
            break;
#endif

#if BT_DUT_TEST_EN
        case FUNC_BT_DUT:
            func_bt_dut();
            break;
#endif

#if FUNC_BTHID_EN
        case FUNC_BTHID:
            func_bthid();
            break;
#endif // FUNC_BTHID_EN

#if FUNC_AUX_EN
        case FUNC_AUX:
            func_aux();
            break;
#endif // FUNC_AUX_EN

#if FUNC_SPEAKER_EN
        case FUNC_SPEAKER:
            func_speaker();
            break;
#endif // FUNC_SPEAKER_EN

        case FUNC_PWROFF:
            func_pwroff(sys_cb.pwrdwn_tone_en);
            break;

#if BT_FCC_TEST_EN
        case FUNC_BT_FCC:
            func_bt_fcc();
            break;
#endif // BT_FCC_TEST_EN

        default:
            func_exit();
            break;
        }
    }
}
```

### 蓝牙功能模式：func_bt()

由于默认进入蓝牙模式，`func_bt()`是最常用的功能函数：

```c
void func_bt(void)
{
    printf("%s\n", __func__);

    func_bt_enter();

    while (func_cb.sta == FUNC_BT) {
        func_bt_process();
        func_bt_message(msg_dequeue());
    }

    func_bt_exit();
}
```

蓝牙功能模式的处理流程：

1. 进入蓝牙模式：

   `func_bt_enter()`

   - 初始化蓝牙相关变量
   - 启动蓝牙功能
   - 播放蓝牙模式提示音（如果启用）

2. 蓝牙处理循环：

   - `func_bt_process()`：处理蓝牙状态、连接、音频等
   - `func_bt_message(msg_dequeue())`：处理消息队列中的消息

3. 特殊状态处理：

   - 来电处理：`sfunc_bt_ring()`
   - 通话处理：`sfunc_bt_call()`
   - 低电量处理
   - 睡眠处理

4. 退出蓝牙模式：`func_bt_exit()`

   - 清理蓝牙资源
   - 保存状态

## 消息处理机制

整个系统通过消息队列来处理各种事件：

1. **消息入队**：各种事件（如按键、蓝牙事件等）会生成消息并入队
2. 消息出队和处理：
   - `msg_dequeue()`：从消息队列中取出消息
   - 各功能模式有自己的消息处理函数，如`func_bt_message()`
     - **不同的模式对应的消息事件处理逻辑肯定不一样。**
3. 常见消息类型：
   - 按键消息（短按、长按、双击等）
   - 蓝牙连接/断开消息
   - 充电状态消息
   - 低电量消息

## 可扩展的关键点

基于以上分析，以下是您可以手动扩展功能的关键点：

1. 自定义初始化：
   - 在`bsp_sys_init()`后面添加自己的初始化代码
   - 创建自己的初始化函数并在适当位置调用
2. 自定义消息处理：
   - 扩展消息处理函数，如`func_bt_message()`
   - 添加新的消息类型和处理逻辑
3. 自定义功能模式：
   - 添加新的功能模式（如游戏模式、低延迟模式等）
   - 在`func_run()`中添加对应的case分支
4. 自定义按键功能：
   - 修改按键映射和处理逻辑
   - 添加多击、组合键等高级功能
5. 自定义音频处理：
   - 添加自定义EQ设置
   - 添加音频效果处理
6. 自定义LED指示：
   - 修改LED指示逻辑
   - 添加新的LED状态和模式
7. 自定义电源管理：
   - 修改低电量处理逻辑
   - 自定义睡眠和唤醒条件
8. 自定义TWS功能：
   - 修改TWS配对和连接逻辑
   - 添加TWS特殊功能

# 耳机方案的默认配置

所有的功能宏都在config,h中定义。

## bsp_sys_init() 函数

这是系统初始化函数，是整个耳机SDK的核心初始化入口。它完成了所有硬件和软件模块的初始化工作，包括：

1. **配置初始化**：加载系统配置，包括电压Trim值、默认配置、蓝牙名称等
2. **IO初始化**：配置GPIO端口
3. **变量初始化**：初始化系统控制块和各种功能模块变量
4. **电源初始化**：根据配置初始化电源管理单元
5. **时钟初始化**：设置系统时钟
6. **外设初始化**：初始化RTC、EEPROM等外设
7. **启用用户定时器**：启用5ms和1ms定时器，用于显示和DAC
8. **蓝牙初始化**：初始化蓝牙模块和工作模式
9. **音频初始化**：初始化DAC和音量设置
10. **设置默认功能模式**：默认进入蓝牙模式

## func_run() 函数

这是功能运行函数，是整个耳机SDK的主循环入口。它是一个无限循环，根据`func_cb.sta`的值来决定执行哪个功能模式：

1. **蓝牙模式(FUNC_BT)**：默认启用，是系统的主要工作模式
2. **蓝牙DUT测试模式(FUNC_BT_DUT)**：默认不启用，用于蓝牙测试
3. **蓝牙HID模式(FUNC_BTHID)**：默认不启用，用于自拍器等功能
4. **AUX模式(FUNC_AUX)**：默认不启用，用于线路输入功能
5. **Speaker模式(FUNC_SPEAKER)**：默认不启用
6. **关机模式(FUNC_PWROFF)**：始终可用，不受条件编译控制
7. **蓝牙FCC测试模式(FUNC_BT_FCC)**：默认不启用，用于FCC认证测试

## 默认开启的功能

根据config.h中的配置，默认开启的主要功能有：

1. **蓝牙功能(FUNC_BT_EN = 1)**：系统默认支持蓝牙功能
2. **BUCK模式(BUCK_MODE_EN = 1)**：电源管理使用BUCK模式
3. **EEPROM记忆(SYS_PARAM_EEPROM = 1)**：支持参数保存到EEPROM
4. **RTCRAM参数保存(SYS_PARAM_RTCRAM = 1)**：支持参数保存到RTCRAM
5. **电池电量检测(VBAT_DETECT_EN = 1)**：支持电池电量检测
6. **Linein检测(LINEIN_DETECT_EN = 1)**：支持Linein插入检测
7. **Linein插入关机(LINEIN_2_PWRDOWN_EN = 1)**：插入Linein后直接软关机（大耳包功能）

## 默认进入的模式

系统默认进入**蓝牙模式(FUNC_BT)**。这是在`bsp_sys_init()`函数的最后设置的：

```c
func_cb.sta = FUNC_BT;  // 默认进入蓝牙模式
```

如果检测到特定条件，系统可能会进入其他模式：

1. 如果启用了LINEIN_2_PWRDOWN_EN并检测到Linein插入，会进入关机模式(FUNC_PWROFF)
2. 如果启用了FUNC_AUX_EN并检测到Linein插入，会进入AUX模式(FUNC_AUX)

**进入模式的两个要素：在config.h中进行了宏定义使能，第二个是func_cb.sta的值要是对应的功能才行。**

# 主循环入口

`func_run()`函数确实是一个基于状态机的轮询模型，它根据`func_cb.sta`的值来决定执行哪个功能模式。

## 状态机工作原理-

1. 状态机结构：
   - `func_cb.sta`是状态变量，表示当前的功能模式
   - `switch`语句根据这个状态变量切换到不同的功能处理函数
   - 每个功能处理函数（如`func_bt()`、`func_aux()`等）都是一个子状态机
2. 默认状态：
   - 在`bsp_sys_init()`函数的最后，默认设置`func_cb.sta = FUNC_BT;`，所以系统启动后默认进入蓝牙模式
   - 这就是为什么您感觉它"一直都是FUNC_BT，一直都进入蓝牙模式"
3. 状态切换：
   - 虽然默认是蓝牙模式，**但`func_cb.sta`的值可以在运行时改变**
   - **状态切换可以由以下几种方式触发：**
     - **用户按键（如按MODE键切换模式）**
     - **外部事件（如插入Linein线）**
     - **系统事件（如低电量自动关机）**
   - **但是其他的模式宏在config.h中没有定义，就算状态改变了也没用。**

## 状态切换示例

### **按键切换模式**

```c
case KU_MODE:
case KU_MODE_PWR:
#if FUNC_AUX_EN || FUNC_SPEAKER_EN || FUNC_MUSIC_EN
    func_cb.sta = FUNC_NULL;  // 设置为NULL，会通过func_exit()切换到下一个模式
#endif
    break;
```

### **插入Linein切换到AUX模式**

```c
case EVT_LINEIN_INSERT:
    if (device_is_online(DEV_LINEIN)) {
        if (xcfg_cb.linein_2_pwrdown_en) {
            sys_cb.pwrdwn_tone_en = LINEIN_2_PWRDOWN_TONE_EN;
            func_cb.sta = FUNC_PWROFF;  // 切换到关机模式
        } else {
            func_cb.sta = FUNC_AUX;     // 切换到AUX模式
        }
    }
    break;
```

### **耳机入仓关机**

```c
case EVT_CHARGE_INBOX:
    sys_cb.pwrdwn_tone_en = 0;
    sys_cb.inbox_pwrdwn_flag = 1;
    bsp_charge_inbox_wakeup_enable();
    func_cb.sta = FUNC_PWROFF;  // 切换到关机模式
    break;
```

## 子状态机

每个功能模式（如`func_bt()`）本身也是一个子状态机，例如：

```c
void func_bt(void)
{
    printf("%s\n", __func__);

    func_bt_enter();  // 进入蓝牙模式的初始化

    while (func_cb.sta == FUNC_BT) {  // 只要状态没变，就一直在这个循环中
        func_bt_process();  // 处理蓝牙相关的周期性任务
        func_bt_message(msg_dequeue());  // 处理蓝牙相关的消息
    }

    func_bt_exit();  // 退出蓝牙模式的清理工作
}
```

这个子状态机会一直运行，直到`func_cb.sta`的值被改变（比如用户按了MODE键切换模式），然后它会退出循环，执行清理工作，控制权返回到`func_run()`，然后`func_run()`会根据新的`func_cb.sta`值进入另一个功能模式。

## 总结

1. 是的，这是一个典型的状态机轮询模型
2. 默认情况下，`func_cb.sta = FUNC_BT`，所以系统会进入蓝牙模式
3. 但`func_cb.sta`的值可以在运行时改变，触发状态切换
4. **每个功能模式本身也是一个子状态机，处理该模式下的所有事件和任务**

这种设计使得系统可以灵活地在不同功能模式之间切换，同时保持代码的模块化和可维护性。如果您想添加新的功能模式，只需要：

1. 在` config.h`中添加新的功能使能宏
2. 在` func.h`中添加新的功能模式枚举值
3. 实现新的功能处理函数
4. 在`func_run()`中添加对应的case分支

这样就可以无缝地集成到现有的状态机框架中。

# 父子状态机的exit()作用

## 模式选择中的状态机中的`func_exit()`

`func_exit()`函数的主要作用是**在大状态机中切换到下一个可用的功能模式**。

```c
void func_exit(void)
{
    u8 func_num;
    u8 funcs_total = get_funcs_total();

    // 在功能排序表中找到上一个功能的位置
    for (func_num = 0; func_num != funcs_total; func_num++) {
        if (func_cb.last == func_sort_table[func_num]) {
            break;
        }
    }
    func_num++;                                     // 切换到下一个任务
    if (func_num >= funcs_total) {
        func_num = 0;
    }
    func_cb.sta = func_sort_table[func_num];        // 设置新的任务
}
```

这个函数的工作流程是：

1. 在功能排序表`func_sort_table`中找到上一个功能模式的位置
2. 将索引加1，切换到下一个功能模式
3. 如果已经到达表的末尾，则回到表的开始
4. 将新的功能模式设置为当前状态`func_cb.sta`

**当大状态机遇到未知模式或未启用的模式时，会调用这个函数来切换到下一个可用的功能模式，确保系统不会卡在无效状态。**

## 子状态机中的`func_bt_exit()`

`func_bt_exit()`函数的主要作用是**在退出蓝牙模式时进行清理工作**。

```c
void func_bt_exit(void)
{
    bt_ring_tone_stop(1);                // 停止蓝牙铃声
#if DAC_DNR_EN
    dac_dnr_set_sta(0);                  // 关闭DAC动态降噪
#endif
    bsp_change_volume(sys_cb.vol);       // 恢复系统音量
#if BT_PWRKEY_5S_DISCOVER_EN
    bsp_bt_pwrkey5s_clr();               // 清除长按电源键5秒进入配对模式的标志
#endif
    tws_res_reset();                     // 重置TWS资源
    dis_auto_pwroff();                   // 禁用自动关机
    ble_popup_ctrl(0);                   // 关闭BLE弹窗控制
    bt_disconnect();                     // 断开蓝牙连接

    dac_fade_out();                      // DAC淡出
    bt_audio_bypass();                   // 蓝牙音频旁路
    bt_off();                            // 关闭蓝牙
#if LED_BREATHE_EN
    if (sys_cb.breathe_led_sta >= T_BRE_TWS_CON) {
        breathe_led_stop();              // 停止LED呼吸灯
    }
#endif
    if (get_music_dec_sta() != MUSIC_STOP) {
        music_control(MUSIC_MSG_STOP);   // 停止音乐播放
    }
    func_bt_set_dac(1);                  // 设置DAC
    if (sys_cb.pwroff_tick) {
        bt_exit_wait_ticks(sys_cb.pwroff_tick); // 等待关机计时
        sys_cb.pwroff_tick = 0;
    }
    f_bt.ring_sta = 0;                   // 清除铃声状态
    f_bt.ring_stop = 0;
    f_bt.disp_status = BT_STA_OFF;       // 设置蓝牙状态为关闭
    f_bt.bt_is_inited = 0;               // 清除蓝牙初始化标志
    func_cb.last = FUNC_BT;              // 记录上一个功能模式为蓝牙
}
```

这个函数的工作流程是：

1. 停止所有与蓝牙相关的活动（铃声、音乐播放等）
2. 关闭蓝牙相关的硬件（DAC、蓝牙模块等）
3. 重置蓝牙相关的状态变量
4. 记录上一个功能模式为蓝牙（`func_cb.last = FUNC_BT`）

**当系统从蓝牙模式切换到其他模式时，会调用这个函数来确保蓝牙模式的所有资源都被正确释放，并为下一个模式做好准备。**

## 两者的区别和联系

### 区别

1. 作用范围不同：
   - `func_exit()`作用于大状态机，负责在不同功能模式之间切换
   - `func_bt_exit()`作用于蓝牙子状态机，负责蓝牙模式的清理工作
2. 调用时机不同：
   - `func_exit()`在遇到未知模式或未启用的模式时被调用
   - `func_bt_exit()`在退出蓝牙模式时被调用（无论是切换到其他模式还是关机）
3. 功能不同：
   - `func_exit()`主要是计算下一个功能模式并设置状态变量
   - `func_bt_exit()`主要是清理资源、关闭硬件、重置状态变量

### 联系

1. 状态传递：
   - `func_bt_exit()`会设置`func_cb.last = FUNC_BT`，记录上一个功能模式为蓝牙
   - `func_exit()`会使用`func_cb.last`来确定下一个功能模式
2. 执行顺序：
   - 当从蓝牙模式切换到其他模式时，先执行`func_bt_exit()`进行清理
   - 如果切换到的是未知模式，然后执行`func_exit()`来确定下一个有效的功能模式

## 子状态机的工作原理

蓝牙模式的子状态机（`func_bt()`）是这样工作的：

```c
void func_bt(void)
{
    printf("%s\n", __func__);

    func_bt_enter();  // 进入蓝牙模式，初始化资源

    while (func_cb.sta == FUNC_BT) {  // 只要状态没变，就一直在这个循环中
        func_bt_process();  // 处理蓝牙相关的周期性任务
        func_bt_message(msg_dequeue());  // 处理蓝牙相关的消息
    }

    func_bt_exit();  // 退出蓝牙模式，清理资源
}
```

1. **进入阶段**：`func_bt_enter()`初始化蓝牙模式所需的资源
2. **运行阶段**：循环执行`func_bt_process()`和`func_bt_message()`，处理蓝牙相关的任务和消息
3. 退出阶段：当func_cb.sta`不再是` FUNC_BT`时，退出循环并执行func_bt_exit()`清理资源

子状态机的退出条件是`func_cb.sta != FUNC_BT`，这通常是由某个消息处理函数改变`func_cb.sta`的值触发的，例如：

```c
case KU_MODE:  // 按下MODE键
    func_cb.sta = FUNC_NULL;  // 将状态设置为NULL，会触发退出蓝牙模式
    break;
```

## 总结

1. 大状态机的`func_exit()`：
   - 作用：在不同功能模式之间切换
   - 调用时机：遇到未知模式或未启用的模式时
   - 工作原理：根据上一个功能模式计算下一个有效的功能模式
2. 子状态机的`func_bt_exit()`：
   - 作用：清理蓝牙模式的资源
   - 调用时机：退出蓝牙模式时
   - 工作原理：停止活动、关闭硬件、重置状态变量、记录上一个模式

这种设计使得系统可以灵活地在不同功能模式之间切换，同时确保每个模式的资源都被正确管理。大状态机负责模式之间的切换，子状态机负责各自模式内的运行和资源管理。

# 蓝牙子状态机中的轮询处理函数

## `func_bt_process()` - 蓝牙模式的周期性任务处理函数

这个函数负责处理蓝牙模式下的周期性任务，主要包括：

1. 通用功能处理：
   - 喂狗（防止系统复位）
   - 电池电量检测
   - 按键检测等
2. 蓝牙特有功能处理：
   - 蓝牙状态更新
   - TWS（真无线立体声）连接管理
   - 电量信息同步等
3. 来电/通话状态处理：
   - 检测来电状态，进入来电子状态机
   - 检测通话状态，进入通话子状态机
   - 重置睡眠和关机延时
4. 自动关机处理：
   - 检测关机延时是否到期
   - 如果蓝牙未连接且延时到期，则进入关机模式
5. 睡眠处理：
   - 检测是否满足睡眠条件
   - 如果满足，则设置特殊状态值触发状态更新

这个函数是蓝牙模式下的"心脏"，负责维持蓝牙功能的正常运行，并处理各种状态变化。

## `func_bt_message()` - 蓝牙模式的消息处理函数

这个函数负责处理蓝牙模式下的各种消息，主要包括：

1. 按键消息处理：
   - 播放/暂停控制
   - 音量调节
   - 通话控制（接听、挂断、拒接等）
   - 语音助手（Siri）控制
   - 多击功能（双击、三击、四击、五击）
2. 系统消息处理：
   - 定时消息（如1秒定时消息）
   - 电池电量报告
3. 蓝牙事件消息处理：
   - 连接/断开事件
   - 音乐播放/停止事件
   - 来电/通话事件

这个函数是蓝牙模式下的"大脑"，负责响应用户操作和系统事件，执行相应的功能。

## 工作原理

蓝牙子状态机的工作原理是：

1. 轮询模式：
   - `func_bt()`函数中的主循环不断调用`func_bt_process()`和`func_bt_message(msg_dequeue())`
   - `func_bt_process()`处理周期性任务
   - `func_bt_message()`处理消息队列中的消息
2. 消息驱动：
   - 按键、定时器和蓝牙事件会产生消息
   - 消息进入消息队列
   - `msg_dequeue()`从队列中取出消息
   - `func_bt_message()`处理这些消息
3. 状态转换：
   - 根据消息和当前状态，可能会改变`func_cb.sta`的值
   - 当`func_cb.sta != FUNC_BT`时，退出蓝牙模式的主循环
   - 执行`func_bt_exit()`清理资源
   - 控制权返回到大状态机，进入新的功能模式

这种设计使得系统可以灵活地响应各种事件和用户操作，同时保持代码的模块化和可维护性。

## 两个函数的协同工作关系

`func_bt_process()`和`func_bt_message()`确实是相互配合的两个函数，它们共同构成了蓝牙模式下的状态机处理机制。我来详细解释一下它们的关系，并以耳机内置触摸按键为例说明它们是如何协同工作的。

### 基本职责分工

1. `func_bt_process()`：
   - 负责**检测和监控**系统状态
   - 执行周期性任务（如电量检测、状态更新等）
   - 检查是否有特定条件触发（如来电、低电量等）
   - 不直接处理用户输入，而是关注系统状态变化
2. `func_bt_message()`：
   - 负责**响应和处理**各种消息
   - 处理用户输入（如按键操作）
   - 处理系统事件（如蓝牙连接/断开）
   - 执行相应的功能逻辑（如播放/暂停音乐、接听/挂断电话等）

## 触摸按键处理的完整流程示例

让我以耳机内置触摸按键为例，详细说明这两个函数如何协同工作：

### 触摸按键检测阶段（硬件 → 消息队列）

当用户触摸耳机上的触摸区域时：

1. **硬件中断**：触摸传感器产生中断信号
2. **按键扫描**：`bsp_key_scan()`函数（在`func_bt_process()`中通过`func_process()`调用）检测到触摸事件
3. **消息生成**：根据触摸的时长和模式，生成相应的消息代码（如`KU_PLAY`表示短按播放键）
4. **消息入队**：将消息放入消息队列中

### 消息处理阶段（消息队列 → 功能执行）

消息进入队列后：

1. **消息出队**：`msg_dequeue()`函数从队列中取出消息
2. **消息分发**：`func_bt_message()`接收消息并进行处理
3. **功能执行**：根据消息类型执行相应的功能

## 具体例子：单击触摸区域播放/暂停音乐

### 按键检测阶段

在SDK中，触摸按键的检测是通过`bsp_key_scan()`函数完成的，该函数在`func_process()`中被调用：

```c
// 在func.c中的func_process函数
AT(.text.func.process)
void func_process(void)
{
    WDT_CLR();  // 喂狗
    
    // 电池电量检测
#if VBAT_DETECT_EN
    lowpower_vbat_process();
#endif

    // 其他系统处理...
    
    // 注意：这里没有直接调用bsp_key_scan()
    // 按键扫描是在系统的其他部分定期调用的
}
```

实际上，按键扫描是在系统的定时器中断中进行的，或者在主循环的其他部分调用。触摸按键的检测流程如下：

`app\platform\bsp\bsp_key.c`

- 定义在平台公共代码部分

```c
// 在bsp_key.c中
AT(.com_text.bsp.key)
u8 bsp_key_scan(void)
{
    u8 key_val;
    u16 key = NO_KEY;

    // 扫描按键
    key_val = key_scan();
    
    // 电池电量检测
#if VBAT_DETECT_EN
    sys_cb.vbat = get_vbat_val();
#endif

    // 处理按键值
#if USER_TKEY_SHORT_SLIDE
    key = bsp_key_slide_process(key_val);
#else
    key = bsp_key_process(key_val);
#endif

#if USER_TKEY_SLIDE
    key = bsp_tkey_slide_process(key);
#endif

    // 如果有有效按键，将消息放入队列
    if ((key != NO_KEY) && (!bsp_key_pwron_filter(key))) {
        // 防止重复发送HOLD消息的处理...
        
        // 将按键消息放入队列
        msg_enqueue(key);
    }
    return key_val;
}

// 触摸按键扫描函数
AT(.com_text.bsp.key)
u8 key_scan(void)
{
    u8 key_val = NO_KEY;

    if (!get_adc_val()) {
        return NO_KEY;
    }

#if USER_TKEY
#if USER_TKEY_SHORT_SLIDE
    key_val = bsp_short_slide_tkey_scan();
#else
    key_val = bsp_tkey_scan();  // 触摸按键扫描
#endif
#endif

    // 其他类型按键的扫描...
    
    return key_val;
}

// 触摸按键扫描的具体实现
AT(.com_text.bsp.tkey)
u8 bsp_tkey_scan(void)
{
    u8 key = NO_KEY;

    if (tkey_is_pressed()) {  // 检测触摸按键是否被按下
        // 根据配置返回不同的按键值
        key = (sys_cb.tkey_pwrdwn_en) ? KEY_PLAY_PWR_USER_DEF : KEY_PLAY_USER_DEF;
    }
#if (USER_TKEY_SLIDE || USER_TKEY_MULTI_EN)
    else {
        key = bsp_tkey_multi_scan();  // 多点触摸或滑动检测
    }
#endif
    return key;
}
```

### 消息处理阶段

一旦按键消息被放入队列，它会在蓝牙模式的主循环中被处理：

```c
// 在func_bt.c中
AT(.text.bfunc.bt)
void func_bt(void)
{
    printf("%s\n", __func__);

    func_bt_enter();  // 进入蓝牙模式

    while (func_cb.sta == FUNC_BT) {
        func_bt_process();  // 处理周期性任务
        func_bt_message(msg_dequeue());  // 从队列中取出消息并处理
    }

    func_bt_exit();  // 退出蓝牙模式
}

// 蓝牙模式的消息处理函数
AT(.text.bfunc.bt)
void func_bt_message(u16 msg)
{
    if (msg == NO_MSG || msg == MSG_SYS_1S) {
        func_bt_message_m(msg);  // 处理特殊消息
    } else {
        func_bt_message_do(msg);  // 处理普通消息
    }
}

// 蓝牙模式的具体消息处理
void func_bt_message_do(u16 msg)
{
    int klu_flag = 0;
    u8 ku_sel = xcfg_cb.user_def_ks_sel;

    switch (msg) {
    case KU_PLAY:  // 播放键短按
        ku_sel = UDK_PLAY_PAUSE;
    case KU_PLAY_USER_DEF:
    case KU_PLAY_PWR_USER_DEF:  // 触摸按键短按
        if (!bt_nor_is_connected()) {
            bt_tws_pair_mode(3);  // 未连接时尝试TWS配对
            break;
        }
        user_def_key_msg(ku_sel);  // 调用用户定义的按键处理函数
        break;
        
    // 其他消息处理...
    }
}

// 用户定义的按键处理函数
bool user_def_key_msg(u8 func_sel)
{
    // ...
    if (func_sel == UDK_PLAY_PAUSE) {
        return user_def_play_pause_msg();  // 播放/暂停功能
    }
    // ...
}

// 播放/暂停功能实现（底层实现，不可见）
bool user_def_play_pause_msg(void)
{
    if (bt_get_status() >= BT_STA_CONNECTED) {
        if (bt_get_sco_status() == 0) {
            if (bt_music_is_playing()) {
                bt_music_pause();  // 如果正在播放，则暂停
            } else {
                bt_music_play();   // 如果已暂停，则播放
            }
            return true;
        }
    }
    return false;
}
```

### 状态更新阶段

在执行完功能后，系统会更新状态并反馈给用户：

```c
// 在func_bt_process()中通过func_bt_sub_process()调用
void func_bt_disp_status(void)
{
    uint status = bt_get_disp_status();

    if(f_bt.disp_status != status) {
        f_bt.disp_status = status;
        func_bt_disp_status_do();  // 更新显示状态
    }
    // ...
}

void func_bt_disp_status_do(void)
{
    // ...
    switch (f_bt.disp_status) {
    // ...
    case BT_STA_PLAYING:
        led_bt_play();  // 更新LED显示为播放状态
        break;
    // ...
    }
}
```

## 完整流程总结

基于实际代码，触摸按键处理的完整流程是：

1. 触摸检测：
   - 系统定期调用`bsp_key_scan()`
   - `bsp_key_scan()` → `key_scan()` → `bsp_tkey_scan()` → `tkey_is_pressed()`检测触摸事件
   - 如果检测到触摸，生成`KEY_PLAY_USER_DEF`或`KEY_PLAY_PWR_USER_DEF`消息
   - 通过`msg_enqueue()`将消息放入队列
2. 消息处理：
   - 在`func_bt()`的主循环中，`msg_dequeue()`从队列取出消息
   - `func_bt_message()` → `func_bt_message_do()`处理消息
   - 根据消息类型调用相应的处理函数，如`user_def_key_msg()` → `user_def_play_pause_msg()`
   - 执行具体功能，如播放/暂停音乐
3. 状态更新：
   - 功能执行后，状态变化会在下一个循环中被`func_bt_process()` → `func_bt_sub_process()` → `func_bt_disp_status()`检测到
   - 更新LED显示或其他用户界面反馈

这个流程清晰地展示了`func_bt_process()`和`func_bt_message()`如何协同工作：前者负责检测状态变化和执行周期性任务，后者负责处理用户输入和系统事件，两者共同构成了一个完整的事件-响应循环。

在这个SDK中，触摸按键是通过专门的触摸检测硬件实现的，支持单点触摸、多点触摸和滑动手势，可以根据配置实现不同的功能。

# 蓝牙耳机的触摸按键的复用机制

## 基本工作原理

蓝牙耳机上的单一触摸按键复用是通过以下几个关键步骤实现的：

1. **按键事件检测**：系统首先检测物理按键动作（单击、双击、长按等）并生成对应的按键事件
2. **状态判断**：系统判断当前耳机所处的状态（如音乐播放、通话中、来电等）
3. **消息分发**：根据当前状态，将按键事件分发到不同的处理函数
4. **功能执行**：对应的处理函数执行特定功能

## 详细实现流程

### 按键事件检测与生成

触摸按键的检测主要在 `bsp_tkey.c`和`bsp_key.c`中实现：

- 系统通过`bsp_tkey_scan()`函数扫描触摸按键状态
- 按键事件根据按下时长和方式被分类为：
  - 单击（KEY_SHORT）
  - 双击（KEY_DOUBLE）
  - 三击（KEY_THREE）
  - 四击（KEY_FOUR）
  - 五击（KEY_FIVE）
  - 长按（KEY_LONG）
  - 长按释放（KEY_LONG_UP）
  - 持续按住（KEY_HOLD）

这些事件会被转换为特定的消息代码，如`KU_PLAY_USER_DEF`（单击播放键）、`KD_PLAY_USER_DEF`（双击播放键）、`KL_PLAY_USER_DEF`（长按播放键）等。

### 消息队列机制

检测到的按键事件会通过消息队列机制传递给系统：

```c
// 如果有有效按键，将消息放入队列
if ((key != NO_KEY) && (!bsp_key_pwron_filter(key))) {
    // 防止enqueue多次HOLD消息的处理...
    msg_enqueue(key);  // 将按键消息放入队列
}
```

系统的主循环会不断从消息队列中获取消息并处理：

```c
while (func_cb.sta == FUNC_BT) {
    func_bt_process();  // 处理蓝牙相关的周期性任务
    func_bt_message(msg_dequeue());  // 处理蓝牙相关的消息
}
```

### 状态判断与消息分发

系统根据当前状态将消息分发到不同的处理函数：

- **普通蓝牙模式**：消息由`func_bt_message()`处理
- **来电状态**：消息由`sfunc_bt_ring_message()`处理
- **通话状态**：消息由`sfunc_bt_call_message()`处理

这是在`func_bt_process()`函数中实现的：

```c
// 来电/通话状态处理
if(f_bt.disp_status == BT_STA_INCOMING) {
    // 来电状态：进入来电子状态机
    sfunc_bt_ring();
    // ...
} else if(f_bt.disp_status >= BT_STA_OUTGOING) {
    // 通话状态：进入通话子状态机
    sfunc_bt_call();
    // ...
}
```

### 不同状态下的按键处理

每个状态下的消息处理函数都有自己的消息处理逻辑：

#### 普通蓝牙模式（音乐播放状态）

在`func_bt_message_do()`中处理按键消息

```c
switch (msg) {
case KU_PLAY:
    ku_sel = UDK_PLAY_PAUSE;
case KU_PLAY_USER_DEF:
case KU_PLAY_PWR_USER_DEF:
    if (!bt_nor_is_connected()) {
        bt_tws_pair_mode(3);  // 单击PLAY按键手动配对
        break;
    }
    user_def_key_msg(ku_sel);  // 播放/暂停音乐
    break;

// 双击按键处理
case KD_PLAY_USER_DEF:
case KD_PLAY_PWR_USER_DEF:
    // 处理双击...
    user_def_key_msg(xcfg_cb.user_def_kd_sel);
    break;

// 长按按键处理
case KL_PLAY_USER_DEF:
case KL_PLAY_PWR_USER_DEF:
    // 处理长按...
    user_def_key_msg(xcfg_cb.user_def_kl_sel);
    break;
    
// 其他按键事件处理...
}
```

#### 来电状态

在`sfunc_bt_ring_message_do()`中处理按键消息：

```c
switch (msg) {
case KU_HSF:                // 接听
    ku_sel = UDK_PLAY_PAUSE;
case KU_PLAY_USER_DEF:
case KU_PLAY_PWR_USER_DEF:
    user_def_key_msg(ku_sel);  // 接听电话
    break;

case KL_PLAY_USER_DEF:
case KL_HSF:
    if (xcfg_cb.user_def_kl_reject_en || msg == KL_HSF) {
        bt_ring_reject();  // 拒接电话
    } else {
        user_def_key_msg(xcfg_cb.user_def_kl_sel);
    }
    break;

// 其他按键事件处理...
}
```

#### 通话状态

在`sfunc_bt_call_message_do()`中处理按键消息：

```c
switch (msg) {
case KU_HSF:
    ku_sel = UDK_PLAY_PAUSE;
case KU_PLAY_USER_DEF:
case KU_PLAY_PWR_USER_DEF:
    user_def_key_msg(ku_sel);  // 挂断电话
    break;

case KD_PLAY_USER_DEF:
case KD_PLAY_PWR_USER_DEF:
    // 处理双击（如切换通话）
    if (call_status == BT_CALL_INCOMING) {
        bt_call_answer_incoming();  // 接听第2路通话
    } else if(call_status == BT_CALL_3WAY_CALL) {
        bt_call_swap();  // 切换两路通话
    }
    break;

// 其他按键事件处理...
}
```

### 功能执行

最终，按键事件会通过`user_def_key_msg()`函数执行具体功能：

```c
bool user_def_key_msg(u8 func_sel)
{
    // 检查功能是否可用
    if (!user_def_func_is_ready(func_sel)) {
        return false;
    }
    
    // 根据功能选择执行不同操作
    if (func_sel == UDK_NEXT_TRACK) {
        // 下一曲
        bt_music_next();
    } else if (func_sel == UDK_PREV_TRACK) {
        // 上一曲
        bt_music_prev();
    } else if (func_sel == UDK_PLAY_PAUSE) {
        // 播放/暂停
        return user_def_play_pause_msg();
    }
    // 其他功能...
    
    return true;
}
```

## 配置系统

耳机的按键功能是可配置的，通过`xcfg_cb`结构体中的配置项来决定不同按键事件的功能：

- `xcfg_cb.user_def_ks_sel`：单击按键功能
- `xcfg_cb.user_def_kd_sel`：双击按键功能
- `xcfg_cb.user_def_kl_sel`：长按按键功能
- `xcfg_cb.user_def_kt_sel`：三击按键功能
- `xcfg_cb.user_def_kfour_sel`：四击按键功能
- `xcfg_cb.user_def_kfive_sel`：五击按键功能

# 问题

## 触摸按键点击事件的复用

**但是我配置了音乐播放状态下的按键功能为双击是暂停和播放，为什么同事说在通话状态下双击是挂断和接听？**
**他们是怎么联系在一起的？如果我使用配置工具配置音乐状态下的暂停和播放为单击的话，那么通话状态下的接听和挂断也是单击？**

### 配置工具与状态功能的关系

从代码中可以看出，配置工具主要配置的是音乐播放状态下的按键功能，但这些配置会影响通话状态下的按键行为。这是通过以下机制实现的：

1. **功能复用**：通话状态下的按键处理函数会参考音乐状态下的配置
2. **状态判断**：系统会根据当前状态选择不同的处理函数
3. **配置传递**：音乐状态的配置会被传递到通话状态的处理函数

### 具体关联规则

从代码分析来看，主要有以下关联规则：

#### **单击按键的关联**

在音乐状态下，单击按键的功能由`xcfg_cb.user_def_ks_sel`配置（通常是播放/暂停）。在通话状态下，系统会使用相同的配置值来决定功能：

```c
// 来电状态下的单击处理
case KU_PLAY_USER_DEF:
case KU_PLAY_PWR_USER_DEF:
    user_def_key_msg(ku_sel);  // ku_sel = xcfg_cb.user_def_ks_sel
    break;
```

这意味着：**如果您在配置工具中将音乐状态下的播放/暂停设置为单击，那么通话状态下的接听/挂断也会是单击**。

#### 双击按键的关联

类似地，双击按键的功能由`xcfg_cb.user_def_kd_sel`配置。在通话状态下：

```c
// 来电状态下的双击处理
case KD_PLAY_USER_DEF:
case KD_PLAY_PWR_USER_DEF:
    if (xcfg_cb.user_def_kd_reject_en) {
        //这个是配置工具中可以单独配置的
        bt_ring_reject();  // 拒接电话
    } else {
        user_def_key_msg(xcfg_cb.user_def_kd_sel);
    }
    break;
```

这表明：**如果您在配置工具中将音乐状态下的播放/暂停设置为双击，那么通话状态下的接听/挂断也会是双击**。

### 特殊情况与优先级

代码中还有一些特殊情况处理：

**拒接电话的优先级**：

```c
if (xcfg_cb.user_def_kd_reject_en) {
    bt_ring_reject();  // 拒接电话的优先级高于普通功能
} else {
    user_def_key_msg(xcfg_cb.user_def_kd_sel);
}
```

**通话状态下的特殊处理**：

```c
if (call_status == BT_CALL_INCOMING) {
    bt_call_answer_incoming();  // 接听第2路通话
} else if(call_status == BT_CALL_3WAY_CALL) {
    bt_call_swap();  // 切换两路通话
}
```

### 具体代码实现

`app\projects\earphone\message\msg_bt.c`

#### 在音乐播放状态下

```c
case KU_PLAY:
    ku_sel = UDK_PLAY_PAUSE;
case KU_PLAY_USER_DEF:
case KU_PLAY_PWR_USER_DEF:
    if (!bt_nor_is_connected()) {
        bt_tws_pair_mode(3);                                            
        break;
    }
    user_def_key_msg(ku_sel);
    break;
```

在来电响铃状态下：

```c
case KU_HSF:                //接听
    ku_sel = UDK_PLAY_PAUSE;
case KU_PLAY_USER_DEF:
case KU_PLAY_PWR_USER_DEF:
    user_def_key_msg(ku_sel);
    break;
```

在通话状态下：

```c
case KU_HSF:
    ku_sel = UDK_PLAY_PAUSE;
case KU_PLAY_USER_DEF:
case KU_PLAY_PWR_USER_DEF:
    user_def_key_msg(ku_sel);
    break;
```

从代码可以看出：

1. 是的，你的理解是正确的。音乐状态和通话状态的按键处理是统一的：
   - 如果在配置工具中设置单击为播放/暂停，那么通话状态下的接听/挂断也是单击
   - 如果在配置工具中设置双击为播放/暂停，那么通话状态下的接听/挂断也是双击
2. 这种统一性体现在：
   - 所有状态下都是通过 `user_def_key_msg(ku_sel)` 来处理
   - 都使用相同的 `ku_sel = UDK_PLAY_PAUSE` 设置
   - 处理相同的按键消息类型（` KU_PLAY_USER_DEF`,`KU_PLAY_PWR_USER_DEF`）
3. 这样设计的好处是：
   - 保持了用户操作的一致性
   - 简化了代码逻辑
   - 便于通过配置工具统一配置按键功能

所以无论是在音乐播放状态还是通话状态，按键的操作方式（单击/双击）都是由配置工具中的设置统一决定的。

### 来电拒接的逻辑

拒接电话的逻辑是独立的，不是和播放/暂停共用的。从代码中可以看到拒接电话的处理：

```c
//来电响铃时拒接操作(长按/双击)
void bt_ring_reject(void)
{
    bt_ring_stop();
    bt_call_terminate();                //拒接
    sys_warning_play(T_WARNING_REJECT, PIANO_REJECT);
}

// 在来电状态下的处理
case KL_PLAY_PWR_USER_DEF:
    //PWRKEY松开前不产生KLH_PLAY_PWR_USER_DEF消息。按键松开自动清此标志。
    if (!xcfg_cb.user_def_kl_call_pwrdwn_en) {
        sys_cb.poweron_flag = 1;
    }
case KL_PLAY_USER_DEF:
case KL_HSF:
    if (xcfg_cb.user_def_kl_reject_en || msg == KL_HSF) {  // 通过配置决定是否启用长按拒接
        bt_ring_reject();
    } else {
        user_def_key_msg(xcfg_cb.user_def_kl_sel);
    }
    break;

case KD_PLAY_USER_DEF:
case KD_PLAY_PWR_USER_DEF:
    if (xcfg_cb.user_def_kd_reject_en) {   // 通过配置决定是否启用双击拒接
        bt_ring_reject();
    } else {
        user_def_key_msg(xcfg_cb.user_def_kd_sel);
    }
    break;
```

从代码可以看出：

1. 拒接电话可以通过配置工具单独配置：
   - ` user_def_kl_reject_en`: 控制是否启用长按拒接
   - ` user_def_kd_reject_en`: 控制是否启用双击拒接
2. 拒接的处理逻辑是独立的：
   - 调用 `bt_ring_reject()` 函数
   - 包含停止铃声、拒接电话、播放提示音等操作
3. 如果没有启用拒接功能，则会执行正常的按键功能：
   - 长按：执行 ` user_def_kl_sel`配置的功能
   - 双击：执行` user_def_kd_sel`配置的功能
   - **执行用户触摸按键定义的事件功能**

所以拒接电话确实是一个独立的功能，可以通过配置工具灵活设置是使用长按还是双击来触发，不会和播放/暂停的功能冲突。

## 增加USER_DEF的最大长按时间（默认最大2.6秒）

### 原理概述

在这个SDK中，长按时间的计算是基于一个计数器实现的，而不是直接以毫秒为单位。具体来说：

1. **基础计数值**：在`bsp_key.h`中定义了`KEY_LONG_TIMES`为160，这是长按检测的基础计数值。
2. 配置选择：通过配置工具，用户可以选择`kl_time_sel`的值（0-3），对应不同的长按时间：
   - 0: 0.8秒
   - 1: 1.4秒
   - 2: 2秒
   - 3: 2.6秒（原来的最大值）
3. **计算公式**：原来的代码中，长按时间的计算公式是

```c
key_cb.filter.long_cnt = KEY_LONG_TIMES + (u32)xcfg_cb.kl_time_sel*120;
```

当`kl_time_sel`为3时，计算结果是：160 + 3*120 = 520，这对应2.6秒的长按时间。

### 修改方案

我们的修改方案是创建一个预定义的长按时间值数组，直接映射`kl_time_sel`的值到对应的计数值：

```c
u32 long_time_values[4] = {160, 280, 400, 600}; // 对应0.8秒, 1.4秒, 2秒, 3秒
key_cb.filter.long_cnt = long_time_values[xcfg_cb.kl_time_sel];
```

这样，当`kl_time_sel`为3时，长按时间的计数值变为600，对应3秒的长按时间。

### 为什么不需要修改配置

您不需要修改配置工具或更改配置值的原因是：

1. **保持接口一致**：我们没有改变配置工具的选项或界面，用户仍然选择0-3的值，保持了向后兼容性。
2. **内部逻辑修改**：我们只修改了内部的计算逻辑，将`kl_time_sel`为3时对应的时间从2.6秒调整为3秒。
3. **无需重新配置**：由于我们的修改是在代码层面实现的，用户只需要保持选择最大值（`kl_time_sel`=3）即可获得3秒的长按时间，不需要重新配置或学习新的设置方式。

### 时间与计数值的关系

在这个SDK中，长按时间的计数值与实际时间的关系大约是：

- 每200个计数单位对应约1秒
- 因此，600的计数值对应约3秒的长按时间

### 总结

这个方案的优点是：

1. **简单直接**：直接修改代码中的计算逻辑，不需要修改配置工具或界面
2. **向后兼容**：保持了与现有配置的兼容性，用户不需要学习新的设置方式
3. **精确控制**：通过预定义的数组，我们可以精确控制每个选项对应的时间
4. **易于维护**：如果将来需要调整其他长按时间值，只需修改数组中的对应值即可

通过这种方式，您可以在不改变用户体验的情况下，将最大长按识别时间从2.6秒增加到3秒，满足您的需求。

### 疑问

**这个方案区分左右耳吗？我的配置文件你也看到了是分左右耳的。当然目前没有针对左右耳的长按时间有不一样**

### 关于左右耳区分

1. 代码实现层面： 我们修改的`key_init()`函数在` app\platform\bsp\bsp_key.c`文件中是一个通用的初始化函数，它会被系统在启动时调用，用于初始化按键相关的参数。这个函数本身不区分左右耳，它适用于所有设备。
2. 配置文件： 您的配置文件` AB5656A3-TWS-R.setting`中的"R"后缀确实表明这是右耳的配置。通常TWS耳机会有左耳(L)和右耳(R)两个不同的配置文件。
3. 长按时间设置： 在您的配置文件中，长按时间的设置（` kl_time_sel`值为3）是针对右耳的。如果左耳也需要相同的长按时间，那么左耳的配置文件中也应该有相同的设置。

##### 对左右耳的影响

1. **相同的代码**： 左右耳使用的是相同的代码，我们修改的`key_init()`函数会在两个耳机上都执行。
2. 各自的配置： 每个耳机会读取自己的配置文件。如果左右耳的配置文件中` kl_time_sel`的值相同（都是3），那么它们的长按时间也会相同（都是3秒）。
3. 不同配置的情况： 如果左右耳的配置文件中`kl_time_sel`的值不同，那么它们的长按时间也会不同。例如，如果左耳的` kl_time_sel`值为2，右耳为3，那么左耳的长按时间会是2秒，右耳会是3秒。

##### 结论

我们的修改方案不会自动区分左右耳，而是根据各自的配置文件来设置长按时间。如果您希望左右耳的长按时间一致，需要确保两个配置文件中的 `kl_time_sel`值相同。

如果您需要查看或修改左耳的配置，可以查找类似 `AB5656A3-TWS-L.setting`的文件。如果您希望左右耳有不同的长按时间，可以分别设置它们的 `kl_time_sel`值，我们的修改会根据各自的配置值生效。

目前，根据您的描述，您没有针对左右耳设置不同的长按时间的需求，所以只要确保左右耳的配置文件中`kl_time_sel`值都是3，它们就会有相同的3秒长按时间。

##### 注意事项

**改了源代码的话，需要重新编译一下再烧录。在烧录时会根据不同的配置文件来定义各种配置和功能。**

##### 公用的计算长按时间代码

`app\platform\bsp\bsp_key.c`中的这段代码：

```c
key_cb.filter.long_cnt = long_time_values[xcfg_cb.kl_time_sel];
```

是一个公用的计算长按时间的代码，它会根据各自配置文件中的 `kl_time_sel`值来计算对应的长按时间。这个机制的工作方式如下：

1. 代码共享：左右耳机使用相同的代码库，包括这个`bsp_key.c`文件。

2. **配置独立**：但每个耳机会读取自己的配置文件（左耳读取L配置，右耳读取R配置）。

3. 运行时计算：当耳机启动时，`key_init()`函数会被调用，它会读取配置文件中的`xcfg_cb.kl_time_sel`

   值，然后根据我们定义的` long_time_values`数组计算出对应的长按时间。

4. 各自生效：因此，即使左右耳的配置文件中` kl_time_sel`值不同，代码也会根据各自的值计算出相应的长按时间。

### 直接修改配置文件

**虽然配置工具没有更大的选项了，但是我可以直接修改配置工具生成的配置文件啊。kl_time_sel我可以直接在对应文件中修改**

确实可以直接修改配置文件中的 `kl_time_sel`值，而不必受限于配置工具的界面选项。

直接修改配置文件的方法

如果您想通过直接修改配置文件来实现3秒的长按时间，而不是修改代码，您可以这样做：

1. 找到配置文件：您已经找到了配置文件` AB5656A3-TWS-R.setting`
2. 修改`kl_time_sel`值：在配置文件中找到这一行：

```c
<add key="kl_time_sel" value="3" />
```

**将值修改为4**：根据我们之前的计算，要达到3秒的长按时间， `kl_time_sel`需要约为3.67。由于这是一个整数值，您可以将其修改为4：

```c
<add key="kl_time_sel" value="4" />
```

**保存文件**：保存修改后的配置文件

#### 代码兼容性

关键是，您需要确认代码能够正确处理这个超出预期范围的值。让我们看看您选中的代码部分：

```c
if (xcfg_cb.kl_time_sel) {
```

这段代码只是检查 `kl_time_sel`是否非零，所以值为4也会通过这个检查。然后，原始的计算公式是

```c
key_cb.filter.long_cnt = KEY_LONG_TIMES + (u32)xcfg_cb.kl_time_sel*120;
```

如果 `kl_time_sel`为4，那么计算结果将是：160 + 4*120 = 640，这甚至会超过3秒，大约为3.2秒。

#### 注意事项

1. 类型检查：确保代码中没有对`kl_time_sel`的值范围进行硬编码的检查，否则可能会导致意外行为。
2. **左右耳一致性**：如果您也想修改左耳的长按时间，别忘了同样修改左耳的配置文件。
3. **备份**：在修改前，最好先备份原始配置文件，以防需要恢复。
4. **测试**：修改后，务必进行测试，确保长按功能正常工作，并且时间确实达到了3秒。

这种方法的优点是不需要修改和重新编译代码，只需修改配置文件。如果您的设备允许直接更新配置文件而不需要重新烧录固件，这将是一个更简单的解决方案。

#### 问题

感觉直接修改配置文件的话，不是很好，因为根据原有公式没有办法得到精准的时间，不如直接修改源代码

直接修改配置文件虽然简单，但确实存在一些问题：

**修改配置文件的缺点**

1. **精度问题**：如您所说，根据原有公式无法精确得到3秒的时间。使用`kl_time_sel=4`会得到约3.2秒，这与您需要的3秒有偏差。
2. **超出设计范围**：配置工具设计时只考虑了0-3的值范围，直接设置为4可能会导致其他依赖这个值的功能出现意外行为。
3. **维护困难**：如果将来升级SDK或重新使用配置工具，您的手动修改可能会被覆盖，需要重新修改。
4. **不够健壮**：这种方法依赖于代码对超出预期范围的值的宽容处理，不够健壮。

**修改源代码的优势**

相比之下，我们之前提出的修改源代码的方案有以下优势：

1. **精确控制**：通过修改计算逻辑，可以精确设置长按时间为3秒。
2. **保持兼容性**：不需要修改配置文件，保持与配置工具的兼容性。
3. **明确的意图**：代码中明确表达了当`kl_time_sel=3`时长按时间为3秒的意图，更易于理解和维护。
4. **健壮性**：不依赖于代码对超出预期范围的值的处理，更加健壮。

## 无论蓝牙是否连接都可以实现游戏模式与普通音乐模式的切换

从代码中可以看出，游戏模式与普通音乐模式的切换是通过`UDK_GAME_SWITCH`功能实现的，主要涉及以下几个关键部分：

**切换逻辑实现**： 在`msg_bt.c`文件中，当用户触发`UDK_GAME_SWITCH`功能时，系统会检查当前是否处于低延迟模式（游戏模式），然后播放相应的提示音：

```c
if (bt_is_low_latency()) {
    tws_res_play(TWS_RES_MUSIC_MODE);           //提示音播放的地方更新sys_cb.game_mode变量
} else {
    tws_res_play(TWS_RES_GAME_MODE);
}
```

**低延迟模式检查**： 通过`bt_is_low_latency()`函数检查当前是否处于游戏模式（低延迟模式）。这个函数在`api_btstack.h`中有声明，但我们没有看到具体实现。

**模式切换实现**： 当播放提示音时，会在`tws_set_sta_for_res`函数中更新`sys_cb.game_mode`变量，从而实际切换模式

**延迟设置**： 在配置文件`xcfg.xm`中，有关于游戏模式延迟的配置：

```c
config(LISTVAL, "蓝牙音乐游戏模式延时", "蓝牙音乐游戏模式延时, 需要配合<Game切换>按键使用", A2DP_GAME_MODE_LATENCY, BIT, 2, 0, 4, ("80ms", 1), ("100ms", 0), ("120ms", 2), ("140ms", 3), BT_A2DP_EN);
```

这表明游戏模式主要是通过调整音频延迟来实现的。

### 关于蓝牙连接状态的依赖分析

从代码中，我们可以得出以下结论：

1. **没有明确的连接状态检查**： 在`UDK_GAME_SWITCH`的处理代码中，没有看到对蓝牙连接状态的直接检查。代码直接调用`bt_is_low_latency()`和`tws_res_play()`，没有先检查蓝牙是否连接。
2. **底层实现可能有依赖**： 虽然在切换逻辑中没有明确检查连接状态，但底层的`bt_is_low_latency()`和`tws_res_play()`函数可能内部依赖蓝牙连接状态。
3. **功能定义与按键绑定**： 游戏模式切换功能（`UDK_GAME_SWITCH`）是通过按键配置绑定的，在`func_bt.h`中定义为值15：

```c
#define UDK_GAME_SWITCH 15
```

### 结论

根据现有代码分析，游戏模式与普通音乐模式的切换功能本身在代码逻辑上没有明确要求蓝牙必须处于连接状态。但是，由于：

1. 游戏模式主要是调整A2DP音频流的延迟，这本质上是针对蓝牙音频传输的优化
2. 在没有蓝牙连接的情况下，调整音频延迟没有实际意义
3. 底层函数可能有内部检查，不允许在未连接状态下切换模式

因此，虽然代码中没有明确检查蓝牙连接状态，但从功能设计和实际使用角度来看，游戏模式切换功能很可能需要蓝牙处于连接状态才能正常工作。

如果您想确认是否可以在未连接状态下切换模式，可以尝试在蓝牙未连接时触发相应按键，看是否能听到模式切换的提示音。如果能听到提示音但没有实际效果，说明切换在逻辑上允许但没有实际意义；如果完全没有反应，则说明底层实现确实依赖蓝牙连接状态。

## 拒接电话的三击按键实现

### 配置定义层面

~~在 xcfg.h 中定义配置变量~~

```c
u32 user_def_kt_reject_en : 1;   //USER_DEF键三击来电拒接
```

~~这是一个1位的位域变量，用于存储三击拒接功能的开关状态（0表示关闭，1表示开启）。~~

**前者不需要，因为在文件头部已经说明，是自动生成的。只需要在后者中使能即可。**



**在 xcfg.xm 中添加配置项**

```c
config(CHECK, "USER_DEF键三击来电拒接", "是否来电响铃时三击拒接", USER_DEF_KT_REJECT_EN, 1);
```

这个配置项定义了在配置工具中显示的选项，包括名称、描述、对应的变量名和默认值（1表示默认开启）。

### 消息处理层面

#### 按键消息定义

系统定义了特定的消息码来表示三击操作：

- ` KTH_PLAY_USER_DEF`：普通USER_DEF键的三击消息
- ` KTH_PLAY_PWR_USER_DEF`：带电源功能的USER_DEF键的三击消息
  - 在配置工具种=中，给触摸按键1定义的功能类型有`PP/PWR/USER_DEF`

#### 消息处理函数

在 `sfunc_bt_ring_message_do`函数中处理来电响铃时的按键消息：

```c
case KTH_PLAY_USER_DEF:
case KTH_PLAY_PWR_USER_DEF:
    if (xcfg_cb.user_def_kt_reject_en) {
        bt_ring_reject();
    } else {
        user_def_key_msg(xcfg_cb.user_def_kt_sel);
    }
    break;
```

这段代码的逻辑是：

1. 当接收到三击消息时
2. 检查` user_def_kt_reject_en`配置是否启用
3. 如果启用，调用 `bt_ring_reject()` 函数拒接电话
4. 如果未启用，则执行默认的三击功能（由` user_def_kt_sel`配置决定）

### 功能执行层面

##### 拒接电话函数

```c
void bt_ring_reject(void)
{
    bt_ring_stop();
    bt_call_terminate();                //拒接
    sys_warning_play(T_WARNING_REJECT, PIANO_REJECT);
}
```

这个函数执行三个操作：

1. 停止来电铃声
2. 终止通话（拒接）
3. 播放拒接提示音

### 工作流程

完整的三击拒接功能工作流程如下：

1. 配置阶段：
   - 在配置工具中启用"USER_DEF键三击来电拒接"选项
   - 系统将` user_def_kt_reject_en`变量设置为1
2. 运行阶段：
   - 当有来电时，系统进入来电响铃状态
   - 用户在USER_DEF键上执行三击操作
   - 系统生成` KTH_PLAY_USER_DEF` 或 `KTH_PLAY_PWR_USER_DEF`消息
3. 处理阶段：
   - 消息被传递到` sfunc_bt_ring_message_do`函数
   - 函数检查` user_def_kt_reject_en`是否为1
   - 如果为1，调用 `bt_ring_reject()` 函数
4. 执行阶段：
   - `bt_ring_reject()` 函数停止铃声
   - 调用蓝牙协议栈函数拒接来电
   - 播放拒接提示音给用户

这种实现方式与长按拒接和双击拒接保持一致，遵循了SDK的设计模式，使得代码结构清晰、易于维护。通过配置工具，用户可以灵活地启用或禁用此功能，而无需修改代码。

## 对耳灯效一致性实现（凌工）

### 背景

配置工具中可以设置对耳的连接LED灯效。但是TWS配对成功时，会导致一个耳机处于连接状态（**TWS连接成功了**）一个处于未连接状态（**未连接手机**），从而导致灯效不一致。
正常来讲的话，应该是以连接手机为准，没有连接手机时的灯效一样。

### 解决方案概述

通过在原有代码基础上增加四个关键部分的逻辑，实现了TWS连接后左右耳机灯效的统一显示。

### 灯效显示逻辑改进（app\platform\functions\func_bt.c）

**原有逻辑**：

```c
static void func_bt_disp_status(void)
{
    uint status = bt_get_disp_status();
    
    if(f_bt.disp_status != status) {
        f_bt.disp_status = status;
        func_bt_disp_status_do();
    }
    func_bt_dac_ctrl();
    func_bt_tws_bre_led_ctl();
}
```

**改进逻辑**：

```c
static void func_bt_disp_status(void)
{
    uint status = bt_get_disp_status();

#if FA11_UI_EN
    // 增加对手机连接状态变化的检测
    static bool nor_connect_disp_sta = 0;
    bool nor_connect_sta = bt_nor_is_connected();
    
    // 关键改进：不仅在蓝牙状态变化时更新灯效，还在手机连接状态变化时更新灯效
    if(f_bt.disp_status != status || nor_connect_disp_sta != nor_connect_sta) {
        nor_connect_disp_sta = nor_connect_sta;
#else
    if(f_bt.disp_status != status) {
#endif
        f_bt.disp_status = status;
        func_bt_disp_status_do();
    }
    func_bt_dac_ctrl();
    func_bt_tws_bre_led_ctl();
}
```

**改进说明**：

- 增加了静态变量`nor_connect_disp_sta`记录上一次的手机连接状态
- 增加了对手机连接状态变化的检测，确保在手机连接状态变化时也更新灯效
- 这解决了TWS连接后，因手机连接状态不同而导致的灯效不一致问题

###  特定状态下的灯效统一（app\platform\functions\func_bt.c）

**原有逻辑**：

```c
case BT_STA_IDLE:
    led_bt_idle();
    break;
    
case BT_STA_CONNECTED:
    led_bt_connected();
    break;
```

**改进逻辑**：

```c
case BT_STA_IDLE:
#if FA11_UI_EN
    if(bt_tws_is_connected()) {
        // TWS已连接但未连接手机时的灯效处理
        if(xcfg_cb.bt_tws_lr_mode == 4) {
            led_set_sta(0x00,0x60,0x04,0x19);
        } else if (xcfg_cb.bt_tws_lr_mode == 5) {
            led_set_sta(0x00,0x60,0x04,0x19);
        }
    } else {
        led_bt_idle();
    }
#else
    led_bt_idle();
#endif
    break;
    
case BT_STA_CONNECTED:
#if FA11_UI_EN
    if(!bt_nor_is_connected()) {
        // TWS已连接但未连接手机的情况
        if(xcfg_cb.bt_tws_lr_mode == 4) {
            led_set_sta(0x00,0x60,0x04,0x19);
        } else if (xcfg_cb.bt_tws_lr_mode == 5) {
            led_set_sta(0x00,0x60,0x04,0x19);
        }
        break;
    }
#endif
    led_bt_connected();
    break;
```

**改进说明**：

- 在BT_STA_IDLE和BT_STA_CONNECTED状态下增加了特殊处理
- 当TWS已连接时，根据bt_tws_lr_mode设置统一的灯效参数
- 使用相同的灯效参数`led_set_sta(0x00,0x60,0x04,0x19)`确保左右耳机显示一致

### 强制更新灯效显示（app\platform\bsp\bsp_bt.c）

**原有逻辑**：

```c
case BT_NOTICE_DISCONNECT:
    bt_emit_notice_disconnect((u8 *)param);
    break;

case BT_NOTICE_CONNECTED:
    bt_emit_notice_connected((u8 *)param);
    break;

case BT_NOTICE_TWS_DISCONNECT:
    f_bt.tws_status &= ~0xc0;
    f_bt.warning_status |= BT_WARN_TWS_DISCON;
    break;

case BT_NOTICE_TWS_CONNECTED:
    bt_emit_notice_tws_connected((u8 *)param);
    break;
```

**改进逻辑**：

```c
case BT_NOTICE_DISCONNECT:
    bt_emit_notice_disconnect((u8 *)param);
#if FA11_UI_EN
    // 蓝牙断开连接时，强制更新灯效显示
    f_bt.disp_status = 0xff;
#endif
    break;

case BT_NOTICE_CONNECTED:
    bt_emit_notice_connected((u8 *)param);
#if FA11_UI_EN
    // 蓝牙连接成功时，强制更新灯效显示
    f_bt.disp_status = 0xff;
#endif
    break;

case BT_NOTICE_TWS_DISCONNECT:
    f_bt.tws_status &= ~0xc0;
    f_bt.warning_status |= BT_WARN_TWS_DISCON;
#if FA11_UI_EN
    // TWS断开连接时，强制更新灯效显示
    f_bt.disp_status = 0xff;
#endif
    break;

case BT_NOTICE_TWS_CONNECTED:
    bt_emit_notice_tws_connected((u8 *)param);
#if FA11_UI_EN
    // TWS连接成功时，强制更新灯效显示
    f_bt.disp_status = 0xff;
#endif
    break;
```

**改进说明**：

- 在四个关键的蓝牙状态变化事件中添加了强制更新灯效的代码
- 通过设置`f_bt.disp_status = 0xff`（无效值），强制在下一次调用func_bt_disp_status函数时更新灯效
- 这确保了在状态变化时，左右耳机都会更新灯效，保持一致

### 方案工作原理

1. **全面的状态检测**：不仅检测蓝牙状态变化，还检测手机连接状态变化，确保在任何状态变化时都能更新灯效
2. **统一的灯效参数**：在TWS连接的情况下，为左右耳机设置相同的灯效参数，确保视觉一致性
3. **强制更新机制**：在关键状态变化点强制更新灯效显示，避免因状态不同步导致的灯效不一致

### 原始灯效与改进后灯效的区别

#### 原始灯效行为

在原始SDK中，TWS耳机的灯效显示完全基于每个耳机自身的状态，导致以下情况：

1. TWS配对阶段：
   - 两只耳机都显示配对/搜索状态的灯效（通常是快速闪烁）
2. TWS连接成功但未连接手机阶段：
   - **主耳机**：显示为"已连接TWS但未连接手机"的状态，通常是某种特定的闪烁模式
   - **从耳机**：显示为"已连接"状态，因为从耳机视角它已经连接到了主耳机
   - **结果**：两只耳机显示不同的灯效，用户会看到不一致的视觉反馈
3. 连接手机阶段：
   - 只有主耳机与手机建立连接
   - **主耳机**：显示为"已连接手机"的状态
   - **从耳机**：仍然只显示"已连接TWS"的状态
   - **结果**：两只耳机可能仍然显示不同的灯效
4. 完全连接阶段：
   - 当主耳机成功与手机连接，并且信息同步到从耳机后
   - 两只耳机才会显示相同的"已连接"状态灯效
5. 休眠影响：
   - 在某些状态下，一只耳机可能进入休眠模式而关闭LED灯，而另一只保持活跃状态
   - 这进一步加剧了灯效的不一致性

#### 改进后灯效行为

改进后的方案通过多种机制确保TWS耳机在各个阶段都显示一致的灯效：

1. TWS配对阶段：
   - 与原来相同，两只耳机都显示配对/搜索状态的灯效
2. TWS连接成功但未连接手机阶段：
   - **关键改进点**：无论主从耳机，都显示相同的统一灯效
   - 通过`led_set_sta(0x00,0x60,0x04,0x19)`设置特定的灯效参数
   - 两只耳机显示完全相同的灯效，提供一致的视觉反馈
3. 连接手机阶段：
   - **关键改进点**：强制更新机制确保状态变化时两只耳机同步更新灯效
   - 通过设置`f_bt.disp_status = 0xff`触发灯效更新
   - 两只耳机显示相同的"已连接手机"状态灯效
4. 完全连接阶段：
   - 两只耳机显示相同的"已连接"状态灯效，与原来相同

#### 具体灯效差异示例

##### 场景一：TWS连接成功但未连接手机

**原始行为**：

- 主耳机：可能显示蓝灯慢闪（表示待连接状态）
- 从耳机：可能显示蓝灯常亮或特定模式闪烁（表示已连接状态）
- 用户体验：看到两只耳机灯光不同，可能误以为有一只耳机出现问题

**改进后行为**：

- 主耳机和从耳机：都显示相同的灯效模式（由`led_set_sta(0x00,0x60,0x04,0x19)`设置）
- 用户体验：看到两只耳机灯光一致，理解为TWS已连接但等待连接手机的状态

##### 场景二：主耳机连接手机过程中

**原始行为**：

- 主耳机：可能显示蓝灯快闪（表示正在连接状态）
- 从耳机：可能仍显示之前的状态灯效
- 用户体验：看到不同步的灯效变化，感到困惑

**改进后行为**：

- 通过强制更新机制，两只耳机同步更新灯效状态
- 用户体验：看到两只耳机同步变化的灯效，理解为系统正在连接手机

