# Zephyr 设备树 Overlay 文件编写指南

本文档以 `blinky` 示例程序和 `esp32_devkitc_esp32_procpu` 板为例，详细讲解如何编写 Overlay 文件，以及 Zephyr 设备树 (Device Tree) 的层级结构。

---

## 目录

1. [设备树基础概念](#1-设备树基础概念)
2. [DTS 文件层级结构](#2-dts-文件层级结构)
3. [各层 DTS 文件的作用详解](#3-各层-dts-文件的作用详解)
4. [YAML Binding 文件详解](#4-yaml-binding-文件详解)
5. [如何查找硬件标签](#5-如何查找硬件标签)
6. [编写 Overlay 文件实战](#6-编写-overlay-文件实战)
7. [Blinky 示例代码分析](#7-blinky-示例代码分析)
8. [常用 GPIO 标志位](#8-常用-gpio-标志位)
9. [调试技巧](#9-调试技巧)

---

## 1. 设备树基础概念

### 1.1 什么是设备树 (Device Tree)

设备树是一种描述硬件的数据结构，它独立于代码，告诉操作系统：
- 系统有哪些硬件设备
- 这些设备的地址、中断、时钟等配置
- 设备之间的连接关系

### 1.2 核心术语

| 术语 | 说明 | 示例 |
|------|------|------|
| **节点 (Node)** | 描述一个设备或逻辑单元 | `gpio0: gpio@3ff44000 { ... }` |
| **属性 (Property)** | 节点的配置参数 | `reg = <0x3ff44000 0x800>;` |
| **标签 (Label)** | 节点的别名，用于引用 | `gpio0:` 是标签，可用 `&gpio0` 引用 |
| **phandle** | 对其他节点的引用 | `gpios = <&gpio0 2 GPIO_ACTIVE_HIGH>;` |
| **compatible** | 声明设备类型，驱动匹配用 | `compatible = "gpio-leds";` |
| **aliases** | 全局别名，代码通过它访问设备 | `led0 = &myled;` |
| **chosen** | 系统级配置选项 | `zephyr,console = &uart0;` |

### 1.3 Overlay 的作用

Overlay 文件 (`.overlay`) 用于**叠加修改**基础设备树，而不需要修改原始 DTS 文件。它可以：
- 添加新设备节点
- 修改现有节点的属性
- 启用/禁用设备 (`status = "okay"` / `"disabled"`)
  - 这是指软件功能API层面的禁用？
  - kconfig是决定整个硬件驱动代码是否编译
    - 整个GPIO子系统编译进系统后，再使用设备树说明或者描述开启或者关闭具体那个GPIO控制器硬件


---

## 2. DTS 文件层级结构

以 ESP32-DevKitC 为例，设备树的继承关系如下：

```
┌─────────────────────────────────────────────────────────────────────┐
│  第5层: skeleton.dtsi (骨架层)                                       │
│  路径: zephyr/dts/common/skeleton.dtsi                              │
│  作用: 定义最基础的根节点结构 - chosen{} 和 aliases{}                 │
└───────────────────────────────────┬─────────────────────────────────┘
                                    │ #include
                                    ▼
┌─────────────────────────────────────────────────────────────────────┐
│  第4层: xtensa.dtsi (架构层)                                         │
│  路径: zephyr/dts/xtensa/xtensa.dtsi                                │
│  作用: 定义 Xtensa 架构的 soc{} 节点容器                             │
└───────────────────────────────────┬─────────────────────────────────┘
                                    │ #include
                                    ▼
┌─────────────────────────────────────────────────────────────────────┐
│  第3层: esp32_common.dtsi (SoC通用层)                                │
│  路径: zephyr/dts/xtensa/espressif/esp32/esp32_common.dtsi          │
│  作用: 定义 ESP32 芯片的所有外设 - GPIO、UART、SPI、I2C 等           │
│       这是最重要的一层，包含所有可用硬件标签                          │
└───────────────────────────────────┬─────────────────────────────────┘
                                    │ #include
                                    ▼
┌─────────────────────────────────────────────────────────────────────┐
│  第2层: esp32_wrover_e_n4r8.dtsi (芯片封装层)                        │
│  路径: zephyr/dts/xtensa/espressif/esp32/esp32_wrover_e_n4r8.dtsi   │
│  作用: 定义具体芯片封装的参数 - Flash大小、PSRAM大小、保留GPIO        │
└───────────────────────────────────┬─────────────────────────────────┘
                                    │ #include
                                    ▼
┌─────────────────────────────────────────────────────────────────────┐
│  第1层: esp32_devkitc_procpu.dts (板级层) ← 你的起点                  │
│  路径: zephyr/boards/espressif/esp32_devkitc/esp32_devkitc_procpu.dts│
│  作用: 定义开发板的具体配置 - 启用哪些外设、引脚复用、按键定义        │
└───────────────────────────────────┬─────────────────────────────────┘
                                    │ 叠加
                                    ▼
┌─────────────────────────────────────────────────────────────────────┐
│  第0层: 你的 Overlay 文件 (应用层)                                   │
│  路径: <app>/boards/esp32_devkitc_esp32_procpu.overlay               │
│  作用: 添加应用所需的设备定义，如 LED、传感器等                       │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 3. 各层 DTS 文件的作用详解

### 3.1 第5层: skeleton.dtsi (骨架层)

**文件路径:** `zephyr/dts/common/skeleton.dtsi`

```dts
/ {
    #address-cells = <1>;    /* 地址占用1个32位单元 */
    #size-cells = <1>;       /* 大小占用1个32位单元 */

    chosen {};    /* 系统级配置容器 */
    aliases {};   /* 全局别名容器 */
};
```

**作用:**
- 定义设备树的**最基础骨架**
- 提供 `chosen` 和 `aliases` 空节点
- 所有设备树最终都继承自此文件

### 3.2 第4层: xtensa.dtsi (架构层)

**文件路径:** `zephyr/dts/xtensa/xtensa.dtsi`

```dts
#include "skeleton.dtsi"

/ {
    soc {
        #address-cells = <1>;
        #size-cells = <1>;
        compatible = "simple-bus";
        ranges;
    };
};
```

**作用:**
- 继承骨架层
- 定义 `soc` 节点作为**所有片上外设的容器**
- `simple-bus` 表示这是一个简单总线，子节点可以直接使用父节点的地址空间

### 3.3 第3层: esp32_common.dtsi (SoC通用层) - 最重要!

**文件路径:** `zephyr/dts/xtensa/espressif/esp32/esp32_common.dtsi`

这是**最关键的一层**，定义了 ESP32 芯片的所有外设。主要内容包括：

#### CPU 定义
```dts
cpus {
    cpu0: cpu@0 {
        device_type = "cpu";
        compatible = "espressif,xtensa-lx6";
        reg = <0>;
        clock-frequency = <DT_FREQ_M(240)>;  /* 240MHz */
    };
    cpu1: cpu@1 { ... };
};
```

#### 内存区域
```dts
soc {
    sram0: memory@40070000 {
        compatible = "zephyr,memory-region", "mmio-sram";
        reg = <0x40070000 DT_SIZE_K(192)>;   /* 192KB */
    };
    sram1: memory@3ffe0000 { ... };
    /* 更多内存区域... */
};
```

#### GPIO 控制器 - 编写 Overlay 时最常用
```dts
gpio: gpio {
    compatible = "simple-bus";
    gpio-map = <0x00 0x0 &gpio0 0x0 0x0
                0x20 0x0 &gpio1 0x0 0x0>;
    #gpio-cells = <2>;    /* 引用GPIO需要2个参数: 引脚号和标志 */

    gpio0: gpio@3ff44000 {
        compatible = "espressif,esp32-gpio";
        gpio-controller;
        #gpio-cells = <2>;
        reg = <0x3ff44000 0x800>;
        ngpios = <32>;    /* GPIO0~31 */
    };

    gpio1: gpio@3ff44800 {
        compatible = "espressif,esp32-gpio";
        gpio-controller;
        #gpio-cells = <2>;
        reg = <0x3ff44800 0x800>;
        ngpios = <8>;     /* GPIO32~39 */
    };
};
```

#### 其他外设
```dts
/* UART */
uart0: uart@3ff40000 {
    compatible = "espressif,esp32-uart";
    reg = <0x3ff40000 0x400>;
    status = "disabled";   /* 默认禁用，板级DTS启用 */
};

/* I2C */
i2c0: i2c@3ff53000 {
    compatible = "espressif,esp32-i2c";
    #address-cells = <1>;
    #size-cells = <0>;
    status = "disabled";
};

/* SPI */
spi2: spi@3ff64000 {
    compatible = "espressif,esp32-spi";
    status = "disabled";
};

/* PWM (LEDC) */
ledc0: ledc@3ff59000 {
    compatible = "espressif,esp32-ledc";
    #pwm-cells = <3>;
    status = "disabled";
};
```

**你可以使用的标签 (Labels):**

| 标签 | 类型 | 说明 |
|------|------|------|
| `&gpio0` | GPIO控制器 | GPIO 0-31 |
| `&gpio1` | GPIO控制器 | GPIO 32-39 |
| `&uart0`, `&uart1`, `&uart2` | UART | 串口 |
| `&i2c0`, `&i2c1` | I2C | I2C总线 |
| `&spi2`, `&spi3` | SPI | SPI总线 |
| `&ledc0` | PWM | LED控制器 |
| `&adc0`, `&adc1` | ADC | 模数转换器 |
| `&timer0` ~ `&timer3` | Timer | 定时器 |
| `&wdt0`, `&wdt1` | Watchdog | 看门狗 |
| `&flash0` | Flash | 内置Flash |
| `&trng0` | TRNG | 真随机数发生器 |

### 3.4 第2层: esp32_wrover_e_n4r8.dtsi (芯片封装层)

**文件路径:** `zephyr/dts/xtensa/espressif/esp32/esp32_wrover_e_n4r8.dtsi`

```dts
#include "esp32_common.dtsi"

/* 保留的GPIO引脚 (被Flash/PSRAM占用或未连出) */
&gpio0 {
    gpio-reserved-ranges = <6 6>,     /* GPIO6-11: Flash */
                           <16 2>,    /* GPIO16-17: PSRAM */
                           <20 1>,    /* GPIO20: NC */
                           <24 1>,    /* GPIO24: NC */
                           <28 4>;    /* GPIO28-31: NC */
};

&gpio1 {
    gpio-reserved-ranges = <5 2>;     /* GPIO37-38: NC */
};

/* Flash 大小: 4MB */
&flash0 {
    reg = <0x0 DT_SIZE_M(4)>;
};

/* PSRAM 大小: 8MB */
&psram0 {
    size = <DT_SIZE_M(8)>;
};
```

**作用:**
- 定义**具体芯片封装**的参数
- 声明**保留的 GPIO** (被 Flash、PSRAM 等占用，不可使用)
- 定义 Flash 和 PSRAM 的实际大小

**重要提示:** `gpio-reserved-ranges` 告诉你哪些引脚**不能使用**！

### 3.5 第1层: esp32_devkitc_procpu.dts (板级层)

**文件路径:** `zephyr/boards/espressif/esp32_devkitc/esp32_devkitc_procpu.dts`

```dts
/dts-v1/;

#include <espressif/esp32/esp32_wrover_e_n4r8.dtsi>
#include "esp32_devkitc-pinctrl.dtsi"
#include <zephyr/dt-bindings/input/input-event-codes.h>
#include <espressif/partitions_0x1000_amp.dtsi>

/ {
    model = "Espressif ESP32-DevkitC PROCPU";
    compatible = "espressif,esp32";

    /* 全局别名 - 代码通过这些名称访问设备 */
    aliases {
        uart-0 = &uart0;
        i2c-0 = &i2c0;
        sw0 = &button0;      /* 按键别名 */
        watchdog0 = &wdt0;
    };

    /* 按键定义 */
    buttons {
        compatible = "gpio-keys";
        button0: button_0 {
            gpios = <&gpio0 0 (GPIO_PULL_UP | GPIO_ACTIVE_LOW)>;
            label = "BOOT Button";
        };
    };

    /* 系统配置 */
    chosen {
        zephyr,sram = &sram1;
        zephyr,console = &uart0;
        zephyr,shell-uart = &uart0;
        zephyr,flash = &flash0;
        zephyr,code-partition = &slot0_partition;
    };
};

/* 启用外设并配置 */
&uart0 {
    status = "okay";
    current-speed = <115200>;
    pinctrl-0 = <&uart0_default>;
    pinctrl-names = "default";
};

&gpio0 {
    status = "okay";
};

&gpio1 {
    status = "okay";
};

&i2c0 {
    status = "okay";
    clock-frequency = <I2C_BITRATE_STANDARD>;
    sda-gpios = <&gpio0 21 GPIO_OPEN_DRAIN>;
    scl-gpios = <&gpio0 22 GPIO_OPEN_DRAIN>;
};

&spi2 {
    status = "okay";
};
```

**作用:**
- **最终整合**所有下层配置
- 定义**开发板特有**的按键、LED等
- **启用需要的外设** (`status = "okay"`)
- 配置**引脚复用** (pinctrl)
- 定义 **aliases** 供代码访问

**注意:** ESP32-DevKitC 板级 DTS **没有定义 LED**，所以需要通过 Overlay 添加！

---

## 4. YAML Binding 文件详解

### 4.1 Binding 是什么

Binding 是 YAML 格式的文件，定义了某种 `compatible` 类型的设备**应该有哪些属性**。Zephyr 构建系统用它来：
- 验证 DTS 属性是否正确
- 生成宏供 C 代码使用

### 4.2 Binding 文件位置

所有 Binding 文件位于: `zephyr/dts/bindings/`

常用目录:

- 不同芯片的构建有不同的标签可以使用。

```
dts/bindings/
├── base/
│   └── base.yaml           # 基础属性 (status, compatible, reg等)
├── gpio/
│   ├── gpio-controller.yaml
│   └── espressif,esp32-gpio.yaml
├── led/
│   ├── gpio-leds.yaml      # gpio-leds 的 binding
│   └── led-node.yaml
├── input/
│   └── gpio-keys.yaml
└── ...
```

### 4.3 gpio-leds.yaml 详解

**文件路径:** `zephyr/dts/bindings/led/gpio-leds.yaml`

```yaml
description: |
  Group of GPIO-controlled LEDs.

  Each LED is defined in a child node of the gpio-leds node.

  Example:
  / {
      leds {
          compatible = "gpio-leds";
          led_0 {
              gpios = <&gpio0 1 GPIO_ACTIVE_LOW>;
          };
          led_1 {
              gpios = <&gpio0 2 GPIO_ACTIVE_HIGH>;
          };
      };
  };

compatible: "gpio-leds"    # 设备兼容性字符串

child-binding:             # 子节点的 binding
  description: GPIO LED child node

  include:
    - name: led-node.yaml  # 包含 LED 通用属性
      property-allowlist:
        - label

  properties:
    gpios:                 # 必须指定 GPIO
      type: phandle-array
      required: true
```

**关键点:**
- `compatible: "gpio-leds"` 是固定的，必须使用这个值
- `gpios` 属性是**必需的** (`required: true`)
- `gpios` 类型是 `phandle-array`，格式为 `<&控制器 引脚号 标志>`

### 4.4 espressif,esp32-gpio.yaml 详解

**文件路径:** `zephyr/dts/bindings/gpio/espressif,esp32-gpio.yaml`

```yaml
description: ESP32 GPIO controller

compatible: "espressif,esp32-gpio"

include: [gpio-controller.yaml, base.yaml]

properties:
  reg:
    required: true

  "#gpio-cells":
    const: 2              # ESP32 GPIO 需要2个参数

gpio-cells:
  - pin                   # 第1个参数: 引脚号
  - flags                 # 第2个参数: 标志位
```

**这告诉我们:**
- 引用 ESP32 GPIO 时，需要提供 **2 个参数**
- 格式: `<&gpioX 引脚号 标志位>`
- 例如: `<&gpio0 2 GPIO_ACTIVE_HIGH>`

---

## 5. 如何查找硬件标签

### 5.1 方法一: 从板级 DTS 向上追溯 (你目前的方法)

```
esp32_devkitc_procpu.dts
    │
    ├── #include <espressif/esp32/esp32_wrover_e_n4r8.dtsi>
    │       │
    │       └── #include "esp32_common.dtsi"  ← 所有标签在这里定义!
    │
    └── #include "esp32_devkitc-pinctrl.dtsi"  ← 引脚复用配置
```

### 5.2 方法二: 查看构建生成的 zephyr.dts

构建后查看 `build/zephyr/zephyr.dts`，这是**所有 DTS 合并后的最终结果**：

```bash
west build -b esp32_devkitc/esp32/procpu samples/basic/blinky
cat build/zephyr/zephyr.dts
```

### 5.3 方法三: 直接查看 SoC 通用层

**ESP32:** `zephyr/dts/xtensa/espressif/esp32/esp32_common.dtsi`

这个文件列出了所有可用外设及其标签。

### 5.4 方法四: 使用 grep 搜索

```bash
# 搜索所有 GPIO 相关标签
grep -r "gpio[0-9]*:" zephyr/dts/xtensa/espressif/

# 搜索特定 compatible
grep -r "espressif,esp32-gpio" zephyr/dts/
```

### 5.5 ESP32 可用 GPIO 引脚一览

根据 `esp32_wrover_e_n4r8.dtsi` 中的 `gpio-reserved-ranges`:

| GPIO 控制器 | 可用引脚 | 不可用引脚 (保留) |
|-------------|---------|------------------|
| `&gpio0` | 0-5, 12-15, 18-19, 21-23, 25-27 | 6-11 (Flash), 16-17 (PSRAM), 20, 24, 28-31 |
| `&gpio1` | 32-34, 39 | 35-36, 37-38 (NC) |

**常用引脚建议:**
- LED: GPIO2 (板载指示灯通常连接这里)
- 按键: GPIO0 (BOOT 按键)
- I2C: GPIO21 (SDA), GPIO22 (SCL)
- SPI: GPIO12-15

---

## 6. 编写 Overlay 文件实战

### 6.1 创建 Overlay 文件

为 `blinky` 示例创建 ESP32 的 Overlay 文件:

**文件路径:** `samples/basic/blinky/boards/esp32_devkitc_esp32_procpu.overlay`

**命名规则:** `<board_name>.overlay`
- 板名来自构建命令: `west build -b esp32_devkitc/esp32/procpu`
- 转换为文件名: `esp32_devkitc_esp32_procpu.overlay`

### 6.2 最简单的 LED Overlay

```dts
/ {
    aliases {
        led0 = &myled0;    /* 定义 led0 别名，代码通过 DT_ALIAS(led0) 访问 */
    };

    leds {
        compatible = "gpio-leds";    /* 必须是这个值 */

        myled0: led_0 {
            gpios = <&gpio0 2 GPIO_ACTIVE_HIGH>;    /* GPIO2, 高电平点亮 */
            label = "User LED";
        };
    };
};
```

### 6.3 详细解释每一行

```dts
/ {                                    /* 根节点，与板级DTS合并 */
    aliases {
        led0 = &myled0;                /* 创建别名 led0 指向 myled0 节点 */
                                       /* 代码用 DT_ALIAS(led0) 获取这个节点 */
    };

    leds {                             /* 新建 leds 容器节点 */
        compatible = "gpio-leds";      /* 声明这是 GPIO LED 组 */
                                       /* 驱动通过此值匹配 */

        myled0: led_0 {                /* myled0 是标签，led_0 是节点名 */
            gpios = <&gpio0 2 GPIO_ACTIVE_HIGH>;
            /*       ^^^^^^ ^ ^^^^^^^^^^^^^^^^^
             *       |      | |
             *       |      | +-- 标志位: 高电平有效
             *       |      +---- 引脚号: GPIO2
             *       +----------- phandle: 引用 gpio0 控制器
             */
            label = "User LED";        /* 可选: 人类可读描述 */
        };
    };
};
```

### 6.4 多个 LED 的 Overlay

```dts
/ {
    aliases {
        led0 = &red_led;
        led1 = &green_led;
        led2 = &blue_led;
    };

    leds {
        compatible = "gpio-leds";

        red_led: led_red {
            gpios = <&gpio0 2 GPIO_ACTIVE_HIGH>;
            label = "Red LED";
        };

        green_led: led_green {
            gpios = <&gpio0 4 GPIO_ACTIVE_HIGH>;
            label = "Green LED";
        };

        blue_led: led_blue {
            gpios = <&gpio0 5 GPIO_ACTIVE_LOW>;   /* 低电平点亮 */
            label = "Blue LED";
        };
    };
};
```

### 6.5 添加按键的 Overlay

```dts
/ {
    aliases {
        led0 = &myled0;
        sw0 = &user_button;    /* 按键别名 */
    };

    leds {
        compatible = "gpio-leds";
        myled0: led_0 {
            gpios = <&gpio0 2 GPIO_ACTIVE_HIGH>;
        };
    };

    buttons {
        compatible = "gpio-keys";

        user_button: button_0 {
            gpios = <&gpio0 15 (GPIO_PULL_UP | GPIO_ACTIVE_LOW)>;
            label = "User Button";
            zephyr,code = <INPUT_KEY_0>;
        };
    };
};
```

---

## 7. Blinky 示例代码分析

### 7.1 代码如何访问设备树

**文件:** `samples/basic/blinky/src/main.c`

```c
#include <zephyr/kernel.h>
#include <zephyr/drivers/gpio.h>

#define SLEEP_TIME_MS   1000

/* 通过 DT_ALIAS 获取 led0 别名对应的节点 */
#define LED0_NODE DT_ALIAS(led0)

/* 从设备树节点提取 GPIO 配置 */
static const struct gpio_dt_spec led = GPIO_DT_SPEC_GET(LED0_NODE, gpios);
/*                                     ^^^^^^^^^^^^^^^^ ^^^^^^^^^  ^^^^^
 *                                     |                |          |
 *                                     |                |          +-- 属性名: gpios
 *                                     |                +------------- 设备树节点
 *                                     +------------------------------- 宏: 获取GPIO规格
 */

int main(void)
{
    /* 检查 GPIO 设备是否就绪 */
    if (!gpio_is_ready_dt(&led)) {
        return 0;
    }

    /* 配置 GPIO 为输出模式 */
    gpio_pin_configure_dt(&led, GPIO_OUTPUT_ACTIVE);

    while (1) {
        /* 翻转 GPIO 状态 */
        gpio_pin_toggle_dt(&led);
        k_msleep(SLEEP_TIME_MS);
    }
    return 0;
}
```

### 7.2 宏展开过程

假设 Overlay 定义:
```dts
aliases { led0 = &myled0; };
leds {
    compatible = "gpio-leds";
    myled0: led_0 {
        gpios = <&gpio0 2 GPIO_ACTIVE_HIGH>;
    };
};
```

**宏展开:**
```c
DT_ALIAS(led0)
    ↓
/* 找到 aliases 中 led0 对应的节点 */
DT_N_S_leds_S_led_0    /* 生成的节点标识符 */

GPIO_DT_SPEC_GET(LED0_NODE, gpios)
    ↓
/* 提取为 gpio_dt_spec 结构体 */
{
    .port = DEVICE_DT_GET(DT_GPIO_CTLR(node, prop)),  /* &gpio0 对应的设备 */
    .pin = 2,                                          /* 引脚号 */
    .dt_flags = GPIO_ACTIVE_HIGH                       /* 标志位 */
}
```

### 7.3 prj.conf 配置

**文件:** `samples/basic/blinky/prj.conf`

```ini
CONFIG_GPIO=y    # 启用 GPIO 子系统
```

---

## 8. 常用 GPIO 标志位

**头文件:** `zephyr/include/zephyr/dt-bindings/gpio/gpio.h`

### 8.1 电平有效性

| 标志 | 值 | 说明 |
|------|-----|------|
| `GPIO_ACTIVE_HIGH` | 0 | 高电平有效 (默认) |
| `GPIO_ACTIVE_LOW` | 1 | 低电平有效 |

### 8.2 输出驱动模式

| 标志 | 说明 |
|------|------|
| `GPIO_PUSH_PULL` | 推挽输出 (默认) |
| `GPIO_OPEN_DRAIN` | 开漏输出 (需外部上拉) |
| `GPIO_OPEN_SOURCE` | 开源输出 (需外部下拉) |

### 8.3 上下拉电阻

| 标志 | 说明 |
|------|------|
| `GPIO_PULL_UP` | 启用内部上拉 |
| `GPIO_PULL_DOWN` | 启用内部下拉 |

### 8.4 组合使用

```dts
/* 低电平有效 + 内部上拉 (常用于按键) */
gpios = <&gpio0 0 (GPIO_PULL_UP | GPIO_ACTIVE_LOW)>;

/* 开漏输出 (常用于 I2C) */
gpios = <&gpio0 21 GPIO_OPEN_DRAIN>;

/* 高电平有效 (简单LED) */
gpios = <&gpio0 2 GPIO_ACTIVE_HIGH>;
```

---

## 9. 调试技巧

### 9.1 查看最终合并的设备树

```bash
# 构建项目
west build -b esp32_devkitc/esp32/procpu samples/basic/blinky

# 查看合并后的完整设备树
cat build/zephyr/zephyr.dts

# 查看生成的设备树宏
cat build/zephyr/include/generated/zephyr/devicetree_generated.h
```

### 9.2 验证设备树节点

在 `zephyr.dts` 中搜索你的 LED 定义:
```bash
grep -A5 "compatible = \"gpio-leds\"" build/zephyr/zephyr.dts
```

### 9.3 常见错误及解决

| 错误 | 原因 | 解决方案 |
|------|------|---------|
| `Undefined node label '&xxx'` | 标签不存在 | 检查 SoC 层 dtsi 中的定义 |
| `'gpios' is marked as required` | 缺少 gpios 属性 | 添加 gpios 属性到 LED 节点 |
| `'compatible' is required` | 缺少 compatible | 添加 `compatible = "gpio-leds";` |
| GPIO 不工作 | 引脚被保留 | 检查 gpio-reserved-ranges，换用其他引脚 |

### 9.4 Overlay 文件不生效

检查:
1. 文件名是否正确: `<board>.overlay`
2. 文件位置是否正确: 项目根目录下
3. 板名格式: `esp32_devkitc/esp32/procpu` → `esp32_devkitc_esp32_procpu.overlay`

---

## 总结

| 层级 | 文件类型 | 职责 |
|------|---------|------|
| 应用层 | `.overlay` | 添加应用特定设备 |
| 板级层 | `.dts` | 开发板配置、启用外设 |
| 芯片封装层 | `.dtsi` | Flash/RAM大小、保留引脚 |
| SoC通用层 | `.dtsi` | **定义所有外设及标签** |
| 架构层 | `.dtsi` | 定义 soc 容器节点 |
| 骨架层 | `.dtsi` | 定义最基础结构 |

**查找标签的最佳实践:**
1. 从板级 DTS 找到 SoC include
2. 在 SoC 通用层 (`esp32_common.dtsi`) 找到所有可用标签
3. 在芯片封装层查看保留引脚
4. 在 `dts/bindings/` 查看属性要求

**编写 Overlay 的步骤:**
1. 确定需要的外设标签 (如 `&gpio0`)
2. 查看对应的 binding 文件了解属性格式
3. 创建 `boards/<board>.overlay` 文件
4. 添加 aliases 供代码访问
5. 构建并查看 `zephyr.dts` 验证
