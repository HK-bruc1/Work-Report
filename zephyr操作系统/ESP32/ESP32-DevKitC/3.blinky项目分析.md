# 项目必须文件



## src功能文件

`blinky\src\main.c`

```c
/*
 * Copyright (c) 2016 Intel Corporation
 *
 * SPDX-License-Identifier: Apache-2.0
 */

#include <stdio.h>
#include <zephyr/kernel.h>
#include <zephyr/drivers/gpio.h>

/* 1000 msec = 1 sec */
#define SLEEP_TIME_MS   1000

/* The devicetree node identifier for the "led0" alias. */
#define LED0_NODE DT_ALIAS(led0)

/*
 * A build error on this line means your board is unsupported.
 * See the sample documentation for information on how to fix this.
 */
static const struct gpio_dt_spec led = GPIO_DT_SPEC_GET(LED0_NODE, gpios);

int main(void)
{
	int ret;
	bool led_state = true;

	if (!gpio_is_ready_dt(&led)) {
		return 0;
	}

	ret = gpio_pin_configure_dt(&led, GPIO_OUTPUT_ACTIVE);
	if (ret < 0) {
		return 0;
	}

	while (1) {
		ret = gpio_pin_toggle_dt(&led);
		if (ret < 0) {
			return 0;
		}

		led_state = !led_state;
		printf("LED state: %s\n", led_state ? "ON" : "OFF");
		k_msleep(SLEEP_TIME_MS);
	}
	return 0;
}

```

## 设备树补充及其补充文件

`zephyr\boards\espressif\esp32_devkitc\esp32_devkitc_procpu.dts`

```c
/*
 * Copyright (c) 2023-2025 Espressif Systems (Shanghai) Co., Ltd.
 *
 * SPDX-License-Identifier: Apache-2.0
 */
/dts-v1/;

#include <espressif/esp32/esp32_wrover_e_n4r8.dtsi>
#include "esp32_devkitc-pinctrl.dtsi"
#include <zephyr/dt-bindings/input/input-event-codes.h>
#include <zephyr/dt-bindings/input/esp32-touch-sensor-input.h>
#include <espressif/partitions_0x1000_amp.dtsi>

/ {
	model = "Espressif ESP32-DevkitC PROCPU";
	compatible = "espressif,esp32";

	aliases {
		uart-0 = &uart0;
		i2c-0 = &i2c0;
		sw0 = &button0;
		watchdog0 = &wdt0;
	};

	buttons {
		compatible = "gpio-keys";

		button0: button_0 {
			gpios = <&gpio0 0 (GPIO_PULL_UP | GPIO_ACTIVE_LOW)>;
			label = "BOOT Button";
			zephyr,code = <INPUT_KEY_0>;
		};
	};

	chosen {
		zephyr,sram = &sram1;
		zephyr,console = &uart0;
		zephyr,shell-uart = &uart0;
		zephyr,flash = &flash0;
		zephyr,code-partition = &slot0_partition;
		zephyr,bt-hci = &esp32_bt_hci;
	};
};

&uart0 {
	status = "okay";
	current-speed = <115200>;
	pinctrl-0 = <&uart0_default>;
	pinctrl-names = "default";
};

&uart1 {
	current-speed = <115200>;
	pinctrl-0 = <&uart1_default>;
	pinctrl-names = "default";
};

&uart2 {
	current-speed = <115200>;
	pinctrl-0 = <&uart2_default>;
	pinctrl-names = "default";
};

&gpio0 {
	status = "okay";
};

&gpio1 {
	status = "okay";
};

&touch {
	debounce-interval-ms = <30>;
	href-microvolt = <2700000>;
	lref-microvolt = <500000>;
	href-atten-microvolt = <1000000>;
	filter-mode = <ESP32_TOUCH_FILTER_MODE_IIR_16>;
	filter-debounce-cnt = <1>;
	filter-noise-thr = <ESP32_TOUCH_FILTER_NOISE_THR_4_8TH>;
	filter-jitter-step = <4>;
	filter-smooth-level = <ESP32_TOUCH_FILTER_SMOOTH_MODE_IIR_2>;
};

&i2c0 {
	status = "okay";
	clock-frequency = <I2C_BITRATE_STANDARD>;
	sda-gpios = <&gpio0 21 GPIO_OPEN_DRAIN>;
	scl-gpios = <&gpio0 22 GPIO_OPEN_DRAIN>;
	pinctrl-0 = <&i2c0_default>;
	pinctrl-names = "default";
};

&i2s0 {
	pinctrl-0 = <&i2s0_default>;
	pinctrl-names = "default";
};

&i2s1 {
	pinctrl-0 = <&i2s1_default>;
	pinctrl-names = "default";
};

&spi2 {
	#address-cells = <1>;
	#size-cells = <0>;
	status = "okay";
	pinctrl-0 = <&spim2_default>;
	pinctrl-names = "default";
};

&spi3 {
	#address-cells = <1>;
	#size-cells = <0>;
	status = "okay";
	pinctrl-0 = <&spim3_default>;
	pinctrl-names = "default";
};

&timer0 {
	status = "disabled";
};

&timer1 {
	status = "disabled";
};

&timer2 {
	status = "disabled";
};

&timer3 {
	status = "disabled";
};

&trng0 {
	status = "okay";
};

&esp32_bt_hci {
	status = "okay";
};

&wifi {
	status = "okay";
};
```

### 补充文件

`blinky\esp32_devkitc_esp32_procpu.overlay`

```c
/ {
    aliases {
        led0 = &myled0;
    };

    leds {
        compatible = "gpio-leds";
        
        myled0: led_0 {
            gpios = <&gpio0 2 GPIO_ACTIVE_HIGH>;
            label = "User LED";
        };
    };
};
```

## 构建描述

`blinky\CMakeLists.txt`

```c
# SPDX-License-Identifier: Apache-2.0

cmake_minimum_required(VERSION 3.20.0)
find_package(Zephyr REQUIRED HINTS $ENV{ZEPHYR_BASE})
project(blinky)
target_sources(app PRIVATE src/main.c)
```

## 构建参数

`blinky\prj.conf`

```c
CONFIG_GPIO=y
```

# src为什么可以这么写？

## 通过设备树访问硬件

```c
/* The devicetree node identifier for the "led0" alias. */
#define LED0_NODE DT_ALIAS(led0)
/**
 * @brief Get a node identifier from /aliases
 *
 * This macro's argument is a property of the `/aliases` node. It
 * returns a node identifier for the node which is aliased. Convert
 * non-alphanumeric characters in the alias property to underscores to
 * form valid C tokens, and lowercase all letters.
 *
 * Example devicetree fragment:
 *
 * @code{.dts}
 *     / {
 *             aliases {
 *                     my-serial = &serial1;
 *             };
 *
 *             soc {
 *                     serial1: serial@40001000 {
 *                             status = "okay";
 *                             current-speed = <115200>;
 *                             ...
 *                     };
 *             };
 *     };
 * @endcode
 *
 * You can use DT_ALIAS(my_serial) to get a node identifier for the
 * `serial@40001000` node. Notice how `my-serial` in the devicetree
 * becomes `my_serial` in the DT_ALIAS() argument. Example usage with
 * DT_PROP() to get the current-speed property:
 *
 * @code{.c}
 *     DT_PROP(DT_ALIAS(my_serial), current_speed) // 115200
 * @endcode
 *
 * @param alias lowercase-and-underscores alias name.
 * @return node identifier for the node with that alias
 */
#define DT_ALIAS(alias) DT_CAT(DT_N_ALIAS_, alias)
```

这个宏的写法 DT_ALIAS(led0) 其实是 Zephyr Devicetree 提供的宏级抽象，它的核心目的是让你的 C 代码不依赖具体的硬件路径，而是通过一个**约定俗成的名字（alias）**来访问硬件。

```c
#define LED0_NODE DT_ALIAS(led0)
==>
#define LED0_NODE DT_CAT(DT_N_ALIAS_, led0)    
```

DT_CAT(a, b) 是 Zephyr 提供的简单 token 拼接宏，展开后就是：

```c
#define LED0_NODE DT_N_ALIAS_led0
```

这个 DT_N_ALIAS_led0 就是 Zephyr 在编译时自动生成的 node identifier（节点标识符），它代表 /aliases 节点下 led0 = &... 指向的那个实际硬件节点。

## 编译器是怎么生成这些宏的？

Zephyr 在构建过程中会：

1. 读取所有 .dts、.dtsi 和 overlay 文件，合并成一个完整的设备树。
2. 运行 gen_defines.py 脚本（位于 scripts/dts/gen_defines.py），根据设备树内容生成 devicetree_generated.h 文件。
3. 在 devicetree_generated.h 中，会为 **每个节点** 生成一堆宏，比如：

```c
/* 某个 GPIO LED 节点（假设是 nrf52840 的 P0.13） */
#define DT_N_S_leds_S_led_0               1
#define DT_N_S_leds_S_led_0_STATUS        okay
#define DT_N_S_leds_S_led_0_LABEL         "User LED"
#define DT_N_S_leds_S_led_0_GPIOS         {DT_N_S_soc_S_gpio_50000000, 13, 1}
...
/* aliases 节点 */
#define DT_N_ALIAS_led0                   DT_N_S_leds_S_led_0
```

- 把特定结构的文档转成头文件中的宏，这种操作再熟悉不过了。

### 什么位置？

在对应的项目中的build目录下：
`blinky\build\esp32_devkitc\esp32\procpu\zephyr\include\generated\zephyr\devicetree_generated.h`

```c
/* Existence and alternate IDs: */
#define DT_N_S_leds_S_led_0_EXISTS 1
#define DT_N_ALIAS_led0       DT_N_S_leds_S_led_0
#define DT_N_NODELABEL_myled0 DT_N_S_leds_S_led_0
```

### 從宏到硬件的完整路徑

```c
DTS 文件描述
   ↓ (gen_defines.py 解析 + 展開)
devicetree_generated.h 裡的宏（DT_N_...）
   ↓ (DT_ALIAS / DT_NODELABEL 使用這些宏)
你的 C 代碼裡的 node identifier（如 LED0_NODE）
   ↓ (GPIO_DT_SPEC_GET 宏展開)
struct gpio_dt_spec 結構體（包含 .port + .pin + .flags）
   ↓ (DEVICE_DT_GET + gpio API)
struct device * （指向 GPIO 驅動實例）
   ↓ (gpio_driver_api 中的函數指針)
gpio_port 驅動的實現（通常是 SoC 特定代碼）
   ↓ (寄存器操作)
真實的 GPIO 硬件寄存器（寫 1/0 → LED 亮/滅）
```

- `LED0_NODE`被最后替换成了`DT_N_S_leds_S_led_0`

```c
/*
 * A build error on this line means your board is unsupported.
 * See the sample documentation for information on how to fix this.
 */
static const struct gpio_dt_spec led = GPIO_DT_SPEC_GET(LED0_NODE, gpios);
```

它实际上会发生下面这些“宏替换”和“层层展开”的过程，最终生成一个可以直接访问硬件的结构体初始化。

### 最终最核心的宏展开

```c
#define GPIO_DT_SPEC_GET_BY_IDX(node_id, prop, idx)     \
    {                                                   \
        .port = DEVICE_DT_GET(DT_GPIO_CTLR_BY_IDX(node_id, prop, idx)), \
        .pin  = DT_GPIO_PIN_BY_IDX(node_id, prop, idx),                 \
        .dt_flags = DT_GPIO_FLAGS_BY_IDX(node_id, prop, idx),           \
    }
```

从接收变量去看最终的替换效果：

经过所有宏的层层展开后，这个 led 变量会被编译器初始化成下面这样的内容（以常见板子为例，实际值取决于你的 .dts 文件）：

```c
static const struct gpio_dt_spec led = {
    .port     = &gpio0_device,             // 指向真正的 GPIO 控制器设备实例（struct device *）
    .pin      = 13,                        // 具体的 GPIO 引脚编号，例如 GPIO13
    .dt_flags = GPIO_ACTIVE_HIGH           // 极性标志，例如高电平有效（1）或低电平有效（0）
};
```

### 这个结构体到底代表什么？为什么它能控制硬件？

struct gpio_dt_spec 就像一张“硬件通行证”，它把所有需要的信息都打包好了：

| 成员      | 含义                        | 来源（宏展开后）                           | 最终用途                             |
| --------- | --------------------------- | ------------------------------------------ | ------------------------------------ |
| .port     | GPIO 控制器的设备指针       | DEVICE_DT_GET(...) → 指向 gpio0 的驱动实例 | 告诉系统“我要操作哪个 GPIO 外设”     |
| .pin      | 具体的引脚编号              | DT_GPIO_PIN(...) → 直接是数字，如 13       | 告诉驱动“我要操作这个引脚”           |
| .dt_flags | 引脚的极性配置（高/低有效） | DT_GPIO_FLAGS(...) → 如 GPIO_ACTIVE_HIGH   | 告诉驱动“高电平点亮”还是“低电平点亮” |

**就是说在预处理阶段，就已经拿到了硬件的基本信息！**

### 整个硬件访问流程

在 Zephyr 中，整个硬件访问流程可以分成两个清晰的阶段：

1. **编译预处理阶段（Compile-time）** → 通过设备树（.dts + overlay） + gen_defines.py 脚本 → 把硬件的所有关键信息（哪个 GPIO 控制器、哪个引脚、什么极性）提前“烘焙”进代码里 → 最终体现在 struct gpio_dt_spec led 这个小结构体中 这时候你已经“静态地”拿到了硬件的基本信息，而且是**类型安全、编译期检查**的！
2. **运行时阶段（Runtime）** → 主程序里直接使用 gpio_pin_xxx_dt() 系列接口 → 这些接口拿到的就是那个提前准备好的 &led（struct gpio_dt_spec *） → 内部会通过 .port->api 调用 SoC 特定的驱动函数 → 最终真正写寄存器，控制硬件

**一句话总结：**

**预处理阶段** 把硬件信息“写死”进 led 结构体（安全、零开销）； **运行阶段** 只需拿着这个结构体调用几个 dt 接口，就能完成所有硬件操作。

这种设计让你的代码：

- **高度可移植**：换板子、换引脚、换 LED 极性 → 只改设备树
- **零魔术数字**：代码里没有硬编码的 13、GPIO0 等
- **易维护**：出问题一看 led.port、led.pin 就知道是哪个硬件

如果你以后想控制多个 LED、按钮、I2C 设备、SPI Flash 等，基本模式都是一样的： 先用 DT_ALIAS 或 DT_NODELABEL 拿到 node_id → 用对应的 *_DT_SPEC_GET 拿到 spec 结构体 → 然后调用 *_dt() 接口。

```c
int main(void)
{
    int ret;
    bool led_state = true;

    // 第一步：检查硬件是否就绪（运行时检查）
    if (!gpio_is_ready_dt(&led)) {
        return 0;  // 如果 GPIO 设备没准备好（比如驱动没初始化），直接退出
    }

    // 第二步：配置引脚为输出 + 初始状态（ACTIVE = 根据 dt_flags 自动处理极性）
    ret = gpio_pin_configure_dt(&led, GPIO_OUTPUT_ACTIVE);
    if (ret < 0) {
        return 0;
    }

    // 第三步：无限循环翻转 LED
    while (1) {
        // 翻转 LED 状态（内部会自动处理极性）
        ret = gpio_pin_toggle_dt(&led);
        if (ret < 0) {
            return 0;
        }

        led_state = !led_state;
        printf("LED state: %s\n", led_state ? "ON" : "OFF");

        k_msleep(SLEEP_TIME_MS);  // 延时（通常 1000ms = 1秒）
    }

    return 0;
}
```

### 开发方式对比

| 项目                        | STM32 裸机开发（传统方式）                                  | Zephyr + 设备树开发方式                                      | 主要优势（Zephyr 侧）                                        |
| --------------------------- | ----------------------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 硬件信息来源                | 手动从参考手册抄寄存器基地址（如 GPIOA_BASE = 0x40020000）  | 全部来自 .dts / .dtsi 文件，编译时自动生成宏和结构体         | 不用自己抄地址，换芯片/板子不用改代码                        |
| 访问方式                    | 直接用结构体指针 + 位运算 `GPIOA->MODER                     | = (1 << 13*2);`                                              | 用抽象结构体 + 高层 API `gpio_pin_configure_dt(&led, GPIO_OUTPUT);` |
| 配置引脚功能                | 手动写寄存器位域 如 MODER、OTYPER、OSPEEDR、PUPDR 等        | 一条 API 搞定所有 `gpio_pin_configure_dt()` 内部自动处理     | 不用记几十个寄存器位域，极性自动处理                         |
| 极性/初始状态处理           | 自己判断高/低有效，自己设置初始值                           | 设备树里写 `GPIO_ACTIVE_HIGH/LOW`，API 自动应用              | 换 LED 极性只改 .dts，不改代码                               |
| 移植性                      | 换 MCU（如从 F4 到 H7 到 G0）要重写一大堆寄存器地址和位定义 | 换板子/芯片，只需换 .dts + board_defconfig，代码基本不动     | 真正实现“一次编写，到处运行”                                 |
| 出错概率                    | 高（地址抄错、位域算错、忘记清位等）                        | 极低（编译期检查 + 抽象层）                                  | 减少低级 bug，开发效率翻倍                                   |
| 代码量（控制一个 LED 示例） | 通常 20~50 行（初始化 + 配置 + 控制）                       | 10 行以内（主要是 while 循环）                               | 更简洁、更专注业务逻辑                                       |
| 底层实现                    | 你自己写或用厂商库（如 STM32Cube HAL/LL）                   | Zephyr 官方 + SoC 厂商维护的驱动（esp32_gpio.c、stm32_gpio.c 等） | 统一接口，厂商维护驱动，你不用管底层细节                     |

在 STM32 裸机开发中，你是**“直接跟寄存器说话”的人，需要自己拿着参考手册去“翻译”硬件需求。 而在 Zephyr 中，你变成了“跟抽象接口说话”**的人，设备树 + 编译期宏已经帮你把所有寄存器地址、位域、控制器信息“翻译”好了，你只要拿着 struct gpio_dt_spec 调用几条 dt 接口，就能完成同样的功能，而且更安全、更可移植。

## 构建时的优化选项

构建时的几个选项：

| 你现在的目标                           | 推荐选项         | 理由                                                         |
| -------------------------------------- | ---------------- | ------------------------------------------------------------ |
| 正在 debug 程序、单步、看变量          | Debug            | 调试体验最好，代码大小大一点没关系（esp32-s3 4MB flash 够用） |
| 已经调试完，想跑性能测试               | Speed            | 平衡性能与大小，Zephyr 官方大多数板子默认这个                |
| Flash/RAM 很紧张（esp32-s3 1MB flash） | Size             | 优先减小 .text / .rodata，大幅减小固件大小                   |
| 想跟板子官方一致（最保险）             | Do not set       | 让板子的 defconfig 决定（nrf52840dk 通常是 -O2，esp32 是 -Os） |
| 极端调试（看最原始汇编）               | No optimizations | 很少用，除非你怀疑优化导致了 bug                             |

# 一些GPIO接口

`zephyr\include\zephyr\drivers\gpio.h`

太多了。。。只能慢慢熟悉。

