# 主机依赖项

## 三个主机依赖项的角色

### **CMake - 构建系统**

**在Zephyr中的作用:**

- 管理整个项目的编译配置和依赖关系
- 根据目标板子自动选择合适的工具链、编译选项
- 处理Kconfig配置,生成最终的编译脚本

**对比STM32开发:**

- STM32CubeIDE: 使用Eclipse + Make/Makefile,配置相对固定
- Keil: 使用自己的项目管理系统(.uvproj文件)
- Zephyr: 使用CMake统一管理,支持跨平台、多架构,更灵活但也更复杂

### **Python - 脚本引擎**

**在Zephyr中的作用:**

- 运行各种构建辅助脚本(生成配置、处理设备树等)
- West工具(Zephyr的meta-tool)就是用Python编写的
- 运行devicetree编译器、Kconfig处理器等工具

**对比STM32开发:**

- STM32CubeMX: 图形化配置工具,生成初始化代码
- Zephyr: 使用Python脚本自动化处理配置,更适合CI/CD和命令行工作流

### **Devicetree Compiler (dtc) - 硬件描述处理器**

**这是最关键的区别!**

**在Zephyr中的作用:**

- 解析 `.dts` (Device Tree Source) 文件,描述硬件配置
- 编译成 `.dtb` (Device Tree Blob) 二进制格式
- 在编译时确定引脚、外设、内存布局等硬件资源

**对比STM32开发:**

| 方面     | STM32传统方式           | Zephyr Devicetree方式        |
| -------- | ----------------------- | ---------------------------- |
| 硬件配置 | STM32CubeMX图形界面点选 | .dts文本文件描述             |
| 引脚配置 | 生成HAL初始化代码       | devicetree + driver自动绑定  |
| 外设配置 | 手动调用HAL_xxx_Init()  | 通过devicetree节点自动初始化 |
| 可移植性 | 需要重新配置CubeMX      | 只需更换.dts文件             |

具体例子:

STM32传统方式(CubeMX生成的代码):

```c
// main.c - 手动初始化
void MX_GPIO_Init(void) {
    GPIO_InitTypeDef GPIO_InitStruct = {0};
    __HAL_RCC_GPIOA_CLK_ENABLE();
    GPIO_InitStruct.Pin = GPIO_PIN_5;
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
}
```

Zephyr Devicetree方式:

```c
// board.dts - 声明式硬件描述
&gpioa {
    status = "okay";
};

/ {
    leds {
        compatible = "gpio-leds";
        led0: led_0 {
            gpios = <&gpioa 5 GPIO_ACTIVE_HIGH>;
            label = "User LED";
        };
    };
};

// main.c - 自动绑定,无需手动初始化
#define LED0_NODE DT_ALIAS(led0)
const struct gpio_dt_spec led = GPIO_DT_SPEC_GET(LED0_NODE, gpios);
// driver已根据devicetree自动初始化
```

工作流程对比：

~~~c
**STM32传统流程:**
```
CubeMX配置 → 生成代码 → IDE编译 → 烧录
   (GUI)      (C代码)    (Make)    (OpenOCD/STLink)
```

**Zephyr流程:**
```
编写.dts → Kconfig配置 → CMake构建 → 烧录
 (硬件)     (功能选项)    (自动化)   (west flash)
   ↓           ↓            ↓
devicetree  Python脚本   工具链调用
compiler    处理配置     编译链接
~~~

## 使用winget软件包管理器安装依赖

在现代 Windows 版本中，winget 默认已预装。

```c
winget install Kitware.CMake Ninja-build.Ninja oss-winget.gperf Python.Python.3.12 Git.Git oss-winget.dtc wget 7zip.7zip
```

### 检查哪一些是安装了的

```c
# 1. CMake
cmake --version

# 2. Ninja
ninja --version

# 3. gperf
gperf --version

# 4. Python (检查3.12版本)
python --version

# 5. Git
git --version

# 6. dtc (Devicetree Compiler)
dtc --version

# 7. wget
wget --version

# 8. 7zip
7z
```

# 安装zephyr中python有关的依赖项

1. 选择一个位置作为工作区
2. 创建虚拟环境并激活
3. 安装west项目管理与构建工具

## 为什么Zephyr选择**工作区隔离**而不是全局安装

场景1: 多项目版本冲突

```c
项目A (Zephyr 3.5)  → 需要 Python包 PyYAML 5.4
项目B (Zephyr 3.7)  → 需要 Python包 PyYAML 6.0
你的全局环境      → 只能装一个版本！💥
```

场景2: 污染系统环境

```c
# 全局安装了一堆Python包
pip install west pyelftools pykwalify ...（100+个包）

# 几个月后...
python my_personal_script.py
# 错误：包版本冲突！某个包升级导致其他脚本挂了
```

**场景3: 多个Zephyr版本并存**

```
C:\zephyr-project-v3.5\    # 旧项目，不想升级
C:\zephyr-project-v3.7\    # 新项目，用新特性
C:\zephyr-project-main\    # 跟踪最新开发版

# 全局环境：只能配一套依赖，其他项目可能跑不起来
```

## 虚拟环境的好处

1. **依赖隔离** ⭐最重要

```c
全局环境:
├── Python 3.12
└── site-packages/
    ├── west==1.2.0          (项目A需要)
    ├── west==1.3.0          (项目B需要) ❌ 冲突！
    └── 200+ 其他包...

虚拟环境:
项目A/.venv/
├── Python 3.12 (链接)
└── site-packages/
    └── west==1.2.0 ✓

项目B/.venv/
├── Python 3.12 (链接)
└── site-packages/
    └── west==1.3.0 ✓
```

2. 可复现性

```c
# 工作区方式：任何人都能重现你的环境
cd zephyr-project
python -m venv .venv
pip install -r requirements.txt  # 精确的版本记录 可以使用命令生成依赖目录和版本信息
west build ...                   # 100%一致的构建环境

# 全局方式：
# "在我电脑上能跑啊？" 
# "你装了什么版本的xxx？"
# "我也不知道，装了好多东西..."
```

3. **干净卸载**

```c
# 虚拟环境：直接删除文件夹
rm -rf zephyr-project/          # 完全干净

# 全局方式：
pip uninstall west pyelftools ...  # 要卸载几十个包
# 还可能遗留配置文件、注册表项等
```

4. **权限问题**

```c
# 全局安装：可能需要管理员权限
pip install west  # 可能失败：Permission Denied

# 虚拟环境：普通用户权限即可
.venv\Scripts\pip install west  # 在自己的目录，没问题
```

### 与STM32开发对比

STM32 Cube IDE (全局方式)

```c
优点:
✓ 简单，点击安装就行
✓ 所有项目共享工具链，节省空间  zephyr的主机依赖项也是共享的。

缺点:
✗ 不同版本Cube冲突  版本不一样就会打不开项目。
✗ 升级一个项目影响所有项目
✗ 工具链路径硬编码（C:\ST\...）
```

Zephyr (工作区方式)
```c
优点:
✓ 每个项目独立，互不影响
✓ 可以同时开发多个版本
✓ 团队成员环境完全一致
✓ CI/CD容易配置

缺点:
✗ 初次配置复杂一些
✗ 每个工作区占用一些空间（Python包）
```

### 实际工作流对比

方式A: 全局环境（不推荐）

```c
# 安装Zephyr
pip install west
west init ~/zephyr-project
cd ~/zephyr-project
west update

# 3个月后，要开发新项目
pip install --upgrade west  # 升级到新版本
cd ~/old-zephyr-project
west build ...  # 💥 错误！新版west不兼容旧项目
```

方式B: 虚拟环境（推荐）

```c
# 项目1 (Zephyr 3.5)
mkdir zephyr-project-old
cd zephyr-project-old
python -m venv .venv
.venv\Scripts\activate
pip install west==1.2.0
west init -m https://github.com/zephyrproject-rtos/zephyr --mr v3.5.0
west update

# 项目2 (Zephyr 3.7) - 完全独立！
cd ..
mkdir zephyr-project-new
cd zephyr-project-new
python -m venv .venv
.venv\Scripts\activate
pip install west==1.3.0
west init -m https://github.com/zephyrproject-rtos/zephyr --mr v3.7.0
west update

# 两个项目互不影响，可以随时切换
```

### 什么情况下用全局？

全局安装适合：

1. **系统级工具**: git, cmake（这些你确实要全局装）
2. **所有项目通用的稳定工具**: 编译器工具链
3. **CLI工具**: 你日常使用的命令行工具

不适合全局安装：

1. **项目特定依赖**: Python包、库文件
2. **频繁变化的工具**: west这类项目管理工具
3. **版本敏感的依赖**: 可能冲突的包

### Zephyr的推荐做法

```c
# 全局安装（系统级工具）
winget install Kitware.CMake Ninja-build.Ninja oss-winget.gperf Python.Python.3.12 Git.Git oss-winget.dtc wget 7zip.7zip

# 工作区安装（项目依赖）
cd my-zephyr-workspace //选择一个项目的工作区
python -m venv .venv //创建一个python虚拟环境
.venv\Scripts\activate //激活虚拟环境
pip install west //安装项目管理与构建工具
```

## 选择一个项目的工作区激活python的虚拟环境并安装有关依赖

```c
cd my-zephyr-workspace //选择一个项目的工作区
python -m venv .venv //创建一个python虚拟环境
.venv\Scripts\activate //激活虚拟环境
pip install west //工作区项目管理工具
```

- 激活后，您的 shell 名称将带有前缀`(.venv)`。您可以随时运行以下命令停用虚拟环境 `deactivate`。
- 每次开始工作时，请记住激活虚拟环境。

### West 是什么？

**West = Zephyr's meta-tool**（元工具/超级工具）

它是一个**多仓库管理工具** + **项目管理工具**，专门为Zephyr设计，但功能远不止这些。

West 的核心功能

1. **多仓库管理** (最重要的功能)

Zephyr不是单一代码仓库，而是由**多个Git仓库**组成：

- 链接到各个git仓库，实现模块化。

```c
zephyrproject/                    # 工作区根目录
├── .west/                        # west配置目录
│   └── config                    # west配置文件
├── zephyr/                       # 主仓库（OS核心）
├── modules/
│   ├── hal/stm32/               # STM32 HAL库（独立仓库）
│   ├── hal/nrf/                 # Nordic HAL库（独立仓库）
│   ├── crypto/mbedtls/          # mbedTLS加密库（独立仓库）
│   ├── fs/fatfs/                # FatFS文件系统（独立仓库）
│   └── ...                      # 50+ 个独立仓库
├── bootloader/mcuboot/          # MCUboot引导加载程序（独立仓库）
└── tools/                       # 各种工具（独立仓库）
```

**为什么要多仓库？**

- Zephyr支持100+种芯片，每个厂商的HAL库都是独立维护的
- 第三方库（mbedTLS、LwIP、FatFS）有自己的开发节奏
- **模块化设计，你只下载需要的部分**
  - West可以管理这一些模块。

### West 工作流详解

`west init` - 初始化工作区

```c
# 创建工作区并克隆主仓库
west init zephyrproject //在这个位置创建工作区

# 实际做了什么：
# 1. 创建 zephyrproject/ 目录
# 2. 创建 .west/ 配置目录
# 3. 克隆 zephyr 主仓库
# 4. 读取 zephyr/west.yml（清单文件）
```

**west.yml 是关键** - 它定义了所有依赖仓库：

```c
# zephyr/west.yml (简化版)
manifest:
  projects:
    - name: hal_stm32
      url: https://github.com/zephyrproject-rtos/hal_stm32
      revision: v1.10.0
      path: modules/hal/stm32
    
    - name: mbedtls
      url: https://github.com/Mbed-TLS/mbedtls
      revision: v3.5.0
      path: modules/crypto/mbedtls
    
    # ... 50+ 个其他仓库
```

`west update` - 获取所有模组依赖

```c
cd zephyrproject
west update

# 实际做了什么：
# 1. 读取 zephyr/west.yml
# 2. 克隆所有列出的仓库到指定目录
# 3. 检出指定的版本/分支
# 4. 确保所有仓库版本一致
```

**等价于手动操作**（但你不用这样做）：

```c
git clone https://github.com/zephyrproject-rtos/hal_stm32 modules/hal/stm32
cd modules/hal/stm32
git checkout v1.10.0
cd ../../..

git clone https://github.com/Mbed-TLS/mbedtls modules/crypto/mbedtls
cd modules/crypto/mbedtls
git checkout v3.5.0
# ... 重复50+次
```

### 项目构建管理

West 还封装了构建命令：

```c
# 传统方式（也能用）
mkdir build
cd build
cmake -DBOARD=stm32f4_disco ../app
ninja

# West方式（更简洁）
west build -b stm32f4_disco app
west build -t menuconfig      # 打开配置菜单
west flash                     # 烧录
west debug                     # 调试
west attach                    # 连接调试器
```

### 其他实用功能

~~~c
# 查看工作区状态
west status                    # 显示所有仓库的git状态

# 更新所有仓库
west update                    # 拉取最新代码

# 查看配置的仓库列表
west list                      # 列出所有项目及路径

# 在所有仓库执行git命令
west forall -c "git status"    # 对所有仓库执行git status

# 导出环境变量
west zephyr-export            # 设置Zephyr开发环境变量

### Zephyr West方式
```
自动化操作:
1. west init （只下载主仓库）
2. west update （按需下载HAL）
3. 版本在west.yml中精确定义
4. 更新时：west update

优势:
- 只下载用到的HAL
- 版本精确控制
- 团队共享west.yml就能保证环境一致
~~~

### 与STM32开发对比

STM32 Cube方式

```c
手动操作:
1. 从ST官网下载CubeF4固件包（1GB+）
2. 解压到C:\STM32Cube\Repository\
3. CubeIDE自动识别
4. 更新时重新下载整个包

问题:
- 所有ST系列都要下载全部固件
- 版本管理困难
- 团队协作需要保证版本一致
```

Zephyr West方式

```c
自动化操作:
1. west init （只下载主仓库）
2. west update （按需下载HAL）
3. 版本在west.yml中精确定义
4. 更新时：west update

优势:
- 只下载用到的HAL
- 版本精确控制
- 团队共享west.yml就能保证环境一致
```

### West 的设计哲学

West解决了这些痛点：

1. **依赖地狱**: 手动管理50+个仓库太痛苦
2. **版本一致性**: 确保所有模块版本匹配
3. **可复现构建**: 同样的west.yml = 同样的代码 = 同样的结果
4. **团队协作**: 共享west.yml，大家环境完全一致
5. **CI/CD友好**: 脚本化的构建流程

### 总结对比

| 功能       | West           | Git Submodules | STM32 Cube   |
| ---------- | -------------- | -------------- | ------------ |
| 多仓库管理 | ✓ 强大灵活     | ✓ 基础功能     | ✗ 单一固件包 |
| 版本锁定   | ✓ west.yml     | ✓ .gitmodules  | △ 手动保证   |
| 构建集成   | ✓ west build   | ✗ 需手动       | ✓ IDE集成    |
| 按需下载   | ✓ 只下载需要的 | ✗ 全部下载     | ✗ 全系列固件 |
| 学习曲线   | 中等           | 陡峭           | 简单         |

West就像是**Git + Make + 项目管理器**的组合体，专门为Zephyr的多仓库架构设计。

## 这几个工具的角色与作用

### 工具层次关系图

```c
┌─────────────────────────────────────────────────┐
│            用户命令层 (最上层)                     │
│                                                 │
│  west build -b stm32f4_disco app               │
│  west flash                                     │
│  west update                                    │
└─────────────────────────────────────────────────┘
                      │
                      │ west是封装层
                      ↓
┌─────────────────────────────────────────────────┐
│         West (Python工具 - 中间层)               │
│                                                 │
│  - 项目管理 (west init/update)                  │
│  - 封装构建命令                                  │
│  - 封装烧录命令                                  │
│                                                 │
│  内部调用 ↓                                      │
└─────────────────────────────────────────────────┘
         │              │              │
         ↓              ↓              ↓
┌────────────┐  ┌────────────┐  ┌────────────┐
│   CMake    │  │   Python   │  │    DTC     │
│  (构建系统) │  │ (脚本引擎)  │  │(设备树编译器)│
│            │  │            │  │            │
│ 生成Ninja  │  │ 运行脚本   │  │ 编译.dts   │
│ 或Makefile │  │ 处理配置   │  │ 生成.dtb   │
└────────────┘  └────────────┘  └────────────┘
         │              │              │
         └──────────────┼──────────────┘
                        │
                        ↓
        ┌───────────────────────────┐
        │  底层工具 (最底层)          │
        │                           │
        │  - GCC编译器              │
        │  - Ninja/Make             │
        │  - Linker                 │
        │  - OpenOCD/JLink          │
        └───────────────────────────┘

```

### 第一层：**主机依赖项**（核心基础设施）

这些是**必需的底层工具**，其他所有工具都依赖它们：

1. **CMake** - 构建配置生成器

```c
# CMake的实际作用
cmake -B build -DBOARD=stm32f4_disco

# 它做什么：
# 1. 读取 CMakeLists.txt
# 2. 处理 Kconfig 配置
# 3. 调用 DTC 编译设备树
# 4. 生成 build.ninja 或 Makefile
# 5. 配置编译器参数、链接脚本等

# CMake本身不编译代码！它只是生成构建脚本
```

**类比STM32：**

- STM32CubeMX生成的Makefile ≈ CMake生成的build.ninja
- 但CMake更智能，可以根据配置自动调整

2. **Python** - 脚本运行环境

```c
# Python的实际作用

# 运行West工具（West是Python写的）
python -m west build

# 运行Kconfig处理脚本
python scripts/kconfig/...

# 运行设备树预处理脚本
python scripts/dts/...

# 生成版本信息、处理分区表等
python scripts/build/...
```

**Python是粘合剂**：连接各种工具，处理配置文件，自动化任务。

3. **DTC (Devicetree Compiler)** - 硬件描述编译器

```c
# DTC的实际作用
dtc -I dts -O dtb board.dts -o board.dtb

# 它做什么：
# 1. 解析 .dts 文本文件
# 2. 编译成二进制 .dtb
# 3. 或生成C头文件供代码使用

# 在Zephyr中，CMake会自动调用DTC
```

### 第二层：**West**（用户友好的封装层）

West **不替代**底层工具，而是**封装调用**它们：

```c
# West内部实现（简化版伪代码）

class WestBuild:
    def build(self, board, app):
        # 1. West调用CMake
        run_command(f"cmake -B build -DBOARD={board} {app}")
        
        # 2. West调用Ninja（CMake生成的）
        run_command("ninja -C build")
        
        # 3. 显示友好的进度信息
        print("✓ Build complete!")

class WestFlash:
    def flash(self):
        # 1. West读取配置，选择烧录工具
        if board.uses_openocd():
            run_command("openocd -f board.cfg -c 'program build/zephyr.elf'")
        elif board.uses_jlink():
            run_command("JLinkExe -device STM32F407VG -if SWD ...")
```

**West的真正价值：**

- 统一接口（不用记住各种工具的复杂参数）
- 智能默认值（自动选择合适的配置）
- 多仓库管理（这是其他工具做不到的）

### 实际执行流程对比

方式A：不用West（手动方式）

```c
# 步骤1: 用CMake配置
cd my-app
mkdir build
cmake -B build -DBOARD=stm32f4_disco -DCMAKE_BUILD_TYPE=Debug

# CMake内部会：
# - 运行Python脚本处理Kconfig
# - 调用DTC编译设备树
# - 生成build.ninja

# 步骤2: 用Ninja构建
ninja -C build

# 步骤3: 手动烧录
openocd -f interface/stlink.cfg -f target/stm32f4x.cfg \
        -c "program build/zephyr/zephyr.elf verify reset exit"
```

方式B：用West（封装方式）

~~~c
# 一条命令完成上面所有步骤
west build -b stm32f4_disco my-app

# West内部自动：
# 1. 调用 cmake -B build -DBOARD=stm32f4_disco
# 2. 调用 ninja -C build
# 3. 显示构建进度

# 烧录也简化了
west flash  # West自动选择合适的烧录工具和参数
```

## 为什么需要这么多层？

### 原因1：职责分离
```
CMake    → 擅长：跨平台构建配置
Python   → 擅长：脚本自动化、文本处理
DTC      → 擅长：设备树编译
West     → 擅长：用户体验、多仓库管理

组合使用 = 发挥各自优势
    
原因2：灵活性
# 你可以选择不用West
cmake -B build ...
ninja -C build

# 也可以用West简化
west build

# 甚至可以混用
west build           # 用West构建
ninja -C build flash # 用Ninja直接烧录    
~~~

工具调用链实例

```c
用户输入: west build -b stm32f4_disco samples/hello_world

↓ West执行 (Python)
  ├─ 检查参数有效性
  ├─ 设置环境变量
  └─ 调用CMake
      
      ↓ CMake执行
        ├─ 读取 CMakeLists.txt
        ├─ 处理 BOARD=stm32f4_disco
        ├─ 调用 Python scripts/kconfig/... (处理配置)
        ├─ 调用 DTC board.dts → board.dtb (编译设备树)
        ├─ 生成 build.ninja
        └─ 调用 Ninja
        
            ↓ Ninja执行
              ├─ 调用 GCC 编译 .c 文件
              ├─ 调用 GCC 汇编 .S 文件
              ├─ 调用 Linker 链接
              └─ 生成 zephyr.elf

↓ West继续
  └─ 显示 "Build complete!" ✓
```

与STM32开发对比

```c
STM32 Cube IDE (集成方式)
用户界面 (Eclipse)
    ↓
内置构建系统 (隐藏的Make/CMake)
    ↓
GCC工具链
    ↓
OpenOCD/STLink

优点: 一键式，简单
缺点: 不灵活，难以自动化
```

# 利用west获取zephyr主仓库源码

- 已经下载了构建工具链
- 选一个位置直接初始化west工作区

```c
west init zephyrproject //在当前zephyrproject位置初始化,前面选择的位置
cd zephyrproject
west update
```

- `west.yml`中定义了所有的git仓库，太多了。为了环境完整，还是不简化`west.yml`了。

# 导出zephyr的cmake包

```c
west zephyr-export
```

`west zephyr-export` 做了什么？

简单理解

**它告诉CMake："嘿，Zephyr在这里！"**

具体来说，它创建了一个**CMake包注册表文件**，让CMake能够找到Zephyr的位置和配置。

~~~c
west zephyr-export

# 执行后，会创建/更新文件：
# Windows: C:\Users\你的用户名\.cmake\packages\Zephyr\<hash>
# Linux:   ~/.cmake/packages/Zephyr/<hash>
```

这个文件的内容非常简单：
```
C:\Users\YourName\zephyrproject\zephyr
~~~

就是记录了Zephyr的安装路径！

没有 `west zephyr-export` 的情况：

- 每个项目都要写死路径，换电脑就要改。

```c
# 你的应用CMakeLists.txt
cmake_minimum_required(VERSION 3.20.0)

# 必须手动指定Zephyr在哪里！❌ 麻烦
set(ZEPHYR_BASE "C:/Users/YourName/zephyrproject/zephyr")
find_package(Zephyr REQUIRED HINTS ${ZEPHYR_BASE})

project(my_app)
target_sources(app PRIVATE src/main.c)
```

执行 `west zephyr-export` 后：

- `west zephyr-export` 就是在**第3步的注册表**中添加了Zephyr的路径。

~~~c
# 你的应用CMakeLists.txt
cmake_minimum_required(VERSION 3.20.0)

# CMake自动找到Zephyr！✓ 方便
find_package(Zephyr REQUIRED)

project(my_app)
target_sources(app PRIVATE src/main.c)
```

CMake会自动到注册表查找Zephyr的位置。

## 详细工作原理

### CMake的包查找机制

CMake有一套标准的包查找路径：
```
find_package(Zephyr) 的查找顺序：

1. CMAKE_PREFIX_PATH 环境变量
2. Zephyr_DIR 变量
3. CMake用户包注册表 ← west zephyr-export 在这里注册
   └─ ~/.cmake/packages/Zephyr/
4. CMake系统包注册表
5. 标准系统路径
~~~

这个路径指向 `ZephyrConfig.cmake` 文件，里面包含了：

- Zephyr的安装路径
- 支持的架构和板子
- CMake宏和函数定义
- 工具链配置

### 什么时候需要运行？

1. 首次安装Zephyr后

```c
   west init zephyrproject
   cd zephyrproject
   west update
   west zephyr-export  # ← 必须执行
```

2. Zephyr安装位置改变后

```c
# 把zephyrproject移动到了新位置
   mv zephyrproject /new/location/
   cd /new/location/zephyrproject
   west zephyr-export  # ← 更新注册表
```

3. 多个Zephyr版本切换时

```c
# 有两个Zephyr工作区
   cd ~/zephyr-v3.5
   west zephyr-export  # 注册v3.5

   cd ~/zephyr-v3.7
   west zephyr-export  # 覆盖注册，现在指向v3.7
```

### 与STM32开发对比

```c
STM32 Cube
STM32 Cube固件包:
- 安装到固定位置: C:\STM32Cube\Repository\
- CubeIDE自动识别
- 不需要额外注册
    
Zephyr源码:
- 可以安装到任意位置
- 需要告诉CMake在哪里
- 通过west zephyr-export注册
```

### West和CMake是独立的

```c
West (Python工具)://虚拟环境安装的
├─ 知道当前工作区的Zephyr在哪里
├─ 通过 .west/config 记录
└─ 只在当前工作区有效

CMake (系统级工具):
├─ 不知道任何工作区的存在
├─ 需要显式告诉它Zephyr在哪里
└─ 通过环境变量或注册表查找
```

### `west zephyr-export` 的本质

~~~c
# 没有 west zephyr-export:
CMake: "find_package(Zephyr)? Zephyr是啥？在哪里？找不到！" ❌

# 执行 west zephyr-export:
# → 在CMake注册表写入: Zephyr在 /path/to/zephyrproject/zephyr
CMake: "哦，找到了！Zephyr在这里。" ✓
```

## 多工作区场景详解

### 场景：同时维护多个Zephyr版本
```
你的电脑:
├─ C:\projects\zephyr-v3.5\      (旧项目)
│   └─ zephyr\  (v3.5.0代码)
│
├─ C:\projects\zephyr-v3.7\      (新项目)
│   └─ zephyr\  (v3.7.0代码)
│
└─ C:\projects\zephyr-main\      (实验性)
    └─ zephyr\  (最新main分支)
~~~

问题：CMake只能记住一个

~~~c
# CMake用户包注册表（全局的）
C:\Users\YourName\.cmake\packages\Zephyr\<hash>

# 这个文件只能指向一个路径！
# 不能同时指向多个Zephyr安装
```

**内容类似：**
```
C:\projects\zephyr-v3.7\zephyr\share\zephyr-package\cmake
~~~

切换工作区时需要重新 export

```c
# 情景1: 开发旧项目
cd C:\projects\zephyr-v3.5
west zephyr-export  # 告诉CMake: 现在用v3.5

# CMake注册表现在指向 → zephyr-v3.5

# 开发...
west build -b stm32f4_disco old-app


# 情景2: 切换到新项目
cd C:\projects\zephyr-v3.7
west zephyr-export  # 告诉CMake: 现在用v3.7

# CMake注册表被覆盖 → zephyr-v3.7

# 开发...
west build -b stm32f4_disco new-app


# 情景3: 又回到旧项目
cd C:\projects\zephyr-v3.5
# 如果直接用CMake构建，会用错版本！
cmake -B build -DBOARD=stm32f4_disco  # ❌ 可能还指向v3.7

# 需要重新export
west zephyr-export  # 更新注册表 → zephyr-v3.5
cmake -B build -DBOARD=stm32f4_disco  # ✓ 现在正确了
```

# 使用以下命令安装 Python 依赖项：`west packages`

```c
west packages pip --install

```

`west packages` 是一个**辅助命令**，用于**自动收集所有需要安装的Python包**。

```c
# 查看west packages的输出
west packages pip

# 输出示例（一行，用空格分隔）：
-r C:\zephyrproject\zephyr\scripts\requirements.txt -r C:\zephyrproject\bootloader\mcuboot\scripts\requirements.txt -r C:\zephyrproject\modules\lib\matter\scripts\requirements.txt
```

**它做了什么？**

- 遍历整个工作区的所有仓库
- 查找每个仓库的 `requirements.txt` 文件
- 将它们全部收集成一个列表

**作用**：封装了整个安装过程，一条命令搞定

传统方式（繁琐）

```c
# 手动安装每个模块的依赖
pip install -r zephyr/scripts/requirements.txt
pip install -r bootloader/mcuboot/scripts/requirements.txt
pip install -r modules/lib/matter/scripts/requirements.txt
# ... 你需要知道所有模块的位置！
```

`west packages` 方式（智能）

```c
# 一条命令安装所有依赖

# west packages 自动发现所有 requirements.txt
# 无需手动查找！
```

三个命令的精确对应关系

```c
┌─────────────────────────────────────────────────────┐
│  west init                                          │
│  └─ 拉取Zephyr主仓库（manifest仓库）                 │
│     └─ 包含 west.yml 清单文件                        │
└─────────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────┐
│  west update                                        │
│  └─ 根据 west.yml 拉取所有依赖的Git仓库              │
│     ├─ hal_stm32 (STM32 HAL源码)                    │
│     ├─ mcuboot (引导加载程序源码)                    │
│     ├─ mbedtls (加密库源码)                          │
│     └─ ... (50+ 个模块的源码)                       │
└─────────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────┐
│  west packages pip --install
│  └─ 安装所有模块的Python依赖                        │
│     ├─ zephyr/scripts/requirements.txt              │
│     ├─ mcuboot/scripts/requirements.txt             │
│     ├─ matter/scripts/requirements.txt              │
│     └─ ... (每个模块的Python工具依赖)               │
└─────────────────────────────────────────────────────┘
```



# 安装编译工具链

编译器是**独立于Zephyr**的，需要你**单独安装**。

Zephyr支持的工具链

```c
Zephyr构建系统
    ↓ (需要工具链)
    
可选的工具链:
├─ Zephyr SDK (官方推荐) ⭐⭐⭐
├─ GNU Arm Embedded (ARM官方)
├─ LLVM/Clang
├─ GCC (系统自带，适用于本机模拟)
└─ 其他厂商工具链 (IAR, Keil等)
```

## Zephyr SDK（官方推荐）

什么是Zephyr SDK？

**Zephyr SDK = 预编译的交叉编译工具链集合包**

```c
Zephyr SDK包含:
├─ arm-zephyr-eabi (ARM Cortex-M/A/R)
├─ riscv64-zephyr-elf (RISC-V)
├─ xtensa-espressif_esp32_zephyr-elf (ESP32)
├─ arc-zephyr-elf (ARC)
├─ x86_64-zephyr-elf (x86)
├─ ... 更多架构
│
└─ 主机工具:
    ├─ gperf, dtc, openocd
    └─ 其他调试工具
```

**一次安装，支持所有架构！** 这是与STM32开发最大的区别。

## 工具分类总结

### 类别1: **编译工具链**（Compilation Toolchain）

**位置：Zephyr SDK**

```c
Zephyr SDK (C:\zephyr-sdk-0.16.5\)
│
├─ arm-zephyr-eabi/          ← ARM编译器
│   ├─ bin/
│   │   ├─ arm-zephyr-eabi-gcc      (C编译器)
│   │   ├─ arm-zephyr-eabi-g++      (C++编译器)
│   │   ├─ arm-zephyr-eabi-ld       (链接器)
│   │   ├─ arm-zephyr-eabi-objcopy  (目标文件转换)
│   │   ├─ arm-zephyr-eabi-gdb      (调试器)
│   │   └─ ...
│   └─ lib/ (标准库)
│
├─ riscv64-zephyr-elf/       ← RISC-V编译器
├─ xtensa-espressif_esp32_zephyr-elf/  ← ESP32编译器
└─ ...

作用: 把C/C++代码编译成特定架构的机器码
```

### 类别2: **构建工具链**（Build Toolchain）

位置：主机依赖项 + Python工具

```c
主机系统
│
├─ CMake (主机依赖项)
│   作用: 构建系统生成器
│   └─ 读取CMakeLists.txt → 生成build.ninja
│
├─ Python (主机依赖项)
│   作用: 脚本执行引擎
│   └─ 运行各种处理脚本
│
├─ DTC (主机依赖项)
│   作用: 设备树编译器
│   └─ .dts → .dtb
│
├─ Ninja (通过winget安装)
│   作用: 实际的构建执行器
│   └─ 根据build.ninja执行编译命令
│
└─ West (Python包)
    作用: 项目管理 + 命令封装
    └─ 调用CMake、Ninja等
```

### 完整的构建流程

~~~c
# 用户输入
west build -b stm32f4_disco samples/hello_world
```

### 详细执行过程：
```
第1步: West (Python工具) 启动
    └─ 解析参数: BOARD=stm32f4_disco
    └─ 设置环境变量
    └─ 调用 CMake ↓

第2步: CMake (构建工具) 配置
    ├─ 读取 boards/arm/stm32f4_disco/board.cmake
    │   └─ 识别: arch=arm, soc=stm32f407
    │
    ├─ 选择编译工具链 (从Zephyr SDK)
    │   └─ ZEPHYR_SDK_INSTALL_DIR/arm-zephyr-eabi/
    │
    ├─ 调用 Python 脚本 (构建工具)
    │   ├─ scripts/kconfig/... → 处理配置选项
    │   └─ scripts/dts/... → 调用DTC
    │
    ├─ 调用 DTC (构建工具)
    │   └─ stm32f4_disco.dts → devicetree_generated.h
    │
    └─ 生成 build.ninja (构建脚本)

第3步: Ninja (构建工具) 执行
    ├─ 读取 build.ninja
    │
    ├─ 调用编译器 (编译工具) ↓
    │   arm-zephyr-eabi-gcc -c main.c -o main.o
    │   arm-zephyr-eabi-gcc -c kernel.c -o kernel.o
    │   ...
    │
    └─ 调用链接器 (编译工具) ↓
        arm-zephyr-eabi-ld main.o kernel.o ... -o zephyr.elf

第4步: West 收尾
    └─ 显示构建结果 ✓
~~~

### 可视化层次关系

````
┌─────────────────────────────────────────────┐
│         用户层                               │
│  west build -b stm32f4_disco               │
└─────────────────────────────────────────────┘
                   ↓
┌─────────────────────────────────────────────┐
│      构建工具链 (Build Toolchain)            │
│  ┌──────────┐  ┌──────┐  ┌─────┐           │
│  │  CMake   │  │Python│  │ DTC │           │
│  │ (配置器) │  │(脚本)│  │(编译)│           │
│  └──────────┘  └──────┘  └─────┘           │
│       ↓           ↓          ↓              │
│  ┌─────────────────────────────┐           │
│  │     Ninja (构建执行器)       │           │
│  └─────────────────────────────┘           │
└─────────────────────────────────────────────┘
                   ↓
         ┌─────────────────┐
         │  调用编译器命令  │
         └─────────────────┘
                   ↓
┌─────────────────────────────────────────────┐
│      编译工具链 (Compilation Toolchain)      │
│         来自 Zephyr SDK                      │
│  ┌────────────────────────────────────┐    │
│  │ arm-zephyr-eabi-gcc  (编译器)      │    │
│  │ arm-zephyr-eabi-ld   (链接器)      │    │
│  │ arm-zephyr-eabi-objcopy (转换器)   │    │
│  └────────────────────────────────────┘    │
└─────────────────────────────────────────────┘
                   ↓
              zephyr.elf (固件)
              
## 与STM32开发对比

### STM32 Cube IDE (一体化)
```
STM32 Cube IDE (一个大软件包)
├─ Eclipse IDE
├─ 构建工具: Make/CMake
├─ 编译工具: arm-none-eabi-gcc
└─ 调试工具: OpenOCD/GDB

优点: 一次安装，全部搞定
缺点: 耦合紧密，难以定制
```

### Zephyr (模块化)
```
构建工具 (系统级 + Python)
├─ CMake (winget安装)
├─ Python (winget安装)
├─ DTC (winget安装)
└─ West (pip安装)

编译工具 (独立SDK)
└─ Zephyr SDK
    ├─ ARM编译器
    ├─ RISC-V编译器
    └─ 其他架构...

优点: 灵活，可单独升级
缺点: 需要理解各部分关系
```

## 为什么要分开？

### 1. **解耦合** - 各司其职
```
构建工具:
- 跨平台 (Windows/Linux/Mac都能用同一套)
- 与具体架构无关
- 可以用于任何项目

编译工具:
- 架构特定 (ARM专用、RISC-V专用)
- 只负责生成机器码
- 可以独立升级
````

## 选择性安装SDK中部分编译工具

1. 下载`zephyr-sdk-1.0.0-beta1_windows-x86_64_minimal.7z`
2. 解压后双击运行里面的`setup.cmd`

```c
1. Install GNU toolchain [Y,N]?
   → Y
   说明：安装 GCC 编译器（必需）

2. Install GNU toolchains for all targets [Y,N]?
   → N
   说明：不装所有平台，自己选择（控制大小）

3. Select toolchains to install:
   → 空格键勾选以下三项：
     [X] xtensa-espressif_esp32_zephyr-elf
     [X] xtensa-espressif_esp32s2_zephyr-elf
     [X] xtensa-espressif_esp32s3_zephyr-elf
   → 回车确认
   说明：只装 ESP32 系列工具链

4. Install host tools [Y,N]?
   → Y
   说明：安装辅助工具（dtc 等，必需）

5. Register Zephyr SDK CMake package [Y,N]?
   → Y
   说明：注册到 CMake，方便使用

6. Install LLVM toolchain [Y,N]?
   → N
   说明：不需要 Clang 编译器（新手不用）
       
Install host tools [Y,N]? 
host tools = 主机工具
           = 在你的电脑（Windows）上运行的辅助工具

包含：
✅ dtc (devicetree compiler) - 设备树编译器，必需！
✅ gperf - 完美哈希函数生成器
✅ ninja - 快速构建工具
✅ 其他构建辅助工具

大小：约 60-70 MB
Register Zephyr SDK CMake package [Y,N]?    
选 Y：
✅ CMake 自动找到 SDK
✅ 构建项目时不需要手动指定 SDK 路径
✅ 更方便，推荐做法

选 N：
❌ 每次构建都要手动指定 SDK 位置
❌ 需要设置额外的环境变量
❌ 麻烦    
```

### github下载选项

#### SDK Bundle（打包版本）

1. Minimal（最小版/安装器）

```c
大小：~5KB
内容：只有安装脚本
作用：运行后让你选择要安装哪些工具链

优点：按需下载，省空间
缺点：需要联网安装
推荐：✅ 适合你这种只需要 ESP32 的情况
    
解压文件 
直接双击 setup.cmd 文件
运行后会看到：
Zephyr SDK Setup
================

Select installation location:
1. C:\zephyr-sdk-1.0.0-beta1
2. Custom path
Enter choice (1/2):

**建议选择 1**（默认路径）

然后会提示：
Select toolchains to install:
[ ] aarch64-zephyr-elf
[ ] arc-zephyr-elf
[ ] arm-zephyr-eabi
[X] xtensa-espressif_esp32_zephyr-elf      ← 勾选这个！
[ ] xtensa-espressif_esp32s2_zephyr-elf
[ ] xtensa-espressif_esp32s3_zephyr-elf

**你的 ESP32 芯片是哪个型号？**
- ESP32 → 勾选 `xtensa-espressif_esp32_zephyr-elf`
- ESP32-S2 → 勾选 `xtensa-espressif_esp32s2_zephyr-elf`
- ESP32-S3 → 勾选 `xtensa-espressif_esp32s3_zephyr-elf`

**也可以全选 ESP32 系列（保险起见）**

### **5. 等待下载和安装**
脚本会自动：
✅ 下载 hosttools（dtc 等工具）
✅ 下载选中的工具链
✅ 配置环境变量
✅ 验证安装    
总下载量：~100-150 MB
时间：取决于网速  
安装完成后，打开新的命令提示符窗口：
# 验证环境变量
echo %ZEPHYR_SDK_INSTALL_DIR%

# 应该显示类似：
# C:\zephyr-sdk-1.0.0-beta1

# 验证 dtc（devicetree compiler）
dtc --version

# 应该显示版本号
```

2. GNU（完整 GNU 工具链版）

```c
大小：~1.7-2GB
内容：所有架构的 GCC 编译器 + hosttools（dtc等）
作用：一次性包含所有工具

优点：离线可用，支持所有平台
缺点：太大
推荐：如果网速好且想一劳永逸
```

3. LLVM（完整 LLVM 工具链版）

```c
大小：~270-320MB
内容：LLVM/Clang 编译器 + hosttools
作用：使用 LLVM 编译器（比 GCC 更现代）

优点：编译速度可能更快，支持更好的静态分析
缺点：某些平台支持不如 GCC 成熟
推荐：⚠️ 暂时不推荐新手用
```

#### GNU Toolchains（单独工具链）

```c
也可以直接下载对应的编译工具链
```

### SDK存放在哪里？

SDK 应该放在系统级目录，SDK 类似于编译器，是系统级工具，不属于某个项目。

```c
推荐的完整目录结构
C:\                                 ← 系统盘
├── zephyr-sdk-1.0.0-beta1\         ← SDK 安装在这里（1次）
│   ├── arm-zephyr-eabi\
│   ├── xtensa-espressif_esp32\
│   └── ...
│
D:\                                 ← 数据盘（或其他位置）
├── zephyr-workspace\               ← West 工作区
│   ├── .west\
│   ├── zephyr\                     ← Zephyr RTOS 源码（约500MB）
│   ├── modules\
│   │   ├── hal\
│   │   └── lib\
│   │
│   ├── my_esp32_app\               ← 你的项目1
│   │   ├── src\
│   │   │   └── main.c
│   │   ├── CMakeLists.txt
│   │   └── prj.conf
│   │
│   └── another_project\            ← 你的项目2
│       ├── src\
│       └── ...    
```

## 使用命令安装SDK

```c
cd %HOMEPATH%\zephyrproject\zephyr
west sdk install
```

您可以使用命令选项指定 SDK 安装目标位置以及要安装的工具链架构。详情请参阅相关文档。`west sdk install --help`

# 工作区的复用

在以下情况下，你可以复用已有的工作区：

## 2.1 **相同的 Zephyr 版本和 SDK**

如果你的所有项目都使用相同的 Zephyr 版本和 SDK，并且工具链配置一致，你完全可以在一个工作区内管理多个项目。复用同一个工作区可以减少环境配置的重复工作。

- **举例：**
   如果你有多个 ESP32 项目，且这些项目都使用相同的 Zephyr 版本（如 4.3.x），你可以在一个工作区内创建多个项目文件夹，使用相同的工作区环境。

## 2.2 **相似的硬件平台**

如果你的项目使用的是相同或相似的硬件平台，而平台间的差异较小，可以复用同一个工作区。比如多个 ESP32 开发板（如 `esp32_devkitc` 和 `esp32_wroom`）可以共享同一个工作区，只需在每个项目中调整板卡配置。

- **举例：**
   如果你的多个项目都使用 ESP32 开发板，并且它们只是在应用程序层次上有所不同，你可以在一个工作区内为每个项目创建一个子文件夹，只需要为每个项目配置适当的 `BOARD` 和 `prj.conf`。

## 2.3 **统一的构建和配置环境**

如果你希望为多个项目共享同一个构建环境（例如，相同的构建缓存、工具链路径、共用库等），则可以复用现有工作区。这样做不仅可以避免重复配置，还能减少每次构建时的资源占用。

- **举例：**
   如果你的项目都依赖于一些公共模块（例如某些设备驱动或中间件），这些模块可以作为工作区的一部分进行共享。只要这些模块在不同项目间兼容，你就不需要为每个项目创建新的工作区。

## **需要创建新工作区的情况：**

- 不同的 Zephyr 版本
- 不同的工具链或平台
- 工作区过于庞大，难以管理
- 不同的硬件平台需求

# 构建 Blinky 示例

- 选择一个开发板进行构建
- 如果您不确定 West 对您的板子使用的名称， 可以使用以下命令获取 Zephyr 支持的所有板子的列表。`west boards`

```c
(.venv) D:\Zephyr\workspace\zephyrproject\zephyr>west build -p always -b esp32_devkitc/esp32/procpu samples/basic/blinky
```

## 构建失败

```c
样板代码中的假设：
Zephyr 官方的 blinky 示例使用了 DT_ALIAS(led0)
这个示例假设所有板子的设备树中都定义了 led0 别名
ESP32 DevKit C 的现实：

ESP32 DevKit C 的默认设备树配置中没有预定义 led0 别名
因为 ESP32 是一个通用开发板，不同厂商的板子 LED 引脚位置可能不同
Zephyr 没有为它提供默认的 LED 定义

解决方案：
通过 .overlay 文件，我们手动添加了 led0 别名的定义
将它映射到 GPIO2（ESP32 DevKit C 常见的板载 LED 引脚）
```

## 两种构建选择

### PROCPU (Protocol CPU - 主核心)

- **完整的外设访问**：GPIO、UART、I2C、SPI 等所有外设都在这个核心上初始化
- **设备树完整**：包含所有硬件外设的定义
- **独立运行**：可以单独运行应用程序
- **常规开发**：大多数应用都运行在这个核心上

### APPCPU (Application CPU - 应用核心)

- **协作核心**：主要用于多核协作场景
- **设备树精简**：只包含核心间通信必需的内容（IPC、共享内存）
- **外设访问受限**：GPIO 等外设通常不直接在这个核心上初始化
- **特殊用途**：用于 AMP（非对称多处理）架构

这不是 overlay 的问题，而是 **ESP32 硬件架构设计** + **Zephyr 板子配置** 共同决定的：

- PROCPU = 全功能核心，可以直接访问硬件
- APPCPU = 协作核心，需要通过 PROCPU 间接访问硬件

所以对于 GPIO 控制这类直接硬件操作，必须使用 PROCPU 配置。

```c
\blinky\esp32_devkitc_esp32_procpu.overlay
/ {
    aliases {
        led0 = &myled0;
    };

    leds {
        compatible = "gpio-leds";
        myled0: led_0 {
            gpios = <&gpio0 2 GPIO_ACTIVE_HIGH>;
            label = "User LED";
        };
    };
};    
```

或者使用通用名称

**文件位置**：`d:\Zephyr\workspace\zephyrproject\blinky\app.overlay`

内容同上。`app.overlay` 对所有板子配置都生效。

对于双核板子，**应该显式指明构建目标**，使用特定的 overlay 文件名，而不是用通用的 `app.overlay`。这样配置更清晰、更不容易出错！

## ESP32 双核架构总结

ESP32 芯片内部**物理上有两个 Xtensa LX6 CPU 核心**：

```c
┌─────────────────────────────────────┐
│         ESP32 芯片内部              │
│                                     │
│  ┌──────────┐      ┌──────────┐   │
│  │ PROCPU   │      │ APPCPU   │   │
│  │(Core 0)  │      │(Core 1)  │   │
│  │ 240MHz   │      │ 240MHz   │   │
│  └─────┬────┘      └────┬─────┘   │
│        │                 │         │
│        └────────┬────────┘         │
│                 │                  │
│        ┌────────▼────────┐         │
│        │  外设总线       │         │
│        └────────┬────────┘         │
│                 │                  │
│     ┌───────────▼──────────┐      │
│     │   GPIO, UART, I2C    │      │
│     │   SPI, WiFi, BT...   │      │
│     └──────────────────────┘      │
└─────────────────────────────────────┘
```

### 核心分工

| 特性              | PROCPU (Core 0)              | APPCPU (Core 1)          |
| ----------------- | ---------------------------- | ------------------------ |
| **全称**          | Protocol CPU                 | Application CPU          |
| **主要职责**      | 系统初始化、外设管理、协议栈 | 应用逻辑、计算任务       |
| **外设访问**      | ✅ **直接访问所有外设**       | ⚠️ 可以访问但通常不初始化 |
| **Zephyr 设备树** | 完整（GPIO、UART 等）        | 精简（仅 IPC、共享内存） |
| **独立运行**      | ✅ 可以单独运行完整应用       | ❌ 通常需要配合 PROCPU    |
| **启动顺序**      | 先启动（引导系统）           | 后启动（由 PROCPU 唤醒） |

### 关键点理解

#### 1. 硬件层面

- 两个核心**都能**访问外设（硬件上没有限制）
- 共享同一个外设总线和内存空间

#### 2. Zephyr 软件设计

- **PROCPU 配置**：Zephyr 在设备树中启用了所有外设
- **APPCPU 配置**：Zephyr 只启用了核间通信（IPC），外设默认不初始化
- 这是**软件设计决策**，不是硬件限制

#### 3. 为什么这样设计？

**避免冲突**：

```c
// 如果两个核心都初始化同一个 GPIO
PROCPU: gpio_pin_configure(GPIO2, OUTPUT);  // 设置为输出
APPCPU: gpio_pin_configure(GPIO2, INPUT);   // 设置为输入？💥冲突！
```

**标准做法**（AMP 模式）：

- PROCPU：负责外设初始化和管理
- APPCPU：通过 IPC 向 PROCPU 请求操作外设
- 避免资源竞争

### 三种使用模式

模式 1：单核模式（最常用）

```c
west build -b esp32_devkitc/esp32/procpu
```

- 所有代码运行在 PROCPU

- 直接访问所有外设

- APPCPU 处于休眠（省电）

- **适合 95% 的应用场景**

模式 2：SMP 模式（对称多处理）

```c
# 在 prj.conf 中启用
CONFIG_SMP=y
CONFIG_MP_MAX_NUM_CPUS=2
```

- 两个核心运行**同一份代码**
- Zephyr 调度器自动分配任务到两个核心
- 外设仍由 PROCPU 初始化
- 适合 CPU 密集型应用

模式 3：AMP 模式（非对称多处理）

```c
# 分别编译两份固件
west build -b esp32_devkitc/esp32/procpu -d build_procpu
west build -b esp32_devkitc/esp32/appcpu -d build_appcpu
```

- 两个核心运行**不同的代码**
- PROCPU：系统管理 + 外设控制
- APPCPU：专用计算任务
- 通过 IPC 通信
- 最复杂，适合特殊需求

### 为什么您的 blinky 在 APPCPU 上失败？

```c
// 您的代码
#define LED0_NODE DT_ALIAS(led0)
static const struct gpio_dt_spec led = GPIO_DT_SPEC_GET(LED0_NODE, gpios);
```

**APPCPU 的设备树中**：

- ❌ 没有 `led0` 别名
- ❌ 没有 `gpio0` 外设定义
- ❌ 无法获取 GPIO 设备

**PROCPU 的设备树中**：

- ✅ 有完整的 GPIO 外设定义
- ✅ 加上 overlay 后有 `led0` 别名
- ✅ 编译通过且能正常工作

# 看打印

对于esp32_devkitc,我想看打印呢？需要额外接线吗？还是可以直接看？

ESP32 DevKitC 可以**直接通过 USB 看打印**，不需要额外接线！非常方便。

## 硬件连接

ESP32 DevKitC 板载了 **USB 转串口芯片**（通常是 CP2102 或 CH340），所以：

```c
[电脑 USB] ←→ [USB 线] ←→ [ESP32 DevKitC 的 Micro-USB 口]
                              ↓
                         [USB转串口芯片]
                              ↓
                         [ESP32 UART0]
```

- **不需要**额外的 USB 转 TTL 模块
- **不需要**接杜邦线
- 一根 USB 线既能**供电**又能**看串口**

## 查看串口输出的方法

使用 Zephyr 自带的 monitor（推荐）

~~~c
# 烧录后自动进入监视模式
west flash --esp-monitor

# 或者单独启动监视
west espressif monitor
```

**退出方式**：`Ctrl + ]`
~~~

## USB 线的三重功能

```c
[电脑] ←─── USB 数据线 ───→ [ESP32 DevKitC]
   ↓                              ↓
   │                              │
   ├─ 供电 (5V)         ─────────→ 给板子供电 ⚡
   │                              │
   ├─ 数据传输         ─────────→ 烧录固件 📥
   │    (烧录)                    │
   │                              │
   └─ 串口通信         ←─────────→ 打印日志 📋
      (UART)
```

### 内部原理

ESP32 DevKitC 板载了 **USB 转串口芯片**（如 CP2102 或 CH340）：

```c
┌─────────────────────────────────────────┐
│         ESP32 DevKitC 板子              │
│                                         │
│  [Micro-USB 口]                         │
│       │                                 │
│       ├─→ 5V 供电 ──→ [稳压器] ──→ 3.3V │
│       │                    ↓            │
│       └─→ USB 数据 ──→ [CP2102/CH340]   │
│                            ↓            │
│                         TX/RX           │
│                            ↓            │
│                      [ESP32 芯片]       │
│                       UART0 (GPIO1/3)   │
│                                         │
│                    [自动下载电路]        │
│                    (DTR/RTS → EN/IO0)   │
└─────────────────────────────────────────┘
```

### 三个功能详解

#### 1. **供电**

- USB 提供 5V 电源
- 板载稳压器转换为 3.3V 供 ESP32 使用
- 可以持续供电，不需要电池

#### 2. **烧录固件** 📥

- USB 转串口芯片将数据转为串口信号
- ESP32 的 **ROM Bootloader** 通过 UART0 接收固件
- **自动下载电路**：
  - `DTR/RTS` 信号自动控制 `EN`（复位）和 `GPIO0`（启动模式）
  - 无需手动按按钮进入下载模式

#### 3. **串口通信** 📋

- 固件运行后，UART0 用于 `printk()` 输出
- USB 转串口芯片将串口数据传回电脑
- 双向通信：可以从电脑发送命令到 ESP32

## **烧录和打印用的是同一个串口（UART0）**，但它们在**不同的时间段**工作，互不冲突。

下载一个**Serial Monitor**插件监听对应的端口就可以实现，可以从烧录日志中看到对应的端口。