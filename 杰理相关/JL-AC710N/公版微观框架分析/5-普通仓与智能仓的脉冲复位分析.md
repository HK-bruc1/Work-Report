# 引入源文件

`apps\earphone\ldoin_commu\ldoin_commu.c`

- 对脉冲信号解析后，写入一个标志位到VM中，开机后检测一下决定是否复位操作。

```c
#include "app_config.h"
#include "system/includes.h"
#include "ldoin_commu.h"
#include "app_main.h"
#include "app_chargestore.h"
#include "timer.h"
#include "btstack/avctp_user.h"
#include "printf.h"
// #include "led_ui_manage.h"
//#include "led/led_ui_manager.h"
//#ifdef CONFIG_DEBUG_LITE_ENABLE
// #include "debug_lite.h"
//#define printf printf_lite
//#else
//#define printf printf
//#endif

/**
 * 起始帧{a=100ms,b=100ms}，1是{d=20ms,f=20ms}，0是{c=20ms,e=20ms,g=20ms}，结束帧h=300ms
 * <-a-><b><c d e f g><-h-> 有效数据是cdef，g固定为0
 *      ___   _   _   ____
 *     |   | | | | | |    |
 * ____|   |_| |_| |_|    |
 */
#if USER_CHARGESTORE_COMM_EN
#define TIMER_CNT_UNIT      85  //us
#define TIMER_OUT_MS        500 //ms

#define MS_TO_CNT(ms, offset)  (((ms*1000) + (offset*1000))/TIMER_CNT_UNIT)

static volatile s32 low_level = 0;                   //低电平时间
static volatile s32 high_level = 0;                  //高电平时间
static volatile u8 get_leader = 0;                   //获取到起始帧标志
static volatile u8 comm_timeout = 1;                 //通信超时标志
static volatile u8 data_byte = 0x00;                 //通信数据暂存变量
static volatile u8 bit_cnt = 0;                      //当前获取到的bit数
static volatile u8 user_comm_data_buff[16] = {0};    //当前获取到的数据缓存
static volatile u8 user_comm_data_len = 0;           //当前获取到的数据缓存长度
static volatile u8 prev_edge = 0xff;

/**
 * @brief 定时器中断函数
 *
 */
___interrupt
void user_comm_timeout(void)
{
    JL_TIMER3->CON |= BIT(14);
    comm_timeout = 1;
    get_leader = 0;
    JL_TIMER3->CON &= ~BIT(0);
    printf("user_comm_timeout\n");
}

/**
 * @brief 通信定时器初始化
 *
 */
void user_comm_init(void)
{
    printf("user_comm_init\n");
    low_level = 0;
    high_level = 0;
    get_leader = 0;
    comm_timeout = 1;
    bit_cnt = 0;
    JL_TIMER3->CON = 0;
    bit_clr_ie(IRQ_TIME3_IDX);
    request_irq(IRQ_TIME3_IDX, 5, user_comm_timeout, 0);
    JL_TIMER3->CNT = 0;
    JL_TIMER3->PRD = TIMER_OUT_MS*1000/TIMER_CNT_UNIT + 1;
    JL_TIMER3->CON |= BIT(14);
    JL_TIMER3->CON = ((6 << 10) | (13 << 4));
}

/**
 * @brief 通信定时器重启
 *
 */
void user_comm_restart(void)
{
    printf("user_comm_restart\n\n");
    JL_TIMER3->CON = 0;
    JL_TIMER3->CNT = 0;
    JL_TIMER3->PRD = TIMER_OUT_MS*1000/TIMER_CNT_UNIT + 1;
    JL_TIMER3->CON |= BIT(14);
    JL_TIMER3->CON = ((6 << 10) | (13 << 4) | BIT(0));
}

/**
 * @brief 通信状态复位
 *
 */
void user_comm_reset(void)
{
    printf("user_comm_reset\n\n");
    low_level = 0;
    high_level = 0;
    get_leader = 0;
    comm_timeout = 0;
    bit_cnt = 0;
    JL_TIMER3->CON = 0;
    JL_TIMER3->CNT = 0;
    JL_TIMER3->PRD = TIMER_OUT_MS*1000/TIMER_CNT_UNIT + 1;
    JL_TIMER3->CON |= BIT(14);
    JL_TIMER3->CON = ((6 << 10) | (13 << 4) | BIT(0));
}

/**
 * @brief 打印volatile缓冲区（处理volatile到const的转换）
 * 
 * @param buf volatile缓冲区指针
 * @param len 缓冲区长度
 */
static inline void put_buf_volatile(volatile const u8 *buf, int len)
{
    put_buf((const u8 *)buf, len);
}

/**
 * @brief 通信完成
 *
 */
void ldoin_comm_end_do(void)
{
    printf("V\n");
    if(user_comm_data_len){
        put_buf_volatile(user_comm_data_buff, user_comm_data_len);
    }
}


#include "btstack/avctp_user.h"

//仓外按键是否发送脉冲的标志位
u8 charge_box_reset_flag = 0;
//必定仓外按键发送脉冲后需要调用这个函数进行存标志位
static void callback_func_no_param(void)
{
    printf("---------%s\n", __func__);
	
    charge_box_reset_flag = 1;
    syscfg_write(CFG_FACTORY_RESET,&charge_box_reset_flag,1);
    // void *active_dev = user_get_active_device();
    // u8 *bt_addr = NULL;

    // bt_addr = btstack_get_device_mac_addr(active_dev); 
    // bt_cmd_prepare_for_addr(bt_addr,USER_CTRL_DISCONNECTION_HCI, 0, NULL);
    // bt_cmd_prepare_for_addr(bt_addr,USER_CTRL_DEL_ALL_REMOTE_INFO, 0, NULL);    
    //  bt_tws_remove_pairs();
    //   sys_enter_soft_poweroff(NULL);
    //  sys_timeout_add(NULL,sys_enter_soft_poweroff,2000);
    //  usr_timeout_add(NULL,cpu_reset,2000,1);
    //  cpu_reset();   
}


//推送某个函数到指定任务执行，把仓复位标志位置位函数注册到系统
//仓发送脉冲后耳机应该调用这个回调函数，注册仓复位标志位置位任务到OS
static void func_callback_in_task(u8 mode)
{
    int err;
    int msg[5];
    
    //推送不带参数的函数到app_core任务
    msg[0] = (int) callback_func_no_param;
    msg[1] = 0;//函数无需参数
    err = os_taskq_post_type("app_core", Q_CALLBACK, 2, msg);
  
    printf("%s %d\n", __func__, err);
}

//耳机应该调用这个
// u8 lsoin_reset_flag = 0;
void extern_send_cover_status(u8 state)
{
    printf("-------------extern_send_cover_status-------------\n");
    func_callback_in_task(0);

//      switch (state)
//      {
//         case 0x05:
//             log_info("open cid\n");
//             __this->power_status = 1;
//             __this->cover_status = 1;
//             __this->close_ing = 0;
//             if (__this->switch2bt == 0) {
//                 chargestore_event_to_user(NULL, DEVICE_EVENT_CHARGE_STORE, CMD_POWER_LEVEL_OPEN, 0);
//             }
//             break;
//         case 0x06:
//             log_info("shut down\n");
//             __this->power_status = 0;
//             __this->cover_status = 0;
//             __this->close_ing = 0;
//             if(__this->shutdown_timer){
//                 sys_hi_timer_del(__this->shutdown_timer);
//             }
//             __this->shutdown_timer = sys_hi_timer_add(NULL, chargestore_shutdown_do, 1000);
//             break;
//         case 0x0a:
//             log_info("close cid\n");
//             __this->power_status = 1;
//             __this->cover_status = 0;
//             chargestore_event_to_user(NULL, DEVICE_EVENT_CHARGE_STORE, CMD_CLOSE_CID, 0);
//             break;

//             default:
//             break;
//  }
}

//脉冲数据解析函数，脉冲就是高低电平的信号
//当脉冲出现时，就调用此函数处理
void ldoin_data_cap(u8 edge)
{
    //获取脉冲的特性
    printf("ldoin_data_cap---get_leader=%d   edge=%d   high_level=%d  low_level=%d",get_leader,edge,high_level,low_level);
    if(get_leader == 0 && high_level > MS_TO_CNT(100, -10) && high_level < MS_TO_CNT(100, 30) && low_level > MS_TO_CNT(100, -20) && low_level < MS_TO_CNT(100, 10)){
    // if(1){
        get_leader = 1; //comm begin;
        user_comm_data_len = 0;
        bit_cnt = 0;
        data_byte = 0;
        if(high_level > MS_TO_CNT(100, 10)){
            high_level -= MS_TO_CNT(100, 0);
            // printf("888888888888888888");
            goto __data_cap;//直接开跳
        }
        high_level = 0;
        low_level = 0;
        // printf("ldoin_data_cap-----------comm get start---------------\n");
    }else if(get_leader){
        if(edge == FALLING_EDGE){
__data_cap:
            u8 bit_n_h = high_level / MS_TO_CNT(20, -5);
            u8 bit_n_l = 1 + high_level / MS_TO_CNT(20, 5);
            u8 bit_n = (bit_n_h + bit_n_l) >> 1;
            if(bit_n < 4){
                for (u8 i = 0; i < bit_n; i++)
                {
                    data_byte |= 0x01;
                    bit_cnt++;
                    printf("get 1\n");
                    if(bit_cnt == 5){
                        if(data_byte & 0x01){
                            printf("comm maybe err\n");
                            get_leader = 0;
                            return;
                        }
                        data_byte >>= 1;
                        printf("FALLING_EDGE   comm get %x\n", data_byte);
                        extern_send_cover_status(data_byte);//进入耳机脉冲复位流程
                        get_leader = 0;
                        return;
                    }else{
                        data_byte = data_byte << 1;
                    }
                }
            }
            else{
                goto __err;//直接跳到错误处理
            }
            return;
        }else if(edge == RISING_EDGE){
            u8 bit_n_h = low_level / MS_TO_CNT(20, -5);
            u8 bit_n_l = 1 + low_level / MS_TO_CNT(20, 5);
            u8 bit_n = (bit_n_h + bit_n_l) >> 1;
            if(bit_n < 4){
                for (u8 i = 0; i < bit_n; i++)
                {
                    data_byte |= 0x00;
                    bit_cnt++;
                    printf("get 0\n");
                    if(bit_cnt == 5){
                        if(data_byte & 0x01){
                            printf("comm maybe err\n");
                            get_leader = 0;
                            return;
                        }
                        data_byte >>= 1;
                        printf("RISING_EDGE   comm get %x\n", data_byte);
                        extern_send_cover_status(data_byte);//进入耳机脉冲复位流程
                        get_leader = 0;
                        return;
                    }else{
                        data_byte = data_byte << 1;
                    }
                }
            }
            else{
                goto __err;
            }
        }
        return;
__err:
        printf("comm maybe err\n");
        get_leader = 0;
        return;
    }
}


/**
 * @brief 电平跳变中断处理 整个脉冲复位流程的入口
 *
 * @param index 唤醒源序号
 * @param gpio 唤醒源所在IO
 * @param edge 唤醒沿
 */
void ldoin_isr_user_comm_deal(u8 index, u8 gpio, u8 edge)
{
    printf("================ %s    gpio=%d   edge=%d   charge_box_reset_flag=%d\n", __func__,gpio,edge,charge_box_reset_flag); 
    if(gpio == IO_LDOIN_DET){
        printf("comm_timeout=%d           prev_edge=%d",comm_timeout,prev_edge);
        if(comm_timeout || prev_edge == 0xff){
            prev_edge = edge;
            user_comm_reset();//复位脉冲相关的元数据
            return;
        }
        else if(edge == FALLING_EDGE){
            printf("prev_edge===============%d",prev_edge);
            if(prev_edge == RISING_EDGE){
                high_level = JL_TIMER3->CNT;
                printf("hhhhhhhhhhhhhhhhh:%d\n", high_level);
            }
            user_comm_restart();
        }
        else if(edge == RISING_EDGE){
            if(prev_edge == FALLING_EDGE){
                low_level = JL_TIMER3->CNT;
                printf("lllllllllllllllll:%d\n", low_level);
            }
          
            user_comm_restart();
        }
        prev_edge = edge;
        ldoin_data_cap(edge);//开始解析脉冲信号
    }
    else{
        printf("gpio %d edge %d\n", gpio, edge);
    }
}

/**
 * @brief 获取通信忙状态
 *
 * @return u8
 */
//没有调用的地方
u8 chargestore_get_comm_busy_flag(void)
{
    // printf("chargestore_get_comm_busy_flag  get_leader=%d ",get_leader);
    return get_leader;
}

#else
u8 chargestore_get_comm_busy_flag(void)
{
    return 0;
}

void user_comm_init(void)
{

}

void ldoin_isr_user_comm_deal(u8 index, u8 gpio, u8 edge)
{

}

#endif
```

# 头文件引出外部接口

`apps\earphone\ldoin_commu\ldoin_commu.h`

```c
#ifndef __LDOIN_COMMU__
#define __LDOIN_COMMU__

#define USER_CHARGESTORE_COMM_EN    1

#define BOX_LOW_GOTO_POWER_OFF      0

void user_comm_init(void);

void ldoin_isr_user_comm_deal(u8 index, u8 gpio, u8 edge);

#endif
```

# 调用

`cpu\br56\power\power_config.c`

```c
__INITCALL_BANK_CODE
void board_power_init()
{
    //gpio_config_init();

    power_control(PCONTROL_PD_VDDIO_KEEP, VDDIO_KEEP_TYPE_NORMAL);
    power_control(PCONTROL_SF_VDDIO_KEEP, VDDIO_KEEP_TYPE_NORMAL);

    /*power_control(PCONTROL_SF_KEEP_PVDD, 1);*/
    /*power_set_dcdc_type(TCFG_DCDC_TYPE);*/

    power_init(&power_pdata);
    #if 1
    printf("user_comm_init();----before\n");
    user_comm_init();
    printf("user_comm_init();----after\n");
    #endif

#if (!TCFG_CHARGE_ENABLE)
    power_set_mode(TCFG_LOWPOWER_POWER_SEL);
    //没开启充电时,关闭漏电寄存器(约2uA)
    CHG_VILOOP_EN(0);
    CHG_VILOOP2_EN(0);
#endif

    key_wakeup_init();
}
```

`cpu\br56\charge\charge_config.c`

- 唤醒回调函数中

```c
static void vpwr_wakeup_callback(P33_IO_WKUP_EDGE edge)
{
    #if 0
    //进入脉冲复位流程判断入口
    //第一个参数没有使用。
    printf("vpwr_wakeup_callback----ldoin_isr_user_comm_deal(0, IO_LDOIN_DET, edge);----before\n");
    //ldoin_isr_user_comm_deal(0, IO_LDOIN_DET, edge);
    printf("vpwr_wakeup_callback----ldoin_isr_user_comm_deal(0, IO_LDOIN_DET, edge);----after\n");
    #endif
    ldoin_wakeup_isr();
}

static const struct _p33_io_wakeup_config vbat_port = {
    .edge               = BOTH_EDGE,        //唤醒方式选择,可选：上升沿\下降沿\双边沿
    .filter      		= PORT_FLT_16ms,
    .gpio               = IO_VBTCH_DET,     //唤醒口选择
    .callback			= vpwr_wakeup_callback,
};

static const struct _p33_io_wakeup_config ldoin_port = {
    .edge               = BOTH_EDGE,        //唤醒方式选择,可选：上升沿\下降沿\双边沿
    .filter      		= PORT_FLT_16ms,
    .gpio               = IO_LDOIN_DET,     //唤醒口选择
    .callback			= vpwr_wakeup_callback,
};
```

# 复位时机

`apps\earphone\mode\bt\earphone.c`

```c
/*
 * 对应原来的状态处理函数，连接，电话状态等
 */
extern u8 charge_box_reset_flag;
extern u8 ntc_open_flag;
static int bt_connction_status_event_handler(struct bt_event *bt)
{

    switch (bt->event) {
    case BT_STATUS_INIT_OK:

#ifndef  CONFIG_FPGA_ENABLE
        // 未调通,会引起复位,临时注释
        /* arch_trim(); */
#endif
        /*
         * 蓝牙初始化完成
         */
        g_bt_hdl.init_ok = 1;
        log_info("BT_STATUS_INIT_OK\n");
#if 1//7103 CHAEGR_BOX_RESET脉冲复位有问题
        log_info("syscfg_read_before----charge_box_reset_flag=%d\n",charge_box_reset_flag);
        //读取一个标志位到VM
        syscfg_read(CFG_FACTORY_RESET,&charge_box_reset_flag,1);
        log_info("syscfg_read_after----charge_box_reset_flag=%d\n",charge_box_reset_flag);
        if(charge_box_reset_flag){
            printf("charge_box_reset_flag----USER_CTRL_DEL_ALL_REMOTE_INFO----------------------\n");
            bt_cmd_prepare_for_addr(NULL,USER_CTRL_DEL_ALL_REMOTE_INFO, 0, NULL);
            //需求暂时是删除手机记录信息，不考虑带APP情况
        }
        charge_box_reset_flag = 0;
        //进行操作之后重新写入标志位，也就是说是通过脉冲给VM中写标志位控制，实际发生作用是在耳机出仓开机后
        //那怎么通过仓外按键发送脉冲写标志位？
        syscfg_write(CFG_FACTORY_RESET,&charge_box_reset_flag,1);
        log_info("rewrite----charge_box_reset_flag=%d\n",charge_box_reset_flag);
#endif
```

# 7103做不了改智能仓的按键复位

- `apps\earphone\include\app_chargestore.h`

- 是否智能仓跟有不有霍尔没有关系。

```c
//LDOIN升级口命令定义
#define CMD_TWS_CHANNEL_SET         0x01
#define CMD_TWS_REMOTE_ADDR         0x02
#define CMD_TWS_ADDR_DELETE         0x03
#define CMD_BOX_TWS_CHANNEL_SEL     0x04//测试盒获取地址
#define CMD_BOX_TWS_REMOTE_ADDR     0x05//测试盒交换地址
#define CMD_POWER_LEVEL_OPEN        0x06//开盖充电舱报告/获取电量
#define CMD_POWER_LEVEL_CLOSE       0x07//合盖充电舱报告/获取电量
#define CMD_RESTORE_SYS             0x08//恢复出厂设置
#define CMD_ENTER_DUT               0x09//进入测试模式
#define CMD_EX_FIRST_READ_INFO      0x0A//F95读取数据首包信息
#define CMD_EX_CONTINUE_READ_INFO   0x0B//F95读取数据后续包信息
#define CMD_EX_FIRST_WRITE_INFO     0x0C//F95写入数据首包信息
#define CMD_EX_CONTINUE_WRITE_INFO  0x0D//F95写入数据后续包信息
#define CMD_EX_INFO_COMPLETE        0x0E//F95完成信息交换
#define CMD_TWS_SET_CHANNEL         0x0F//F95设置左右声道信息
#define CMD_BOX_UPDATE              0x20//测试盒升级
#define CMD_BOX_MODULE              0x21//测试盒一级命令

#define CMD_SHUT_DOWN               0x80//充电舱关机,充满电关机,或者是低电关机
#define CMD_CLOSE_CID               0x81//充电舱盒盖
#define CMD_ANC_MODULE              0x90//ANC一级命令
#define CMD_CALIBRATION_MODULE      0x91//充电电流校准设备一级命令
#define CMD_FAIL                    0xfe//失败
#define CMD_UNDEFINE                0xff//未知命令回复
```

## 处理函数注册进OS的

`apps\earphone\battery\charge_store.c`

```c
CHARGESTORE_HANDLE_REG(chargestore, app_chargestore_data_handler);

static int app_chargestore_data_handler(u8 *buf, u8 len)
{
    u8 send_buf[36];
    /* log_info_hexdump(buf, len); */
    chargestore_shutdown_reset();
    send_buf[0] = buf[0];
#ifdef CONFIG_CHARGESTORE_REMAP_ENABLE
    if (remap_app_chargestore_data_deal(buf, len)) {
        return 1;
    }
#endif

    switch (buf[0]) {
    case CMD_TWS_CHANNEL_SET:
        __this->channel = (buf[1] == TWS_CHANNEL_LEFT) ? 'L' : 'R';
        chargestore_event_to_user(NULL, buf[0], 0);
        if (__this->bt_init_ok) {
            len = chargestore_get_tws_remote_info(&send_buf[1]);
            chargestore_api_write(send_buf, len + 1);
        } else {
            send_buf[0] = CMD_UNDEFINE;
            chargestore_api_write(send_buf, 1);
        }
        break;
//...

    case CMD_RESTORE_SYS:
        r_printf("restore sys\n");
        __this->power_status = 1;
        __this->cover_status = 1;
        __this->close_ing = 0;
        chargestore_api_write(send_buf, 1);
        chargestore_event_to_user(NULL, CMD_RESTORE_SYS, 0);
        break;
    //不是充电舱的指令,返回0
    default:
        return 0;
    }
    return 1;
}

//解析出指令后发送充点仓类型消息
void chargestore_event_to_user(u8 *packet, u8 event, u8 size)
{
    struct chargestore_event evt;

    if (packet != NULL) {
        if (size > sizeof(local_packet)) {
            return;
        }
        memcpy(local_packet, packet, size);
    }
    evt.event   = event;
    evt.packet  = local_packet;
    evt.size    = size;

    os_taskq_post_type("app_core", MSG_FROM_CHARGE_STORE,
                       (sizeof(evt) + 3) / 4, (int *)&evt);
}

//收到消息后进入对应处理函数处理
APP_MSG_HANDLER(chargestore_msg_entry) = {
    .owner      = 0xff,
    .from       = MSG_FROM_CHARGE_STORE,
    .handler    = app_chargestore_event_handler,
};
static int app_chargestore_event_handler(int *msg)
{
    int ret = false;
    struct chargestore_event *chargestore_dev = (struct chargestore_event *)msg;

#if defined(TCFG_CHARGE_KEEP_UPDATA) && TCFG_CHARGE_KEEP_UPDATA
    //在升级过程中,不响应智能充电舱app层消息
    if (dual_bank_update_exist_flag_get() || classic_update_task_exist_flag_get()) {
        return ret;
    }
#endif

    switch (chargestore_dev->event) {
    case CMD_RESTORE_SYS:
#if TCFG_USER_TWS_ENABLE
        bt_tws_remove_pairs();
#endif
        bt_cmd_prepare(USER_CTRL_DEL_ALL_REMOTE_INFO, 0, NULL);
        cpu_reset();
        break;
    case CMD_TWS_CHANNEL_SET:
        chargestore_set_tws_channel_info(__this->channel);
        break;
    //...
    default:
        break;
    }

    return ret;
}
```

充电仓发送指令直接处理。具体通信方式看不到。

- 如果智能仓发送的脉冲不是想要的结果（可以通过示波器或者逻辑分析仪（推荐））解析出发送的具体是什么指令。
- 710恢复出厂指令似乎不生效？那就使用普通仓普通的方式，省略掉解析部分。写入一个标志位到VM。在开机蓝牙初始化检查即可。
