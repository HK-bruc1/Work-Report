# AC710N 关机后唤醒开机流程完整分析

## 目录
1. [系统开机流程总览](#系统开机流程总览)
2. [触摸按键唤醒流程](#触摸按键唤醒流程)
3. [IO按键唤醒流程](#io按键唤醒流程)
4. [AD按键唤醒流程](#ad按键唤醒流程)
5. [关键问题解答](#关键问题解答)
6. [时序图](#时序图)
7. [配置参数说明](#配置参数说明)

---

## 系统开机流程总览

### 1. 主流程入口

系统上电后的启动流程：

```
app_main()
  └─> task_create(app_task_loop, ...)
       └─> app_task_init()
            ├─> app_var_init()
            ├─> cfg_file_parse(0)
            ├─> do_early_initcall()
            ├─> board_init()
            ├─> do_platform_initcall()
            ├─> key_driver_init()          // 初始化按键驱动
            ├─> do_initcall()              // 触摸按键在此初始化
            ├─> do_module_initcall()
            ├─> do_late_initcall()
            └─> app_poweron_check(update)  // 检查开机条件
                 └─> check_power_on_key()  // 检测开机按键
```

**代码位置**：`SDK/apps/earphone/app_main.c:372-438`

`app_poweron_check(update)` 

```c
__INITCALL_BANK_CODE
static struct app_mode *app_task_init()
{
    app_var_init();
    app_version_check();

#ifndef CONFIG_CPU_BR56
    sdfile_init();
    syscfg_tools_init();
#endif
    cfg_file_parse(0);

    jlstream_init();

    do_early_initcall();
    board_init();
    do_platform_initcall();

#if (defined(TCFG_DEBUG_DLOG_ENABLE) && TCFG_DEBUG_DLOG_ENABLE)
    dlog_init();
    dlog_enable(1);
    extern void dlog_uart_auto_enable_init(void);
    extern int dlog_uart_output_set(enum DLOG_OUTPUT_TYPE type);
    dlog_uart_output_set(DLOG_OUTPUT_2_FLASH | dlog_output_type_get());
    dlog_uart_auto_enable_init();
#endif

    key_driver_init();

    do_initcall();
    do_module_initcall();
    do_late_initcall();

    dev_manager_init();


    int update = 0;
    if (CONFIG_UPDATE_ENABLE) {
        update = update_result_deal();
    }
#if TCFG_MC_BIAS_AUTO_ADJUST
    mic_capless_trim_init(update);
#endif

    int msg[4] = { MSG_FROM_APP, APP_MSG_GOTO_MODE, 0, 0 };

    if (get_charge_online_flag()) {
#if(TCFG_SYS_LVD_EN == 1)
        vbat_check_init();
#endif
        msg[2] = APP_MODE_IDLE | (IDLE_MODE_CHARGE << 8);
    } else {
        msg[2] = APP_MODE_POWERON;
        check_power_on_voltage();
        app_poweron_check(update);//正常流程中会卡在这里

        app_send_message(APP_MSG_POWER_ON, 0);
    }

#if TCFG_CHARGE_ENABLE
    set_charge_event_flag(1);
#endif

    struct app_mode *mode;
    mode = app_mode_switch_handler(msg);
    ASSERT(mode != NULL);
    return mode;
}
```

- `app_poweron_check(update);`放到最后面，程序进入后因为while1一直卡在这里。

```c
/*充电拔出,CPU软件复位, 不检测按键，直接开机*/
__INITCALL_BANK_CODE
static void app_poweron_check(int update)
{
#if (CONFIG_BT_MODE == BT_NORMAL)
    if (!update && cpu_reset_by_soft()) {
        app_var.play_poweron_tone = 0;
        return;
    }
#if TCFG_CHARGE_ENABLE
    if (is_ldo5v_wakeup()) {
#if TCFG_CHARGE_OFF_POWERON_EN  //出仓开机
        app_var.play_poweron_tone = 0;
        app_var.poweron_reason = SYS_POWERON_BY_OUT_BOX;
        return;
#else
        //拔出关机
        power_set_soft_poweroff(); //没有开启出仓就是进入关机
#endif
    }
#endif

#if TCFG_AUTO_POWERON_ENABLE //上电直接返回进入开机流程
    return;
#endif
    check_power_on_key();  //这里应该出仓后，关机正常检测各按键类型的开机状态

#endif
}
```

### 2. 开机检测函数 `check_power_on_key()`

这是所有按键类型唤醒开机的核心检测逻辑：

```c
__INITCALL_BANK_CODE
void check_power_on_key(void)
{
    u32 delay_10ms_cnt = 0;

    while (1) {
        wdt_clear();                    // 清看门狗，因为程序一直卡在这里，不清楚就会直接复位。
        os_time_dly(1);                 // 延时 10ms

        if (get_power_on_status()) {    // 检测所有按键类型
            putchar('+');
            delay_10ms_cnt++;

            // 持续按下超过配置时间(_SOFTOFF_WAKEUP_TIME)则开机
            if (delay_10ms_cnt > _SOFTOFF_WAKEUP_TIME) {
                app_var.poweron_reason = SYS_POWERON_BY_KEY;
                return;  // 退出循环，正式开机
            }
        } else {
            log_info("enter softpoweroff\n");//按键唤醒条件没有满足
            delay_10ms_cnt = 0;
            app_var.poweroff_reason = SYS_POWEROFF_BY_KEY;
            power_set_soft_poweroff();  // 重新进入关机状态
        }
    }
}
```

**代码位置**：`SDK/apps/earphone/app_main.c:286-309`

**关键参数**：
- `_SOFTOFF_WAKEUP_TIME`：默认200（单位：10ms），即需要持续按下 2000ms（2秒）才能开机
- 可在 `customer/{项目名}/customer.conf` 中配置

### 3. 统一开机状态检测 `get_power_on_status()`

该函数轮询所有按键类型的开机状态：

```c
u8 get_power_on_status(void)
{
    u8 flag = 0;

#if TCFG_IOKEY_ENABLE
    if (is_iokey_press_down()) {
        flag = 1;
    }
#endif

#if TCFG_ADKEY_ENABLE
    if (is_adkey_press_down()) {
        flag = 1;
    }
#endif

#if TCFG_LP_TOUCH_KEY_ENABLE
    if (lp_touch_key_power_on_status()) {
        flag = 1;
    }
#endif

    return flag;
}
```

**代码位置**：`SDK/apps/earphone/app_main.c:261-282`

---

## 触摸按键唤醒流程

### 1. 触摸按键硬件架构

触摸按键基于 **LPCTMU（Low Power Capacitive Touch Measurement Unit）** 硬件模块：

```
┌──────────────────────────────────────────┐
│     LPCTMU 硬件模块 (独立硬件单元)        │
├──────────────────────────────────────────┤
│  - 独立时钟源                            │
│  - DMA数据采集                           │
│  - 硬件算法引擎                          │
│  - 低功耗模式支持                        │
│  - 软关机唤醒功能                        │
└──────────────────────────────────────────┘
         ↓                    ↓
    触摸通道扫描        中断唤醒CPU
    (关机时仍工作)      (检测到触摸)
```

### 2. 触摸按键初始化流程

```c
// 代码位置: SDK/cpu/br56/periph/touch/lp_touch_key.c:461-483
__INITCALL_BANK_CODE
void lp_touch_key_init(const struct lp_touch_key_platform_data *pdata)
{
    __this->pdata = pdata;

    // 创建信号量用于初始化同步
    touch_ready_sem = (OS_SEM *)malloc(sizeof(OS_SEM));
    os_sem_create(touch_ready_sem, 0);

    // 创建触摸按键任务
    int err = task_create(lp_touch_key_task, NULL, "lp_touch_key");

    // 等待任务初始化完成
    os_sem_pend(touch_ready_sem, 0);

    free(touch_ready_sem);
}
```

### 3. 触摸按键任务初始化 `lp_touch_key_task()`

#### 3.1 检测唤醒源

```c
// 代码位置: SDK/cpu/br56/periph/touch/lp_touch_key.c:328-332
if ((is_wakeup_source(PWR_WK_REASON_P11)) &&
    (is_wakeup_source(PWR_WK_REASON_LPCTMU))) {
    // 同时从P11和LPCTMU唤醒，抛弃第一次短按
    touch_abandon_short_click_once = 1;
} else {
    touch_abandon_short_click_once = 0;
}
```

#### 3.2 配置软关机唤醒模式

```c
// 代码位置: SDK/cpu/br56/periph/touch/lp_touch_key.c:406-413
if (__this->lpctmu_cfg.ch_wkp_en) {
    // 默认：充电时不唤醒
    __this->lpctmu_cfg.softoff_wakeup_cfg =
        LPCTMU_WAKEUP_EN_WITHOUT_CHARGE_ONLINE;

    // 配置：充电时也允许唤醒
    if (__this->pdata->charge_online_softoff_wakeup) {
        __this->lpctmu_cfg.softoff_wakeup_cfg =
            LPCTMU_WAKEUP_EN_ALWAYS;
    }
} else {
    __this->lpctmu_cfg.softoff_wakeup_cfg = LPCTMU_WAKEUP_DISABLE;
}
```

#### 3.3 算法参数加载

```c
// 代码位置: SDK/cpu/br56/periph/touch/lp_touch_key.c:361-384
for (ch_idx = 0; ch_idx < __this->pdata->key_num; ch_idx ++) {
    // 检查唤醒源，决定是否从VM中恢复算法参数
    if ((!is_wakeup_source(PWR_WK_REASON_P11)) ||
        (__this->pdata->ldo_wkp_algo_reset && is_ldo5v_wakeup()) ||
        (__this->pdata->charge_online_algo_reset && get_charge_online_flag())) {

        // 重新初始化算法
        __this->identify_algo_invalid |= BIT(ch_idx);
        lp_touch_key_identify_algorithm_init(ch_idx,
            algo_cfg->algo_cfg0, algo_cfg->algo_cfg2);
    } else {
        // 从VM读取之前保存的算法参数
        log_debug("read vm algo param\n");
        ret = syscfg_read(VM_LP_TOUCH_KEY0_IDTY_ALGO + ch_idx,
                         tia_addr, tia_size);
        if (ret == tia_size) {
            log_debug("read vm algo param succ\n");
            // 成功恢复算法状态
        }
    }
}
```

### 4. 触摸按键开机状态检测

```c
// 代码位置: SDK/cpu/br56/periph/touch/lp_touch_key.c:486-493
u32 lp_touch_key_power_on_status()
{
    if (!__this->pdata) {
        return 0;
    }
    // 返回最后的触摸状态（低8位）
    u32 state = 0xff & (lp_touch_key_get_last_touch_state());
    return state;
}

u32 lp_touch_key_get_last_touch_state(void)
{
    if (!__this) {
        return 0;
    }
    // [31:16]算法无效标志 | [15:0]触摸状态
    u32 state = (__this->identify_algo_invalid << 16) | __this->last_touch_state;
    return state;
}
```

**代码位置**：`SDK/cpu/br56/periph/touch/lp_touch_key.c:295-302`

### 5. 关机前保存触摸算法参数

```c
// 代码位置: SDK/cpu/br56/periph/touch/lp_touch_key.c:573-585
static void lp_touch_key_pre_softoff_cbfunc(void)
{
    if (0 == lpctmu_is_working()) {
        return;
    }

    // 等待用户松手
    u32 key_state = lp_touch_key_get_last_touch_state();
    while (key_state) {
        os_time_dly(2);  // 延时20ms
        key_state = lp_touch_key_get_last_touch_state();
    }

    // 保存算法参数到VM
    lp_touch_key_save_identify_algo_param();
}
platform_uninitcall(lp_touch_key_pre_softoff_cbfunc);
```

### 6. LPCTMU关机保持工作判断

```c
// 代码位置: SDK/cpu/br56/periph/touch/lpctmu_hw.c:766-801
u32 lpctmu_is_sf_keep(void)
{
    u32 lpctmu_softoff_keep_work;

    if (lpctmu_is_working()) {
        switch (__this->softoff_wakeup_cfg) {
        case LPCTMU_WAKEUP_DISABLE:
            lpctmu_softoff_keep_work = 0;  // 关机时停止工作
            break;

        case LPCTMU_WAKEUP_EN_WITHOUT_CHARGE_ONLINE:
            lpctmu_softoff_keep_work = 1;  // 默认工作
            if (get_charge_online_flag()) {
                lpctmu_softoff_keep_work = 0;  // 充电时停止
            }
            break;

        case LPCTMU_WAKEUP_EN_ALWAYS:
            lpctmu_softoff_keep_work = 1;  // 始终工作
            break;

        default:
            lpctmu_softoff_keep_work = 1;
            break;
        }

        if (lpctmu_softoff_keep_work == 0) {
            lpctmu_disable();
            return 0;
        } else {
            return 1;  // 保持工作，可以唤醒
        }
    }
    return 0;
}
```

### 7. 触摸按键唤醒完整流程图

```
┌─────────────────────────────────────────────────────────────┐
│                    系统关机状态                              │
├─────────────────────────────────────────────────────────────┤
│  1. 保存触摸算法参数到VM (等待松手后保存)                    │
│  2. LPCTMU硬件模块检查softoff_wakeup_cfg配置                │
│  3. 决定是否进入低功耗扫描模式                               │
└─────────────────────────────────────────────────────────────┘
                           ↓
┌─────────────────────────────────────────────────────────────┐
│               LPCTMU低功耗扫描模式                           │
├─────────────────────────────────────────────────────────────┤
│  - 扫描间隔：lowpower_sample_scan_time (默认100ms)          │
│  - 硬件自动扫描触摸通道                                      │
│  - CPU处于低功耗睡眠                                        │
│  - 不需要IO保护（硬件模块独立工作）                          │
└─────────────────────────────────────────────────────────────┘
                           ↓
                    [检测到触摸触发]
                           ↓
┌─────────────────────────────────────────────────────────────┐
│                  LPCTMU产生唤醒中断                          │
├─────────────────────────────────────────────────────────────┤
│  - 唤醒CPU                                                  │
│  - 设置唤醒源标志：PWR_WK_REASON_LPCTMU                     │
│  - 系统开始启动流程                                          │
└─────────────────────────────────────────────────────────────┘
                           ↓
┌─────────────────────────────────────────────────────────────┐
│              app_main() → app_task_init()                   │
├─────────────────────────────────────────────────────────────┤
│  1. do_initcall() → lp_touch_key_init()                    │
│  2. 创建lp_touch_key任务                                    │
│  3. lp_touch_key_task()初始化                              │
│     - 检测唤醒源                                            │
│     - 从VM恢复算法参数                                      │
│     - 配置LPCTMU                                            │
│     - 初始化完成                                            │
└─────────────────────────────────────────────────────────────┘
                           ↓
┌─────────────────────────────────────────────────────────────┐
│           app_poweron_check() → check_power_on_key()        │
├─────────────────────────────────────────────────────────────┤
│  while(1) {                                                 │
│    if (get_power_on_status()) {                            │
│      // 调用lp_touch_key_power_on_status()                 │
│      // 检查__this->last_touch_state                       │
│      delay_10ms_cnt++;                                     │
│      if (delay_10ms_cnt > _SOFTOFF_WAKEUP_TIME) {         │
│        return; // 开机成功                                 │
│      }                                                     │
│    } else {                                                │
│      power_set_soft_poweroff(); // 重新关机                │
│    }                                                       │
│  }                                                         │
└─────────────────────────────────────────────────────────────┘
                           ↓
                   [系统正式开机]
```

---

## IO按键唤醒流程

### 1. IO按键硬件架构

IO按键是最简单的按键类型，直接使用GPIO检测：

```
┌──────────────────────────────────────────┐
│          GPIO 输入检测                    │
├──────────────────────────────────────────┤
│  - 需要在关机状态保持GPIO输入功能         │
│  - 通过PORT_PROTECT保护IO                │
│  - 开机后轮询GPIO电平                     │
└──────────────────────────────────────────┘
         ↓
    按键连接方式：
    ONE_PORT_TO_LOW   按下时IO为低电平
    ONE_PORT_TO_HIGH  按下时IO为高电平
```

### 2. IO按键配置

```c
// 代码位置: SDK/apps/earphone/board/iokey_config.c:39-75
__INITCALL_BANK_CODE
const struct iokey_platform_data *get_iokey_platform_data()
{
    const struct iokey_info *info = g_iokey_info;

    platform_data.num = ARRAY_SIZE(g_iokey_info);
    platform_data.port = iokey_ports;
    platform_data.enable = 1;

    for (int i = 0; i < platform_data.num; i++) {
        // 配置按键连接方式
        if (info[i].detect == 0) {
            iokey_ports[i].connect_way = ONE_PORT_TO_LOW;  // 按下为低
        } else {
            iokey_ports[i].connect_way = ONE_PORT_TO_HIGH; // 按下为高
        }

        iokey_ports[i].key_type.one_io.port = info[i].key_io;
        iokey_ports[i].key_value = info[i].key_value;

        // 长按复位配置
        if (info[i].long_press_reset_enable) {
            platform_data.long_press_enable = 1;
            platform_data.long_press_time = info[i].long_press_reset_time;
            platform_data.long_press_port = info[i].key_io;
            platform_data.long_press_level = info[i].detect;
        }
    }

    return &platform_data;
}
```

### 3. IO按键开机状态检测

```c
// 代码位置: SDK/apps/earphone/board/iokey_config.c:77-94
bool is_iokey_press_down()
{
#if TCFG_IOKEY_ENABLE
    if (platform_data.enable == 0) {
        return false;
    }

    // 查找KEY_POWER按键
    for (int i = 0; i < platform_data.num; i++) {
        if (iokey_ports[i].key_value == KEY_POWER) {
            // 读取GPIO电平
            int value = gpio_read(iokey_ports[i].key_type.one_io.port);

            // 根据连接方式判断
            if (iokey_ports[i].connect_way == ONE_PORT_TO_LOW) {
                return value == 0 ? true : false;  // 低电平按下
            }
            return value == 1 ? true : false;      // 高电平按下
        }
    }
#endif
    return false;
}
```

### 4. IO按键关机保护

```c
// 代码位置: SDK/cpu/br56/power/power_port.c:9-28
void gpio_config_soft_poweroff(void)
{
    PORT_TABLE(g);

#if TCFG_IOKEY_ENABLE
    // 保护IO按键端口，使其在关机状态下保持输入功能
    PORT_PROTECT(get_iokey_power_io());
#endif

#if _TCFG_PWMLED_PORT_PROTECT_ENABLE
    // 保护LED端口（充满电时LED需要持续亮）
    PORT_PROTECT(_LED0_PORT_PROTECT);
    PORT_PROTECT(_LED1_PORT_PROTECT);
#endif

#if TCFG_ADKEY_ENABLE
    // 保护AD按键端口
    PORT_PROTECT(get_adkey_io());
#endif

    __port_init((u32)gpio_config);
}
```

**PORT_PROTECT作用**：

- 防止IO在软关机状态下被配置为其他功能
- 保持GPIO的输入状态
- 确保唤醒时能够正确检测按键状态

### 5. IO按键唤醒完整流程图

```
┌─────────────────────────────────────────────────────────────┐
│                    系统关机状态                              │
├─────────────────────────────────────────────────────────────┤
│  1. 调用gpio_config_soft_poweroff()                         │
│  2. PORT_PROTECT(get_iokey_power_io())                     │
│  3. 保持GPIO输入功能                                        │
│  4. CPU进入低功耗模式                                        │
└─────────────────────────────────────────────────────────────┘
                           ↓
                    [用户按下按键]
                           ↓
┌─────────────────────────────────────────────────────────────┐
│                  GPIO电平变化                                │
├─────────────────────────────────────────────────────────────┤
│  - ONE_PORT_TO_LOW：GPIO变为低电平                          │
│  - ONE_PORT_TO_HIGH：GPIO变为高电平                         │
│  - 产生GPIO唤醒中断                                         │
│  - 唤醒CPU                                                  │
└─────────────────────────────────────────────────────────────┘
                           ↓
┌─────────────────────────────────────────────────────────────┐
│              app_main() → app_task_init()                   │
├─────────────────────────────────────────────────────────────┤
│  1. key_driver_init() 初始化按键驱动                        │
│  2. 调用get_iokey_platform_data()获取配置                   │
└─────────────────────────────────────────────────────────────┘
                           ↓
┌─────────────────────────────────────────────────────────────┐
│           app_poweron_check() → check_power_on_key()        │
├─────────────────────────────────────────────────────────────┤
│  while(1) {                                                 │
│    if (get_power_on_status()) {                            │
│      // 调用is_iokey_press_down()                          │
│      // 读取gpio_read(iokey_port)                          │
│      // 判断电平是否符合按下条件                            │
│      delay_10ms_cnt++;                                     │
│      if (delay_10ms_cnt > _SOFTOFF_WAKEUP_TIME) {         │
│        return; // 开机成功                                 │
│      }                                                     │
│    } else {                                                │
│      power_set_soft_poweroff(); // 误触，重新关机          │
│    }                                                       │
│  }                                                         │
└─────────────────────────────────────────────────────────────┘
                           ↓
                   [系统正式开机]
```

---

## AD按键唤醒流程

### 1. AD按键硬件架构

AD按键通过电阻分压+ADC采样来区分不同按键：

```
VCC (3.3V)
  │
  ├─── 上拉电阻 (pull_up_value)
  │
  ├─── ADC输入 ──→ ADC通道采样
  │
  ├─── 按键1 + 电阻R1 ─── GND
  ├─── 按键2 + 电阻R2 ─── GND
  └─── 按键N + 电阻RN ─── GND

不同按键按下时产生不同的ADC值：
  ADC_value = max_ad_value × Rn / (Rn + pull_up_value)
```

### 2. AD按键配置与电阻排序

```c
// 代码位置: SDK/apps/earphone/board/adkey_config.c:21-96
const struct adkey_platform_data *get_adkey_platform_data()
{
    const struct adkey_info *info = &g_adkey_data;
    u16 key_numbers = ARRAY_SIZE(adkey_res_table);

    // 基本配置
    g_adkey_platform_data.adkey_pin = info->key_io;
    g_adkey_platform_data.extern_up_en = info->pull_up_type;
    g_adkey_platform_data.ad_channel = adc_io2ch(g_adkey_platform_data.adkey_pin);

    u16 ordering_res[CONFIG_ADKEY_MAX_NUM][2];

    // 记录电阻与序号
    for (u16 i = 0; i < key_numbers; i++) {
        ordering_res[i][0] = adkey_res_table[i].res_value;
        ordering_res[i][1] = i;
    }

    // 按电阻从小到大排序（冒泡排序）
    for (u16 i = 0; i < key_numbers - 1; i++) {
        for (u16 j = 0; j < key_numbers - 1 - i; j++) {
            if (ordering_res[j][0] > ordering_res[j + 1][0]) {
                // 交换电阻值
                u16 tmp = ordering_res[j][0];
                ordering_res[j][0] = ordering_res[j + 1][0];
                ordering_res[j + 1][0] = tmp;
                // 交换序号
                tmp = ordering_res[j][1];
                ordering_res[j][1] = ordering_res[j + 1][1];
                ordering_res[j + 1][1] = tmp;
            }
        }
    }

    // 计算AD判断阈值（取中间值）
    u16 tmp_value1, tmp_value2;
    for (u16 i = 0; i < key_numbers; i++) {
        // 当前按键的ADC理论值
        tmp_value1 = info->max_ad_value * ordering_res[i][0] /
                     (ordering_res[i][0] + info->pull_up_value);

        // 下一个按键的ADC理论值（最后一个按键用max_ad_value）
        if (i == key_numbers - 1) {
            tmp_value2 = info->max_ad_value;
        } else {
            tmp_value2 = info->max_ad_value * ordering_res[i + 1][0] /
                         (ordering_res[i + 1][0] + info->pull_up_value);
        }

        // 取中间值作为判断阈值
        g_adkey_platform_data.ad_value[i] = (tmp_value1 + tmp_value2) / 2;
        g_adkey_platform_data.key_value[i] =
            adkey_res_table[ordering_res[i][1]].key_value;

        printf("ADkey:%d, judge_advalue:%d, key_value:%d\n",
               i, g_adkey_platform_data.ad_value[i],
               g_adkey_platform_data.key_value[i]);
    }

    g_adkey_platform_data.enable = 1;
    return &g_adkey_platform_data;
}
```

### 3. AD按键开机状态检测

```c
// 代码位置: SDK/apps/earphone/board/adkey_config.c:99-111
bool is_adkey_press_down()
{
#if TCFG_ADKEY_ENABLE
    if (g_adkey_platform_data.enable == 0) {
        return false;
    }

    // 读取ADC值，小于10表示有按键按下
    // （按键按下时，分压电阻较小，ADC值接近0）
    if (adc_get_value(g_adkey_platform_data.ad_channel) < 10) {
        return true;
    }
#endif
    return false;
}
```

**检测逻辑**：
- ADC值 < 10：有按键按下（接近GND）
- ADC值 ≥ 10：无按键按下（上拉到VCC）

### 4. AD按键关机保护

与IO按键类似，AD按键也需要IO保护：

```c
// 代码位置: SDK/cpu/br56/power/power_port.c:23-24
#if TCFG_ADKEY_ENABLE
    PORT_PROTECT(get_adkey_io());  // 保护ADC输入IO
#endif
```

**保护目的**：
- 保持ADC通道的输入功能
- 确保开机时能正确读取ADC值
- 防止IO被配置为其他功能

### 5. AD按键唤醒完整流程图

```
┌─────────────────────────────────────────────────────────────┐
│                    系统关机状态                              │
├─────────────────────────────────────────────────────────────┤
│  1. 调用gpio_config_soft_poweroff()                         │
│  2. PORT_PROTECT(get_adkey_io())                           │
│  3. 保持ADC通道输入功能                                      │
│  4. CPU进入低功耗模式                                        │
└─────────────────────────────────────────────────────────────┘
                           ↓
                    [用户按下按键]
                           ↓
┌─────────────────────────────────────────────────────────────┐
│                  ADC电压变化                                 │
├─────────────────────────────────────────────────────────────┤
│  - 按键按下，电阻分压                                        │
│  - ADC输入电压变化（接近GND）                                │
│  - 产生GPIO/ADC唤醒中断                                      │
│  - 唤醒CPU                                                  │
└─────────────────────────────────────────────────────────────┘
                           ↓
┌─────────────────────────────────────────────────────────────┐
│              app_main() → app_task_init()                   │
├─────────────────────────────────────────────────────────────┤
│  1. key_driver_init() 初始化按键驱动                        │
│  2. 调用get_adkey_platform_data()获取配置                   │
│     - 计算ADC阈值                                           │
│     - 排序电阻值                                            │
│  3. 初始化ADC通道                                           │
└─────────────────────────────────────────────────────────────┘
                           ↓
┌─────────────────────────────────────────────────────────────┐
│           app_poweron_check() → check_power_on_key()        │
├─────────────────────────────────────────────────────────────┤
│  while(1) {                                                 │
│    if (get_power_on_status()) {                            │
│      // 调用is_adkey_press_down()                          │
│      // 读取adc_get_value(ad_channel)                      │
│      // 判断ADC值是否<10                                    │
│      delay_10ms_cnt++;                                     │
│      if (delay_10ms_cnt > _SOFTOFF_WAKEUP_TIME) {         │
│        return; // 开机成功                                 │
│      }                                                     │
│    } else {                                                │
│      power_set_soft_poweroff(); // 误触，重新关机          │
│    }                                                       │
│  }                                                         │
└─────────────────────────────────────────────────────────────┘
                           ↓
                   [系统正式开机]
```

---

## 关键问题解答

### Q1: 为什么触摸按键不需要IO保护？

**答案**：触摸按键不需要IO保护的核心原因是 **LPCTMU是独立的硬件模块**。

- AD按键以及IO按键则是需要的。

#### 详细解释：

**1. 硬件架构差异**

| 按键类型 | 硬件实现 | 关机状态工作方式 | 是否需要IO保护 |
|---------|---------|----------------|--------------|
| IO按键 | GPIO输入 | 依赖GPIO保持输入功能 | **需要** |
| AD按键 | ADC采样 | 依赖ADC通道保持输入功能 | **需要** |
| 触摸按键 | LPCTMU硬件模块 | LPCTMU独立工作，不依赖IO配置 | **不需要** |

**2. LPCTMU的独立性**

```c
// 代码位置: SDK/interface/driver/cpu/br56/asm/lpctmu_hw.h:85-95
struct lpctmu_platform_data {
    u8 sample_window_time;              // 采样窗口时间
    u8 sample_scan_time;                // 正常扫描间隔 (20ms)
    u8 lowpower_sample_scan_time;       // 关机扫描间隔 (100ms)
    u16 aim_vol_delta;
    u16 aim_charge_khz;
    u32 dma_nvram_addr;                 // DMA缓冲区
    u32 dma_nvram_size;
};
```

LPCTMU特性：
- **独立时钟源**：不依赖系统时钟，关机时仍能运行
- **独立DMA**：硬件自动采样，不需要CPU参与
- **独立电源域**：即使CPU关机，LPCTMU仍能工作
- **硬件算法引擎**：触摸检测算法在硬件中完成

**3. 关机状态工作流程**

```c
// 代码位置: SDK/cpu/br56/periph/touch/lpctmu_hw.c:766-801
u32 lpctmu_is_sf_keep(void)
{
    if (lpctmu_is_working()) {
        // 根据配置决定是否在关机状态继续工作
        switch (__this->softoff_wakeup_cfg) {
        case LPCTMU_WAKEUP_EN_WITHOUT_CHARGE_ONLINE:
            // 不充电时工作，充电时停止
            lpctmu_softoff_keep_work = 1;
            if (get_charge_online_flag()) {
                lpctmu_softoff_keep_work = 0;
            }
            break;
        case LPCTMU_WAKEUP_EN_ALWAYS:
            // 始终工作
            lpctmu_softoff_keep_work = 1;
            break;
        }

        if (lpctmu_softoff_keep_work == 1) {
            return 1;  // LPCTMU保持工作，不需要额外配置
        }
    }
}
```

**4. IO按键和AD按键为什么需要保护？**

```c
// IO按键依赖GPIO功能
PORT_PROTECT(get_iokey_power_io());
// ↑ 防止GPIO被配置为其他功能（如SPI、UART等）
// ↑ 确保保持输入模式
// ↑ 开机时能读取到正确的电平

// AD按键依赖ADC功能
PORT_PROTECT(get_adkey_io());
// ↑ 防止ADC通道被禁用
// ↑ 确保保持模拟输入模式
// ↑ 开机时能读取到正确的ADC值
```

**总结**：
- IO/AD按键是**被动检测**，需要系统提供GPIO/ADC功能支持
- 触摸按键是**主动检测**，LPCTMU硬件模块独立完成所有工作
- LPCTMU直接连接到触摸通道，不经过通用GPIO复用系统

### Q2: 触摸按键如何在关机状态下保持检测？

**答案**：通过LPCTMU硬件模块的低功耗扫描模式。

```
正常运行模式：
  sample_scan_time = 20ms  （快速响应）

关机模式：
  lowpower_sample_scan_time = 100ms  （省电）

流程：
  1. 系统进入关机状态
  2. LPCTMU检查softoff_wakeup_cfg配置
  3. 如果允许唤醒，切换到低功耗扫描模式
  4. 硬件定时扫描触摸通道（100ms一次）
  5. 检测到触摸时产生中断唤醒CPU
```

### Q3: 唤醒时间为什么需要持续2秒（_SOFTOFF_WAKEUP_TIME=200）？

**答案**：防止误触和抖动。

```c
// 代码位置: SDK/apps/earphone/app_main.c:294-299
if (get_power_on_status()) {
    delay_10ms_cnt++;
    if (delay_10ms_cnt > _SOFTOFF_WAKEUP_TIME) {  // 200 × 10ms = 2秒
        app_var.poweron_reason = SYS_POWERON_BY_KEY;
        return;  // 开机
    }
}
```

**原因**：
1. **防误触**：避免放在口袋等场景下意外开机
2. **去抖动**：机械按键有抖动，需要稳定检测
3. **用户体验**：明确的开机意图（长按）
4. **省电考虑**：短暂触碰立即关机，避免无效开机

**可配置性**：
```bash
# 在 customer.conf 中配置
_SOFTOFF_WAKEUP_TIME=200  # 2000ms (2秒)
_SOFTOFF_WAKEUP_TIME=300  # 3000ms (3秒)  更严格
_SOFTOFF_WAKEUP_TIME=100  # 1000ms (1秒)  更灵敏
```

### Q4: 触摸按键的算法参数为什么要保存到VM？

**答案**：保持触摸灵敏度的一致性。

```c
// 关机前保存
// 代码位置: SDK/cpu/br56/periph/touch/lp_touch_key.c:573-584
static void lp_touch_key_pre_softoff_cbfunc(void)
{
    // 等待松手
    u32 key_state = lp_touch_key_get_last_touch_state();
    while (key_state) {
        os_time_dly(2);
        key_state = lp_touch_key_get_last_touch_state();
    }

    // 保存算法参数
    lp_touch_key_save_identify_algo_param();
}
```

```c
// 开机后恢复
// 代码位置: SDK/cpu/br56/periph/touch/lp_touch_key.c:368-383
ret = syscfg_read(VM_LP_TOUCH_KEY0_IDTY_ALGO + ch_idx, tia_addr, tia_size);
if (ret == tia_size) {
    log_debug("read vm algo param succ\n");
    // 恢复之前的算法状态
    // 包括：基准值、阈值、灵敏度等
}
```

**原因**：
1. **自适应算法**：触摸算法会根据环境自动调整基准值
2. **环境稳定性**：保存的参数反映了上次使用时的环境状态
3. **快速响应**：开机后立即使用已校准的参数，无需重新学习
4. **一致体验**：避免每次开机灵敏度不一致

**特殊情况下重新初始化**：
```c
if (is_ldo5v_wakeup() || get_charge_online_flag()) {
    // 充电状态可能改变环境，重新初始化
    lp_touch_key_identify_algorithm_init(...);
}
```

---

## 时序图

### 触摸按键唤醒时序

```
用户         LPCTMU硬件         CPU              软件驱动
 │              │                │                  │
 │ [手指触摸]   │                │                  │
 ├─────────────>│                │                  │
 │              │ [电容变化]     │                  │
 │              │ [硬件检测]     │                  │
 │              │ [算法判断]     │                  │
 │              ├───────────────>│                  │
 │              │   产生中断     │                  │
 │              │                │ [CPU唤醒]        │
 │              │                │                  │
 │              │                │ app_main()       │
 │              │                ├─────────────────>│
 │              │                │                  │ app_task_init()
 │              │                │                  │ └─> do_initcall()
 │              │                │                  │     └─> lp_touch_key_init()
 │              │                │                  │         └─> 创建任务
 │              │                │                  │
 │              │                │                  │ lp_touch_key_task()
 │              │                │                  │ ├─> 检测唤醒源
 │              │                │                  │ ├─> 从VM恢复算法参数
 │              │                │                  │ └─> lpctmu_init()
 │              │<──────────────────────────────────┤
 │              │   配置LPCTMU   │                  │
 │              │                │                  │
 │ [持续按下]   │                │                  │
 ├─────────────>│                │                  │
 │              │ [持续检测]     │                  │
 │              │                │ check_power_on_key()
 │              │                │<─────────────────┤
 │              │                │  轮询开机状态    │
 │              │                │                  │
 │              │                │ get_power_on_status()
 │              │                │ └─> lp_touch_key_power_on_status()
 │              │<──────────────────────────────────┤
 │              │   查询触摸状态 │                  │
 │              ├───────────────────────────────────>│
 │              │   返回: 按下   │                  │
 │              │                │                  │
 │              │                │ [每10ms检查]     │
 │              │                │ delay_10ms_cnt++ │
 │              │                │                  │
 │ [持续2秒]    │                │                  │
 ├─────────────>│                │                  │
 │              │                │ [200次循环后]    │
 │              │                │ return 开机成功  │
 │              │                │                  │
 │              │                │ [进入BT模式]     │
```

### IO按键唤醒时序

```
用户         GPIO硬件           CPU              软件驱动
 │              │                │                  │
 │ [按下按键]   │                │                  │
 ├─────────────>│                │                  │
 │              │ [电平变化]     │                  │
 │              │ LOW/HIGH       │                  │
 │              ├───────────────>│                  │
 │              │   GPIO中断     │                  │
 │              │                │ [CPU唤醒]        │
 │              │                │                  │
 │              │                │ app_main()       │
 │              │                ├─────────────────>│
 │              │                │                  │ key_driver_init()
 │              │                │                  │ └─> get_iokey_platform_data()
 │              │                │                  │
 │              │                │ check_power_on_key()
 │              │                │<─────────────────┤
 │              │                │                  │
 │ [持续按下]   │                │ is_iokey_press_down()
 ├─────────────>│<──────────────────────────────────┤
 │              │   gpio_read()  │                  │
 │              ├───────────────────────────────────>│
 │              │   返回: 按下   │                  │
 │              │                │                  │
 │              │                │ [每10ms检查]     │
 │              │                │ delay_10ms_cnt++ │
 │              │                │                  │
 │ [持续2秒]    │                │ [200次循环后]    │
 ├─────────────>│                │ return 开机成功  │
```

### AD按键唤醒时序

```
用户      电阻网络    ADC硬件         CPU              软件驱动
 │           │          │              │                  │
 │[按下按键] │          │              │                  │
 ├──────────>│          │              │                  │
 │           │[分压]    │              │                  │
 │           ├─────────>│              │                  │
 │           │ ADC变化  │              │                  │
 │           │          ├─────────────>│                  │
 │           │          │   ADC中断    │                  │
 │           │          │              │ [CPU唤醒]        │
 │           │          │              │                  │
 │           │          │              │ app_main()       │
 │           │          │              ├─────────────────>│
 │           │          │              │                  │ key_driver_init()
 │           │          │              │                  │ └─> get_adkey_platform_data()
 │           │          │              │                  │     └─> 计算ADC阈值
 │           │          │              │                  │
 │           │          │              │ check_power_on_key()
 │           │          │              │<─────────────────┤
 │           │          │              │                  │
 │[持续按下] │          │              │ is_adkey_press_down()
 ├──────────>│          │<─────────────────────────────────┤
 │           │          │ adc_get_value()                 │
 │           │          ├──────────────────────────────────>│
 │           │          │   返回: <10  │                  │
 │           │          │              │                  │
 │           │          │              │ [每10ms检查]     │
 │           │          │              │ delay_10ms_cnt++ │
 │           │          │              │                  │
 │[持续2秒]  │          │              │ [200次循环后]    │
 ├──────────>│          │              │ return 开机成功  │
```

---

## 配置参数说明

### 1. 触摸按键相关配置

#### customer.conf 配置

```bash
# 代码位置: SDK/customer/{项目名}/customer.conf

# 触摸按键功能使能
TCFG_LP_TOUCH_KEY_ENABLE = y

# 触摸按键配置文件路径
LP_TOUCH_KEY_PLATFORM_CFG_FILE = SDK/apps/earphone/board/br56/lp_touch_key_config.c
```

#### 触摸按键平台配置

```c
// 代码位置: SDK/apps/earphone/board/br56/lp_touch_key_config.c

const struct lp_touch_key_platform_data lp_touch_key_data = {
    .key_num = 2,                              // 触摸通道数量
    .charge_online_softoff_wakeup = 0,         // 充电时是否允许唤醒
    .charge_enter_algo_reset = 1,              // 进入充电时重置算法
    .charge_exit_algo_reset = 1,               // 退出充电时重置算法
    .ldo_wkp_algo_reset = 1,                   // LDO唤醒时重置算法
    .charge_online_algo_reset = 1,             // 充电在线时重置算法
    .softoff_wakeup_time = 1000,               // 关机唤醒时间 (ms)
    .slide_mode_en = 0,                        // 滑动模式使能

    .key_cfg = {
        {
            .key_ch = CH0_PB11_L2,             // 触摸通道0: PB11
            .wakeup_enable = 1,                // 允许唤醒
            .eartch_en = 0,                    // 入耳检测功能
            .index = 0,                        // 算法参数索引
            .algo_cfg = {
                {
                    .algo_cfg0 = 280,          // 算法参数0：灵敏度
                    .algo_cfg1 = 300,          // 算法参数1：基准阈值
                    .algo_cfg2 = 60,           // 算法参数2：触发阈值
                    .algo_range_max = 200,     // 最大变化范围
                },
            },
        },
        {
            .key_ch = CH1_PB10_L3,             // 触摸通道1: PB10
            .wakeup_enable = 1,
            .eartch_en = 0,
            .index = 0,
            .algo_cfg = {
                {
                    .algo_cfg0 = 280,
                    .algo_cfg1 = 300,
                    .algo_cfg2 = 60,
                    .algo_range_max = 200,
                },
            },
        },
    },

    .lpctmu_pdata = &lpctmu_data,
};

// LPCTMU硬件配置
LPCTMU_PLATFORM_DATA_BEGIN(lpctmu_data)
    .sample_window_time = 2,                   // 采样窗口 2ms
    .sample_scan_time = 20,                    // 正常扫描间隔 20ms
    .lowpower_sample_scan_time = 100,          // 关机扫描间隔 100ms
    .aim_vol_delta = 0,
    .aim_charge_khz = 0,
LPCTMU_PLATFORM_DATA_END()
```

### 2. IO按键相关配置

#### customer.conf 配置

```bash
# IO按键功能使能
TCFG_IOKEY_ENABLE = y

# IO按键配置文件
IOKEY_CFG_FILE = SDK/apps/earphone/board/iokey_config.c
```

#### IO按键平台配置

```c
// 代码位置: SDK/apps/earphone/board/iokey_config.c

// 从JSON配置生成（在sdk_config.h中）
const struct iokey_info g_iokey_info[] = {
    {
        .key_io = IO_PORTB_05,                 // 按键IO: PB05
        .key_value = KEY_POWER,                // 按键值
        .detect = 0,                           // 检测电平: 0=低电平按下
        .long_press_reset_enable = 0,          // 长按复位功能
        .long_press_reset_time = 0,            // 长按复位时间(秒)
    },
};
```

### 3. AD按键相关配置

#### customer.conf 配置

```bash
# AD按键功能使能
TCFG_ADKEY_ENABLE = y

# AD按键配置文件
ADKEY_CFG_FILE = SDK/apps/earphone/board/adkey_config.c
```

#### AD按键平台配置

```c
// 代码位置: SDK/apps/earphone/board/adkey_config.c

// AD按键基本信息（从JSON配置生成）
const struct adkey_info g_adkey_data = {
    .key_io = IO_PORTB_01,                     // ADC输入IO
    .pull_up_type = 1,                         // 上拉类型: 1=外部上拉
    .pull_up_value = 47000,                    // 上拉电阻 47KΩ
    .max_ad_value = 1023,                      // 最大ADC值
    .long_press_reset_enable = 0,              // 长按复位功能
    .long_press_reset_time = 0,                // 长按复位时间(秒)
};

// 按键电阻表（从JSON配置生成）
const struct adkey_res_info adkey_res_table[] = {
    { .res_value = 0,     .key_value = KEY_POWER },     // 0Ω    → POWER
    { .res_value = 10000, .key_value = KEY_NEXT },      // 10KΩ  → NEXT
    { .res_value = 22000, .key_value = KEY_PREV },      // 22KΩ  → PREV
    { .res_value = 33000, .key_value = KEY_MODE },      // 33KΩ  → MODE
};
```

**ADC值计算公式**：
```
ADC_value = max_ad_value × Rkey / (Rkey + Rpull_up)

例如：
  POWER键（0Ω）：    1023 × 0 / (0 + 47000)     ≈ 0
  NEXT键（10KΩ）：   1023 × 10000 / (10000 + 47000) ≈ 179
  PREV键（22KΩ）：   1023 × 22000 / (22000 + 47000) ≈ 326
  MODE键（33KΩ）：   1023 × 33000 / (33000 + 47000) ≈ 422
  无按键（∞）：      1023 × ∞ / (∞ + 47000)    = 1023
```

### 4. 开机时间配置

#### customer.conf 配置

```bash
# 关机唤醒按键时间（单位：10ms）
_SOFTOFF_WAKEUP_TIME = 200                     # 2000ms (2秒)

# 不同项目的配置示例：
# _SOFTOFF_WAKEUP_TIME = 100                   # 1秒 (更灵敏)
# _SOFTOFF_WAKEUP_TIME = 300                   # 3秒 (防误触更强)
```

**代码位置**：`SDK/apps/earphone/board/br56/customer.h:26`

### 5. 自动开机配置

```bash
# 自动开机使能（插入充电直接开机，不检测按键）
TCFG_AUTO_POWERON_ENABLE = n

# 充电拔出开机使能
TCFG_CHARGE_OFF_POWERON_EN = y
```

**代码位置**：`SDK/apps/earphone/app_main.c:340-342`

```c
#if TCFG_AUTO_POWERON_ENABLE
    return;  // 直接开机，不检测按键
#endif
check_power_on_key();  // 否则需要按键开机
```

---

## 总结

### 三种按键唤醒方式对比

| 特性 | 触摸按键 | IO按键 | AD按键 |
|-----|---------|-------|-------|
| **硬件基础** | LPCTMU独立模块 | GPIO输入 | ADC采样 |
| **关机工作方式** | 硬件自动扫描 | 保持GPIO输入 | 保持ADC输入 |
| **是否需要IO保护** | 否 | 是 | 是 |
| **功耗** | 低（100ms扫描一次） | 极低（静态） | 低（静态） |
| **抗干扰能力** | 强（算法滤波） | 弱（需要硬件去抖） | 中（电阻分压） |
| **成本** | 中（需要触摸IC） | 低（仅需GPIO） | 低（需要电阻） |
| **一键多用** | 支持（滑动/长按/入耳检测） | 支持（长按/短按） | 支持（多键检测） |
| **算法复杂度** | 高（自适应算法） | 低 | 中（阈值计算） |
| **唤醒速度** | 快（硬件中断） | 快（GPIO中断） | 快（ADC中断） |
| **可靠性** | 高（无机械磨损） | 中（机械磨损） | 高（无机械磨损） |

### 关键要点

1. **触摸按键**通过LPCTMU硬件模块实现真正的"软关机唤醒"，不需要IO保护
2. **IO按键和AD按键**需要通过PORT_PROTECT保护IO功能，确保开机时能正确检测
3. **所有按键类型**都需要持续按下`_SOFTOFF_WAKEUP_TIME`时间（默认2秒）才能开机
4. **触摸按键算法参数**保存在VM中，开机后恢复，保持灵敏度一致性
5. **LPCTMU**在关机状态下以100ms间隔扫描，平衡了功耗和响应速度

### 代码文件关联图

```
apps/earphone/app_main.c (主流程)
  ├─> check_power_on_key()
  │    └─> get_power_on_status()
  │         ├─> lp_touch_key_power_on_status()  [触摸]
  │         ├─> is_iokey_press_down()           [IO]
  │         └─> is_adkey_press_down()           [AD]
  │
  ├─> do_initcall()
  │    └─> lp_touch_key_init()
  │         └─> task_create(lp_touch_key_task)
  │              └─> lpctmu_init()
  │
  └─> key_driver_init()
       ├─> get_iokey_platform_data()
       └─> get_adkey_platform_data()

cpu/br56/power/power_port.c (关机IO保护)
  └─> gpio_config_soft_poweroff()
       ├─> PORT_PROTECT(iokey_io)    [IO按键保护]
       └─> PORT_PROTECT(adkey_io)    [AD按键保护]

cpu/br56/periph/touch/lp_touch_key.c (触摸驱动)
  ├─> lp_touch_key_init()
  ├─> lp_touch_key_task()
  ├─> lp_touch_key_power_on_status()
  └─> lp_touch_key_pre_softoff_cbfunc()

cpu/br56/periph/touch/lpctmu_hw.c (LPCTMU硬件)
  ├─> lpctmu_init()
  ├─> lpctmu_is_sf_keep()           [判断关机时是否保持工作]
  └─> lpctmu_lowpower_enter()       [进入低功耗扫描]
```

## 疑问解答：两个"开机时间"参数的区别

### Q5: `_SOFTOFF_WAKEUP_TIME` vs `.softoff_wakeup_time` 有什么区别？

**用户疑问**：
> 我的触摸开机时间设定是通过`_SOFTOFF_WAKEUP_TIME`控制的，那么`lp_touch_key_config.c`结构体中的`.softoff_wakeup_time = 1000`有什么作用呢？之前`_SOFTOFF_WAKEUP_TIME`是1000，后面我改用宏控制了。是因为之前我修改的是`softoff_wakeup_time`没有作用。

**答案**：你的观察是完全正确的！`.softoff_wakeup_time`这个参数**在当前代码中没有被使用**，是一个**无效参数**。

---

### 详细分析

#### 1. 代码搜索验证

通过全局搜索代码发现：

```bash
# 搜索 softoff_wakeup_time 的使用情况
grep -rn "->softoff_wakeup_time\|\.softoff_wakeup_time" SDK/

# 结果：只有定义，没有任何使用
SDK/interface/driver/cpu/periph/lp_touch_key_common.h:146:    .softoff_wakeup_time = 1000, \
```

**结论**：`.softoff_wakeup_time`参数只在头文件中定义，但在整个代码库中**没有任何地方读取或使用**这个值。

#### 2. 两个参数的对比

| 参数名称 | 定义位置 | 单位 | 是否生效 | 实际作用 |
|---------|---------|------|---------|---------|
| `_SOFTOFF_WAKEUP_TIME` | `customer.conf` | 10ms | **是** | 控制所有按键类型的开机时间 |
| `.softoff_wakeup_time` | `lp_touch_key_platform_data` | ms | **否** | 无任何作用（废弃参数） |

#### 3. `_SOFTOFF_WAKEUP_TIME` 的实际使用

```c
// 代码位置: SDK/apps/earphone/app_main.c:286-309
__INITCALL_BANK_CODE
void check_power_on_key(void)
{
    u32 delay_10ms_cnt = 0;

    while (1) {
        wdt_clear();
        os_time_dly(1);  // 延时 10ms

        if (get_power_on_status()) {
            delay_10ms_cnt++;
            // 这里使用 _SOFTOFF_WAKEUP_TIME
            if (delay_10ms_cnt > _SOFTOFF_WAKEUP_TIME) {  // ✅ 实际生效
                app_var.poweron_reason = SYS_POWERON_BY_KEY;
                return;  // 开机成功
            }
        } else {
            power_set_soft_poweroff();
        }
    }
}
```

**配置方式**：
```bash
# 在 customer/{项目名}/customer.conf 中配置
_SOFTOFF_WAKEUP_TIME=200   # 200 × 10ms = 2000ms (2秒)
_SOFTOFF_WAKEUP_TIME=300   # 300 × 10ms = 3000ms (3秒)
_SOFTOFF_WAKEUP_TIME=100   # 100 × 10ms = 1000ms (1秒)
```

**代码位置**：`SDK/apps/earphone/board/br56/customer.h:26`

#### 4. `.softoff_wakeup_time` 为什么存在？

这个参数可能是**历史遗留参数**，有几种可能：

1. **早期版本使用**：可能在旧版SDK中曾经使用，后来改用统一的`_SOFTOFF_WAKEUP_TIME`
2. **预留接口**：可能是为未来功能预留的参数（如触摸按键单独配置开机时间）
3. **代码重构残留**：在代码重构时被废弃，但定义没有删除

#### 5. 触摸按键相关的其他时间参数（有效参数）

在`lp_touch_key_platform_data`结构体中，这些时间参数**是有效的**，用于控制**运行时**的触摸按键行为：

```c
// 代码位置: SDK/interface/driver/cpu/periph/lp_touch_key_common.h:119-123
struct lp_touch_key_platform_data {
    u16 softoff_wakeup_time;         // ❌ 无效参数（未使用）

    u16 short_click_check_time;      // ✅ 短按检测时间 (500ms)
    u16 long_click_check_time;       // ✅ 长按检测时间 (2000ms)
    u16 hold_click_check_time;       // ✅ 连按检测时间 (200ms)

    u16 eartch_touch_filter_time;    // ✅ 入耳检测滤波时间 (500ms)
    u16 eartch_touch_valid_time;     // ✅ 入耳检测有效时间 (1300ms)
    // ... 其他参数
};
```

**这些参数的实际使用**：

```c
// 代码位置: SDK/cpu/components/touch/lp_touch_key_click.c:66-69
void lp_touch_key_fall_click_handle(u32 ch_idx)
{
    struct touch_key_arg *arg = &(__this->arg[ch_idx]);
    if (arg->short_timer == 0) {
        // ✅ 使用 short_click_check_time
        arg->short_timer = usr_timeout_add(
            (void *)ch_idx,
            lp_touch_key_short_click_time_out_handle,
            __this->pdata->short_click_check_time,  // 500ms
            1
        );
    }
}

// 代码位置: SDK/cpu/components/touch/lp_touch_key_click.c:132
void lp_touch_key_start_check_long_click(u32 ch_idx)
{
    struct touch_key_arg *arg = &(__this->arg[ch_idx]);
    if (arg->long_timer == 0) {
        // ✅ 使用 long_click_check_time
        arg->long_timer = usr_timeout_add(
            (void *)ch_idx,
            lp_touch_key_trigger_long_click_event,
            __this->pdata->long_click_check_time,  // 2000ms
            1
        );
    }
}
```

#### 6. 参数作用域对比图

```
┌─────────────────────────────────────────────────────────────┐
│              系统上电 / 关机状态唤醒                          │
└─────────────────────────────────────────────────────────────┘
                           ↓
                    [检测到按键触发]
                           ↓
┌─────────────────────────────────────────────────────────────┐
│         check_power_on_key() - 开机检测阶段                  │
│                                                             │
│  使用参数：_SOFTOFF_WAKEUP_TIME (200×10ms = 2秒)   ✅       │
│  作用域：  所有按键类型（IO/AD/触摸）                        │
│  控制：    持续按下多久才能开机                              │
└─────────────────────────────────────────────────────────────┘
                           ↓
                    [开机成功，返回]
                           ↓
┌─────────────────────────────────────────────────────────────┐
│              系统进入运行模式（BT/Music等）                   │
└─────────────────────────────────────────────────────────────┘
                           ↓
                    [用户操作触摸按键]
                           ↓
┌─────────────────────────────────────────────────────────────┐
│         lp_touch_key_click.c - 运行时按键检测                │
│                                                             │
│  使用参数：short_click_check_time (500ms)        ✅         │
│           long_click_check_time (2000ms)        ✅         │
│           hold_click_check_time (200ms)         ✅         │
│  作用域：  仅触摸按键                                        │
│  控制：    区分短按/长按/连按                                │
│                                                             │
│  未使用：  softoff_wakeup_time                   ❌         │
└─────────────────────────────────────────────────────────────┘
```

---

### 总结

#### ✅ 正确的配置方法

**修改开机时间**（所有按键类型）：
```bash
# 修改 customer/{项目名}/customer.conf
_SOFTOFF_WAKEUP_TIME=200   # 这个才是真正控制开机时间的参数
```

**修改运行时触摸按键行为**（仅触摸按键）：
```c
// 修改触摸按键配置结构体
const struct lp_touch_key_platform_data lp_touch_key_data = {
    .short_click_check_time = 500,    // 短按检测时间
    .long_click_check_time = 2000,    // 长按检测时间
    .hold_click_check_time = 200,     // 连按检测时间

    .softoff_wakeup_time = 1000,      // ❌ 这个参数无效，不要修改
};
```

#### ❌ 错误的理解

- ~~修改`.softoff_wakeup_time`可以改变触摸开机时间~~ **错误！该参数未被使用**
- ~~不同按键类型有不同的开机时间~~ **错误！所有按键共用`_SOFTOFF_WAKEUP_TIME`**

#### 🎯 关键要点

1. **开机时间统一控制**：所有按键类型（IO/AD/触摸）的开机时间都由`_SOFTOFF_WAKEUP_TIME`控制
2. **`.softoff_wakeup_time`无效**：这个参数在代码中没有被使用，修改它不会产生任何效果
3. **运行时参数有效**：`short_click_check_time`等参数用于运行时按键事件检测，与开机无关
4. **配置文件优先**：`customer.conf`中的宏定义才是真正生效的配置

#### 💡 建议

1. **不要依赖无效参数**：不要试图通过修改`.softoff_wakeup_time`来改变开机时间
2. **统一配置管理**：所有开机时间配置都通过`customer.conf`中的`_SOFTOFF_WAKEUP_TIME`管理
3. **代码注释更新**：建议在`.softoff_wakeup_time`参数上添加注释，标明该参数未使用，避免误导
4. **清理建议**：如果确认该参数永久废弃，建议在未来版本中删除，保持代码整洁

