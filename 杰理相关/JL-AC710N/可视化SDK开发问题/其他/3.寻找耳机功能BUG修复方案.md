# 寻找耳机功能BUG修复方案

## 问题描述

### 现象
1. **双耳播放异常**：点击APP的"双耳播放"按钮时，有时候只有一只耳机播放提示音
2. **单耳播放失效**：点击"左耳播放"或"右耳播放"时，无法正确控制单耳播放
3. **播放位置不对**：看起来总是主机在播放，而不是根据APP指定的左右耳

### 确认
- APP传递的参数是正确的（从日志可以看出）
- 问题出在耳机端的代码逻辑

---

## 根本原因分析

### BUG 1: TWS连接时主机不播放提示音 🐛

**文件**: `SDK/apps/common/third_party_profile/jieli/rcsp/server/rcsp_cmd_recieve.c`
**行号**: 342-350

**问题代码**:
```c
// 300ms超时，发送对端同步执行
#if TCFG_USER_TWS_ENABLE
if (tws_api_get_tws_state() & TWS_STA_SIBLING_CONNECTED) {
    extern void find_device_sync(u8 * param, u32 msec);
    find_device_sync(other_opt, 300);
    return;  // ❌ BUG: 这里直接返回了！主机不会播放！
}
#endif

// 主机永远执行不到这里
JL_rcsp_event_to_user(DEVICE_EVENT_FROM_RCSP, MSG_JL_FIND_DEVICE_RESUME, other_opt, sizeof(other_opt));
```

**问题分析**:
1. 当TWS已连接时，代码调用 `find_device_sync` 同步参数给从机
2. 然后直接 `return`，不再继续执行
3. 导致主机不会发送 `MSG_JL_FIND_DEVICE_RESUME` 消息给自己
4. **结果**：只有从机播放，主机不播放

**执行流程**:
```
APP发送命令
    ↓
主机收到 (rcsp_cmd_recieve.c:find_device_handle)
    ↓
检测到TWS已连接
    ↓
调用 find_device_sync(other_opt, 300)  // 同步给从机
    ↓
return;  ❌ 主机直接返回，不播放
    ↓
从机收到同步消息 (adv_find_dev_sync_func_t)
    ↓
从机发送 MSG_JL_FIND_DEVICE_RESUME 给自己
    ↓
从机播放提示音 ✓
```

---

### BUG 2: 单耳播放逻辑错误 🐛

**文件**: `SDK/apps/common/third_party_profile/jieli/rcsp/server/rcsp_command.c`
**行号**: 238-286

**问题代码**:
```c
static void earphone_mute_timer_func(void *param) {
    u8 way = ((u8 *)param)[0];      // 0=双耳, 1=左耳, 2=右耳
    u8 player = ((u8 *)param)[1];   // 0=APP, 1=耳机

    // 首先取消所有声道静音
    earphone_mute('L', 0);
    earphone_mute('R', 0);

    #if TCFG_USER_TWS_ENABLE
    if (tws_api_get_tws_state() & TWS_STA_SIBLING_CONNECTED) {
        switch (way) {
            case 1:  // 仅左侧播放
                earphone_mute('R', 1);  // ❌ 只是静音右声道DAC，不影响播放
                break;
            case 2:  // 仅右侧播放
                earphone_mute('L', 1);  // ❌ 只是静音左声道DAC，不影响播放
                break;
        }
    }
    #endif

    switch (player) {
        case 1:
            bt_cmd_prepare(USER_CTRL_AVCTP_OPID_STOP, 0, NULL);

            // ❌ 问题：两个耳机都会执行播放，只是某个被静音了
            play_tone_file(get_tone_files()->_TONE_APP_FIND_EAR_NAME);

            earphone_mute_handler(param, _TONE_FIND_EAR_REPEAT_TIME);
            break;
    }
}
```

**问题分析**:
1. `earphone_mute('L', 1)` 只是在**DAC硬件层面**静音左声道
2. 不影响音频数据的处理和路由
3. **两个耳机都会执行** `play_tone_file` 播放提示音
4. 只是某个耳机的DAC输出被静音，用户听不到而已
5. **音频资源仍在消耗，逻辑错误**

**正确的做法**:
- 应该根据 `way` 参数和本机的左右声道身份，决定**是否播放提示音**
- 而不是都播放，然后靠静音来"屏蔽"

---

### BUG 3: 缺少左右声道身份判断 🐛

**文件**: `SDK/apps/common/third_party_profile/jieli/rcsp/server/rcsp_cmd_recieve.c`
**行号**: 230

**问题代码**:
```c
extern char bt_tws_get_local_channel();  // ❌ 声明了但从未使用！
extern int tws_api_get_role(void);
```

**问题分析**:
1. `bt_tws_get_local_channel()` 函数可以返回当前耳机的声道身份（'L' 或 'R'）
2. 代码中声明了这个函数，但从未调用
3. 导致无法根据 `way` 参数和本机声道身份，正确判断是否应该播放

**应该的逻辑**:
```c
char local_channel = bt_tws_get_local_channel();  // 获取本机声道 'L' 或 'R'
u8 way = param[0];  // 0=双耳, 1=左耳, 2=右耳

bool should_play = false;

if (way == 0) {
    // 双耳播放
    should_play = true;
} else if (way == 1 && local_channel == 'L') {
    // 只播放左耳，且本机是左耳
    should_play = true;
} else if (way == 2 && local_channel == 'R') {
    // 只播放右耳，且本机是右耳
    should_play = true;
}

if (should_play) {
    play_tone_file(...);
}
```

---

## 完整修复方案

### 修复 1: 让主机也播放提示音

**文件**: `SDK/apps/common/third_party_profile/jieli/rcsp/server/rcsp_cmd_recieve.c`
**行号**: 340-350

**修改前**:
```c
// 300ms超时，发送对端同步执行
#if TCFG_USER_TWS_ENABLE
if (tws_api_get_tws_state() & TWS_STA_SIBLING_CONNECTED) {
    extern void find_device_sync(u8 * param, u32 msec);
    find_device_sync(other_opt, 300);
    return;  // ❌ 直接返回
}
#endif
JL_rcsp_event_to_user(DEVICE_EVENT_FROM_RCSP, MSG_JL_FIND_DEVICE_RESUME, other_opt, sizeof(other_opt));
```

**修改后**:
```c
// 300ms超时，发送对端同步执行
#if TCFG_USER_TWS_ENABLE
if (tws_api_get_tws_state() & TWS_STA_SIBLING_CONNECTED) {
    extern void find_device_sync(u8 * param, u32 msec);
    find_device_sync(other_opt, 300);
    // ✅ 移除 return，让主机也播放
}
#endif
// ✅ 主机和从机都会执行到这里
JL_rcsp_event_to_user(DEVICE_EVENT_FROM_RCSP, MSG_JL_FIND_DEVICE_RESUME, other_opt, sizeof(other_opt));
```

**效果**:
- 主机调用 `find_device_sync` 同步参数给从机
- 主机继续执行，发送 `MSG_JL_FIND_DEVICE_RESUME` 给自己
- **主从耳机都会播放提示音**

---

### 修复 2: 正确实现单耳播放逻辑

**文件**: `SDK/apps/common/third_party_profile/jieli/rcsp/server/rcsp_command.c`
**行号**: 193-286

**修改前**:
```c
static void earphone_mute_timer_func(void *param) {
    u8 way = ((u8 *)param)[0];
    u8 player = ((u8 *)param)[1];

    earphone_mute('L', 0);
    earphone_mute('R', 0);

    #if TCFG_USER_TWS_ENABLE
    if (tws_api_get_tws_state() & TWS_STA_SIBLING_CONNECTED) {
        switch (way) {
            case 1:
                earphone_mute('R', 1);  // ❌ 静音方式错误
                break;
            case 2:
                earphone_mute('L', 1);
                break;
        }
    }
    #endif

    switch (player) {
        case 1:
            bt_cmd_prepare(USER_CTRL_AVCTP_OPID_STOP, 0, NULL);
            play_tone_file(get_tone_files()->_TONE_APP_FIND_EAR_NAME);  // ❌ 两个都播放
            earphone_mute_handler(param, _TONE_FIND_EAR_REPEAT_TIME);
            break;
    }
}
```

**修改后**:
```c
static void earphone_mute_timer_func(void *param) {
    u8 way = ((u8 *)param)[0];      // 0=双耳, 1=左耳, 2=右耳
    u8 player = ((u8 *)param)[1];   // 0=APP, 1=耳机

    // ✅ 首先判断本机是否应该播放
    bool should_play = true;

    #if TCFG_USER_TWS_ENABLE
    if (tws_api_get_tws_state() & TWS_STA_SIBLING_CONNECTED) {
        extern char bt_tws_get_local_channel();  // 获取本机声道
        char local_channel = bt_tws_get_local_channel();  // 'L' 或 'R'

        printf("rcsp_find local_channel=%c, way=%d\n", local_channel, way);

        if (way == 1 && local_channel == 'R') {
            // APP要求只播放左耳，但本机是右耳
            should_play = false;
        } else if (way == 2 && local_channel == 'L') {
            // APP要求只播放右耳，但本机是左耳
            should_play = false;
        }
        // way == 0 时，双耳都播放，should_play = true
    }
    #endif

    // ✅ 取消声道静音（不再需要静音控制）
    earphone_mute('L', 0);
    earphone_mute('R', 0);

    printf("rcsp_find should_play=%d, way:%d, player:%d\n", should_play, way, player);

    switch (player) {
        case 0:
            // APP端播放，设备端不播放
            tone_player_stop();
            break;

        case 1:
            // 设备端播放
            if (should_play) {
                // ✅ 只有应该播放的耳机才执行播放
                bt_cmd_prepare(USER_CTRL_AVCTP_OPID_STOP, 0, NULL);
                printf("bt_cmd_prepare(USER_CTRL_AVCTP_OPID_STOP, 0, NULL);----app_find_ear\n");
                play_tone_file(get_tone_files()->_TONE_APP_FIND_EAR_NAME);
                earphone_mute_handler(param, _TONE_FIND_EAR_REPEAT_TIME);
            } else {
                // ✅ 不应该播放的耳机停止播放
                printf("rcsp_find this earphone should not play, stop tone\n");
                tone_player_stop();
            }
            break;
    }
}
```

**效果**:
- 根据 `way` 参数和本机声道身份，判断是否应该播放
- **只有应该播放的耳机才执行 `play_tone_file`**
- 不需要的耳机直接停止播放，不浪费资源

---

## 修改步骤

### 步骤 1: 修改 rcsp_cmd_recieve.c

打开文件：`SDK/apps/common/third_party_profile/jieli/rcsp/server/rcsp_cmd_recieve.c`

找到第 340-350 行，修改如下：

```c
// 原代码（删除）:
#if TCFG_USER_TWS_ENABLE
if (tws_api_get_tws_state() & TWS_STA_SIBLING_CONNECTED) {
    extern void find_device_sync(u8 * param, u32 msec);
    find_device_sync(other_opt, 300);
    return;  // ❌ 删除这个 return
}
#endif

// 修改为：
#if TCFG_USER_TWS_ENABLE
if (tws_api_get_tws_state() & TWS_STA_SIBLING_CONNECTED) {
    extern void find_device_sync(u8 * param, u32 msec);
    find_device_sync(other_opt, 300);
    // ✅ 移除 return，继续执行
}
#endif
JL_rcsp_event_to_user(DEVICE_EVENT_FROM_RCSP, MSG_JL_FIND_DEVICE_RESUME, other_opt, sizeof(other_opt));
```

### 步骤 2: 修改 rcsp_command.c

打开文件：`SDK/apps/common/third_party_profile/jieli/rcsp/server/rcsp_command.c`

找到第 193-286 行的 `earphone_mute_timer_func` 函数，完整替换为：

```c
static void earphone_mute_timer_func(void *param)
{
    u8 way = ((u8 *)param)[0];      // 播放方式: 0=双耳, 1=左耳, 2=右耳
    u8 player = ((u8 *)param)[1];   // 播放设备: 0=APP, 1=耳机

    // ✅ 首先判断本机是否应该播放
    bool should_play = true;

#if TCFG_USER_TWS_ENABLE
    if (tws_api_get_tws_state() & TWS_STA_SIBLING_CONNECTED) {
        extern char bt_tws_get_local_channel();  // 获取本机声道
        char local_channel = bt_tws_get_local_channel();  // 'L' 或 'R'

        printf("rcsp_find local_channel=%c, way=%d\n", local_channel, way);

        if (way == 1 && local_channel == 'R') {
            // APP要求只播放左耳，但本机是右耳
            should_play = false;
        } else if (way == 2 && local_channel == 'L') {
            // APP要求只播放右耳，但本机是左耳
            should_play = false;
        }
        // way == 0 时，双耳都播放，should_play = true
    }
#endif

    // ✅ 取消声道静音
    earphone_mute('L', 0);
    earphone_mute('R', 0);

    printf("rcsp_find %s, %s, %d, should_play=%d, way:%d, player:%d\n",
           __FILE__, __FUNCTION__, __LINE__, should_play, way, player);

    switch (player) {
    case 0:
        // APP端播放，设备端不播放
        tone_player_stop();
        break;

    case 1:
        // 设备端播放
        if (should_play) {
            // ✅ 只有应该播放的耳机才执行播放

            // 先暂停正在播放的音乐，避免被覆盖
            bt_cmd_prepare(USER_CTRL_AVCTP_OPID_STOP, 0, NULL);
            printf("bt_cmd_prepare(USER_CTRL_AVCTP_OPID_STOP, 0, NULL);----app_find_ear\n");

            // 播放"寻找耳机"提示音
            play_tone_file(get_tone_files()->_TONE_APP_FIND_EAR_NAME);

            // 递归调用，实现重复播放（每300ms重复一次）
            earphone_mute_handler(param, _TONE_FIND_EAR_REPEAT_TIME);
        } else {
            // ✅ 不应该播放的耳机停止播放
            printf("rcsp_find this earphone should not play, stop tone\n");
            tone_player_stop();
        }
        break;
    }
}
```

### 步骤 3: 重新编译

```bash
cd SDK
make clean
make
```

### 步骤 4: 下载固件测试

1. 将生成的 `jl_isd.bin` 下载到设备
2. 测试以下场景：
   - **双耳播放**：应该两只耳机都播放提示音
   - **左耳播放**：应该只有左耳播放提示音
   - **右耳播放**：应该只有右耳播放提示音

---

## 测试验证

### 测试用例 1: 双耳播放

**操作**: APP点击"双耳播放"

**预期日志**:
```
主机：
[rcsp_find] local_channel=L, way=0
[rcsp_find] should_play=1, way:0, player:1
[bt_cmd_prepare] USER_CTRL_AVCTP_OPID_STOP
[tone_player] tone_en/find_ear.*

从机：
[rcsp_find] local_channel=R, way=0
[rcsp_find] should_play=1, way:0, player:1
[bt_cmd_prepare] USER_CTRL_AVCTP_OPID_STOP
[tone_player] tone_en/find_ear.*
```

**预期结果**: ✅ 两只耳机都播放提示音

---

### 测试用例 2: 左耳播放

**操作**: APP点击"左耳播放"

**预期日志**:
```
主机（左耳）：
[rcsp_find] local_channel=L, way=1
[rcsp_find] should_play=1, way:1, player:1
[bt_cmd_prepare] USER_CTRL_AVCTP_OPID_STOP
[tone_player] tone_en/find_ear.*

从机（右耳）：
[rcsp_find] local_channel=R, way=1
[rcsp_find] should_play=0, way:1, player:1
[rcsp_find] this earphone should not play, stop tone
```

**预期结果**: ✅ 只有左耳播放提示音

---

### 测试用例 3: 右耳播放

**操作**: APP点击"右耳播放"

**预期日志**:
```
主机（左耳）：
[rcsp_find] local_channel=L, way=2
[rcsp_find] should_play=0, way:2, player:1
[rcsp_find] this earphone should not play, stop tone

从机（右耳）：
[rcsp_find] local_channel=R, way=2
[rcsp_find] should_play=1, way:2, player:1
[bt_cmd_prepare] USER_CTRL_AVCTP_OPID_STOP
[tone_player] tone_en/find_ear.*
```

**预期结果**: ✅ 只有右耳播放提示音

---

## 注意事项

### ⚠️ 重要提醒

1. **bt_tws_get_local_channel() 函数**
   - 这个函数在代码中被声明为 `extern`
   - 需要确认它在其他文件中有实现
   - 如果没有实现，需要查找类似功能的函数替代

2. **主从角色判断**
   - 修改后，主机和从机都会播放（双耳模式）
   - 确保 TWS 同步机制正常工作

3. **编译警告**
   - 可能会有 `bool` 类型的编译警告
   - 如果项目不支持 `bool`，改用 `u8` 类型：
     ```c
     u8 should_play = 1;  // 1=true, 0=false
     ```

4. **调试日志**
   - 修改后的代码增加了调试日志
   - 方便排查问题
   - 生产环境可以删除或用条件编译控制

---

## 预期效果对比

### 修改前

| 场景 | 实际表现 | 问题 |
|-----|---------|------|
| 双耳播放 | 有时只有一只播放 | 主机不播放 ❌ |
| 左耳播放 | 两只都播放，一只静音 | 逻辑错误 ❌ |
| 右耳播放 | 两只都播放，一只静音 | 逻辑错误 ❌ |

### 修改后

| 场景 | 预期表现 | 状态 |
|-----|---------|------|
| 双耳播放 | 两只耳机都播放 | 正常 ✅ |
| 左耳播放 | 只有左耳播放 | 正常 ✅ |
| 右耳播放 | 只有右耳播放 | 正常 ✅ |

---

## 总结

### 问题根源
1. TWS连接时，主机直接 `return` 不播放
2. 使用 DAC 静音代替播放控制，逻辑错误
3. 没有使用声道身份判断函数

### 修复要点
1. 移除 `return`，让主机也发送播放消息
2. 根据 way 参数和本机声道，决定是否播放
3. 使用 `bt_tws_get_local_channel()` 获取声道身份

### 修改文件
1. `SDK/apps/common/third_party_profile/jieli/rcsp/server/rcsp_cmd_recieve.c` (删除1行)
2. `SDK/apps/common/third_party_profile/jieli/rcsp/server/rcsp_command.c` (重写函数)

### 验证方法
- 编译、下载、测试三种场景
- 查看日志确认逻辑正确
- 实际听音确认效果

---

**文档版本**: v1.0
**创建日期**: 2025-12-11
**作者**: Claude Code
**SDK版本**: AC710N v3.0.0 patch_06
