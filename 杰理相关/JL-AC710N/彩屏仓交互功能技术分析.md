# 彩屏仓交互功能技术分析报告

## 版本信息
- **提交版本**: 553d35d (2025年4月2日)
- **提交描述**: "通信正常，完成基本播放暂停音量音乐状态同步功能"
- **分析日期**: 2025年9月9日

## 功能概述

本次更新为杰理AC710N耳机项目增加了与彩屏仓（Smart Box）的双向通信功能，实现了耳机状态的实时同步和远程控制能力。

## 核心架构变更

### 1. 新增模块结构

```
SDK/apps/common/third_party_profile/jl_earbox/
├── sbox_core_config.h/.c    # 核心配置和缓冲区管理
├── sbox_protocol.h/.c       # BLE协议定义和底层通信
├── sbox_user_app.h/.c       # 用户应用层接口
├── sbox_uart_app.c          # 串口通信支持（与982芯片通信）
└── sbox_core_code.c         # 协议核心处理逻辑
```

### 2. 配置系统集成

在`app_config.h`中新增彩屏仓支持：
```c
#define JL_SBOX_EN (1 << 31)
#define THIRD_PARTY_PROTOCOLS_SEL (ONLINE_DEBUG_EN|JL_SBOX_EN)
```

## BLE协议扩展实现

### 1. 自定义BLE Service定义

基于标准BLE GATT协议，新增了专用的彩屏仓通信服务：

**Service UUID**: `0xAE00`

**主要特征值**：

- **0xAE01**: Write Without Response (彩屏仓→耳机命令)
- **0xAE02**: Notify (耳机→彩屏仓状态同步) 
- **0xAE98**: Write Without Response (扩展命令通道)
- **0xAE99**: Notify (扩展状态通道)

### 2. 协议栈层次结构

```
应用层    │ sbox_user_app.c (状态同步/命令处理)
协议层    │ sbox_protocol.c (BLE服务定义/连接管理)
传输层    │ sbox_core_code.c (数据包处理/缓冲管理)
配置层    │ sbox_core_config.c (参数配置/内存管理)
硬件层    │ sbox_uart_app.c (串口通信支持)
```

### 3. 数据传输机制

- **缓冲区大小**: 256字节（必须为16的倍数）
- **缓存机制**: 支持最大5包数据缓存 (SBOX_TR_BUF_LEN = 1360字节)
- **数据保护**: 采用CBUF循环缓冲区防止数据踩踏
- **传输方式**: BLE ATT Write Without Response + Notify

## 支持的功能命令

### 状态同步命令 (耳机→彩屏仓)幻觉

| 命令ID | 功能描述 | 实现函数 |
|--------|----------|----------|
| 0xFF | 同步所有状态信息 | `custom_sync_all_info_to_box()` |
| 0x01 | 经典蓝牙连接状态 | `custom_sync_bt_connect_state()` |
| 0x02 | BLE连接状态 | `custom_sync_ble_connect_state()` |
| 0x03 | 电池电量信息 | `custom_sync_vbat_percent_state()` |
| 0x04 | 音量信息 | `custom_sync_volume_state()` |
| 0x05 | 时间信息 | `custom_sync_time_info()` |
| 0x06 | EQ模式信息 | `custom_sync_eq_info_to_box()` |
| 0x07 | ANC降噪状态 | `custom_sync_anc_info_to_box()` |
| 0x08 | 通话状态 | `custom_sync_call_state()` |
| 0x09 | 通话记录信息 | `custom_sync_phone_call_info()` |
| 0x0A | 自定义按键设置 | `custom_sync_key_setting()` |

### 控制命令 (彩屏仓→耳机)

| 命令ID | 功能描述 | 支持状态 |
|--------|----------|----------|
| 0x32 | 音量控制 | ✅ 已实现 |
| 0x33 | 音乐播放控制 | ✅ 已实现 |
| 0x34 | ANC模式控制 | ✅ 已实现 |
| 0x35 | EQ模式控制 | ✅ 已实现 |
| 0x36 | 播放模式设置 | ✅ 已实现 |
| 0x37 | 闹钟设置 | 🔄 待实现 |
| 0x38 | 查找耳机 | 🔄 待实现 |
| 0x39 | 手电筒控制 | 🔄 待实现 |
| 0x40 | 语言切换 | 🔄 待实现 |
| 0x41 | 通话控制 | ✅ 已实现 |

## 与原有BLE协议的关系

### 扩展方式
1. **非侵入式扩展**: 保持原有BLE协议完整性，通过独立Service实现
2. **多协议共存**: 与RCSP、GFPS等其他协议并行运行
3. **资源共享**: 复用原有BLE协议栈的ATT层和连接管理

### 连接参数优化
```c
// 连接间隔优化表
static const struct conn_update_param_t connection_param_table[] = {
    {16, 24, 16, 600},  // 标准模式
    {12, 28, 14, 600},  // 平衡模式  
    {8,  20, 20, 600},  // 低延时模式
};

// iOS设备优化
{6, 12, 0, 400},  // iOS快速响应模式
```

## 数据结构设计

### 状态信息结构
```c
struct sbox_state_info {
    bool ble_conn_state;        // BLE连接状态
    bool bt_conn_state;         // 经典蓝牙连接状态
    bool ble_into_no_lantacy;   // 低延时模式
    bool phone_call_mute;       // 通话静音
    bool music_states;          // 音乐状态
    bool game_mode;             // 游戏模式
    u8 box_addr[6];            // 彩屏仓蓝牙地址
};
```

### 音乐信息结构
```c
struct custom_music_info {
    u16 time;                   // 播放时间
    u8 type_artist_name;        // 艺术家名称类型
    u8 name_len;               // 名称长度
    u8 type_album_name;        // 专辑名称类型
    u8 album_len;              // 专辑长度
    u8 type_title;             // 标题类型
    u8 title_len;              // 标题长度
    u8 artist_name[256];       // 艺术家名称
    u8 album_name[256];        // 专辑名称
    u8 title[256];             // 歌曲标题
};
```

## TWS对耳同步机制

实现了TWS对耳之间的状态同步：

```c
enum {
    SYNC_CMD_EQ_SWITCH_0,       // EQ模式同步
    SYNC_CMD_EQ_SWITCH_1,
    SYNC_CMD_ANC_ON,           // ANC开启同步
    SYNC_CMD_ANC_OFF,          // ANC关闭同步
    SYNC_CMD_VOLUME_UP,        // 音量增加同步
    SYNC_CMD_VOLUME_DOWN,      // 音量减少同步
    SYNC_CMD_CALL_MUTE,        // 通话静音同步
    SYNC_CMD_SBOX_POWER_OFF_TOGETHER, // 协同关机
};
```

## 集成点分析

### 1. 应用层集成
- **app_main.c**: 添加了`sbox_app_init()`初始化调用
- **vol_sync.c**: 音量同步时触发彩屏仓状态更新

### 2. 编译系统集成
- **Makefile**: 新增sbox相关源文件编译
- **工程配置**: 更新了项目配置文件以包含新模块

### 3. 配置文件更新
多个JSON配置文件得到更新以支持彩屏仓功能，特别是蓝牙配置和音频流程配置。

## 技术特点

### 优势
1. **模块化设计**: 清晰的分层架构，便于维护和扩展
2. **协议复用**: 充分利用现有BLE协议栈
3. **状态一致性**: 完善的TWS对耳同步机制
4. **低功耗优化**: 支持连接参数动态调整
5. **数据保护**: CBUF缓冲机制防止数据丢失

### 潜在挑战
1. **内存占用**: 新增约1.5KB缓冲区占用
2. **功能完整性**: 部分高级功能仍需完善
3. **兼容性测试**: 需要验证与不同彩屏仓型号的兼容性

## 总结

本次更新成功为杰理AC710N耳机添加了完整的彩屏仓交互能力，通过自定义BLE协议实现了双向通信。架构设计合理，基础功能完善，为后续功能扩展奠定了坚实基础。核心的播放控制、音量调节、状态同步等功能已经实现，可以满足基本的彩屏仓交互需求。

# `sbox_uart_app.c` 串口通信支持（与982芯片通信）

## 通信协议规范

耳机放入彩屏仓后，通过单线串口与982芯片进行通信，采用自定义协议格式：

```
协议格式: [包头(0xAA)] + [命令类型] + [数据] + [校验和]
- 包头: 0xAA (CMD_CUSTOM_DEAL)
- 命令类型: 1字节命令标识
- 数据: 可变长度数据
- 校验和: 累加和的低8位
```

## 主要通信功能

### 1. MAC地址交换

**982→耳机 (命令0x10)**：

```c
// 982发送请求MAC地址命令
[0xAA] + [0x10] + [校验和]
```

**耳机→982 (事件0x31)**：

```c
// 耳机响应发送MAC地址
Send_Mac(EARPHONE_MAC_MSG, bt_get_mac_addr(), 6);
数据包: [0xAA] + [0x31] + [6字节MAC地址] + [校验和]
```

**实现函数**：
```c
void Send_Mac(u8 event, u8 *addr, u8 len)
{
    unsigned char temp[9];
    temp[0] = CMD_CUSTOM_DEAL;    // 0xAA
    temp[1] = event;              // 0x31
    memcpy(&temp[2], addr, 6);    // MAC地址
    // 计算校验和
    u16 sum = 0;
    for(u8 i=0; i<8; i++) {
        sum += temp[i];
    }
    temp[8] = sum & 0xff;         // 校验和
    chargestore_api_write(temp, sizeof(temp));
}
```

### 2. 数据处理流程

**接收数据处理**：
```c
int user_app_chargestore_data_deal(u8 *buf, u8 len)
{
    switch (buf[0]) {
        case CMD_CUSTOM_DEAL:  // 0xAA
            // 校验和验证
            u16 sum = 0;
            for(u8 i=0; i<len-1; i++) {
                sum += buf[i];
            }
            if(buf[len-1] != (sum&0xFF)) {
                printf("err check\n");
                return 0;
            }
            
            switch (buf[1]) {  // 命令类型
                case 0x10:
                    // 收到MAC地址请求，发送本机MAC
                    Send_Mac(EARPHONE_MAC_MSG, bt_get_mac_addr(), 6);
                    break;
                // ... 其他命令处理
            }
            break;
    }
    return 0;
}
```

**数据接收处理函数在什么地方被调用**

`apps\earphone\tools\app_testbox.c`

```c
extern int user_app_chargestore_data_deal(u8 *buf, u8 len);
//数据执行函数,在串口中断调用
//当耳机对应引脚有高低电平时触发中断，在中断回调函数中会调用app_testbox_data_handler处理串口数据
static int app_testbox_data_handler(u8 *buf, u8 len)
{
    u8 send_buf[36];
    send_buf[0] = buf[0];
    //优先处理来自982的串口数据包
    user_app_chargestore_data_deal(buf,len);
    //数据包头不是0XAA的话就会尝试进入下面的case,如果都不是那就不处理
    switch (buf[0]) {
    case CMD_BOX_MODULE:
        app_testbox_sub_cmd_handle(send_buf, sizeof(send_buf), buf, len);
        break;

    case CMD_BOX_UPDATE:
        __this->testbox_status = 1;
        printf(">>>[test]:buf13 = 0x%x, chip_id = 0x%x\n", buf[13], get_jl_chip_id());
        if (buf[13] == 0xff || buf[13] == get_jl_chip_id() || buf[13] == get_jl_chip_id2()) {
            //进行串口升级流程
            //vm_flush2flash();时间处理较长，不能够在串口中断处做处理，需要发送到线程进行处理
#if (defined CONFIG_CPU_BR50) || (defined CONFIG_CPU_BR52) || (defined CONFIG_CPU_BR56) // 耳机目前仅支持br50\br52
            if (buf[15]) { // 存在新的升级流程
                send_buf[1] = 0xAA;//回复0xAA表示使用新的串口升级流程 uart_ota2.bin
                chargestore_api_write(send_buf, 2);
            }
#endif
            testbox_event_to_user(&buf[15], CMD_BOX_UPDATE, 1);
        } else if (buf[13] == 0xff) {
            //进行电量更新流程,需要及时回复
            send_buf[1] = 0xff;
            WRITE_LIT_U32(&send_buf[2], support_update_mask);
            chargestore_api_write(send_buf, 2 + sizeof(support_update_mask));
            log_info("rsp update_mask\n");
        } else {
            send_buf[1] = 0x01;//chip id err
            chargestore_api_write(send_buf, 2);
        }
        break;
    case CMD_BOX_TWS_CHANNEL_SEL:
        __this->testbox_status = 1;
        if (len == 3) {
            __this->keep_tws_conn_flag = buf[2];
            putchar('K');
        }  else {
            __this->keep_tws_conn_flag = 0;
        }
        __this->channel = (buf[1] == TWS_CHANNEL_LEFT) ? 'L' : 'R';
#ifdef UPDATE_VOICE_REMIND
        if (0 == __this->event_hdl_flag || app_var.update_tone_end_flag == 1) {
#else
        if (0 == __this->event_hdl_flag) {
#endif
            testbox_event_to_user(NULL, CMD_BOX_TWS_CHANNEL_SEL, 0);
            __this->event_hdl_flag = 1;
        }
        if (__this->bt_init_ok) {
            len = chargestore_get_tws_remote_info(&send_buf[1]);
            chargestore_api_write(send_buf, len + 1);
        } else {
            send_buf[0] = CMD_UNDEFINE;
            chargestore_api_write(send_buf, 1);
        }
        break;
#if TCFG_USER_TWS_ENABLE
    case CMD_BOX_TWS_REMOTE_ADDR:
        __this->testbox_status = 1;
        testbox_event_to_user((u8 *)&buf[1], buf[0], len - 1);
        chargestore_api_set_timeout(100);
        break;
#endif
    //不是测试盒命令,返回0,未处理
    default:
        return 0;
    }
    return 1;
}

CHARGESTORE_HANDLE_REG(testbox, app_testbox_data_handler);
```

### 3.串口发送数据函数

- `chargestore_api_write`

不一定都是向982发送的。还有向测试盒发送串口数据的场景。

# 彩屏仓的耳机电量来源

## 通过串口向充电仓（可能是982）发送电量信息

  **场景：耳机放入充电仓时的物理接触通信**

- `charge_store.c:789, 802`
- `app_chargestore_data_handler`

```c
static int app_chargestore_data_handler(u8 *buf, u8 len)
{
    //这里是充电仓发送过来的指令时对应的回复
    //发送耳机mac地址单独写在了一个模块中
    u8 send_buf[36];
    /* log_info_hexdump(buf, len); */
    chargestore_shutdown_reset();
    //取出数据包头，用于回复指令时使用相同数据包头
    //包头也是指令类型，不是0XAA就说明，终端不是彩屏仓的主控
    //可能就是普通充电仓中也可以向耳机发指令
    send_buf[0] = buf[0];
    
//......

  // 开盖时发送电量
  case CMD_POWER_LEVEL_OPEN:
      send_buf[1] = chargestore_get_vbat_percent();  // 电量百分比
      send_buf[2] = chargestore_get_det_level(__this->chip_type);
      chargestore_api_write(send_buf, 3);  // 通过串口发送给982

  // 合盖时发送电量
  case CMD_POWER_LEVEL_CLOSE:
      send_buf[1] = chargestore_get_vbat_percent();  // 电量百分比
      send_buf[2] = chargestore_get_det_level(__this->chip_type);
      chargestore_api_write(send_buf, 3);  // 通过串口发送给982
```

###   电量获取函数

```c
u8 chargestore_get_vbat_percent(void)
{
    u8 power;
#if CONFIG_DISPLAY_DETAIL_BAT
    power = get_vbat_percent();//显示个位数的电量
#else
    power = get_self_battery_level() * 10 + 10; //显示10%~100%
#endif

#if TCFG_CHARGE_ENABLE
    if (get_charge_full_flag()) {
        power = 100;
    } else if (power == 100) {
        power = 99;
    }
    if (get_charge_online_flag()) {
        power |= BIT(7);
    }
#endif
    return power;
}
```



## 通过BLE直接向彩屏仓主控发送电量信息

- **场景：耳机与彩屏仓BLE连接时的实时状态同步**

- 实现位置：`sbox_user_app.c:165`

```c
//同步耳机电量状态给仓
__attribute__((weak))
void custom_sync_vbat_percent_state(void)
{
    u8 bat_state[3];
    u8 channel = tws_api_get_local_channel();

    // byte0:L耳机电量---- byte1：R耳机电量
    if ('L' == channel) {
        bat_state[0] = 10*(battery_value_to_phone_level()+1);//get_vbat_percent();
        bat_state[1] = get_tws_sibling_bat_persent();
    } else if ('R' == channel) {
        bat_state[0] = get_tws_sibling_bat_persent();
        bat_state[1] = 10*(battery_value_to_phone_level()+1);//get_vbat_percent();
    }else {
        bat_state[0] = 10*(battery_value_to_phone_level()+1);//get_vbat_percent();
        bat_state[1] = 0xff;
    }
    bat_state[2]=bt_get_total_connect_dev(); 
    
    log_info("sscustom_sync_vbat_percent_state bat_states:%x, vbat_percent:%d, tws_vbat_percent:%d", bat_state, get_vbat_percent(), get_tws_sibling_bat_persent());
    sbox_ble_att_send_data(CUSTOM_BLE_BATTERY_STATE_CMD, bat_state, sizeof(bat_state)); //将当前电量状态回复给手表
}
```

  两种方式的差异对比

| 项目     | 串口通信(→982)             | BLE通信(→彩屏仓主控)              |
| -------- | -------------------------- | --------------------------------- |
| 触发时机 | 开盖/合盖物理动作          | 实时状态变化时                    |
| 数据内容 | 单耳机电量+充电状态        | 双耳电量+连接状态                 |
| 传输方式 | chargestore_api_write()    | sbox_ble_att_send_data()          |
| 命令ID   | CMD_POWER_LEVEL_OPEN/CLOSE | CUSTOM_BLE_BATTERY_STATE_CMD(0x3) |
| 电量格式 | 10%-100%+充电标志位        | 左右耳独立电量值                  |
| 用途     | 基础电量同步给充电仓       | 彩屏实时显示电量状态              |

  实际工作流程

  1. 入仓时：

    - 物理接触触发→串口发送电量给982→982转发给彩屏仓主控
  2. BLE连接后：

    - 电量变化触发→直接BLE发送给彩屏仓主控→彩屏实时更新显示
  3. 出仓时：

    - 物理断开触发→串口发送最终电量给982→断开BLE连接

  耳机SDK采用了双通道电量同步机制：
  - 串口通道：负责基础的电量信息交换，确保充电仓了解耳机电量状态
  - BLE通道：负责实时的电量状态显示，支持彩屏仓的动态电量显示功能

  这种设计既保证了基本功能的可靠性（串口物理连接），又提供了丰富的用户体验（BLE实时显示）。

### BLE回调同步电量函数时机

```c
struct s_box_app_cb sbox_cb_func = {
    .sbox_sync_battery_info = custom_sync_vbat_percent_state,
};
static int sbox_app_power_event_handler(int *msg)
{
    //这个处理函数注册进系统了
    //当耳机有MSG_FROM_BATTERY类型信息时，应该会调用。
    //从而通过BLE同步到彩屏仓
    switch (msg[0]) {
    case POWER_EVENT_SYNC_TWS_VBAT_LEVEL:
        printf("POWER_EVENT_SYNC_TWS_VBAT_LEVEL----update sbox bat");
        sbox_cb_func.sbox_sync_battery_info();
        break;
    case POWER_EVENT_POWER_CHANGE:
        printf("POWER_EVENT_POWER_CHANGE----update sbox bat");
        sbox_cb_func.sbox_sync_battery_info();
        break;
    }
    return 0;
}

APP_MSG_HANDLER(sbox_level_msg_entry) = {
    .owner      = 0xff,
    .from       = MSG_FROM_BATTERY,
    .handler    = sbox_app_power_event_handler,
};
```

### 总结

可以在仓获取耳机电量时加打印说明电量来源，就知道到底是耳机BLE发送的还是982中转过来的。

