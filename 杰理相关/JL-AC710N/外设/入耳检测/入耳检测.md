# 入耳检测功能详细分析

## 目录

1. [功能概述](#功能概述)
2. [系统架构](#系统架构)
3. [配置说明](#配置说明)
4. [文件结构与作用](#文件结构与作用)
5. [初始化流程](#初始化流程)
6. [检测流程](#检测流程)
7. [事件处理流程](#事件处理流程)
8. [TWS同步机制](#tws同步机制)
9. [功能交互](#功能交互)
10. [开发指南](#开发指南)

---

## 功能概述

入耳检测功能通过外部元器件（触摸传感器或红外传感器）实现对耳机佩戴状态的检测，当检测到耳机入耳或出耳时，系统会自动执行相应的控制操作。

### 工作原理

通过一个外部元器件实现入耳检测，耳机端只需要检测结果即可。例如检测 PC2 的高低电平来判定是否入耳然后做对应的处理。

### 支持的检测类型

项目支持两种入耳检测方式：

1. **触摸式入耳检测（EAR_DETECT_BY_TOUCH）**
   - 基于触摸传感器
   - 检测触摸电容变化

2. **红外式入耳检测（EAR_DETECT_BY_IR）**
   - 基于红外传感器
   - 支持 IO 电平检测模式
   - 支持 AD 模拟量检测模式

**注意：两种检测方式在处理上没有区别，都是根据检测结果处理。**

---

## 系统架构

### 模块层次

```
┌─────────────────────────────────────────────────────┐
│              应用层 (BT Mode)                        │
│    - 音乐播放控制                                     │
│    - 通话链路控制                                     │
│    - 按键使能控制                                     │
│    - 主从切换控制                                     │
└──────────────────┬──────────────────────────────────┘
                   │ MSG_FROM_IN_EAR
┌──────────────────┴──────────────────────────────────┐
│         管理层 (in_ear_manage)                        │
│    - 状态管理                                         │
│    - 事件分发                                         │
│    - TWS 同步                                         │
│    - 音乐控制逻辑                                     │
│    - 通话控制逻辑                                     │
└──────────────────┬──────────────────────────────────┘
                   │
┌──────────────────┴──────────────────────────────────┐
│        驱动层 (in_ear_detect)                         │
│    - IR 检测驱动                                      │
│    - Touch 检测驱动                                   │
│    - GPIO 配置                                        │
│    - 定时器管理                                       │
└─────────────────────────────────────────────────────┘
```

### 消息流转

```
硬件检测 → 状态改变 → 事件产生 → TWS 同步 → 事件处理 → 功能控制
```

---

## 配置说明

### 板级配置文件

位置：`SDK/apps/earphone/board/br52/board_jl709n_demo_cfg.h`

#### 基本配置

```c
//*********************************************************************************//
//                                 外置入耳检测                                     //
//*********************************************************************************//
#define TCFG_EAR_DETECT_ENABLE                  ENABLE_THIS_MOUDLE         // 入耳检测使能
#define DEVICE_EVENT_FROM_EAR_DETECT            (('E' << 24) | ('A' << 16) | ('R' << 8) | '\0')

/* 检测类型选择 */
#define TCFG_EAR_DETECT_TYPE                    EAR_DETECT_BY_IR           // EAR_DETECT_BY_TOUCH 或 EAR_DETECT_BY_IR
```

#### 触摸检测配置

```c
// TOUCH 配置
#define TCFG_EAR_DETECT_DET_IO                  IO_PORTB_02                // 检测引脚
#define TCFG_EAR_DETECT_TOUCH_MODE              0                          // 0:触发检测  1:timer检测
```

#### 红外检测配置

```c
// IR 电源控制
#define TCFG_EAR_DET_IR_POWER_IO                NO_CONFIG_PORT             // 入耳红外电源IO

// IR 控制引脚
#define TCFG_EAR_DETECT_IRO1                    IO_PORTC_03                // 红外发射控制IO
#define TCFG_EAR_DETECT_IRO1_LEVEL              0                          // IRO1工作电平选择

// IR 检测引脚
#define TCFG_EAR_DETECT_IRO2                    IO_PORTC_04                // 红外接收检测IO
#define TCFG_EAR_DETECT_IR_MODE                 0                          // 0:IO检测  1:AD检测

// IR AD 检测配置（仅在 IR_MODE=1 时有效）
#define TCFG_EAR_DETECT_AD_CH                   NO_CONFIG_PORT             // AD检测通道
#define TCFG_EAR_DETECT_AD_VALUE                60                         // AD阈值
```

##### 原理

- 红外传感器实现入耳检测的原理？需要三个IO脚？一个电源，一个发射脚，一个接收脚？

**工作原理：** 红外入耳检测采用反射式光电传感器原理。当耳机佩戴入耳时，红外发射管发出的红外光会被耳道皮肤/耳廓反射回来，接收管接收到反射光信号，从而判断耳机处于"入耳"状态。当耳机取出时，没有反射物体，接收管接收不到或接收到很弱的信号，判断为"离耳"状态。

**VCC（电源脚）**：为红外发射管和接收管供电，通常是3.3V或其他工作电压

**IR_TX（发射控制脚）**：控制红外发射管的开关，主控芯片通过这个IO控制发射管发射红外光。可以PWM调制也可以简单的开关控制

**IR_RX（接收检测脚）**：连接红外接收管（光敏三极管/光敏二极管），主控通过读取这个IO的电平变化或ADC值来判断是否有反射光，从而判断入耳状态

- 有些集成度高的传感器模块可能只需要2个IO（一个使能控制+一个数据输出）

- 也有使用I2C接口的数字传感器，只需要SDA和SCL两根信号线

- 为了省电，发射管通常不是持续发射，而是间歇性检测（如每秒检测几次）

##### 发射引脚的工作电平与入耳检测有效电平的区别

**核心结论：这两个配置项完全独立，由不同的硬件电路设计决定，没有直接关联。**

---

###### 1. 发射引脚工作电平 (TCFG_EAR_DETECT_IRO1_LEVEL)

**作用：控制红外发射管的使能方式**

```c
#define TCFG_EAR_DETECT_IRO1_LEVEL     0    // IRO1工作电平选择
```

**工作原理：**

- **配置为 0**：发射管**低电平有效**，拉低 IRO1 时红外发射管工作(发射红外光)
- **配置为 1**：发射管**高电平有效**，拉高 IRO1 时红外发射管工作(发射红外光)

**代码实现验证：**

```c
// in_ear_detect.c 第103-123行
static void __ear_detect_ir_run(void *priv)
{
    if (__this->check_status == DETECT_IDLE) {
        // ========== 进入检测阶段 ==========
        __this->check_status = DETECT_CHECKING;

        // 开启红外发射
        gpio_set_mode(IO_PORT_SPILT(TCFG_EAR_DETECT_IRO1), PORT_OUTPUT_LOW);

        sys_hi_timer_modify(__this->s_hi_timer, __this->cfg->ear_det_ir_enable_time);
        return;
    }

    // ... 检测逻辑 ...

    // ========== 回到休眠阶段 ==========
    __this->check_status = DETECT_IDLE;

    // 关闭红外发射
    gpio_set_mode(IO_PORT_SPILT(TCFG_EAR_DETECT_IRO1), PORT_OUTPUT_HIGH);

    sys_hi_timer_modify(__this->s_hi_timer, __this->cfg->ear_det_ir_disable_time);
}
```

**硬件决定因素：**

取决于红外发射电路的接法：

```
方案A (低电平有效，LEVEL=0):
    VCC ──┬─ 限流电阻 ─ 红外发射管正极
          │
    IRO1 ─┴─ 红外发射管负极

    当 IRO1=低电平时，形成电流回路，发射管工作

方案B (高电平有效，LEVEL=1):
    IRO1 ──┬─ 限流电阻 ─ 红外发射管正极
           │
    GND  ──┴─ 红外发射管负极

    当 IRO1=高电平时，形成电流回路，发射管工作
```

**当前项目配置：**

```c
#define TCFG_EAR_DETECT_IRO1_LEVEL     0    // 低电平工作
```

- 休眠时：`PORT_OUTPUT_HIGH` → 关闭发射
- 检测时：`PORT_OUTPUT_LOW` → 开启发射

---

###### 2. 入耳检测有效电平 (TCFG_EAR_DETECT_DET_LEVEL)

**作用：定义接收引脚的入耳判断标准**

```c
#define TCFG_EAR_DETECT_DET_LEVEL      1    // 入耳检测电平
```

**工作原理：**

- **配置为 0**：接收引脚**低电平表示入耳**，读到低电平判断为入耳状态
- **配置为 1**：接收引脚**高电平表示入耳**，读到高电平判断为入耳状态

**代码实现验证：**

```c
// in_ear_detect.c 第125-164行
static void __ear_detect_ir_run(void *priv)
{
    // ... 省略检测准备代码 ...

    #if (!TCFG_EAR_DETECT_IR_MODE)
        // IO 检测模式
        if (gpio_read(TCFG_EAR_DETECT_IRO2) == TCFG_EAR_DETECT_DET_LEVEL) {
            // ========== 入耳处理 ==========
            putchar('i');
            __this->out_cnt = 0;

            if (__this->in_cnt < __this->cfg->ear_det_in_cnt) {
                __this->is_idle = 0;
                __this->in_cnt++;

                if (__this->in_cnt == __this->cfg->ear_det_in_cnt) {
                    log_info("earphone ir in\n");
                    __this->is_idle = 1;
                    ear_detect_change_state_to_event(TCFG_EAR_DETECT_DET_LEVEL);
                }
            }
        } else {
            // ========== 出耳处理 ==========
            putchar('o');
            __this->in_cnt = 0;

            if (__this->out_cnt < __this->cfg->ear_det_out_cnt) {
                __this->is_idle = 0;
                __this->out_cnt++;

                if (__this->out_cnt == __this->cfg->ear_det_out_cnt) {
                    log_info("earphone ir out\n");
                    __this->is_idle = 1;
                    ear_detect_change_state_to_event(!TCFG_EAR_DETECT_DET_LEVEL);
                }
            }
        }
    #endif
}
```

**硬件决定因素：**

取决于红外接收电路的设计：

```
方案A (高电平表示入耳，LEVEL=1):
    VCC ──┬─ 上拉电阻
          │
    IRO2 ─┼─ 光敏三极管集电极
          │
          └─ 光敏三极管发射极 ─ GND

    有反射光时：光敏三极管导通，IRO2 被拉低 → 低电平(离耳)
    无反射光时：光敏三极管截止，IRO2 被上拉 → 高电平(入耳)
    配置：TCFG_EAR_DETECT_DET_LEVEL = 1

方案B (低电平表示入耳，LEVEL=0):
    IRO2 ─┬─ 光敏三极管集电极
          │
          └─ 光敏三极管发射极 ─ 下拉电阻 ─ GND

    有反射光时：光敏三极管导通，IRO2 被拉高 → 高电平(离耳)
    无反射光时：光敏三极管截止，IRO2 被下拉 → 低电平(入耳)
    配置：TCFG_EAR_DETECT_DET_LEVEL = 0
```

**注意：** 反射式红外传感器通常是"入耳时有反射光"，但根据光敏元件类型(三极管/二极管)和外围电路设计的不同，最终的电平表现可能完全相反！

**当前项目配置：**

```c
#define TCFG_EAR_DETECT_DET_LEVEL      1    // 高电平入耳
```

- `gpio_read(IRO2) == 1` → 判断为入耳
- `gpio_read(IRO2) == 0` → 判断为离耳

---

###### 3. 两者的独立性验证

**配置对比：**

| 配置项 | 值 | 含义 | 控制对象 |
|--------|-----|------|----------|
| TCFG_EAR_DETECT_IRO1_LEVEL | 0 | 低电平使能发射 | 发射管工作时序 |
| TCFG_EAR_DETECT_DET_LEVEL | 1 | 高电平表示入耳 | 接收管判断逻辑 |

**完全独立的原因：**

1. **时序独立**：
   - IRO1 是周期性切换的(2ms开启 → 300ms关闭)，发射脚
   - IRO2 是持续采样的(在 IRO1 开启时读取)，接收脚

2. **电路独立**：
   - IRO1 连接发射管电路(输出)
   - IRO2 连接接收管电路(输入)

3. **逻辑独立**：
   - IRO1_LEVEL 决定"如何控制发射"
   - DET_LEVEL 决定"如何判断结果"

**实际使用场景：**

```
场景1: 低电平发射 + 高电平入耳
    TCFG_EAR_DETECT_IRO1_LEVEL = 0
    TCFG_EAR_DETECT_DET_LEVEL = 1
    (当前项目使用)

场景2: 高电平发射 + 低电平入耳
    TCFG_EAR_DETECT_IRO1_LEVEL = 1
    TCFG_EAR_DETECT_DET_LEVEL = 0

场景3: 低电平发射 + 低电平入耳
    TCFG_EAR_DETECT_IRO1_LEVEL = 0
    TCFG_EAR_DETECT_DET_LEVEL = 0

场景4: 高电平发射 + 高电平入耳
    TCFG_EAR_DETECT_IRO1_LEVEL = 1
    TCFG_EAR_DETECT_DET_LEVEL = 1
```

所有组合都是合法的，具体使用哪种完全由**硬件电路设计**决定。

---

###### 4. 如何确定正确的配置

**步骤1：查看硬件原理图**

- 确认 IRO1 是高侧驱动还是低侧驱动
- 确认 IRO2 接收电路的上拉/下拉配置

**步骤2：万用表测试**

```bash
测试发射管工作电平：
1. 将 IRO1 接 GND，测量发射管是否发光(用手机摄像头可见)
2. 将 IRO1 接 VCC，测量发射管是否发光
   → 发光时的电平即为工作电平

测试接收管有效电平：
1. 用手遮挡传感器(模拟入耳)，测量 IRO2 电平
2. 移开手(模拟离耳)，测量 IRO2 电平
   → 入耳时的电平即为检测有效电平
```

**步骤3：固件调试验证**

```c
// 添加调试代码到 __ear_detect_ir_run()
log_info("IRO2 level: %d, expect: %d\n",
    gpio_read(TCFG_EAR_DETECT_IRO2),
    TCFG_EAR_DETECT_DET_LEVEL);
```

- 入耳时，两个值应该相等
- 离耳时，两个值应该相反

---

###### 5. 配置错误的表现

**错误1：IRO1_LEVEL 配置反了**

```
现象：红外发射管一直不工作，或一直工作(功耗异常高)
原因：使能电平错误，发射管无法正常开关
解决：将 TCFG_EAR_DETECT_IRO1_LEVEL 取反
```

**错误2：DET_LEVEL 配置反了**

```
现象：入耳时判断为离耳，离耳时判断为入耳(逻辑完全颠倒)
原因：检测电平配置与实际硬件电平相反
解决：将 TCFG_EAR_DETECT_DET_LEVEL 取反
```

**错误3：两者都配置反了**

```
现象：发射管不工作，且检测逻辑反转
解决：同时修正两个配置
```

---

###### 6. 总结

| 特性 | IRO1_LEVEL (发射) | DET_LEVEL (检测) |
|------|-------------------|------------------|
| **作用对象** | 红外发射管(输出) | 红外接收管(输入) |
| **控制内容** | 什么电平使能发射 | 什么电平判断入耳 |
| **使用时机** | 周期性切换(2ms/300ms) | 检测时采样 |
| **决定因素** | 发射电路接法 | 接收电路接法 |
| **配置依据** | 硬件原理图 | 硬件原理图 |
| **相互关系** | **完全独立，无关联** | **完全独立，无关联** |

**关键要点：**

1. 两者由不同的硬件电路决定，互不影响
2. 必须根据实际硬件原理图配置，不能凭经验猜测
3. 配置错误会导致功能完全失效或逻辑反转
4. 调试时可通过日志和万用表验证配置正确性

#### 通用配置

```c
// 检测电平
#define TCFG_EAR_DETECT_DET_LEVEL               1                          // 入耳检测有效电平

// 功能控制
#define TCFG_EAR_DETECT_AUTO_CHG_MASTER         1                          // 通话时自动切换主从
#define TCFG_EAR_DETECT_CALL_CTL_SCO            0                          // 入耳控制通话链路
#define TCFG_EAR_DETECT_CTL_KEY                 1                          // 入耳按键有效使能
#define TCFG_KEY_IN_EAR_FILTER_ENABLE           0                          // 按键过滤使能
```

### 运行时配置

位置：`SDK/apps/common/device/in_ear_detect/in_ear_manage.c`

```c
const struct ear_detect_platform_data ear_detect_cfg = {
    // 音乐控制配置
    .ear_det_music_ctl_en = 1,              // 音乐控制使能
    .ear_det_music_ctl_ms = 0,              // 音乐暂停后控制时间(ms)，0=无限制
    .ear_det_in_music_sta = 0,              // 0:入耳播歌  1:入耳不播歌

    // 按键延迟配置
    .ear_det_key_delay_time = 0,            // 入耳后按键起效时间(ms)，0=立即有效

    // 消抖配置
    .ear_det_in_cnt = 3,                    // 入耳消抖次数
    .ear_det_out_cnt = 2,                   // 出耳消抖次数

    // IR 定时配置
    .ear_det_ir_enable_time = 2,            // IR 使能时长(ms)
    .ear_det_ir_disable_time = 300,         // IR 休眠时长(ms)
    .ear_det_ir_compensation_en = 0,        // 防太阳光干扰

    // 音乐状态检测
    .ear_det_music_play_cnt = 20,           // 音乐播放检测次数
    .ear_det_music_pause_cnt = 10,          // 音乐暂停检测次数
};
```

---

## 文件结构与作用

### 核心文件列表

```
SDK/apps/common/device/in_ear_detect/
├── in_ear_detect.h                          # 检测驱动头文件
├── in_ear_detect.c                          # 检测驱动实现（IR/Touch）
├── in_ear_manage.h                          # 管理层头文件
└── in_ear_manage.c                          # 管理层实现（事件处理、状态管理）

SDK/apps/earphone/mode/bt/
└── eartch_event_deal.c                      # 事件处理（已禁用，仅供参考）

SDK/apps/earphone/board/br52/
└── board_jl709n_demo_cfg.h                  # 板级配置
```

### 文件功能详解

#### 1. in_ear_detect.h / in_ear_detect.c

**作用**：底层检测驱动，负责硬件接口控制和状态采集。

**核心函数**：

```c
// IR 检测初始化 加载运行时配置以及三个IO口的初始化。
void ear_detect_ir_init(const struct ear_detect_platform_data *cfg);

// Touch 检测初始化 加载运行时配置以及根据timer还是触发检测进行不同方式的初始化。
void ear_detect_tch_init(const struct ear_detect_platform_data *cfg);

// IR 检测运行（定时器回调） 
static void __ear_detect_ir_run(void *priv);

// Touch 检测运行（定时器回调）
void __ear_detect_tch_run(void *priv);

// Touch 边沿唤醒处理 触发检测方式
void ear_touch_edge_wakeup_handle(u8 index, u8 gpio);
```

**工作模式**：

- **IR 检测模式**：定时器周期性检测，支持功耗优化
- **Touch 定时模式**：定时器周期性检测
- **Touch 触发模式**：边沿中断触发检测

**关键特性**：

- 消抖处理：通过计数器防止误触发
- 低功耗管理：idle 状态标志支持 sniff 模式
- 按键过滤：入耳瞬间过滤按键事件（可选）

#### 2. in_ear_manage.h / in_ear_manage.c

**作用**：管理层，负责状态管理、事件分发、TWS 同步和功能控制。

**核心数据结构**：

```c
struct ear_detect_d {
    u8 toggle        : 1;       // 入耳功能总开关
    u8 music_en      : 1;       // 音乐控制使能
    u8 pre_music_sta : 2;       // 前次音乐状态
    u8 pre_state     : 1;       // 前次入耳状态
    u8 cur_state     : 1;       // 当前入耳状态
    u8 tws_state     : 1;       // 对耳入耳状态
    u8 bt_init_ok    : 1;       // 蓝牙初始化完成标志
    u16 music_check_timer;      // 音乐状态检测定时器
    u16 change_master_timer;    // 主从切换定时器
    u16 key_enable_timer;       // 按键使能定时器
    u8 key_delay_able;          // 按键延迟有效标志
    // ... 其他字段
};
```

**核心函数**：

```c
// 初始化入口（自动调用）
void ear_detect_init(void);

// 状态变更触发事件
void ear_detect_change_state_to_event(u8 state);

// 事件处理入口
int ear_detect_event_handle(int *msg);

// 命令消息处理
int cmd_key_msg_handle(int *msg);

// TWS 状态同步
void tws_sync_ear_detect_state(u8 need_do);

// 入耳处理
static void ear_detect_in_deal(void);

// 出耳处理
static void ear_detect_out_deal(void);
```

**管理功能**：

1. **音乐控制**：A2DP 播放/暂停控制
2. **通话控制**：SCO 链路控制、主从切换
3. **按键管理**：入耳延迟使能、按键过滤
4. **TWS 同步**：双耳状态同步

#### 3. eartch_event_deal.c

**作用**：低功耗触摸耳机事件处理（当前代码中已禁用 `#if 0`，仅供参考）

**说明**：该文件提供了另一套完整的入耳检测处理逻辑，包含更复杂的音乐控制策略（15秒超时机制）和 A2DP 链路控制。当前项目使用 `in_ear_manage.c` 中的实现。

---

## 初始化流程

### 初始化时序图

```
系统启动
    ↓
app_main.c
    ↓
__initcall(ear_detect_init) ← 自动调用
    ↓
ear_detect_init() [in_ear_manage.c:881]
    ↓
    ├─→ 加载配置 ear_detect_cfg
    │
    ├─→ 根据检测类型初始化
    │   ├─ EAR_DETECT_BY_IR
    │   │   └─→ ear_detect_ir_init()
    │   │       ├─→ __ear_detect_ir_init()        # GPIO 配置
    │   │       └─→ sys_s_hi_timer_add()          # 启动高优先级定时器 10ms里面会修改时间
    │   │
    │   └─ EAR_DETECT_BY_TOUCH
    │       └─→ ear_detect_tch_init()
    │           ├─→ TOUCH_MODE=1 (定时模式)
    │           │   └─→ sys_s_hi_timer_add()      # 启动定时器
    │           │
    │           └─→ TOUCH_MODE=0 (触发模式)
    │               ├─→ ear_detect_tch_wakeup_init()
    │               └─→ ear_touch_edge_wakeup_handle()  # 初始状态
    │
    └─→ 注册消息处理器
        ├─→ APP_MSG_PROB_HANDLER(in_ear_cmd_msg_entry)
        ├─→ APP_MSG_PROB_HANDLER(ear_detect_msg_entry)
        └─→ APP_MSG_HANDLER(ear_det_app_msg_stub)
```

### 初始化步骤详解

#### 步骤 1：自动初始化

```c
// in_ear_manage.c:905
__initcall(ear_detect_init);
```

通过 `__initcall` 宏，系统启动时自动调用 `ear_detect_init()`。

#### 步骤 2：加载配置

```c
void ear_detect_init(void)
{
    ASSERT(&ear_detect_cfg);
    __this->cfg = &ear_detect_cfg;  // 加载运行时配置

    // ... 根据检测类型初始化
}
```

#### 步骤 3：IR 检测初始化

```c
void ear_detect_ir_init(const struct ear_detect_platform_data *cfg)
{
    __this->cfg = cfg;
    __ear_detect_ir_init();          // GPIO 初始化

    // 启动高优先级定时器，10ms 后首次运行
    __this->s_hi_timer = sys_s_hi_timer_add(NULL, __ear_detect_ir_run, 10);
}
```

**GPIO 初始化细节**：

```c
static void __ear_detect_ir_init(void)
{
    // 1. IR 电源控制（如果配置）
    if (TCFG_EAR_DET_IR_POWER_IO != NO_CONFIG_PORT) {
        gpio_set_mode(..., PORT_OUTPUT_HIGH);  // 拉高供电
    }

    // 2. IR 发射控制（IRO1）
    gpio_set_mode(TCFG_EAR_DETECT_IRO1, PORT_OUTPUT_HIGH);  // 初始关闭

    // 3. IR 接收检测（IRO2）
    #if TCFG_EAR_DETECT_IR_MODE
        // AD 模式
        adc_add_sample_ch(TCFG_EAR_DETECT_AD_CH);
        gpio_set_direction(TCFG_EAR_DETECT_IRO2, 1);  // 输入
    #else
        // IO 模式
        gpio_set_mode(TCFG_EAR_DETECT_IRO2, PORT_INPUT_PULLDOWN_LEVEL1);
    #endif
}
```

#### 步骤 4：Touch 检测初始化

##### 定时模式（TOUCH_MODE=1）

```c
void ear_detect_tch_init(const struct ear_detect_platform_data *cfg)
{
    __this->cfg = cfg;

    #if TCFG_EAR_DETECT_TOUCH_MODE
        // 启动定时器，10ms 后首次运行
        __this->s_hi_timer = sys_s_hi_timer_add(NULL, __ear_detect_tch_run, 10);
    #endif
}
```

##### 触发模式（TOUCH_MODE=0）

```c
void ear_detect_tch_init(const struct ear_detect_platform_data *cfg)
{
    __this->cfg = cfg;

    #if !TCFG_EAR_DETECT_TOUCH_MODE
        // 触发模式初始化
        ear_touch_edge_wakeup_handle(0, TCFG_EAR_DETECT_DET_IO);
    #endif
}

// 触发模式初始化详细步骤
void ear_touch_edge_wakeup_handle(u8 index, u8 gpio)
{
    // 1. 读取当前 IO 状态 没有对IO初始化啊，
    u8 io_state = gpio_read(TCFG_EAR_DETECT_DET_IO);

    // 2. 根据状态产生初始事件
    if (io_state == TCFG_EAR_DETECT_DET_LEVEL) {
        ear_detect_change_state_to_event(TCFG_EAR_DETECT_DET_LEVEL);  // 入耳
    } else {
        ear_detect_change_state_to_event(!TCFG_EAR_DETECT_DET_LEVEL); // 出耳
    }

    // 3. 配置边沿中断 根据对应IO口配置唤醒机制
    if (io_state) {
        p33_io_wakeup_edge(TCFG_EAR_DETECT_DET_IO, FALLING_EDGE);  // 下降沿触发
    } else {
        p33_io_wakeup_edge(TCFG_EAR_DETECT_DET_IO, RISING_EDGE);   // 上升沿触发
    }
}
```

**根据初始IO的电平状态判定一次初始出耳或者入耳状态，接着根据此刻的状态配置唤醒机制，比如此刻是低电平的话，配置上升沿唤醒。这个触发模式是什么意思呢？而且我没有看到IO口的初始化啊？**

这个是入耳检测来实现自动开关机并且处理一次入耳与出耳事件吗？

- 看文档。

#### 步骤 5：注册消息处理器

```c
// 1. 入耳命令消息处理器（音乐播放/暂停）
APP_MSG_PROB_HANDLER(in_ear_cmd_msg_entry) = {
    .owner      = 0xff,                     // 所有模式
    .from       = MSG_FROM_IN_EAR,
    .handler    = cmd_key_msg_handle,
};

// 2. 入耳事件消息处理器（入耳/出耳事件）
APP_MSG_PROB_HANDLER(ear_detect_msg_entry) = {
    .owner      = 0xff,
    .from       = MSG_FROM_IN_EAR,
    .handler    = ear_detect_event_handle,
};

// 3. 蓝牙事件处理器（连接/断开/通话）
APP_MSG_HANDLER(ear_det_app_msg_stub) = {
    .owner      = 0xff,
    .from       = MSG_FROM_BT_STACK,
    .handler    = ear_det_app_event_handler,
};
```

---

## 检测流程

### IR 检测流程

#### 状态机

```
DETECT_IDLE (休眠) ─┐
       ↑            │ ear_det_ir_disable_time (300ms)
       │            ↓
       │      关闭 IRO1
       │      读取补偿值
       │            │
       │            ↓
       │     DETECT_CHECKING (检测中)
       │            │
       │            ↓ ear_det_ir_enable_time (2ms)
       │      开启 IRO1
       │      读取检测值
       │            │
       │            ├─→ 入耳电平？
       │            │   ├─ Yes → in_cnt++
       │            │   │         │
       │            │   │         ├─ in_cnt >= ear_det_in_cnt (3)?
       │            │   │         │   └─→ Yes → 触发入耳事件
       │            │   │         │
       │            │   │         └─ No → 继续检测
       │            │   │
       │            │   └─ No → out_cnt++
       │            │             │
       │            │             ├─ out_cnt >= ear_det_out_cnt (2)?
       │            │             │   └─→ Yes → 触发出耳事件
       │            │             │
       │            │             └─ No → 继续检测
       │            │
       └────────────┘
```

#### 检测周期

```
│←─ 300ms ─→│←2ms→│←─ 300ms ─→│←2ms→│
  休眠        检测    休眠       检测
 (省电)     (IRO1开启)  (省电)  (IRO1开启)
```

#### 代码流程

```c
static void __ear_detect_ir_run(void *priv)
{
    // ========== 阶段 1: 充电保护 ==========
    if (get_charge_online_flag()) {
        __this->check_status = DETECT_IDLE;
        gpio_set_mode(..., PORT_OUTPUT_HIGH);      // 关闭 IRO1
        sys_hi_timer_modify(__this->s_hi_timer,
            __this->cfg->ear_det_ir_disable_time); // 进入休眠
        return;
    }

    // ========== 阶段 2: 休眠阶段（DETECT_IDLE） ==========
    if (__this->check_status == DETECT_IDLE) {
        // 太阳光补偿检测（可选）
        if (__this->cfg->ear_det_ir_compensation_en == 1) {
            if (gpio_read(TCFG_EAR_DETECT_IRO2) == TCFG_EAR_DETECT_DET_LEVEL) {
                // 在未开启 IRO1 时就检测到入耳电平，可能是阳光干扰
                if (is_ear_detect_state_in() == 1) {
                    // 当前认为是入耳状态，强制切换为出耳
                    ear_detect_change_state_to_event(!TCFG_EAR_DETECT_DET_LEVEL);
                }
                return;  // 跳过本次检测
            }
        }

        // 进入检测阶段
        __this->check_status = DETECT_CHECKING;
        gpio_set_mode(..., PORT_OUTPUT_LOW);       // 开启 IRO1 发射
        sys_hi_timer_modify(__this->s_hi_timer,
            __this->cfg->ear_det_ir_enable_time);  // 等待 2ms 稳定
        return;
    }

    // ========== 阶段 3: 检测阶段（DETECT_CHECKING） ==========
    #if (!TCFG_EAR_DETECT_IR_MODE)
        // IO 检测模式
        if (gpio_read(TCFG_EAR_DETECT_IRO2) == TCFG_EAR_DETECT_DET_LEVEL) {
    #else
        // AD 检测模式
        u32 ear_ad = adc_get_value(TCFG_EAR_DETECT_AD_CH);
        if (ear_ad >= TCFG_EAR_DETECT_AD_VALUE) {
    #endif
            // ========== 入耳处理 ==========
            putchar('i');
            __this->out_cnt = 0;  // 清除出耳计数

            if (__this->in_cnt < __this->cfg->ear_det_in_cnt) {
                __this->is_idle = 0;  // 消抖期间禁止 sniff
                __this->in_cnt++;

                if (__this->in_cnt == __this->cfg->ear_det_in_cnt) {
                    // 达到消抖次数，确认入耳
                    log_info("earphone ir in\n");

                    #if TCFG_KEY_IN_EAR_FILTER_ENABLE
                        // 按键过滤：入耳瞬间如果按键按下，标记过滤
                        if (gpio_read(IO_PORTB_01) == 0) {
                            io_key_filter_flag = 1;
                        }
                    #endif

                    __this->is_idle = 1;  // 允许进入 sniff
                    ear_detect_change_state_to_event(TCFG_EAR_DETECT_DET_LEVEL);
                }
            }
        } else {
            // ========== 出耳处理 ==========
            putchar('o');
            __this->in_cnt = 0;  // 清除入耳计数

            if (__this->out_cnt < __this->cfg->ear_det_out_cnt) {
                __this->is_idle = 0;  // 消抖期间禁止 sniff
                __this->out_cnt++;

                if (__this->out_cnt == __this->cfg->ear_det_out_cnt) {
                    // 达到消抖次数，确认出耳
                    log_info("earphone ir out\n");
                    __this->is_idle = 1;  // 允许进入 sniff
                    ear_detect_change_state_to_event(!TCFG_EAR_DETECT_DET_LEVEL);
                }
            }
        }

    // ========== 回到休眠阶段 ==========
    __this->check_status = DETECT_IDLE;
    gpio_set_mode(..., PORT_OUTPUT_HIGH);      // 关闭 IRO1
    sys_hi_timer_modify(__this->s_hi_timer,
        __this->cfg->ear_det_ir_disable_time); // 进入休眠 300ms
}
```

### Touch 检测流程

#### 定时模式（TOUCH_MODE=1）

```c
void __ear_detect_tch_run(void *priv)
{
    // ========== 阶段 1: 使能上拉 ==========
    if (__this->check_status == DETECT_IDLE) {
        __this->check_status = DETECT_CHECKING;
        gpio_set_mode(..., PORT_INPUT_PULLUP_10K);  // 使能上拉
        sys_hi_timer_modify(__this->s_hi_timer, 2); // 2ms 后检测
        return;
    }

    // ========== 阶段 2: 检测状态 ==========
    if (gpio_read(TCFG_EAR_DETECT_DET_IO) == TCFG_EAR_DETECT_DET_LEVEL) {
        // 入耳处理（同 IR 检测）
        __this->out_cnt = 0;
        if (__this->in_cnt < __this->cfg->ear_det_in_cnt) {
            __this->is_idle = 0;
            __this->in_cnt++;
            if (__this->in_cnt == __this->cfg->ear_det_in_cnt) {
                log_info("earphone touch in\n");
                __this->is_idle = 1;
                ear_detect_change_state_to_event(TCFG_EAR_DETECT_DET_LEVEL);
            }
        }
    } else {
        // 出耳处理（同 IR 检测）
        __this->in_cnt = 0;
        if (__this->out_cnt < __this->cfg->ear_det_out_cnt) {
            __this->is_idle = 0;
            __this->out_cnt++;
            if (__this->out_cnt == __this->cfg->ear_det_out_cnt) {
                log_info("earphone touch out\n");
                __this->is_idle = 1;
                ear_detect_change_state_to_event(!TCFG_EAR_DETECT_DET_LEVEL);
            }
        }
    }

    // ========== 回到休眠 ==========
    __this->check_status = DETECT_IDLE;
    gpio_set_mode(..., PORT_HIGHZ);             // 高阻态省电
    sys_hi_timer_modify(__this->s_hi_timer, 10); // 10ms 后再次检测
}
```

#### 触发模式（TOUCH_MODE=0）

```c
void ear_touch_edge_wakeup_handle(u8 index, u8 gpio)
{
    // ========== 读取当前状态 ==========
    u8 io_state = gpio_read(TCFG_EAR_DETECT_DET_IO);

    // ========== 按键过滤（可选） ==========
    #if TCFG_KEY_IN_EAR_FILTER_ENABLE
        if (gpio_read(IO_PORTB_01) == 0) {
            io_key_filter_flag = 1;
        }
    #endif

    // ========== 产生状态变更事件 ==========
    if (io_state == TCFG_EAR_DETECT_DET_LEVEL) {
        log_info("earphone touch in\n");
        ear_detect_change_state_to_event(TCFG_EAR_DETECT_DET_LEVEL);
    } else {
        log_info("earphone touch out\n");
        ear_detect_change_state_to_event(!TCFG_EAR_DETECT_DET_LEVEL);
    }

    // ========== 切换边沿中断方向 ==========
    if (io_state) {
        // 当前高电平，下次检测下降沿（出耳）
        p33_io_wakeup_edge(TCFG_EAR_DETECT_DET_IO, FALLING_EDGE);
    } else {
        // 当前低电平，下次检测上升沿（入耳）
        p33_io_wakeup_edge(TCFG_EAR_DETECT_DET_IO, RISING_EDGE);
    }
}
```

### 低功耗管理

```c
// 注册低功耗目标
REGISTER_LP_TARGET(ear_detect_lp_target) = {
    .name = "ear_det",
    .is_idle = ear_det_idle,  // 返回是否可以进入 sniff
};

static u8 ear_det_idle()
{
    return __this->is_idle;  // 消抖期间返回 0，禁止 sniff
}
```

---

## 事件处理流程

### 事件类型

```c
enum {
    EAR_DETECT_EVENT_NULL = 0,
    EAR_DETECT_EVENT_IN,        // 本机入耳
    EAR_DETECT_EVENT_OUT,       // 本机出耳
    EAR_DETECT_EVENT_IN_DEAL,   // TWS 对耳入耳，本机（主机）需要处理
    EAR_DETECT_EVENT_OUT_DEAL,  // TWS 对耳出耳，本机（主机）需要处理
};
```

### 命令类型

```c
enum {
    CMD_EAR_DETECT_MUSIC_PLAY = 1,      // 播放音乐
    CMD_EAR_DETECT_MUSIC_PAUSE,         // 暂停音乐
    CMD_EAR_DETECT_SCO_CONN,            // 连接 SCO 链路
    CMD_EAR_DETECT_SCO_DCONN,           // 断开 SCO 链路
};
```

### 事件产生流程

```
检测驱动检测到状态变化
    ↓
ear_detect_change_state_to_event(u8 state) [in_ear_manage.c:548]
    │
    ├─→ 更新状态：pre_state、cur_state
    │
    ├─→ 判断状态是否改变
    │   └─→ 相同状态则忽略
    │
    └─→ 产生事件
        │
        └─→ ear_detect_post_event(event)
            │
            ├─→ 退出 sniff：bt_cmd_prepare(USER_CTRL_ALL_SNIFF_EXIT, ...)
            │
            └─→ 发送消息到应用层
                │
                └─→ os_taskq_post_type("app_core", MSG_FROM_IN_EAR, 2, msg)
                    │
                    ├─→ msg[0] = DEVICE_EVENT_FROM_EAR_DETECT
                    └─→ msg[1] = event (EAR_DETECT_EVENT_IN / OUT / IN_DEAL / OUT_DEAL)
```

### 事件处理流程

#### 1. 入耳事件处理（EAR_DETECT_EVENT_IN）

```c
APP_MSG_PROB_HANDLER(ear_detect_msg_entry) = {  
    .owner      = 0xff,
    .from       = MSG_FROM_IN_EAR,
    .handler    = ear_detect_event_handle,
};
int ear_detect_event_handle(int *msg)
{
    switch (msg[1]) {
    case EAR_DETECT_EVENT_IN:
        log_info("EAR_DETECT_EVENT_IN");

        // ========== ANC 模式切换（可选） ==========
        #if INEAR_ANC_UI
            etch_in_anc();  // 双耳入耳时开启 ANC
        #endif

        // ========== 播放提示音（可选，已注释） ==========
        // 条件：功能开关、蓝牙已初始化、非通话状态
        if (__this->toggle && __this->bt_init_ok &&
            (bt_get_call_status() == BT_CALL_HANGUP)) {
            #if TCFG_USER_TWS_ENABLE
                if (get_tws_sibling_connect_state()) {
                    // TWS 模式：只在对耳未入耳时播放
                    if (__this->tws_state != TCFG_EAR_DETECT_DET_LEVEL) {
                        // bt_tws_play_tone_at_same_time(...);
                    }
                } else
            #endif
                {
                    // 单耳模式：播放提示音
                    // tone_play(TONE_EAR_CHECK, 1);
                }
        }

        // ========== TWS 状态同步 ==========
        #if TCFG_USER_TWS_ENABLE
            if (get_tws_sibling_connect_state()) {
                tws_sync_ear_detect_state(1);  // 同步到对耳，需要处理

                // 主机执行入耳处理
                if (tws_api_get_role() == TWS_ROLE_MASTER) {
                    __ear_detect_in_dealy_deal(NULL);
                }
            } else
        #endif
            {
                // 单耳模式：直接执行入耳处理
                __ear_detect_in_dealy_deal(NULL);
            }

        // ========== 按键延迟使能 ==========
        if ((__this->key_enable_timer == 0) &&
            (__this->cfg->ear_det_key_delay_time != 0)) {
            // 延迟后使能按键
            __this->key_enable_timer = sys_timeout_add(
                (void *)1,
                ear_detect_set_key_delay_able,
                __this->cfg->ear_det_key_delay_time
            );
        }
        break;

    // ... 其他事件处理
    }
}
```

#### 2. 出耳事件处理（EAR_DETECT_EVENT_OUT）

```c
case EAR_DETECT_EVENT_OUT:
    log_info("EAR_DETECT_EVENT_OUT");

    // ========== ANC 模式切换（可选） ==========
    #if INEAR_ANC_UI
        etch_out_anc();  // 出耳时关闭 ANC
    #endif

    // ========== TWS 状态同步 ==========
    #if TCFG_USER_TWS_ENABLE
        if (get_tws_sibling_connect_state()) {
            tws_sync_ear_detect_state(1);  // 同步到对耳

            // 主机执行出耳处理
            if (tws_api_get_role() == TWS_ROLE_MASTER) {
                ear_detect_out_deal();
            }
        } else
    #endif
        {
            // 单耳模式：直接执行出耳处理
            ear_detect_out_deal();
        }

    // ========== 禁用按键 ==========
    if (__this->cfg->ear_det_key_delay_time != 0) {
        ear_detect_set_key_delay_able(0);  // 立即禁用按键

        if (__this->key_enable_timer) {
            sys_timeout_del(__this->key_enable_timer);
            __this->key_enable_timer = 0;
        }
    }
    break;
```

### 入耳/出耳处理详解

#### 入耳处理（ear_detect_in_deal）

```c
static void ear_detect_in_deal()
{
    u8 call_status = bt_get_call_status();

    if (0 == __this->toggle) return;  // 功能已关闭

    // ========== 通话状态处理 ==========
    if (call_status != BT_CALL_HANGUP) {
        // ---------- 控制 SCO 链路（可选） ----------
        #if TCFG_EAR_DETECT_CALL_CTL_SCO
            if (call_status == BT_CALL_ACTIVE) {
                // 有耳机入耳，连接 SCO
                if (ear_detect_check_online(0) == 1) {
                    cmd_post_key_msg(CMD_EAR_DETECT_SCO_CONN);
                }
            }
        #endif

        // ---------- 主从切换（可选） ----------
        #if (TCFG_EAR_DETECT_AUTO_CHG_MASTER && TCFG_USER_TWS_ENABLE)
            ear_detect_change_master_timer_del();  // 取消之前的切换定时器

            // 主机不在耳，从机在耳 → 2秒后切换主从
            if (get_tws_sibling_connect_state() &&
                (__this->cur_state != TCFG_EAR_DETECT_DET_LEVEL) &&
                (__this->tws_state == TCFG_EAR_DETECT_DET_LEVEL)) {
                __this->change_master_timer = sys_timeout_add(
                    NULL,
                    ear_detect_change_master_timeout_deal,
                    2000
                );
            }
        #endif
    }
    // ========== 已连接且非通话状态 ==========
    else if (bt_get_total_connect_dev()) {
        // 有耳机入耳 → 播放音乐
        if ((__this->cur_state == TCFG_EAR_DETECT_DET_LEVEL) ||
            (__this->tws_state == TCFG_EAR_DETECT_DET_LEVEL)) {
            ear_detect_music_play_ctl(MUSIC_STATE_PLAY);
        }
    }
}
```

#### 出耳处理（ear_detect_out_deal）

```c
static void ear_detect_out_deal()
{
    u8 call_status = bt_get_call_status();

    if (0 == __this->toggle) return;  // 功能已关闭

    // ========== 通话状态处理 ==========
    if (call_status != BT_CALL_HANGUP) {
        if (call_status == BT_CALL_ACTIVE) {
            // 双耳都不在耳 → 断开 SCO
            if (ear_detect_check_online(1) == 1) {
                #if (TCFG_EAR_DETECT_AUTO_CHG_MASTER && TCFG_USER_TWS_ENABLE)
                    ear_detect_change_master_timer_del();  // 取消主从切换
                #endif

                #if TCFG_EAR_DETECT_CALL_CTL_SCO
                    cmd_post_key_msg(CMD_EAR_DETECT_SCO_DCONN);
                #endif
            }

            // 主从切换检查
            #if (TCFG_EAR_DETECT_AUTO_CHG_MASTER && TCFG_USER_TWS_ENABLE)
                ear_detect_change_master_timer_del();

                // 主机不在耳，从机在耳 → 2秒后切换主从
                if (get_tws_sibling_connect_state() &&
                    (__this->cur_state != TCFG_EAR_DETECT_DET_LEVEL) &&
                    (__this->tws_state == TCFG_EAR_DETECT_DET_LEVEL)) {
                    __this->change_master_timer = sys_timeout_add(
                        NULL,
                        ear_detect_change_master_timeout_deal,
                        2000
                    );
                }
            #endif
        }
    }
    // ========== 已连接且非通话状态 ==========
    else if (bt_get_total_connect_dev()) {
        // 有耳机出耳 → 暂停音乐
        if ((__this->cur_state != TCFG_EAR_DETECT_DET_LEVEL) ||
            (__this->tws_state != TCFG_EAR_DETECT_DET_LEVEL)) {
            ear_detect_music_play_ctl(MUSIC_STATE_PAUSE);
        }
    }
}
```

### 音乐控制流程

#### 播放/暂停控制

```c
static void ear_detect_music_play_ctl(u8 music_state)
{
    // ========== 防止重复操作 ==========
    #if TCFG_USER_TWS_ENABLE
        if (get_tws_sibling_connect_state() &&
            (__this->pre_music_sta == music_state)) {
            // TWS 模式下，防止两只耳机陆续入耳时重复操作
            if (__this->cfg->ear_det_music_ctl_en == 1) {
                return;
            }
        }
    #endif

    __this->pre_music_sta = music_state;

    // ========== 检查音乐控制使能 ==========
    if (!__this->music_en) return;  // 音乐控制未使能

    // ========== 播放音乐 ==========
    if (music_state == MUSIC_STATE_PLAY) {
        if (__this->cfg->ear_det_music_ctl_en == 1) {
            __this->music_regist_en = 0;  // 取消超时注册
        }

        if (__this->cfg->ear_det_in_music_sta == 0) {  // 入耳播歌
            if (bt_a2dp_get_status() != BT_MUSIC_STATUS_STARTING) {
                // 当前未播放 → 发送播放命令
                cmd_post_key_msg(CMD_EAR_DETECT_MUSIC_PLAY);
            } else {
                // 当前已播放 → 启动状态检测
                cancel_music_state_check();
                __this->music_check_timer = sys_timer_add(
                    NULL,
                    music_play_state_check,
                    100
                );
            }
        }
    }
    // ========== 暂停音乐 ==========
    else {
        if (__this->cfg->ear_det_music_ctl_en == 1) {
            __this->music_regist_en = 1;  // 注册超时控制
        }

        if (bt_a2dp_get_status() == BT_MUSIC_STATUS_STARTING) {
            // 当前播放中 → 发送暂停命令
            cmd_post_key_msg(CMD_EAR_DETECT_MUSIC_PAUSE);
        } else {
            // 当前已暂停 → 启动状态检测
            cancel_music_state_check();
            __this->music_check_timer = sys_timer_add(
                NULL,
                music_play_state_check,
                100
            );
        }
    }
}
```

#### 音乐命令处理

```c
int cmd_key_msg_handle(int *msg)
{
    bt_cmd_prepare(USER_CTRL_ALL_SNIFF_EXIT, 0, NULL);  // 退出 sniff

    // 防止重复发送
    static u8 old_msg = 0;
    if ((old_msg == (u8)msg[1]) || ((msg[1] != 1) && (msg[1] != 2))) {
        return 0;
    }
    old_msg = (u8)msg[1];

    switch (msg[1]) {
    case CMD_EAR_DETECT_MUSIC_PLAY:
        // 播放音乐
        if (bt_a2dp_get_status() != BT_MUSIC_STATUS_STARTING) {
            if (tws_api_get_role() == TWS_ROLE_MASTER) {
                bt_cmd_prepare(USER_CTRL_AVCTP_OPID_PLAY, 0, NULL);
            } else {
                tws_api_sync_call_by_uuid('T', SYNC_CMD_MUSIC_PLAY, 400);
            }
        }
        break;

    case CMD_EAR_DETECT_MUSIC_PAUSE:
        // 暂停音乐
        if (bt_a2dp_get_status() == BT_MUSIC_STATUS_STARTING) {
            if (tws_api_get_role() == TWS_ROLE_MASTER) {
                bt_cmd_prepare(USER_CTRL_AVCTP_OPID_PLAY, 0, NULL);  // 注意：这里用 PLAY 切换
            } else {
                tws_api_sync_call_by_uuid('T', SYNC_CMD_MUSIC_STOP, 400);
            }
        }
        break
;
    }
    return 0;
}
```

### 音乐状态检测

```c
static void music_play_state_check(void *priv)
{
    if (__this->pre_music_sta == MUSIC_STATE_PLAY) {
        // ========== 期望播放状态 ==========
        if (__this->cfg->ear_det_in_music_sta == 1) {
            // 配置为入耳不播歌 → 取消检测
            cancel_music_state_check();
        } else {
            if (bt_a2dp_get_status() == BT_MUSIC_STATUS_STARTING) {
                // 已经在播放 → 计数
                __this->music_sta_cnt++;
            } else {
                // 期间变成了暂停 → 重新发送播放命令
                cmd_post_key_msg(CMD_EAR_DETECT_MUSIC_PLAY);
                cancel_music_state_check();
            }

            if (__this->music_sta_cnt >= __this->cfg->ear_det_music_play_cnt) {
                // 检测次数达到 → 取消检测
                cancel_music_state_check();
            }
        }
    } else {
        // ========== 期望暂停状态 ==========
        if (bt_a2dp_get_status() != BT_MUSIC_STATUS_STARTING) {
            // 已经暂停 → 计数
            __this->music_sta_cnt++;
        } else {
            // 期间变成了播放 → 重新发送暂停命令
            cmd_post_key_msg(CMD_EAR_DETECT_MUSIC_PAUSE);
            cancel_music_state_check();
        }

        if (__this->music_sta_cnt >= __this->cfg->ear_det_music_pause_cnt) {
            // 检测次数达到 → 取消检测
            cancel_music_state_check();
        }
    }
}
```

### A2DP 状态监控

```c
#define A2DP_PLAY_CNT           2
#define A2DP_STOP_CNT           2

static void ear_detect_a2dp_detech(void *priv)
{
    if (bt_get_call_status() != BT_CALL_HANGUP) {
        return;  // 通话中不检测
    }

    u8 a2dp_state = bt_a2dp_get_status();

    if (a2dp_state == BT_MUSIC_STATUS_STARTING) {
        // ========== 正在播放 ==========
        __this->stop_cnt = 0;

        if (__this->play_cnt < A2DP_PLAY_CNT) {
            __this->play_cnt++;

            if (__this->play_cnt == A2DP_PLAY_CNT) {
                // 连续 2 次检测到播放 → 使能音乐控制
                __this->pre_music_sta = MUSIC_STATE_PLAY;
                ear_detect_music_ctl_en(1);
            }
        }
    } else {
        // ========== 未播放 ==========
        __this->play_cnt = 0;

        if (__this->stop_cnt < A2DP_STOP_CNT) {
            __this->stop_cnt++;

            if (__this->stop_cnt == A2DP_STOP_CNT) {
                // 连续 2 次检测到停止 → 禁用音乐控制（带超时）
                if (__this->music_en) {
                    __this->pre_music_sta = MUSIC_STATE_PAUSE;
                    ear_detect_music_ctl_en(0);
                }
            }
        }
    }
}

void ear_detect_a2dp_det_en(u8 en)
{
    if (en) {
        // 启动 A2DP 状态监控（500ms 周期）
        if (!__this->a2dp_det_timer) {
            __this->a2dp_det_timer = sys_timer_add(NULL, ear_detect_a2dp_detech, 500);
        }
    } else {
        // 停止监控
        if (__this->a2dp_det_timer) {
            sys_timer_del(__this->a2dp_det_timer);
            __this->a2dp_det_timer = 0;
        }
    }
}
```

---

## TWS同步机制

### 同步原理

在 TWS（True Wireless Stereo）模式下，两只耳机需要同步入耳检测状态，以便协同控制音乐播放、通话链路等功能。

### 同步时机

```c
void tws_sync_ear_detect_state(u8 need_do)
{
    u8 state = 0;

    // ========== 构造同步数据 ==========
    state = need_do ? (BIT(7) | __this->cur_state) : __this->cur_state;

    if (!need_do) {
        state |= (__this->music_en << 6);  // 携带音乐控制使能标志
    }

    // ========== 发送到对耳 ==========
    tws_api_send_data_to_sibling(&state, 1, TWS_FUNC_ID_EAR_DETECT_SYNC);
}
```

**同步数据格式：**

```
Bit 7: need_do 标志（是否需要对方执行处理）
Bit 6: music_en 标志（音乐控制使能）
Bit 0: cur_state（当前入耳状态）
```

### 同步数据接收

```c
static void tws_sync_ear_detect_state_deal(void *_data, u16 len, bool rx)
{
    u8 *data = (u8 *)_data;
    u8 state = data[0];

    if (rx) {
        // ========== 更新对耳状态 ==========
        __this->tws_state = state & BIT(0);

        // ========== 判断是否需要执行处理 ==========
        if ((state & BIT(7))) {
            // 需要执行 → 发送事件到应用层
            if (__this->tws_state == TCFG_EAR_DETECT_DET_LEVEL) {
                ear_detect_post_event(EAR_DETECT_EVENT_IN_DEAL);
            } else {
                ear_detect_post_event(EAR_DETECT_EVENT_OUT_DEAL);
            }
        }
    }
}

// 注册 TWS 同步处理函数
REGISTER_TWS_FUNC_STUB(ear_detect_sync) = {
    .func_id = TWS_FUNC_ID_EAR_DETECT_SYNC,
    .func    = tws_sync_ear_detect_state_deal,
};
```

### 同步场景

#### 场景 1：本机入耳

```
耳机 A (本机)                    耳机 B (对耳)
    │                                │
    ├─→ 检测到入耳                    │
    │   ear_detect_change_state      │
    │       _to_event()              │
    │                                │
    ├─→ EAR_DETECT_EVENT_IN          │
    │   ear_detect_event_handle()    │
    │                                │
    ├─→ 同步到对耳                    │
    │   tws_sync_ear_detect_state(1) │
    │   ────────────────────────────→│
    │                                ├─→ 接收同步数据
    │                                │   tws_sync_ear_detect_state_deal()
    │                                │
    │                                ├─→ 更新对耳状态
    │                                │   __this->tws_state = 1
    │                                │
    │                                ├─→ 发送事件（如果是主机）
    │                                │   EAR_DETECT_EVENT_IN_DEAL
    │                                │
    │                                └─→ 执行入耳处理
    │                                    ear_detect_in_deal()
    │                                    (音乐播放控制)
    ├─→ 执行入耳处理（主机）
    │   __ear_detect_in_dealy_deal()
    │   (音乐播放控制)
    │
```

#### 场景 2：主从切换

```
主机（不在耳）                   从机（在耳）
    │                                │
    ├─→ 检测到出耳                    │
    │                                ├─→ 检测到入耳
    │                                │
    ├─→ 同步到对耳 ─────────────────→│
    │                                ├─→ 接收同步数据
    │                                │   主机不在耳，从机在耳
    │                                │
    │                                ├─→ 启动主从切换定时器
    │                                │   (2秒延迟)
    │                                │
    │←──── 切换主从角色 ──────────────│
    │                                │
    ├─→ 变成从机                     ├─→ 变成主机
    │                                │
    │                                └─→ 主机执行控制
    │                                    (音乐/通话)
```

---

## 功能交互

### 与按键模块交互

#### 按键过滤

```c
#if TCFG_KEY_IN_EAR_FILTER_ENABLE
u8 iokey_filter_hook(u8 io_state)
{
    u8 ret = 0;

    if (io_key_filter_flag) {
        if (io_state == 1) {
            // 按键释放 → 清除过滤标志
            io_key_filter_flag = 0;
        } else {
            // 按键按下 → 过滤此次按键
            ret = 1;
        }
    }

    return ret;  // 1=过滤，0=不过滤
}
#endif
```

**工作原理：**入耳瞬间如果检测到按键按下，设置 `io_key_filter_flag = 1`，此后第一次按键事件会被过滤，直到按键释放。

#### 按键有效控制

```c
#if TCFG_EAR_DETECT_CTL_KEY
int key_event_remap(struct key_event *e)
{
    // 检查按键延迟
    if (ear_detect_get_key_delay_able() == 0) {
        log_info("key disable ");
        return 0;  // 按键未使能
    }

    // 检查入耳状态
    if (!is_ear_detect_state_in()) {
        log_info("key remap");
        return 0;  // 不在耳朵上，禁止按键
    }

    return 1;  // 允许按键
}
#endif
```

**工作流程：**

1. 出耳时，`key_delay_able = 0`，所有按键无效
2. 入耳时，根据配置延迟 N 毫秒后，`key_delay_able = 1`，按键生效
3. 如果 `TCFG_EAR_DETECT_CTL_KEY = 1`，不在耳时按键无效

### 与蓝牙模块交互

#### 连接/断开事件

```c
static void ear_det_app_event_handler(int *_event)
{
    struct bt_event *event = (struct bt_event *)_event;

    switch (event->event) {
    case BT_STATUS_FIRST_CONNECTED:
    case BT_STATUS_SECOND_CONNECTED:
        // 蓝牙连接 → 启动 A2DP 状态监控
        if (__this->cfg->ear_det_music_ctl_en) {
            ear_detect_a2dp_det_en(1);
        }
        break;

    case BT_STATUS_FIRST_DISCONNECT:
    case BT_STATUS_SECOND_DISCONNECT:
        // 蓝牙断开 → 停止 A2DP 状态监控
        if (__this->cfg->ear_det_music_ctl_en) {
            ear_detect_a2dp_det_en(0);
        }
        break;

    case BT_STATUS_PHONE_ACTIVE:
        // 来电激活
        #if TCFG_EAR_DETECT_ENABLE
            #if TCFG_EAR_DETECT_CALL_CTL_SCO
                ear_detect_phone_active_deal();  // 控制 SCO 链路
            #endif

            #if (TCFG_EAR_DETECT_AUTO_CHG_MASTER && TCFG_USER_TWS_ENABLE)
                ear_detect_call_chg_master_deal();  // 主从切换
            #endif
        #endif
        break;

    case BT_STATUS_PHONE_HANGUP:
        // 通话挂断
        #if (TCFG_EAR_DETECT_ENABLE && TCFG_EAR_DETECT_AUTO_CHG_MASTER && TCFG_USER_TWS_ENABLE)
            ear_detect_change_master_timer_del();  // 取消主从切换定时器
        #endif
        break;
    }
}
```

#### 通话时主从切换

```c
void ear_detect_call_chg_master_deal()
{
    if (0 == __this->toggle) return;

    // 条件：对耳连接、本机是主机、主机不在耳、从机在耳
    if (get_tws_sibling_connect_state() &&
        (tws_api_get_role() == TWS_ROLE_MASTER) &&
        (__this->cur_state != TCFG_EAR_DETECT_DET_LEVEL) &&
        (__this->tws_state == TCFG_EAR_DETECT_DET_LEVEL)) {

        // 立即切换主从
        ear_detect_change_master_timeout_deal(NULL);
    }
}

void ear_detect_change_master_timeout_deal(void *priv)
{
    __this->change_master_timer = 0;

    // 禁用自动主从切换
    tws_api_auto_role_switch_disable();

    // 执行主从切换
    tws_api_role_switch();
}
```

### 与音频模块交互

#### ANC 模式控制（可选）

```c
#if INEAR_ANC_UI
void etch_in_anc(void)
{
    if (get_tws_sibling_connect_state()) {
        // TWS 模式：双耳都入耳时开启 ANC
        if (__this->tws_state && __this->cur_state) {
            if (inear_tws_ancmode == ANC_ON) {
                anc_mode_switch(inear_tws_ancmode, 1);
            }
        } else if (__this->cur_state && !__this->tws_state) {
            // 单耳入耳 → 关闭 ANC
            if (inear_tws_ancmode == ANC_ON) {
                anc_mode_switch(ANC_OFF, 0);
            }
        }
    }
}

void etch_out_anc(void)
{
    if (get_tws_sibling_connect_state()) {
        // 有耳机出耳 → 关闭 ANC
        inear_tws_ancmode = ANC_ON;
        anc_mode_switch(ANC_OFF, 0);
    }
}
#endif
```

### 与电源模块交互

#### 低功耗模式

```c
static u8 ear_det_idle()
{
    return __this->is_idle;  // 消抖期间返回 0，禁止进入 sniff
}

REGISTER_LP_TARGET(ear_detect_lp_target) = {
    .name = "ear_det",
    .is_idle = ear_det_idle,
};
```

**工作原理：**

- 检测稳定时：`is_idle = 1`，允许系统进入 sniff 模式
- 消抖期间：`is_idle = 0`，禁止系统进入 sniff 模式，保证检测及时性

#### 充电保护

```c
static void __ear_detect_ir_run(void *priv)
{
    // 充电时关闭 IR 检测，避免干扰
    if (get_charge_online_flag()) {
        __this->check_status = DETECT_IDLE;
        gpio_set_mode(..., PORT_OUTPUT_HIGH);  // 关闭 IRO1
        sys_hi_timer_modify(__this->s_hi_timer,
            __this->cfg->ear_det_ir_disable_time);
        return;
    }

    // ... 正常检测流程
}
```

---

## 开发指南

### 添加新的检测类型

如果需要添加新的检测硬件（如霍尔传感器），可以按照以下步骤：

#### 步骤 1：定义检测类型

在 `in_ear_manage.h` 中添加：

```c
#define EAR_DETECT_BY_HALL      2  // 霍尔传感器入耳检测
```

#### 步骤 2：添加配置宏

在 `board_jl709n_demo_cfg.h` 中添加：

```c
// HALL 配置
#define TCFG_EAR_DETECT_HALL_IO                 IO_PORTB_05    // 霍尔传感器 IO
#define TCFG_EAR_DETECT_HALL_LEVEL              0              // 入耳有效电平
```

#### 步骤 3：实现检测驱动

在 `in_ear_detect.c` 中添加：

```c
static void __ear_detect_hall_init(void)
{
    // GPIO 初始化
    gpio_set_mode(IO_PORT_SPILT(TCFG_EAR_DETECT_HALL_IO), PORT_INPUT_PULLUP_10K);

    // 配置边沿中断
    p33_io_wakeup_set_callback(TCFG_EAR_DETECT_HALL_IO, hall_wakeup_callback);
}

static void hall_wakeup_callback(u8 index, u8 gpio)
{
    u8 io_state = gpio_read(TCFG_EAR_DETECT_HALL_IO);

    if (io_state == TCFG_EAR_DETECT_HALL_LEVEL) {
        ear_detect_change_state_to_event(TCFG_EAR_DETECT_DET_LEVEL);
    } else {
        ear_detect_change_state_to_event(!TCFG_EAR_DETECT_DET_LEVEL);
    }

    // 切换中断边沿
    if (io_state) {
        p33_io_wakeup_edge(TCFG_EAR_DETECT_HALL_IO, FALLING_EDGE);
    } else {
        p33_io_wakeup_edge(TCFG_EAR_DETECT_HALL_IO, RISING_EDGE);
    }
}

void ear_detect_hall_init(const struct ear_detect_platform_data *cfg)
{
    ASSERT(cfg);
    __this->cfg = cfg;
    __ear_detect_hall_init();
}

// 在 in_ear_detect.h 中添加声明
extern void ear_detect_hall_init(const struct ear_detect_platform_data *cfg);
```

#### 步骤 4：注册到初始化流程

在 `in_ear_manage.c` 的 `ear_detect_init()` 中添加：

```c
void ear_detect_init(void)
{
    // ... 原有代码

    #if (TCFG_EAR_DETECT_TYPE == EAR_DETECT_BY_HALL)
        ear_detect_hall_init(&ear_detect_cfg);
    #endif
}
```

### 自定义入耳处理逻辑

#### 修改入耳时的行为

编辑 `in_ear_manage.c` 中的 `ear_detect_in_deal()`：

```c
static void ear_detect_in_deal()
{
    // ... 原有逻辑

    // 添加自定义逻辑
    if (bt_get_total_connect_dev()) {
        // 例如：入耳时切换 EQ 模式
        // user_eq_mode_switch(EQ_MODE_NORMAL);

        // 例如：入耳时调整音量
        // app_audio_set_volume(APP_AUDIO_CURRENT_STATE, 15);
    }
}
```

#### 修改出耳时的行为

编辑 `in_ear_manage.c` 中的 `ear_detect_out_deal()`：

```c
static void ear_detect_out_deal()
{
    // ... 原有逻辑

    // 添加自定义逻辑
    if (bt_get_total_connect_dev()) {
        // 例如：出耳时保存当前音量
        // user_volume_save();
    }
}
```

### 调试技巧

#### 1. 使能详细日志

在 `in_ear_detect.c` 和 `in_ear_manage.c` 中已定义：

```c
#define LOG_INFO_ENABLE
#include "debug.h"
```

可以添加更多调试日志：

```c
log_info("current state: %d, tws state: %d", __this->cur_state, __this->tws_state);
```

#### 2. 监控检测状态

添加调试定时器：

```c
static void debug_ear_detect_status(void *priv)
{
    printf("[EAR_DETECT] cur:%d tws:%d music_en:%d in_cnt:%d out_cnt:%d\n",
        __this->cur_state,
        __this->tws_state,
        __this->music_en,
        _ear_detect_t.in_cnt,
        _ear_detect_t.out_cnt
    );
}

// 在 ear_detect_init() 中添加
sys_timer_add(NULL, debug_ear_detect_status, 1000);  // 1秒打印一次
```

#### 3. 测试消抖参数

修改 `ear_detect_cfg` 中的消抖参数：

```c
const struct ear_detect_platform_data ear_detect_cfg = {
    .ear_det_in_cnt = 5,    // 增加入耳消抖次数
    .ear_det_out_cnt = 3,   // 增加出耳消抖次数
    // ...
};
```

根据实际硬件调整消抖次数，避免误触发。

#### 4. 禁用特定功能

可以通过宏定义快速禁用某些功能：

```c
// 禁用音乐控制
#define TCFG_EAR_DETECT_MUSIC_CTL_EN    0

// 禁用通话链路控制
#define TCFG_EAR_DETECT_CALL_CTL_SCO    0

// 禁用按键控制
#define TCFG_EAR_DETECT_CTL_KEY         0
```

### 常见问题

#### 问题 1：入耳检测不灵敏

**可能原因：**

1. 消抖次数过多
2. 检测周期过长
3. 硬件安装位置不佳

**解决方案：**

```c
// 减少消抖次数
.ear_det_in_cnt = 2,
.ear_det_out_cnt = 1,

// 缩短 IR 休眠时间
.ear_det_ir_disable_time = 200,  // 从 300ms 改为 200ms
```

#### 问题 2：频繁误触发

**可能原因：**

1. 消抖次数过少
2. 检测电平配置错误
3. 硬件干扰

**解决方案：**

```c
// 增加消抖次数
.ear_det_in_cnt = 5,
.ear_det_out_cnt = 4,

// 使能太阳光补偿（IR 模式）
.ear_det_ir_compensation_en = 1,
```

#### 问题 3：TWS 模式下音乐控制异常

**可能原因：**

1. 两只耳机状态不同步
2. 音乐状态检测未完成

**解决方案：**

```c
// 增加音乐状态检测次数
.ear_det_music_play_cnt = 30,   // 从 20 改为 30
.ear_det_music_pause_cnt = 20,  // 从 10 改为 20
```

#### 问题 4：入耳时按键被过滤

**可能原因：**

`TCFG_KEY_IN_EAR_FILTER_ENABLE = 1` 且入耳瞬间按键被按下

**解决方案：**

```c
// 禁用按键过滤
#define TCFG_KEY_IN_EAR_FILTER_ENABLE   0

// 或增加按键延迟时间
.ear_det_key_delay_time = 500,  // 入耳后 500ms 才使能按键
```

#### 问题 5：通话时主从切换失败

**可能原因：**

1. 切换延迟时间过短
2. 通话链路不稳定

**解决方案：**

```c
// 增加切换延迟
__this->change_master_timer = sys_timeout_add(
    NULL,
    ear_detect_change_master_timeout_deal,
    3000  // 从 2000ms 改为 3000ms
);
```

---

## 总结

入耳检测功能是一个完整的软硬件协同系统，涉及：

1. **底层驱动**：GPIO 配置、定时器管理、状态采集
2. **中间层管理**：事件分发、状态管理、TWS 同步
3. **应用层控制**：音乐控制、通话控制、按键管理

通过本文档，开发者可以：

- 理解入耳检测的完整工作流程
- 掌握配置参数的含义和调整方法
- 学会添加自定义功能和调试技巧
- 解决常见的入耳检测问题

如有疑问，请参考源代码或联系技术支持。
