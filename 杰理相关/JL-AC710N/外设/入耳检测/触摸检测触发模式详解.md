# 触摸检测触发模式详解

## 问题背景

在分析触摸式入耳检测的触发模式（TOUCH_MODE=0）时，发现以下疑问：

1. **触发模式是什么意思？**
   1. 利用硬件边沿变化中断机制。

2. **为什么在 `ear_touch_edge_wakeup_handle()` 中没有看到IO口的初始化？**
   1. 在前面，后面是通用初始化。


---

## 1. 触发模式的含义

### 两种检测模式对比

| 特性 | 定时模式 (MODE=1) | 触发模式 (MODE=0) |
|------|-------------------|-------------------|
| **检测方式** | 主动轮询 | 被动中断 |
| **触发条件** | 定时器到期 | IO电平变化 |
| **检测周期** | 固定周期(10ms) | 实时响应 |
| **功耗** | 较高(持续运行定时器) | 极低(仅在变化时唤醒) |
| **响应速度** | 取决于定时器周期 | 立即响应(硬件中断) |
| **适用场景** | 通用场景 | 低功耗场景 |

### 触发模式的工作原理

**核心思想：利用硬件边沿中断实现零功耗检测**

```
正常运行态                    低功耗休眠态
    │                             │
    │  检测到入耳/出耳              │  等待IO电平变化
    │  处理事件                    │  系统可进入sniff
    │  配置反向边沿中断             │  功耗极低
    │                             │
    └──────────────────────────────┘
              ↑         │
              │         │
              │         ↓
         IO电平变化
         硬件自动唤醒
         触发中断回调
```

**关键机制：动态边沿切换**

```c
// 当前是高电平(入耳) → 配置下降沿中断 → 等待低电平(出耳)
if (io_state) {
    p33_io_wakeup_edge(TCFG_EAR_DETECT_DET_IO, FALLING_EDGE);
}
// 当前是低电平(出耳) → 配置上升沿中断 → 等待高电平(入耳)
else {
    p33_io_wakeup_edge(TCFG_EAR_DETECT_DET_IO, RISING_EDGE);
}
```

**工作流程：**

```
1. 初始化时读取IO状态 → 判断初始状态(入耳/出耳)
                      ↓
2. 根据当前状态配置反向边沿中断
   (如果当前高电平，配置下降沿中断；如果当前低电平，配置上升沿中断)
                      ↓
3. 系统进入低功耗状态，等待IO电平变化
                      ↓
4. IO电平变化 → 硬件自动唤醒 → 触发边沿中断
                      ↓
5. 执行中断回调 ear_touch_edge_wakeup_handle()
   ├─ 读取新的IO状态
   ├─ 判断入耳/出耳
   ├─ 发送事件
   └─ 重新配置反向边沿中断
                      ↓
6. 回到步骤3，继续等待
```

---

## 2. IO初始化在哪里？

### 完整的初始化调用链

```
ear_detect_init() [in_ear_manage.c:881]
    ↓
    ├─→ (1) 触发模式特定初始化
    │       ├─→ ear_detect_tch_wakeup_init()     [in_ear_detect.c:174]
    │       │   └─→ gpio_set_mode(DET_IO, PORT_INPUT_PULLUP_10K)  ← IO初始化!!! 默认直接将IO配置为上拉输入状态。
    │       │
    │       └─→ in_ear_port_edge_wakeup_callback(0, DET_IO)//这里手动调用一次中断回调的处理函数，为后面的反复开个头
    │           └─→ ear_touch_edge_wakeup_handle(0, DET_IO)
    │               ├─→ gpio_read(DET_IO)              # 读取初始状态
    │               ├─→ 产生初始入耳/出耳事件
    │               └─→ p33_io_wakeup_edge()           # 配置边沿中断 等待边沿电平变换调用回调函数
    │
    └─→ (2) 通用初始化
        └─→ ear_detect_tch_init(&ear_detect_cfg)      [in_ear_detect.c:284]
            └─→ ear_touch_edge_wakeup_handle(0, DET_IO)  # 这里又手动调用一次
```

### 代码实现详解

#### (1) IO初始化：ear_detect_tch_wakeup_init()

```c
// in_ear_detect.c:174-179
void ear_detect_tch_wakeup_init(void)
{
    log_info("%s\n", __func__);

    // ========== IO初始化：配置为上拉输入模式 ==========
    gpio_set_mode(IO_PORT_SPILT(TCFG_EAR_DETECT_DET_IO), PORT_INPUT_PULLUP_10K);
}
```

**作用：**
- 将检测IO配置为**输入模式**
- 使能**10K内部上拉电阻**
- 为后续的电平读取和边沿检测做准备

**为什么需要上拉？**

- 触摸传感器通常是**开漏输出**或**漏极开路**
- 入耳时：传感器拉低 → IO读到低电平
- 出耳时：传感器释放 → 上拉电阻将IO拉高 → IO读到高电平

#### (2) 初始状态判断：ear_touch_edge_wakeup_handle()

```c
// in_ear_manage.c:746-780
void ear_touch_edge_wakeup_handle(u8 index, u8 gpio)
{
    log_info("%s", __func__);
    u8 io_state = 0;
    ASSERT(gpio == TCFG_EAR_DETECT_DET_IO);

    // ========== 1. 读取当前 IO 状态 ==========
    io_state = gpio_read(TCFG_EAR_DETECT_DET_IO);
    printf("gpio_read(TCFG_EAR_DETECT_DET_IO)==%d", io_state);

    // ========== 2. 根据状态产生初始事件 ==========
    if (io_state == TCFG_EAR_DETECT_DET_LEVEL) {
        log_info("earphone touch in\n");

        #if TCFG_KEY_IN_EAR_FILTER_ENABLE
        extern u8 io_key_filter_flag;
        if (gpio_read(IO_PORTB_01) == 0) {
            io_key_filter_flag = 1;
        } else {
            io_key_filter_flag = 0;
        }
        #endif

        // 触发入耳事件
        ear_detect_change_state_to_event(TCFG_EAR_DETECT_DET_LEVEL);
    } else {
        log_info("earphone touch out\n");

        // 触发出耳事件
        ear_detect_change_state_to_event(!TCFG_EAR_DETECT_DET_LEVEL);
    }

    // ========== 3. 配置边沿中断 ==========
    if (io_state) {
        // 当前高电平 → 配置下降沿中断 → 等待变为低电平
        p33_io_wakeup_edge(TCFG_EAR_DETECT_DET_IO, FALLING_EDGE);
    } else {
        // 当前低电平 → 配置上升沿中断 → 等待变为高电平
        p33_io_wakeup_edge(TCFG_EAR_DETECT_DET_IO, RISING_EDGE);
    }
}
```

**作用：**
1. **读取初始状态**：系统启动时判断耳机是否已经在耳朵上
2. **产生初始事件**：确保应用层能获得正确的初始状态
3. **配置边沿中断**：设置对应的唤醒边沿，准备响应后续变化

##### p33_io_wakeup_edge 函数深度解析

- 设置低功耗唤醒源部分看文档。

#### (3) 中断回调注册

```c
void ear_detect_init(void)
{
    printf("ear_detect_init");
    log_info("%s", __func__);
    ASSERT(&ear_detect_cfg);
    __this->cfg = &ear_detect_cfg;

#if TCFG_EAR_DETECT_ENABLE
#if (TCFG_EAR_DETECT_TYPE == EAR_DETECT_BY_TOUCH) && (!TCFG_EAR_DETECT_TOUCH_MODE)
	void ear_detect_tch_wakeup_init(void);
	ear_detect_tch_wakeup_init();
	// p33_io_wakeup_set_callback(TCFG_EAR_DETECT_DET_IO,in_ear_port_edge_wakeup_callback);
    // in_ear_port_edge_wakeup_callback();
    in_ear_port_edge_wakeup_callback(0,TCFG_EAR_DETECT_DET_IO);//这里有一次，这个唤醒源写死了，说明根本不是回调。
#endif
#endif

#if (TCFG_EAR_DETECT_TYPE == EAR_DETECT_BY_IR)
    ear_detect_ir_init(&ear_detect_cfg);
#elif (TCFG_EAR_DETECT_TYPE == EAR_DETECT_BY_TOUCH)
    ear_detect_tch_init(&ear_detect_cfg);//这里面有一次
#endif

}
__initcall(ear_detect_init);
```

使用`p33_io_wakeup_edge(TCFG_EAR_DETECT_DET_IO, FALLING_EDGE);`后。边沿发生变化触发中断后一定会调用`in_ear_port_edge_wakeup_callback`，我没有看见注册或者绑定啊？`p33_io_wakeup_edge`使用这个是不是把耳机唤醒了？如果是关机状态的话？

入耳检测的中断处理函数中核心是`ear_touch_edge_wakeup_handle`，在通用初始化时调用了两次处理感觉有一点多余：

- 两次会不会冗余了？
  - 老接口不删除！写的一坨屎！
-  `in_ear_port_edge_wakeup_callback(0,TCFG_EAR_DETECT_DET_IO);`这里有一次，这个唤醒源写死了，说明根本不是中断回调。

- `cpu\br52\power\power_config.c`

```c
#if TCFG_EAR_DETECT_ENABLE
#if (TCFG_EAR_DETECT_TYPE == EAR_DETECT_BY_TOUCH) && (!TCFG_EAR_DETECT_TOUCH_MODE)
struct _p33_io_wakeup_config port2 = {
	.pullup_down_mode = ENABLE,                            //配置I/O 内部上下拉是否使能
	.edge               = !TCFG_EAR_DETECT_DET_LEVEL,                            //唤醒方式选择,可选：上升沿\下降沿
    .filter             = PORT_FLT_16ms,
	.gpio              = TCFG_EAR_DETECT_DET_IO,                             //唤醒口选择
};
#endif
#endif


#if TCFG_EAR_DETECT_ENABLE
static const struct wakeup_param wk_param = {
    #if (TCFG_EAR_DETECT_TYPE == EAR_DETECT_BY_TOUCH) && (!TCFG_EAR_DETECT_TOUCH_MODE)
	.port[0] = &port2,
#endif
};
#endif

#if TCFG_EAR_DETECT_ENABLE
static void port_wakeup_callback(u8 index, u8 gpio)
{
    switch (index) {
#if (TCFG_TEST_BOX_ENABLE || TCFG_CHARGESTORE_ENABLE || TCFG_ANC_BOX_ENABLE)
    case 2:
        extern void chargestore_ldo5v_fall_deal(void);
        chargestore_ldo5v_fall_deal();
        break;
#endif
#if TCFG_EAR_DETECT_ENABLE
#if ((TCFG_EAR_DETECT_TYPE == EAR_DETECT_BY_TOUCH) && (!TCFG_EAR_DETECT_TOUCH_MODE))
	if (gpio == TCFG_EAR_DETECT_DET_IO) {
		ear_touch_edge_wakeup_handle(index, gpio);
	}
#endif
#endif /* #if TCFG_EAR_TCH_ENABLE */

    }
}
#endif
```

##### 两种回调注册方式

系统支持两种不同的回调注册机制：

**方式一：通过结构体 callback 成员直接注册（针对单个 GPIO）**

```c
// 示例：按键唤醒 (key_wakeup.c:20-26)
static struct _p33_io_wakeup_config port0 = {
    .pullup_down_mode = PORT_INPUT_PULLUP_10K,
    .filter           = PORT_FLT_DISABLE,
    .edge             = FALLING_EDGE,
    .gpio             = IO_PORTB_01,
    .callback         = key_wakeup_callback,  // ← 直接指定回调函数
};

void key_wakeup_init()
{
    p33_io_wakeup_port_init(&port0);
    p33_io_wakeup_enable(port0.gpio, 1);
}
```

这种方式下，当检测到 IO_PORTB_01 的边沿变化时，会直接调用 `key_wakeup_callback` 函数。

**方式二：通过 wk_param 结构和统一回调函数（用于多个 GPIO）**

```c
// 入耳检测配置 (power_config.c:42-57)
struct _p33_io_wakeup_config port2 = {
    .pullup_down_mode = ENABLE,
    .edge             = !TCFG_EAR_DETECT_DET_LEVEL,
    .filter           = PORT_FLT_16ms,
    .gpio             = TCFG_EAR_DETECT_DET_IO,
    // 注意：没有设置 .callback 成员
};

static const struct wakeup_param wk_param = {
    .port[0] = &port2,  // 将配置添加到唤醒参数数组
};
```

当配置结构中**没有设置 callback 成员**时，系统会使用**同一文件中定义的 `port_wakeup_callback` 函数**作为默认回调。

**关键点：**

- `port_wakeup_callback` 是一个 `static` 函数，没有显式的外部注册代码
- 它的注册是通过**约定命名**和**编译时链接**实现的
- 底层驱动库会在 `power_config.c` 文件中查找名为 `port_wakeup_callback` 的函数
- 如果 `wk_param.port[x]` 配置的结构体没有设置 `callback` 成员，就会调用这个函数
- 函数参数 `index` 对应 `wk_param.port[]` 的数组索引，`gpio` 是触发的 GPIO 引脚号

**in_ear_port_edge_wakeup_callback 的实际作用：**

1. **不是中断回调**：这个函数**不会被硬件中断自动调用**
2. **初始化时手动调用**：在初始化时被手动调用一次（第 894 行）
3. **目的**：读取初始的入耳/出耳状态，并配置相应的唤醒边沿
4. **历史遗留**：第 892 行被注释掉的代码表明，这个函数原本设计为通过 `p33_io_wakeup_set_callback` 注册，但现在改用 `port_wakeup_callback` 统一处理

### 中断触发流程

**当IO电平变化时：**

```
硬件检测到边沿变化
    ↓
power_config.c 中的唤醒处理
    ↓
port_edge_wakeup_handler()
    ↓
调用注册的回调函数
    ↓
in_ear_port_edge_wakeup_callback(index, gpio) [in_ear_manage.c:868]
    ↓
ear_touch_edge_wakeup_handle(index, gpio)
    ├─→ 读取新的IO状态
    ├─→ 判断入耳/出耳
    ├─→ 发送事件到应用层
    └─→ 重新配置反向边沿中断
```

---

## 3. 关键代码位置总结

| 功能 | 文件 | 行号 | 说明 |
|------|------|------|------|
| **IO初始化** | `in_ear_detect.c` | 174-179 | `ear_detect_tch_wakeup_init()` |
| **初始状态判断** | `in_ear_manage.c` | 746-780 | `ear_touch_edge_wakeup_handle()` |
| **边沿中断配置** | `in_ear_manage.c` | 770-779 | `p33_io_wakeup_edge()` |
| **中断回调注册** | `in_ear_manage.c` | 868-879 | `in_ear_port_edge_wakeup_callback()` |
| **总初始化入口** | `in_ear_manage.c` | 881-905 | `ear_detect_init()` |

## 5. 定时模式 vs 触发模式

### 定时模式的IO初始化

```c
// in_ear_detect.c:181-224
void __ear_detect_tch_run(void *priv)
{
    if (__this->check_status == DETECT_IDLE) {
        __this->check_status = DETECT_CHECKING;

        // ========== 每次检测时重新配置IO ==========
        gpio_set_mode(IO_PORT_SPILT(TCFG_EAR_DETECT_DET_IO), PORT_INPUT_PULLUP_10K);

        sys_hi_timer_modify(__this->s_hi_timer, 2);
        return;
    }

    // ... 读取IO状态并判断 ...

    // ========== 检测完毕，IO切换到高阻态省电 ==========
    __this->check_status = DETECT_IDLE;
    gpio_set_mode(IO_PORT_SPILT(TCFG_EAR_DETECT_DET_IO), PORT_HIGHZ);
    sys_hi_timer_modify(__this->s_hi_timer, 10);
}
```

**特点：**
- IO配置在**定时器回调内部**
- 每次检测时才使能上拉
- 检测完毕切换到高阻态以省电
- 周期性重复：`高阻态(10ms) → 上拉检测(2ms) → 高阻态(10ms) → ...`

### 触发模式的IO初始化

```c
// in_ear_detect.c:174-179
void ear_detect_tch_wakeup_init(void)
{
    // ========== IO配置一次，永久有效 ==========
    gpio_set_mode(IO_PORT_SPILT(TCFG_EAR_DETECT_DET_IO), PORT_INPUT_PULLUP_10K);
}
```

**特点：**
- IO配置在**初始化阶段一次性完成**
- **始终保持上拉输入模式**
- 无需周期性切换，依赖硬件边沿检测
- 功耗主要来自上拉电阻(可忽略不计)

---

## 6. 触发模式的优势

### 功耗对比

| 模式 | 定时器运行 | IO切换频率 | 系统唤醒频率 | 估算功耗 |
|------|-----------|-----------|-------------|---------|
| **定时模式** | 10ms周期 | 每10ms切换2次 | 每10ms唤醒1次 | 较高 |
| **触发模式** | 不运行 | 0(仅初始化1次) | 仅状态变化时 | 极低 |

### 响应速度对比

```
场景：用户佩戴耳机的瞬间

定时模式：
    用户佩戴
        ↓
    等待定时器周期(最长10ms)
        ↓
    读取IO → 判断入耳 → 响应
    平均延迟：5ms

触发模式：
    用户佩戴
        ↓
    硬件立即检测到边沿 → 触发中断 → 响应
    延迟：<1ms (硬件中断级别)
```

### 系统资源占用对比

| 资源 | 定时模式 | 触发模式 |
|------|---------|---------|
| **定时器** | 占用1个高优先级定时器 | 不占用 |
| **中断** | 不使用 | 使用GPIO边沿中断 |
| **CPU唤醒** | 每10ms唤醒1次 | 仅状态变化时 |
| **Sniff模式** | 定时器运行期间无法进入 | 可随时进入 |

---

## 7. 实际应用建议

### 何时使用触发模式？

✅ **推荐场景：**
- TWS耳机(对功耗敏感)
- 待机时间要求长的产品
- 硬件支持可靠的边沿检测
- 传感器输出稳定(无抖动)

❌ **不推荐场景：**
- 传感器输出不稳定(频繁抖动)
- 硬件不支持边沿唤醒
- 需要高频采样(如用于手势识别)

## 8. 总结

### 触发模式的核心要点

1. **本质**：利用硬件边沿中断实现被动检测，替代软件定时器主动轮询
2. **IO初始化**：在 `ear_detect_tch_wakeup_init()` 中完成，配置为上拉输入
3. **初始状态判断**：在 `ear_touch_edge_wakeup_handle()` 中读取并产生初始事件
4. **动态边沿切换**：根据当前状态配置反向边沿，确保能检测到下一次变化
5. **功耗优势**：仅在状态变化时唤醒，其余时间系统可进入深度休眠
