# 电量防抖机制分析报告

## 概述

本文档详细分析 `apps/earphone/power_manage/app_power_manage.c` 中的电量管理和防抖处理机制，重点关注为什么虽然有 `remap_calculate_vbat_percent` 函数防抖，但电量仍会以 10% 的速度跳变。

---

## 一、电量检测架构

### 1.1 电量检测定时器体系

系统使用双定时器机制进行电量检测：

```c
static int vbat_slow_timer = 0;   // 慢速定时器
static int vbat_fast_timer = 0;   // 快速定时器
```

**定时器配置：**

| 定时器 | 周期 | 触发条件 | 作用 |
|--------|------|----------|------|
| `vbat_slow_timer` | 充电时 60s<br>非充电时 10s | 始终运行 | 触发 `vbat_check_slow()` |
| `vbat_fast_timer` | 10ms | 由慢速定时器启动 | 执行 `vbat_check()` |

**初始化流程（vbat_check_init）：**
```c
void vbat_check_init(void)
{
    percent_save_init();  // 初始化保存的电量百分比
    if (vbat_slow_timer == 0) {
        vbat_slow_timer = sys_timer_add(NULL, vbat_check_slow, 10 * 1000);
    }
    if (vbat_fast_timer == 0) {
        vbat_fast_timer = usr_timer_add(NULL, vbat_check, 10, 1);
    }
}
```

### 1.2 电量读取流程

```
ADC采样 → 电压滤波 → 电压转百分比 → 防抖处理 → 百分比转级别 → 上报手机
```

---

- 以为是上报十个级别，所以手机只能以10%的速度变化。

## 二、核心函数分析

### 2.1 `vbat_check()` - 电量采样与检测

**功能：** 每 10ms 执行一次，采样电池电压并进行滤波

```c
void vbat_check(void *priv)
{
    static u8 unit_cnt = 0;

    // 电压滤波：新值与旧值取平均
    if (!bat_val) {
        bat_val = get_vbat_level();
    } else {
        bat_val = (get_vbat_level() + bat_val) / 2;  // ⚠️ 简单滤波
    }

    // 将电压转换为电量级别（0-9级）
    cur_battery_level = battery_value_to_phone_level(bat_val);

    unit_cnt++;

    // 每 6 次采样（60ms）进行一次电量判断
    if (unit_cnt >= VBAT_DETECT_CNT) {  // VBAT_DETECT_CNT = 6
        // ... 低电检测逻辑

        // 电量变化检测
        if (cur_battery_level != old_battery_level) {
            power_event_to_user(POWER_EVENT_POWER_CHANGE);  // 触发电量变化事件
        }
        old_battery_level = cur_battery_level;
        unit_cnt = 0;
    }
}
```

**关键点：**
- ✅ 电压采样使用滑动平均滤波（但仅与上一次取平均，滤波效果有限）
- ✅ 每 60ms 判断一次电量变化
- ⚠️ 比较的是 `cur_battery_level`（0-9级），而不是百分比

---

### 2.2 `get_vbat_level()` - 获取电池电压

**功能：** 从 ADC 读取电池电压

```c
u16 get_vbat_level(void)
{
    return (adc_get_voltage(AD_CH_VBAT) * 4 / 10);  // 返回单位：0.01V
}
```

**说明：**
- 返回值单位为 0.01V（例如：405 = 4.05V）
- 直接调用底层 ADC 接口，无缓存
- 返回的值原本是四位，因为除以10，所以是三位。根据电量映射表格能够对应上。

---

### 2.3 `get_vbat_percent()` - 获取电量百分比

**功能：** 将电池电压转换为百分比

```c
u8 get_vbat_percent(void)
{
    u16 tmp_bat_val;
    //返回采集的电压值
    u16 bat_val = get_vbat_level();
    //这里会获取满电电压的电压值，内置充电的话，有一个计算：板级文件中有赋值，根据选择的挡位换算成实际的电压值，做减小处理，防止达不到。出来的依旧是三位数。
    //不是内置充电的话，直接指定满电电压为420
    if (battery_full_value == 0) {
#if TCFG_CHARGE_ENABLE
        battery_full_value = (get_charge_full_value() - 100) / 10; //防止部分电池充不了这么高电量，充满显示未满的情况
#else
        battery_full_value = 420;
#endif
    }

    //如果获取出来的三位数电压值小于关机电压的话，直接返回0%的百分比
    if (bat_val <= app_var.poweroff_tone_v) {
        return 0;
    }
	
    //如果是大于关机电压的话，进入防抖流程处理并映射出电池百分比
    tmp_bat_val = remap_calculate_vbat_percent(bat_val);
    
    //
    // if (!tmp_bat_val) {
    //     tmp_bat_val = ((u32)bat_val - app_var.poweroff_tone_v) * 100 / (battery_full_value - app_var.poweroff_tone_v);
    //     if (tmp_bat_val > 100) {
    //         tmp_bat_val = 100;
    //     }
    // }
    return (u8)tmp_bat_val;
}
```

**问题点：**
- ⚠️ 重新调用 `get_vbat_level()`，而不是使用 `vbat_check()` 中滤波后的 `bat_val`
- 这导致防抖处理使用的是未经充分滤波的原始电压值

---

### 2.4 `remap_calculate_vbat_percent()` - 核心防抖函数

这是整个电量管理的核心函数，负责将电压映射到百分比并进行防抖处理。

```c
__attribute__((weak)) u8 remap_calculate_vbat_percent(u16 bat_val)
{
    u8 i = 0;
    u8 percent = 0;
    u8 temp_percent = percent_save;
    static u32 time_ms = 0;
    
    //获取的三位电压值大于映射表中的90%的上限就返回100%
    if(bat_val >= vbat_value_to_percent[0].upper){
        percent = 100;
        local_detail_percent = 100;
        //不是静态变量，有必要赋值吗？
        i = 0;
    }
    //小于映射表中的0%的下限。整个数组大小有10个等级，最大下标就是10-1=9。
    else if(bat_val < vbat_value_to_percent[ARRAY_SIZE(vbat_value_to_percent) - 1].lower){
        //百分比就是10%
        percent = 10;
        //精确一点就是0%
        local_detail_percent = 0;
        //下面会算的，这里赋值有用吗？
        i = ARRAY_SIZE(vbat_value_to_percent) - 1;
    }
    else{
        //获取的三位电压值在映射表的区间中。开始遍历映射表得出具体在哪里区间
        for (i = 0; i < ARRAY_SIZE(vbat_value_to_percent); i++)
        {
            if(bat_val >= vbat_value_to_percent[i].lower && bat_val < vbat_value_to_percent[i].upper){
                //进入某一个具体百分比区间，计算初略的百分比以及详细到个位的百分比
                percent = vbat_value_to_percent[i].level;
                local_detail_percent = vbat_value_to_percent[i].level + 9*(bat_val - vbat_value_to_percent[i].lower)/(vbat_value_to_percent[i].upper - vbat_value_to_percent[i].lower);
                //从高到低依次遍历寻找，找到了就退出。
                break;
            }
        }
    }
    //经过上面三次判断，初略百分比要比100%，要么10%，要么在区间内90%-0%。
    if(percent > 100){
        percent = 100;
    }
    else if(percent < 10){
        //这里只是针对初略百分比为0%的处理，只有第三种情况计算后会进入到这里来。
        percent = 10;
    }
    
    //第一次开直接赋值
    //已经开机的情况下，满足某一个条件时再一次更新temp_percent
    //当计算后的percent小于上电开机第一次赋值给temp_percent的百分比时，且两者差距绝对值大于百分之二十了。
    if(temp_percent == 0xff 
        || (is_power_up && sys_timer_get_ms() < 2000 && get_lvcmp_det() == 0 
        && percent < temp_percent && abs((int)(temp_percent/10*10) - (int)(percent)) > 20))
    {
        printf("temp_percent abnormal, reset!!!\n");
        //第一次上电temp_percent必定是0xff，那么就把计算后的初略百分比percent赋值给temp_percent
        //后续，如果当保存的电量与实际检测的电量百分比相差20%以上，就会强制更新。
        temp_percent = percent;//第一次上电开机，重置电量
    }
    if(get_charge_online_flag()){//if(get_lvcmp_det()){ //充电中
        if(sys_timer_get_ms() >= time_ms + CHARGING_POWER_PERCENT_UPDATE_TIME){
            time_ms = sys_timer_get_ms();
            if(temp_percent < percent){
                //充电的话，电量只能增加。进入充电一瞬间，percent有浮压肯定变化大，但是temp_percent不能变化太剧烈不然很突兀
                //在充电中上次保存的电量百分比肯定小于当前检测的（因为一直在充电。）
                //慢慢递增
                temp_percent++; //只允许变大
            }
            //打印实际检测出来的三位电压值，计算出来的初略百分比，要上传的百分比，保存的百分比，计算出来的详细百分比
            printf("bat_val %d --> percent %d, temp_percent %d %d %d\n", bat_val, percent, temp_percent, percent_save, local_detail_percent);
        }
        //避免充电temp_percent累加太慢，这里做一个判断
        if(percent == 100 && temp_percent > 90 && bat_val >= 414){
            temp_percent = 100;//避免跳100慢
        }
    }
    else{ //非充电中
        if(sys_timer_get_ms() >= time_ms + NORMAL_POWER_PERCENT_UPDATE_TIME){
            time_ms = sys_timer_get_ms();
            u8 change = 0;
            //非充电中，percent肯定小于开机上电赋值给temp_percent的百分比。
            //这里也要慢慢追赶防止变化剧烈
            //非充电中，上次保存的电量百分比肯定大于当前的电量百分比
            if(temp_percent > percent){
                temp_percent--; //只允许变小
            }
            printf("bat_val %d --> percent %d, temp_percent %d %d %d\n", bat_val, percent, temp_percent, percent_save, local_detail_percent);
        }
    }
    //按道理来说这个是根据初略百分比经过防抖处理后的百分比，是可以实现个位数精度的。
    //然后赋值给保存的电量值并返回。
    //感觉可以根据当前计算的精确百分比做一个平均值处理，校准一下。但是原本的流程就可以实现%1的充电与耗电了。
    percent_save = temp_percent;
    return percent_save;
}
```

#### 2.4.1 电压到百分比映射表

```c
const struct VBAT_V_TO_LEVEL vbat_value_to_percent[] = {
    //  上限   下限   百分比
    {  405,   396,   90  },  // 4.05V - 3.96V → 90%
    {  396,   390,   80  },  // 3.96V - 3.90V → 80%
    {  393,   386,   70  },  // 3.93V - 3.86V → 70%
    {  386,   380,   60  },  // 3.86V - 3.80V → 60%
    {  380,   377,   50  },  // 3.80V - 3.77V → 50%
    {  377,   370,   40  },  // 3.77V - 3.70V → 40%
    {  370,   360,   30  },  // 3.70V - 3.60V → 30%
    {  360,   340,   20  },  // 3.60V - 3.40V → 20% (LOW_POWER_WARN_VAL=340)
    {  340,   330,   10  },  // 3.40V - 3.30V → 10% (LOW_POWER_OFF_VAL=330)
    {  330,   300,   0   },  // 3.30V - 3.00V → 0%  (LOW_POWER_SHUTDOWN=300)
};
```

**映射算法：**
```c
// 精细百分比计算（每个区间内线性插值）
local_detail_percent = vbat_value_to_percent[i].level
                     + 9 * (bat_val - vbat_value_to_percent[i].lower)
                         / (vbat_value_to_percent[i].upper - vbat_value_to_percent[i].lower);

// 粗略百分比（直接取区间级别）
percent = vbat_value_to_percent[i].level;
```

**示例：**
- 假设电压 = 398 (3.98V)，落在第一个区间 [396, 405]
- `percent = 90`（粗略值）
- `local_detail_percent = 90 + 9 * (398 - 396) / (405 - 396) = 90 + 2 = 92`（精细值）

---

#### 2.4.2 防抖策略

**防抖参数：**

| 状态 | 更新周期 | 变化速率 | 防抖方式 |
|------|----------|----------|----------|
| 充电中 | 33秒 | 每次 +1% | 只允许递增 |
| 非充电 | 8秒 | 每次 -1% | 只允许递减 |

**核心防抖代码：**

```c
u8 remap_calculate_vbat_percent(u16 bat_val)
{
    u8 percent = 0;              // 从电压映射得到的目标百分比
    u8 temp_percent = percent_save;  // 上次保存的百分比
    static u32 time_ms = 0;

    // 1. 根据电压计算目标百分比（通过映射表）
    // ... 省略映射逻辑 ...

    // 2. 充电状态下的防抖
    if(get_charge_online_flag()) {
        if(sys_timer_get_ms() >= time_ms + CHARGING_POWER_PERCENT_UPDATE_TIME) {
            time_ms = sys_timer_get_ms();
            if(temp_percent < percent) {
                temp_percent++;  // ✅ 每33秒最多增加1%
            }
            printf("充电: bat_val %d → percent %d, temp_percent %d\n",
                   bat_val, percent, temp_percent);
        }

        // 快速跳到100%的优化
        if(percent == 100 && temp_percent > 90 && bat_val >= 414) {
            temp_percent = 100;  // ⚠️ 跳过91-99%，直接到100%
        }
    }
    // 3. 非充电状态下的防抖
    else {
        if(sys_timer_get_ms() >= time_ms + NORMAL_POWER_PERCENT_UPDATE_TIME) {
            time_ms = sys_timer_get_ms();
            if(temp_percent > percent) {
                temp_percent--;  // ✅ 每8秒最多减少1%
            }
            printf("放电: bat_val %d → percent %d, temp_percent %d\n",
                   bat_val, percent, temp_percent);
        }
    }

    percent_save = temp_percent;  // 保存当前百分比
    return percent_save;
}
```

**防抖机制总结：**
- ✅ **时间防抖**：通过固定时间间隔限制更新频率
- ✅ **单调性保证**：充电只增不减，放电只减不增
- ✅ **速率限制**：每次最多变化1%
- ⚠️ **特殊情况**：接近满电时会跳过中间值直接到100%

---

#### 2.4.3 上电异常处理

```c
if(temp_percent == 0xff
   || (is_power_up && sys_timer_get_ms() < 2000
       && get_lvcmp_det() == 0
       && percent < temp_percent
       && abs((int)(temp_percent/10*10) - (int)(percent)) > 20))
{
    printf("temp_percent abnormal, reset!!!\n");
    temp_percent = percent;  // 重置电量
}
```

**触发条件：**
1. 首次上电（`temp_percent == 0xff`）
2. 上电2秒内，未充电状态下，新电量比保存值低20%以上
   1. 直接更新为当前检测的实际电压百分比


**作用：** 防止电量显示异常（如长时间未使用后电量自放电）

---

### 2.5 `battery_value_to_phone_level()` - 转换为手机电量级别

**这是导致10%跳变的关键函数！**

```c
u8 battery_value_to_phone_level(u16 bat_val)
{
    u8 battery_level = 0;
    //这里面出来的值在0%-100%之间，但是手机只能显示十个等级，所以这做了处理。
    u8 vbat_percent = get_vbat_percent();  // 获取防抖后的百分比

    if (vbat_percent < 5) {
        return 0;  // 小于5%显示为0级（手机显示10%）
    }

    // ⚠️ 核心转换逻辑：将0-100%映射到0-9级
    //百分比大于6时。6，7，8，9，10%以及以上。除以10进行映射等级1-10个等级。
    battery_level = (vbat_percent - 5) / 10;

    return battery_level;
}
```

**转换对照表：**

| 百分比范围 | 级别 | 手机显示 | 说明 |
|-----------|------|----------|------|
| 0% - 4%   | 0    | 10%      | 低电保护 |
| 5% - 14%  | 0    | 10%      |  |
| 15% - 24% | 1    | 20%      |  |
| 25% - 34% | 2    | 30%      |  |
| 35% - 44% | 3    | 40%      |  |
| 45% - 54% | 4    | 50%      |  |
| 55% - 64% | 5    | 60%      |  |
| 65% - 74% | 6    | 70%      |  |
| 75% - 84% | 7    | 80%      |  |
| 85% - 94% | 8    | 90%      |  |
| 95% - 100% | 9   | 100%     |  |

**问题根源：**

尽管 `remap_calculate_vbat_percent()` 函数每次只允许百分比变化1%，但由于：

```
级别 = (百分比 - 5) / 10
```

这意味着每变化10%才会导致级别改变。因此：

- 内部百分比从 84% → 83% → 82% ... → 75%（平滑过渡）
- 但手机显示从 90% 不变，直到百分比降到 74%，手机显示突然跳到 80%
- **表现为10%的跳变！**
  - 手机为百分之10%的跳变没有问题。但是彩屏仓需要精确到个位数。


---

## 三、完整流程时序图

```
[系统启动]
   ↓
percent_save_init()  ← 从VM读取上次保存的百分比
   ↓
vbat_check_init()    ← 启动双定时器
   ↓
┌──────────────────────────────────────────────┐
│  vbat_slow_timer (10s/60s)                   │
│    ↓                                          │
│  vbat_check_slow() ← 启动快速定时器          │
└──────────────────────────────────────────────┘
   ↓
┌──────────────────────────────────────────────┐
│  vbat_fast_timer (10ms)                      │
│    ↓                                          │
│  vbat_check()                                 │
│    ├─ 读取ADC电压                             │
│    ├─ 滤波: bat_val = (new + old) / 2        │
│    ├─ 转换级别: battery_value_to_phone_level()│
│    │     ↓                                    │
│    │   get_vbat_percent()                     │
│    │     ↓                                    │
│    │   remap_calculate_vbat_percent()         │
│    │     ├─ 电压→百分比映射                   │
│    │     ├─ 防抖处理（8s/-1% 或 33s/+1%）     │
│    │     └─ 返回 percent_save                 │
│    │   ← 返回百分比                           │
│    │   转换: (percent - 5) / 10 → 级别(0-9)   │
│    ↓                                          │
│  比较 cur_battery_level 与 old_battery_level   │
│    ├─ 相同 → 不处理                            │
│    └─ 不同 → POWER_EVENT_POWER_CHANGE         │
│              ↓                                │
│         tws_sync_bat_level() (TWS同步)        │
│         user_send_cmd_prepare() (上报手机)    │
└──────────────────────────────────────────────┘
```

---

## 四、问题分析

### 4.1 主要问题：10%跳变现象

**现象描述：**
- 手机显示电量从 90% → 80% → 70% 跳变
- 虽然内部百分比平滑过渡，但外部显示是阶跃变化

**根本原因：**

1. **双重转换机制：**
   ```
   电压 → 百分比(0-100) → 级别(0-9) → 手机显示(10%-100%)
   ```

2. **防抖作用域错位：**
   - 防抖只作用于**百分比**层面（每8秒-1%）
   - 但最终上报的是**级别**（每10%一个台阶）
   - 级别层面没有防抖

3. **量化误差：**
   ```
   百分比 84% → 级别 7 → 手机 80%
   百分比 83% → 级别 7 → 手机 80%  ← 不变
   百分比 82% → 级别 7 → 手机 80%  ← 不变
   ...
   百分比 75% → 级别 7 → 手机 80%  ← 不变
   百分比 74% → 级别 6 → 手机 70%  ← 突变！
   ```

### 4.2 次要问题

#### 问题1：电压采样滤波不足

```c
// vbat_check() 中的滤波
bat_val = (get_vbat_level() + bat_val) / 2;
```

**问题：**
- 只与上一次取平均，滤波深度为1
- 对于突发噪声抑制能力弱
- 建议使用滑动平均（如最近10次的平均值）

#### 问题3：VM存储时机不明确

```c
void percent_save_vm(void)
{
    if(get_charge_full_flag()){
        percent_save = 100;
    }
    set_vm_vbat_percent(percent_save);
}
```

**问题：**
- 函数定义了，但在当前文件中没有定期调用
- 可能导致断电后电量显示不准确
- 建议在电量变化或关机时调用
- `apps\earphone\power_manage\app_power_manage.c`没有调用，但是在其他地方调用了。
  - `sys_enter_soft_poweroff`关机调用一次。
  - `charge_full_deal`冲满电调用一次
  - `charge_ldo5v_off_deal`结束充电调用一次。

- 什么时候获取保存的电量百分比呢？
  - `vbat_check_init`会获取一次
    - `check_power_on_voltage`调用`vbat_check_init`
      - 开机的`app_main`会调用`check_power_on_voltage`


## 七、总结

### 问题本质

**电量以10%速度掉电的根本原因是双重量化机制：**

1. `remap_calculate_vbat_percent()` 的防抖只作用于**百分比**（0-100）
2. `battery_value_to_phone_level()` 将百分比量化为**级别**（0-9）
3. 手机接收的是**级别**，转换为10%步进显示

```
内部：84% → 83% → 82% → ... → 75% → 74%  (平滑)
级别：  7  →  7  →  7  → ... →  7  →  6   (阶跃)
手机： 80% → 80% → 80% → ... → 80% → 70%  (跳变10%)
```

---

## 附录：关键参数配置表

| 参数 | 当前值 | 建议值 | 说明 |
|------|--------|--------|------|
| VBAT_DETECT_CNT | 6 | 6-10 | 电压采样次数 |
| CHARGING_POWER_PERCENT_UPDATE_TIME | 33s | 30-60s | 充电时电量更新周期 |
| NORMAL_POWER_PERCENT_UPDATE_TIME | 8s | 8-15s | 放电时电量更新周期 |
| 滤波深度 | 1 (无效) | 10-20 | 滑动平均缓冲区大小 |
| 级别变化确认时间 | 0 (无) | 30s | 新增：级别防抖时间 |
| 电压滤波方式 | 简单平均 | 滑动平均 | 提高稳定性 |

## 疑问

- get_vbat_percent()函数中有一段注释掉的防抖处理，为什么不使用呢？
- 手机电量更新是根据电量根据`battery_value_to_phone_level`上传十个等级实现。因为手机只能整十显示，这没有问题。
- 按道理来说只要同步彩屏仓使用这个函数就可以实现个位数电量显示！
  - 看一下在哪里调用的？？？？？
- 公版来讲，直接计算出来填入即可，你的100%是多少就填入第一个就行。
  -  `if(percent == 100 && temp_percent > 90 && bat_val >= 414)`同步更新这里就没有问题。
