# 开低功耗

- 功耗不行
  - 先看有没有开低功耗
  - 再看在EQ有没有关
  - 看官方文档

开低功耗可以1mA以下。不开一般5mA以内。

```c
//*********************************************************************************//
//                                  低功耗配置                                     //
//*********************************************************************************//
#define TCFG_LOWPOWER_POWER_SEL				PWR_DCDC15//PWR_LDO15                    //电源模式设置，可选DCDC和LDO
#define TCFG_LOWPOWER_BTOSC_DISABLE			0                            //低功耗模式下BTOSC是否保持
#define TCFG_LOWPOWER_LOWPOWER_SEL			1//0   //芯片是否进入powerdown
/*强VDDIO等级配置,可选：
    VDDIOM_VOL_20V    VDDIOM_VOL_22V    VDDIOM_VOL_24V    VDDIOM_VOL_26V
    VDDIOM_VOL_30V    VDDIOM_VOL_30V    VDDIOM_VOL_32V    VDDIOM_VOL_36V*/
#define TCFG_LOWPOWER_VDDIOM_LEVEL			VDDIOM_VOL_28V
/*弱VDDIO等级配置，可选：
    VDDIOW_VOL_21V    VDDIOW_VOL_24V    VDDIOW_VOL_28V    VDDIOW_VOL_32V*/
#define TCFG_LOWPOWER_VDDIOW_LEVEL			VDDIOW_VOL_26V               //弱VDDIO等级配置
#define TCFG_LOWPOWER_OSC_TYPE              OSC_TYPE_LRC
#define TCFG_LOWPOWER_LIGHT_SLEEP_ATTRIBUTE 	LOWPOWER_LIGHT_SLEEP_ATTRIBUTE_KEEP_CLOCK 		//低功耗LIGHT模式属性, 可以选择是否保持住一些电源和时钟

```

看是否带ANC，可能会影响ANC效果以及灯效。

`apps\earphone\board\br36\board_ac700n_demo_cfg.h`

```c
/**************
 *ANC配置
 *************/
#define TCFG_AUDIO_ANC_ENABLE				CONFIG_ANC_ENABLE		//ANC总使能,根据global_bulid_cfg板级定义
#define TCFG_ANC_TOOL_DEBUG_ONLINE 			1//DISABLE_THIS_MOUDLE		//ANC工具蓝牙spp调试
#define TCFG_ANC_EXPORT_RAM_EN				DISABLE_THIS_MOUDLE		//ANCdebug数据释放RAM使能
#if TCFG_ANC_EXPORT_RAM_EN
#define TCFG_AUDIO_CVP_CODE_AT_RAM			DISABLE_THIS_MOUDLE
#define TCFG_AUDIO_AAC_CODE_AT_RAM			DISABLE_THIS_MOUDLE
#endif/*TCFG_ANC_EXPORT_RAM_EN*/
```

**要保护的IO口**

`apps\earphone\board\br36\board_ac700n_demo.c`

```c
#if TCFG_AUDIO_ANC_ENABLE
	if(anc_status_get() && (!is_softoff)){
		//ANC 低功耗状态下需要保持的IO口
		port_protect(port_group, TCFG_AUDIO_MIC_PWR_PORT); 
	}
#endif/*TCFG_AUDIO_ANC_ENABLE*/
	gpio_set_pull_up(IO_PORT_DP, 0);
    gpio_set_pull_down(IO_PORT_DP, 0);
    gpio_set_die(IO_PORT_DP, 0);
    gpio_set_dieh(IO_PORT_DP, 0);
    gpio_set_direction(IO_PORT_DP, 1);
    //冲突了？保护PC2但是DM脚与它共用？
    //DM的状态有消耗？还是不行。。。
    // gpio_set_pull_up(IO_PORT_DM, 0);
    // gpio_set_pull_down(IO_PORT_DM, 0);
    // gpio_set_die(IO_PORT_DM, 0);
    // gpio_set_dieh(IO_PORT_DM, 0);
    // gpio_set_direction(IO_PORT_DM, 1);
```



## 连接状态进入低功耗后，功耗会跳变

- **公版也会跳动。**

## 不进入低功耗

检查所有对外的调试接口，都要关闭。

- 在线EQ
- 触摸测试等

# ANC

## 记忆模式

`cpu\br36\audio\audio_anc.h`

```c
#define ANC_INFO_SAVE_ENABLE	1//0	/*ANC信息记忆:保存上一次关机时所处的降噪模式等等*/
```

## 每次都保存ANC模式（开机默认降噪）

`cpu\br36\audio\audio_anc.c`

```c
/*ANC信息保存*/
void anc_info_save()
{
    if (anc_hdl) {
        anc_info_t anc_info;
        int ret = syscfg_read(CFG_ANC_INFO, &anc_info, sizeof(anc_info));
        if (ret == sizeof(anc_info)) {
#if INEAR_ANC_UI
            if (anc_info.mode == anc_hdl->param.mode && anc_info.inear_tws_mode == inear_tws_ancmode) {
#else
            if (anc_info.mode == anc_hdl->param.mode) {
#endif/*INEAR_ANC_UI*/
                user_anc_log("anc info.mode == cur_anc_mode");
                return;
            }
        } else {
            user_anc_log("read anc_info err");
        }

        user_anc_log("save anc_info");
        //anc_info.mode = anc_hdl->param.mode;//anc_hdl->param.mode = ANC_OFF;
        anc_info.mode = ANC_ON; //打开记忆功能，每次都保存ANC，保证每次开机都是ANC_ON状态
#if INEAR_ANC_UI
        anc_info.inear_tws_mode = inear_tws_ancmode;
#endif/*INEAR_ANC_UI*/
        ret = syscfg_write(CFG_ANC_INFO, &anc_info, sizeof(anc_info));
        if (ret != sizeof(anc_info)) {
            user_anc_log("anc info save err!\n");
        }

    }
}
```

## 开降噪测试

在降噪测试仪上测降噪。

跟调ANC参数同理。开SPP。

![image-20250710153357644](./开发问题.assets/image-20250710153357644.png)

![23a65beb4289055848245fd3e3cc493](./开发问题.assets/23a65beb4289055848245fd3e3cc493.png)

`apps\earphone\board\br36\board_ac700n_demo_cfg.h`

![image-20250710153742390](./开发问题.assets/image-20250710153742390.png)

![image-20250710154312652](./开发问题.assets/image-20250710154312652.png)

- 自动打开SPP和在线调试功能

- **`TCFG_AEC_TOOL_ONLINE_ENABLE`** - 回音消除（AEC）参数在线调试功能开启
- **`TCFG_AUDIO_DMS_DUT_ENABLE`** - 双麦克风降噪DUT（Device Under Test）模式开启
- **`TCFG_ANC_TOOL_DEBUG_ONLINE`** - ANC（主动降噪）工具蓝牙SPP调试功能开启
- **`TCFG_COMM_TYPE == TCFG_SPP_COMM`** - 通信类型配置为SPP通信模式

当上述任意条件满足时，代码会：

```c
#undef USER_SUPPORT_PROFILE_SPP    // 取消之前的定义
#undef APP_ONLINE_DEBUG            // 取消之前的定义
#define USER_SUPPORT_PROFILE_SPP 1  // 启用SPP配置文件支持
#define APP_ONLINE_DEBUG 1          // 启用应用在线调试功能
```

允许在需要调试功能时自动启用SPP支持，避免在正常产品中包含不必要的调试代码。

- **还是要手动打开`APP_ONLINE_DEBUG`，降噪仪器才能使用。**
- **开对应的调试宏，开SPP，开在线调试宏。**

![image-20250710154601430](./开发问题.assets/image-20250710154601430.png)

## 配置ANC



# EQ

## 音乐整体音量

- 播放整体音量降1db
- 直接在 音乐eq 上去减

![image-20250709164603161](./开发问题.assets/image-20250709164603161.png)

![image-20250709164627274](./开发问题.assets/image-20250709164627274.png)

![image-20250709164718048](./开发问题.assets/image-20250709164718048.png)

- 根据是否开ANC，选择EQ文件进行修改

![image-20250709164802179](./开发问题.assets/image-20250709164802179.png)

![image-20250709164847505](./开发问题.assets/image-20250709164847505.png)

![image-20250709164945597](./开发问题.assets/image-20250709164945597.png)

![image-20250709165045040](./开发问题.assets/image-20250709165045040.png)

**编译后，最终eq会被替换。最明显的标志就是两者的修改时间是一样的。但是这一次校验码没变，不知道为什么。**

## 支持eq配置bin文件切换

可以切换`NORMAL`和`BASS`的EQ

`apps\earphone\board\br36\board_ac700n_demo_cfg.h`

```c
#define TCFG_USE_EQ_FILE                          1    //离线eq使用配置文件还是默认系数表 1：使用文件  0 使用默认系数表
#define TCFG_EQ_FILE_SWITCH_EN                    1//0     //支持eq配置文件切换(需使能TCFG_USE_EQ_FILE)
```

**切换时的提示音**

`apps\earphone\include\tone_player.h`

使用工具转换。

```c
#define TONE_NORMAL_EQ  		SDFILE_RES_ROOT_PATH"tone/normal_eq.*"
#define TONE_BASS_EQ  	    	SDFILE_RES_ROOT_PATH"tone/bass_eq.*"

IDEX_TONE_NORMAL_EQ,
IDEX_TONE_BASS_EQ,
```

`eq_file_switch();`

```c
#if TCFG_EQ_FILE_SWITCH_EN
//根据eq_file_switch_list切换到指定的eq文件
void eq_file_set_by_index(u8 index)
{
    if (index >= ARRAY_SIZE(eq_file_switch_list)) {
        printf("err, max index %d\n", ARRAY_SIZE(eq_file_switch_list));
        return;
    }
    EQ_CFG *eq_cfg = get_eq_cfg_hdl();
    if (!eq_cfg) {
        return;
    }
    int ret = eq_file_get_cfg(eq_cfg, eq_file_switch_list[index]);
    printf("eq_file_switch : %d, ret : %d", index, ret);
}

//根据eq_file_switch_list成员个数顺序切换eq文件
void eq_file_switch()
{
    static u8 index = 0;
    // index++;
    // if (index >= ARRAY_SIZE(eq_file_switch_list)) {
    //     index = 0;
    // }
    if(index){
        tone_play_index(IDEX_TONE_NORMAL_EQ,1);
    }else{
        tone_play_index(IDEX_TONE_BASS_EQ,1);
    }
    index = !index;
    eq_file_set_by_index(index);
}
#endif
```

`cpu\br36\audio\eq_config.c`

```c
#if TCFG_EQ_FILE_SWITCH_EN
const u8 *eq_file_switch_list[] = {
    (u8 *)SDFILE_RES_ROOT_PATH"eq_cfg_hw.bin",
    (u8 *)SDFILE_RES_ROOT_PATH"eq_cfg_hw1.bin",
    // (u8 *)SDFILE_RES_ROOT_PATH"eq_cfg_hw2.bin",
};
#endif
```

使用不同的eq的bin文件实现不同音效模式。

## 在线调EQ

不定义就会报错：

![image-20250710154816244](./开发问题.assets/image-20250710154816244.png)

## EQ的启用形式

- **当常规流程替换外面的eq时校验码没有改变时，可能eq的应用形式已经改变。**

`apps\earphone\board\br36\board_ac700n_demo_cfg.h`

![image-20250806104836681](./开发问题.assets/image-20250806104836681.png)

- `cpu\br36\audio\eq_config.c`
- 这是EQ切换时的数组

![image-20250806104907174](./开发问题.assets/image-20250806104907174.png)

- 没有用到外面的eq文件？

![image-20250806110211714](./开发问题.assets/image-20250806110211714.png)

**正常带APP的download：**
![image-20250806115254572](./开发问题.assets/image-20250806115254572.png)

所以按常规流程不行，没用到那个文件。

# 按键

## 内置触摸多击加长按X秒的检测

- 实现：检测多击加长按X秒，同时不会发出多击事件和长按事件

- 原理：检测完多击之后，检测是否还处于长按状态，利用内置触摸的long和hold回调计算长按时间

**加一个变量**

- `include_lib\driver\cpu\br36\asm\lp_touch_key_api.h`

```c
struct ctmu_key {
    u8 init;
    u8 softoff_mode;
    u8 slide_dir;
    u8 click_cnt[LP_CTMU_CHANNEL_SIZE];
    u8 last_key[LP_CTMU_CHANNEL_SIZE];
    u16 short_timer[LP_CTMU_CHANNEL_SIZE];

    u8 key_ch_msg_lock;
    u16 key_ch_msg_lock_timer;

    u8 eartch_inear_ok;
    u8 eartch_last_state;
    u8 eartch_trim_flag;
    u16 eartch_trim_value;
    u16 key_active_cnt[LP_CTMU_CHANNEL_SIZE];//长按计数

    const struct lp_touch_key_platform_data *config;
};
```

**long回调判断之前有没有多击，有多击就进入多击长按流程**

- `cpu\br36\lp_touch_key.c`

```c
static void ctmu_long_click_handle(u8 ch)
{
    struct sys_event e;
#if CTMU_CLICK_LONG_PRESS_DET_EN
    //多击+长按状态不发长按事件（可以改成自定义事件）
    if(__this->last_key[ch] == CTMU_KEY_SHORT_CLICK){
        __this->key_active_cnt[ch] = 0;
        __this->last_key[ch] = CTMU_KEY_SHORT_LONG_CLICK;
        e.u.key.event = KEY_EVENT_USER + __this->click_cnt[ch];
        e.u.key.value = __this->key_active_cnt[ch];
        __ctmu_notify_key_event(&e, ch);
        log_debug("notify key short long");
        return;
    }
#endif
    __this->last_key[ch] = CTMU_KEY_LONG_CLICK;
    e.u.key.event = KEY_EVENT_LONG;
    e.u.key.value = __this->config->ch[ch].key_value;

    __ctmu_notify_key_event(&e, ch);
}
```

**hold回调计算长按时间**

- `cpu\br36\lp_touch_key.c`

```c
static void ctmu_hold_click_handle(u8 ch)
{
    struct sys_event e;
#if CTMU_CLICK_LONG_PRESS_DET_EN
    //多击+长按状态不发HOLD事件（可以改成自定义事件）
    if(__this->last_key[ch] == CTMU_KEY_SHORT_LONG_CLICK){
        if((__this->key_active_cnt[ch] + 1) >= 255){
            return;//超过255次不处理
        }
        __this->key_active_cnt[ch] += 1;
        e.u.key.event = KEY_EVENT_USER + __this->click_cnt[ch];
        e.u.key.value = __this->key_active_cnt[ch];
        __ctmu_notify_key_event(&e, ch);
        return;
    }
#endif

    __this->last_key[ch] = CTMU_KEY_HOLD_CLICK;
    e.u.key.event = KEY_EVENT_HOLD;
    e.u.key.value = __this->config->ch[ch].key_value;

    __ctmu_notify_key_event(&e, ch);
}
```

**raise回调结束流程**

- `cpu\br36\lp_touch_key.c`

```c
static void ctmu_raise_click_handle(u8 ch)
{
    struct sys_event e = {0};

#if CTMU_CLICK_LONG_PRESS_DET_EN
    //多击+长按状态不发长按抬起事件（可以改成自定义事件）
    if(__this->last_key[ch] == CTMU_KEY_SHORT_LONG_CLICK){
        __this->last_key[ch] = CTMU_KEY_NULL;
        //e.u.key.event = KEY_EVENT_USER + __this->click_cnt[ch];
        //e.u.key.value = __this->key_active_cnt[ch];
        //__ctmu_notify_key_event(&e, ch);
        log_debug("notify key short long up");
        return;
    }
#endif

    if (__this->last_key[ch] >= CTMU_KEY_LONG_CLICK) {
        e.u.key.event = KEY_EVENT_UP;
        e.u.key.value = __this->config->ch[ch].key_value;
        __ctmu_notify_key_event(&e, ch);

        __this->last_key[ch] = CTMU_KEY_NULL;
        log_debug("notify key HOLD UP event");
    } else {
        ctmu_short_click_handle(ch);
    }
}
```

**屏蔽多击事件**

```c
static void __ctmu_short_click_time_out_handle(void *priv)
{
    u8 ch = *((u8 *)priv);
    struct sys_event e;

#if CTMU_CLICK_LONG_PRESS_DET_EN
    //触摸状态下不允许发多击事件
    if(P2M_CTMU_WKUP_MSG & (P2M_MESSAGE_KEY_ACTIVE_FLAG)){
        __this->short_timer[ch] = LP_TOUCH_KEY_TIMER_MAGIC_NUM;
        log_debug("key%d is active!!!!!!!/n", ch);
        return;
    }
#endif

    switch (__this->click_cnt[ch]) {
```

**获取多击+长按事件**

- `apps\earphone\key_event_deal.c`
- `app_earphone_key_event_handler`

```c
#if TCFG_APP_MUSIC_EN
    if (event->arg == DEVICE_EVENT_FROM_CUSTOM) {
        log_e("is music mode msg\n");
        return false;
    }
#endif
#if CTMU_CLICK_LONG_PRESS_DET_EN
    if (key->event >= KEY_EVENT_USER) {
        log_info("key_event_user:%d %d\n",key->event,key->value);
        //内置触摸按键的多击+长按功能处理
        u8 click_cnt = key->event - KEY_EVENT_USER; //多击次数
        u32 long_press_cnt = key->value;//长按时间（实际时间用second_to_cnt反推）
        switch (click_cnt) {
            case 1:
             //单击+长按(这里默认两秒？)
             if (get_tws_sibling_connect_state()) {
                    if ((u32)event->arg != KEY_EVENT_FROM_TWS) {
                        tws_api_sync_call_by_uuid('T', SYNC_CMD_POWER_OFF_TOGETHER, TWS_SYNC_TIME_DO);
                    } else {
                        goto_poweroff_cnt--;
                    }
                } else {
                    sys_enter_soft_poweroff(NULL);
                }
                break;
            // case 3:
            //     //三击+长按
            //     if(long_press_cnt == second_to_cnt(5)){
            //         //三击+长按5秒强制TWS组队，清除手机配对记录
            //         printf("三击+长按5秒强制TWS组队,清除手机配对记录\n");
            //         set_tws_force_pair_flag(1);
            //         user_send_cmd_prepare(USER_CTRL_DEL_ALL_REMOTE_INFO, 0, NULL); //清除手机配对记录
            //         sys_enter_soft_poweroff(NULL);
            //     }
            //     break;
            default:
                break;
        }
    }
#endif
```

**宏值定义**

- `include_lib\driver\cpu\br36\asm\lp_touch_key_api.h`

```c
enum ctmu_key_event {
    CTMU_KEY_NULL,
    CTMU_KEY_SHORT_CLICK,
    CTMU_KEY_LONG_CLICK,
    CTMU_KEY_HOLD_CLICK,
    CTMU_KEY_SHORT_LONG_CLICK,//单击+长按
};
```

## 触摸按键的灵敏度

- `apps\earphone\board\br36\board_ac700n_demo_cfg.h`

```c
//电容检测灵敏度级数配置(范围: 0 ~ 9)
//该参数配置与触摸时电容变化量有关, 触摸时电容变化量跟模具厚度, 触摸片材质, 面积等有关,
//触摸时电容变化量越小, 推荐选择灵敏度级数越大,
//触摸时电容变化量越大, 推荐选择灵敏度级数越小,
//用户可以从灵敏度级数为0开始调试, 级数逐渐增大, 直到选择一个合适的灵敏度配置值.
#define TCFG_LP_TOUCH_KEY0_SENSITIVITY		3 	//触摸按键0电容检测灵敏度配置(级数0 ~ 9)
#define TCFG_LP_TOUCH_KEY1_SENSITIVITY		2 	//触摸按键1电容检测灵敏度配置(级数0 ~ 9)
#define TCFG_LP_TOUCH_KEY2_SENSITIVITY		3 	//触摸按键2电容检测灵敏度配置(级数0 ~ 9)
#define TCFG_LP_TOUCH_KEY3_SENSITIVITY		3 	//触摸按键3电容检测灵敏度配置(级数0 ~ 9)
#define TCFG_LP_TOUCH_KEY4_SENSITIVITY		3 	//触摸按键4电容检测灵敏度配置(级数0 ~ 9)
```



# 提示音

## 替换提示音

打开配置工具入口，点击配置工具：

![image-20250425091528271](./开发问题.assets/image-20250425091528271.png)

1. 收集对应的中文MP3格式的音效素材
2. 把原有音效删除，新音效改为同名MP3
3. 然后点击打开选中即可
4. 格式跟原来一样，点击保存提示音文件
5. 再点击保存到bin即可编译生效。
6. **换音质的话，应该从MP3开始转换，如果WTG低音质转成WTS高音质的话，会失真。**

### 区分左右耳

**区分左右耳的话，出包需要分开编译分别打包各自的ufw文件：**

**apps\earphone\include\app_config.h**

```c
/* 声道确定方式选择 */
#define CONFIG_TWS_MASTER_AS_LEFT             0 //主机作为左耳
#define CONFIG_TWS_AS_LEFT_CHANNEL            1 //固定左耳
#define CONFIG_TWS_AS_RIGHT_CHANNEL           2 //固定右耳
#define CONFIG_TWS_LEFT_START_PAIR            3 //双击发起配对的耳机做左耳
#define CONFIG_TWS_RIGHT_START_PAIR           4 //双击发起配对的耳机做右耳
#define CONFIG_TWS_EXTERN_UP_AS_LEFT          5 //外部有上拉电阻作为左耳
#define CONFIG_TWS_EXTERN_DOWN_AS_LEFT        6 //外部有下拉电阻作为左耳
#define CONFIG_TWS_SECECT_BY_CHARGESTORE      7 //充电仓决定左右耳
#define CONFIG_TWS_CHANNEL_SELECT             CONFIG_TWS_AS_LEFT_CHANNEL //配对方式选择
```

**左右耳分别切换宏编译出包。**

格式支持要做好，不要的格式就不启用，免得占用资源：

`apps\earphone\board\br30\board_ad697n_demo_cfg.h`

`TCFG_BT_SUPPORT_G729` 用于控制 G.729 格式（即 WTG）的支持：

- 置为 `1` 时开启 G.729（WTG）格式解码支持；
- 置为 `0` 时关闭此支持。

`TCFG_DEC_WTGV2_ENABLE` 用于控制 WTS 格式的支持：

- 置为 `1` 时开启 WTS 格式解码支持；
- 置为 `0` 时关闭此支持。

**格式对不上的话，烧录进入是完全没有提示音的。**

### 出包

在左耳文件夹中更新表格，并重命名新的包含校验码和修改时间的文件名。

使用**烧写文件授权工具**可以查看大写的校验码，使用校验码查看工具可以看到小写的校验码。

分别打包压缩发出即可。

## 生效

`apps\earphone\include\tone_player.h`工具转换了，但是代码不引用也是不生效的。

![image-20250710144010243](./开发问题.assets/image-20250710144010243.png)

![image-20250710144117998](./开发问题.assets/image-20250710144117998.png)

**所以demo.c配置了，TWS模式下，`play_tone_at_same_time`这里不调用，也是不生效。**



## 最大提示音需要打断（抢断）音乐

`apps\earphone\key_event_deal.c`

```c
void volume_up(u8 inc)
{
    u8 test_box_vol_up = 0x41;
    s8 cur_vol = 0;
    u8 call_status = get_call_status();

    if (tone_get_status() && volume_flag) {
        if (get_call_status() == BT_CALL_INCOMING) {
            volume_up_down_direct(1);
        }
        return;
    }

    /*打电话出去彩铃要可以调音量大小*/
    if ((call_status == BT_CALL_ACTIVE) || (call_status == BT_CALL_OUTGOING)) {
        cur_vol = app_audio_get_volume(APP_AUDIO_STATE_CALL);
    } else {
        cur_vol = app_audio_get_volume(APP_AUDIO_STATE_MUSIC);
    }
    if (get_remote_test_flag()) {
        user_send_cmd_prepare(USER_CTRL_TEST_KEY, 1, &test_box_vol_up); //音量加
    }

    if (cur_vol >= app_audio_get_max_volume()) {
#if TCFG_USER_TWS_ENABLE
        if (get_tws_sibling_connect_state()) {
            if (tws_api_get_role() == TWS_ROLE_MASTER && replay_tone_flag) {
                replay_tone_flag = 0;               //防止提示音被打断标志
                bt_tws_play_tone_at_same_time(SYNC_TONE_MAX_VOL, 400);
                max_tone_timer_hdl = sys_timeout_add(NULL, max_tone_timer, TWS_SYNC_TIME_DO + 100);  //同步在TWS_SYNC_TIME_DO之后才会播放提示音，所以timer需要在这个时间之后才去检测提示音状态
            }
        } else
#endif
        {
#if TCFG_MAX_VOL_PROMPT
            STATUS *p_tone = get_tone_config();
            //1是抢断，0是叠加---------------这是单耳的
            tone_play_index(p_tone->max_vol, 0);
#endif
        }

//...
```

双耳调用的是`bt_tws_play_tone_at_same_time(SYNC_TONE_MAX_VOL, 400);`

```c
TWS_SYNC_CALL_REGISTER(tws_tone_play) = {
    .uuid = 0x123A9E50,
    .task_name = "app_core",
    .func = play_tone_at_same_time,
};

void bt_tws_play_tone_at_same_time(int tone_name, int msec)
{
    tws_api_sync_call_by_uuid(0x123A9E50, tone_name, msec);
}
```

`apps\earphone\bt_tws.c`

```c
/*
 * 提示音同步播放
 */
static void play_tone_at_same_time(int tone_name, int err)
{
    STATUS *p_tone = get_tone_config();
    int state;

    switch (tone_name) {
#if TCFG_EAR_DETECT_ENABLE
    //...
    case SYNC_TONE_MAX_VOL:
#if TCFG_MAX_VOL_PROMPT
        if (p_tone->max_vol != IDEX_TONE_NONE) {
            //1是可以抢断音乐
            tone_play_index(p_tone->max_vol, 1);
        } else {
            /* tone_sin_play(150, 1); */
        }
#endif
        break;
```

## 内部提示音引用路径位置

`apps\earphone\include\tone_player.h`

```c
#define TONE_LOW_LATENCY_IN     	DEFAULT_SINE_TONE(SINE_WTONE_LOW_LATENRY_IN)//SDFILE_RES_ROOT_PATH"tone/game_mode.*"//DEFAULT_SINE_TONE(SINE_WTONE_LOW_LATENRY_IN)
#define TONE_LOW_LATENCY_OUT    	SDFILE_RES_ROOT_PATH"tone/music_mode.*"//DEFAULT_SINE_TONE(SINE_WTONE_LOW_LATENRY_OUT)
```

- 使用内部和弦音或者引用外部提示音配置

## 提示音不同步

以**两个SDK**工程区分机器左右耳的话，如果代码层面没有查出问题的话。而烧录同一个工程又可以同步时。

可以`AC897N_AD697N_earphone_release_V2.3.0-left\cpu\br30\tools\earphone\standard`查看tone.cfg文件大小不一样的话，需要同步替换一下。

**其中一个工程修改过提示音的音质的话，两边音质不一样，提示音文件解析速度不一样就导致了双耳提示音不同步。**

## 两个提示音函数

### `tone_play_index(TONE_LOW_LATENCY_IN, 1);`

```c
/*
 *index:提示音索引
 *preemption:抢断标志-----1会打断，0会叠加
 */
__BANK_TONE_ENTRY
int tone_play_index(u8 index, u8 preemption)
{
    printf("tone_play_index:%d,preemption:%d", index, preemption);
    if (index >= IDEX_TONE_NONE) {
        return 0;
    }
    return tone_play(tone_index[index], preemption);
}
```

这意味着`apps\earphone\include\tone_player.h`需要定义类似的枚举变量`IDEX_TONE_NONE`，值不能超过`IDEX_TONE_NONE`，也就是添加在它的前面。

`tone_play_index(TONE_LOW_LATENCY_OUT, 1);`直接使用的话。`TONE_LOW_LATENCY_OUT`这是一个宏（提示音引用路径），可能过不了那个if判断而出错（**经过验证**）。

#### 疑问

`apps\earphone\board\br36\board_ac700n_demo.c`中定义的提示音又是怎么使用呢？

`STATUS_CONFIG status_config`

```c
	//提示音设置
    .tone = {
        .charge_start  = IDEX_TONE_NONE,
        .charge_full   = IDEX_TONE_NONE,
        .power_on      = IDEX_TONE_POWER_ON,
        .power_off     = IDEX_TONE_POWER_OFF,
        .lowpower      = IDEX_TONE_LOW_POWER,
        .max_vol       = IDEX_TONE_MAX_VOL,
        .phone_in      = IDEX_TONE_NONE,
        .phone_out     = IDEX_TONE_NONE,
        .phone_activ   = IDEX_TONE_NONE,
        .bt_init_ok    = IDEX_TONE_BT_MODE,
        .bt_connect_ok = IDEX_TONE_BT_CONN,
        .bt_disconnect = IDEX_TONE_BT_DISCONN,
        .tws_connect_ok   = IDEX_TONE_TWS_CONN,
        .tws_disconnect   = IDEX_TONE_TWS_DISCONN,
    }
```

**这个也是生效的。前提是工具有音源文件，代码中路径也搞好了。不知道这个是同名索引枚举值？**

- 加`IDEX`内部应该有处理的。

```c
#define TONE_POWER_ON			SDFILE_RES_ROOT_PATH"tone/power_on.*"

IDEX_TONE_ANC_OFF
```

### `tone_play(TONE_LOW_LATENCY_IN, 1);`

提示音的底层播放函数是，可以直接传入提示音的宏定义（引用路径）

## 外部提示音的宏定义怎么来的？

使用配置工具添加并保存提示音后，也没有宏定义。难道是手动写？工具只是转换以及保存到`tone.cfg`以及`cfg_tool.bin`

**如果是可视化的话，自动生成。如果是非可视化配置工具的话，就是自己写。**

- 通过配置工具添加保存到文件中（工程中）
  - `tone.cf`
  - `cfg_tool.bin`
- 模仿其他宏写对应定义
- 使用`tone_play`播放

### 非可视化工具添加后，代码中添加路径

`apps\earphone\include\tone_player.h`

```c
#define TONE_LINEIN				SDFILE_RES_ROOT_PATH"tone/linein.*"
#define TONE_MIN_VOL			SDFILE_RES_ROOT_PATH"tone/vol_min.*"
#define TONE_KEY			    SDFILE_RES_ROOT_PATH"tone/key.*"

#define TONE_CALL_CANCEL	    SDFILE_RES_ROOT_PATH"tone/call_cancel.*"//名称需要十位一下，不然报不出声音。
#define TONE_CALL_REJECT	    SDFILE_RES_ROOT_PATH"tone/call_reject.*"

//。。。
IDEX_TONE_HEARAID_OFF,
IDEX_TONE_LINEIN,
IDEX_TONE_MIN_VOL,
IDEX_TONE_CALL_CANCEL,//为了可以使用tone_play_index(IDEX_TONE_CALL_CANCEL, 0);这个不是必须的。跟下面一一对应。否则机器重启断连接
IDEX_TONE_CALL_REJECT,
```

`apps\earphone\tone_table.c`

```c
static const char *const tone_index[] = {
    TONE_LINEIN,
    TONE_MIN_VOL,
    TONE_CALL_CANCEL,
    TONE_CALL_REJECT,//为了使用tone_play(tone_index[index], preemption);这个是必须的
};

/*
 *index:提示音索引
 *preemption:抢断标志
 */
__BANK_TONE_ENTRY
int tone_play_index(u8 index, u8 preemption)
{
    printf("tone_play_index:%d,preemption:%d", index, preemption);
    if (index >= IDEX_TONE_NONE) {
        return 0;
    }
    return tone_play(tone_index[index], preemption);
}
```

### 注意事项

非可视化名称必须小于10，加上符号。不然报不了提示音。

#### 结构体也需要同步，如果要读取demo配置的提示音的话。

```c
STATUS *p_tone = get_tone_config();
if (app_var.play_poweron_tone) {
    tone_play_index(p_tone->power_on, 1);
}
```



## 最大最小提示音

`apps\earphone\bt_tws.c`

- 在加减提示音音量函数中有相关的判断
  - `volume_down`
  - `volume_up`

```c
void volume_up(u8 inc)
{
    u8 test_box_vol_up = 0x41;
    s8 cur_vol = 0;
    u8 call_status = get_call_status();

    if (tone_get_status() && volume_flag) {
        if (get_call_status() == BT_CALL_INCOMING) {
            volume_up_down_direct(1);
        }
        return;
    }

    /*打电话出去彩铃要可以调音量大小*/
    if ((call_status == BT_CALL_ACTIVE) || (call_status == BT_CALL_OUTGOING)) {
        cur_vol = app_audio_get_volume(APP_AUDIO_STATE_CALL);
    } else {
        cur_vol = app_audio_get_volume(APP_AUDIO_STATE_MUSIC);
    }
    if (get_remote_test_flag()) {
        user_send_cmd_prepare(USER_CTRL_TEST_KEY, 1, &test_box_vol_up); //音量加
    }

    //获取最大音量，与当前音量比较
    if (cur_vol >= app_audio_get_max_volume()) {
#if TCFG_USER_TWS_ENABLE //TWS双耳的逻辑
        if (get_tws_sibling_connect_state()) {
            if (tws_api_get_role() == TWS_ROLE_MASTER && replay_tone_flag) {
                replay_tone_flag = 0;               //防止提示音被打断标志
                bt_tws_play_tone_at_same_time(SYNC_TONE_MAX_VOL, 400);//400ms后调用函数
                max_tone_timer_hdl = sys_timeout_add(NULL, max_tone_timer, TWS_SYNC_TIME_DO + 100);  //同步在TWS_SYNC_TIME_DO之后才会播放提示音，所以timer需要在这个时间之后才去检测提示音状态
            }
        } else
#endif
        {
#if TCFG_MAX_VOL_PROMPT //单耳的逻辑
            STATUS *p_tone = get_tone_config();
            tone_play_index(p_tone->max_vol, 1);//这里直接使用配置中的枚举
#endif
        }

        if (get_call_status() != BT_CALL_HANGUP) {
            /*本地音量最大，如果手机音量还没最大，继续加，以防显示不同步*/
            if (bt_user_priv_var.phone_vol < 15) {
                if (get_curr_channel_state() & HID_CH) {
                    user_send_cmd_prepare(USER_CTRL_HID_VOL_UP, 0, NULL);
                } else {
                    user_send_cmd_prepare(USER_CTRL_HFP_CALL_VOLUME_UP, 0, NULL);
                }
            }
            return;
        }
#if BT_SUPPORT_MUSIC_VOL_SYNC
        opid_play_vol_sync_fun(&app_var.music_volume, 1);
        user_send_cmd_prepare(USER_CTRL_CMD_SYNC_VOL_INC, 0, NULL);
#endif/*BT_SUPPORT_MUSIC_VOL_SYNC*/
        return;
    }

#if BT_SUPPORT_MUSIC_VOL_SYNC
    opid_play_vol_sync_fun(&app_var.music_volume, 1);
    app_audio_set_volume(APP_AUDIO_STATE_MUSIC, app_var.music_volume, 1);
#else
    app_audio_volume_up(inc);
#endif/*BT_SUPPORT_MUSIC_VOL_SYNC*/
    log_info("vol+: %d", app_audio_get_volume(APP_AUDIO_CURRENT_STATE));
    if (get_call_status() != BT_CALL_HANGUP) {
        if (get_curr_channel_state() & HID_CH) {
            user_send_cmd_prepare(USER_CTRL_HID_VOL_UP, 0, NULL);
        } else {
            user_send_cmd_prepare(USER_CTRL_HFP_CALL_VOLUME_UP, 0, NULL);
        }
    } else {
#if BT_SUPPORT_MUSIC_VOL_SYNC
        /* opid_play_vol_sync_fun(&app_var.music_volume, 1); */

#if TCFG_USER_TWS_ENABLE
        user_send_cmd_prepare(USER_CTRL_CMD_SYNC_VOL_INC, 0, NULL);     //使用HID调音量
        //user_send_cmd_prepare(USER_CTRL_AVCTP_OPID_SEND_VOL, 0, NULL);
#else
        user_send_cmd_prepare(USER_CTRL_CMD_SYNC_VOL_INC, 0, NULL);
#endif/*TCFG_USER_TWS_ENABLE*/
#endif/*BT_SUPPORT_MUSIC_VOL_SYNC*/
    }
}
```

`bt_tws_play_tone_at_same_time`

```c
/*
 * 提示音同步播放
 */
static void play_tone_at_same_time(int tone_name, int err)
{
    STATUS *p_tone = get_tone_config();
    int state;

    switch (tone_name) {
            case SYNC_TONE_MAX_VOL:
#if TCFG_MAX_VOL_PROMPT
        if (p_tone->max_vol != IDEX_TONE_NONE) {
            tone_play_index(p_tone->max_vol, 1);
        } else {
            /* tone_sin_play(150, 1); */
        }
#endif
        break;
```

**所以demo.c配置了，TWS模式下，这里不调用，也是不生效。**

### 没有按键控制，使用手机控制到最大音量时

手机上操作到最大音量就不会往上加了，耳机到最大提示音时，还要加音量，耳机触发条件会播报。

## 提示音的音量调节

### 来电同步手机的提示音太小

- 这个是手机的，音量增加不了，只能手机控制音量，进而控制来电提示音的大小

### 调节耳机提示音的音量大小

- 这个软件的提示音film mode,music mode, game mode这3个提示音的音量要帮忙减小1/3
  - 如果是个别的话直接修改音源。

![image-20250806195100317](./开发问题.assets/image-20250806195100317.png)

`cpu\br36\audio\audio_config.h`

```c
#define MAX_ANA_VOL             (15)	// 系统最大模拟音量,范围: 0 ~ 15
#define MAX_COM_VOL             (16)    // 数值应该大于等于16，具体数值应小于联合音量等级的数组大小 (combined_vol_list)
#define MAX_DIG_VOL             (16)    // 数值应该大于等于16，因为手机是16级，如果小于16会导致某些情况手机改了音量等级但是小机音量没有变化

#if (SYS_VOL_TYPE == VOL_TYPE_DIGITAL)  //---------提示音音量
#define SYS_MAX_VOL             16
#define SYS_DEFAULT_VOL         16
#define SYS_DEFAULT_TONE_VOL    10
#define SYS_DEFAULT_SIN_VOL    	8
```

## 添加按键提示音

配置工具中要有按键提示音的音源文件。

![image-20250708144128914](./开发问题.assets/image-20250708144128914.png)

`apps\earphone\board\br28\board_jl701n_demo_cfg.h`

```c
//*********************************************************************************//
//                                 key 配置                                        //
//*********************************************************************************//
#define KEY_NUM_MAX                        	10
#define KEY_NUM                            	3

#define MULT_KEY_ENABLE						DISABLE 		//是否使能组合按键消息, 使能后需要配置组合按键映射表

#define TCFG_KEY_TONE_EN					1//DISABLE 		// 按键提示音。
```

`apps\earphone\board\br28\board_jl701n_demo_cfg.h`对应的解码要打开：

![image-20250708144941942](./开发问题.assets/image-20250708144941942.png)

`cpu\br28\lp_touch_key.c`

`p33_ctmu_key_event_irq_handler`中：

```c
case CTMU_P2M_CH4_FALLING_EVENT:
        log_debug("CH%d: FALLING", ch_num);
        is_lpkey_active = 1;

#if CTMU_CHECK_LONG_CLICK_BY_RES
        falling_res_avg[ch_num] = lp_touch_key_ctmu_res_buf_avg(ch_num);
        log_debug("falling_res_avg: %d", falling_res_avg[ch_num]);
#endif
        #if  TCFG_KEY_TONE_EN
        //这个不行audio_key_tone_init();
		audio_key_tone_play();
        #endif
        break;
```

`apps\common\device\key\key_driver.c`

```c
if (key_event_remap(&e)) {
        sys_event_notify(&e);
#if TCFG_KEY_TONE_EN
        audio_key_tone_play();
#endif
    }
_scan_end:
    scan_para->last_key = cur_key_value;
    return;
}
```

`cpu\br28\audio_dec.c`

```c
int audio_dec_init()
{
    int err;
    printf("audio_dec_init\n");

    tone_play_init();

#if TCFG_KEY_TONE_EN
    // 按键音初始化
    audio_key_tone_init();
#endif
```

**全局搜索-按键提示音-有相关的接口。** **全局搜索`TCFG_KEY_TONE_EN`**

### 问题

注意可能复位的情况。

## 来电提示音

替换了还是手机自带的提示音而不是配置工具中的。

`apps\earphone\board\br30\board_ad697n_demo_cfg.h`

```c
#define BT_INBAND_RINGTONE                        0//1   //是否播放手机自带来电铃声
#define BT_PHONE_NUMBER                           0   //是否播放来电报号
#define BT_SUPPORT_DISPLAY_BAT                    1   //是否使能电量检测
#define BT_SUPPORT_MUSIC_VOL_SYNC                 1   //是否使能音量同步
```

## 提示音播放后有操作

```c
if ((get_call_status() == BT_CALL_OUTGOING) ||
    (get_call_status() == BT_CALL_ALERT)) {
    user_send_cmd_prepare(USER_CTRL_HFP_CALL_HANGUP, 0, NULL);
    tone_play_index(IDEX_TONE_CALL_CANCEL, 1);
}else if (get_call_status() == BT_CALL_INCOMING) {
    user_send_cmd_prepare(USER_CTRL_HFP_CALL_HANGUP, 0, NULL);
    tone_play_index(IDEX_TONE_CALL_REJECT, 1);
}
```

拒接操作的提示音似乎被打断了。

使用另一个接口：

```c
/* __BANK_TONE_ENTRY */
int tone_play_index_with_callback(u8 index, u8 preemption, void (*user_evt_handler)(void *priv), void *priv)
{
    printf("tone_play_index:%d,preemption:%d", index, preemption);
    if (index >= IDEX_TONE_NONE) {
        return 0;
    }
    return tone_play_with_callback(tone_index[index], preemption, user_evt_handler, priv);
}

void call_reject_tone_play_callback(void *priv){
    user_send_cmd_prepare(USER_CTRL_HFP_CALL_HANGUP, 0, NULL);
}

tone_play_index_with_callback(IDEX_TONE_CALL_REJECT, 1, call_reject_tone_play_callback, NULL);
```

## 同时开启铃声与报号

`apps\earphone\board\br36\board_ac700n_demo_cfg.h`

```c
#define BT_INBAND_RINGTONE                        1   //是否播放手机自带来电铃声
#define BT_PHONE_NUMBER                           1//0   //是否播放来电报号
```

先报号，再播放ring提示音。没有手机自带铃声。

### 自带手机铃声前加自定义提示音

```c
    case BT_STATUS_PHONE_INCOME:
        log_info("BT_STATUS_PHONE_INCOME\n");
        esco_dump_packet = ESCO_DUMP_PACKET_CALL;
        ui_update_status(STATUS_PHONE_INCOME);
        u8 tmp_bd_addr[6];
        memcpy(tmp_bd_addr, bt->args, 6);
        jl_call_kws_handler(BT_STATUS_PHONE_INCOME);
        /*
         *(1)1t2有一台通话的时候，另一台如果来电不要提示
         *(2)1t2两台同时来电，现来的题示，后来的不播
         */
        if ((check_esco_state_via_addr(tmp_bd_addr) != BD_ESCO_BUSY_OTHER) &&
            (bt_user_priv_var.phone_ring_flag == 0)) {

#if BT_INBAND_RINGTONE
            extern u8 get_device_inband_ringtone_flag(void);
            bt_user_priv_var.inband_ringtone = get_device_inband_ringtone_flag();
#else
            bt_user_priv_var.inband_ringtone = 0 ;
            lmp_private_esco_suspend_resume(3);
#endif

            g_printf("bt_user_priv_var.inband_ringtone=0x%x\n", bt_user_priv_var.inband_ringtone);
            bt_user_priv_var.phone_ring_flag = 1;
            bt_user_priv_var.phone_income_flag = 1;
#if TCFG_USER_TWS_ENABLE
            if (!bt_tws_sync_phone_num(NULL))
#endif
            {
#if BT_PHONE_NUMBER
                phone_num_play_start();
#else
                //tone_play_index(IDEX_TONE_RING, 1);
                //播放自带铃声之前播放自定义提示音
                tone_play_index_with_callback(IDEX_TONE_RING, 1, phone_ring_play_start, NULL);
                //phone_ring_play_start();
#endif

            }
            user_send_cmd_prepare(USER_CTRL_HFP_CALL_CURRENT, 0, NULL); //发命令获取电话号码
        } else {
            log_info("SCO busy now:%d,%d\n", check_esco_state_via_addr(tmp_bd_addr),
                     bt_user_priv_var.phone_ring_flag);
        }
        break;
```

## TWS提示音默认是咚的一声

## 出仓提示音被打断

- 使用延迟
- `apps\earphone\earphone.c`

```c
/*
 * earphone 模式状态机, 通过start_app()控制状态切换
 */
/* extern int audio_mic_init(); */

static int state_machine(struct application *app, enum app_state state, struct intent *it)
{
    int error = 0;

    r_printf("bt_state_machine=%d\n", state);
    switch (state) {
    case APP_STA_CREATE:
        /* set_adjust_conn_dac_check(0); */
#if TCFG_APP_LINEIN_EN
        extern u8 poweron_tone_play_flag;
        if (poweron_tone_play_flag == 0) {
            poweron_tone_play_flag = 1;
            if (app_var.play_poweron_tone) {
                extern void poweron_tone_play_callback(void *priv);
                tone_play_index_with_callback(IDEX_TONE_POWER_ON, 1, poweron_tone_play_callback, NULL);
            }
        } else {
            STATUS *p_tone = get_tone_config();
            tone_play_index(p_tone->bt_init_ok, 1);
        }
#endif
#if TCFG_SD0_ENABLE || TCFG_PC_ENABLE
        STATUS *p_tone = get_tone_config();
        tone_play_index(p_tone->bt_init_ok, 1);
#elif !TCFG_APP_LINEIN_EN
        if (app_var.play_poweron_tone) {
            //tone_play_index(p_tone->power_on, 1);
            //STATUS *p_tone = get_tone_config();
            //tone_play_index_with_callback(IDEX_TONE_POWER_ON, 1, bt_wait_conn_callback, NULL);
        } else {
#ifdef CONFIG_CURRENT_SOUND_DEAL_ENABLE
            dac_analog_power_control(0);
#endif
        }
#endif
        break;
            
//.........
case BT_STATUS_INIT_OK:
        /*
         * 蓝牙初始化完成
         */
        log_info("BT_STATUS_INIT_OK\n");
        //为了不突兀，只能放到最前面了，不然灯效有延迟为单色灯。即使开机灯效是一样。
        //但是开机灯效也没有保持。。。
        //不知道是阻塞式延迟还是非阻塞式延迟，任务是否进入阻塞态把CPU让出去并发其他任务
        ui_update_status(STATUS_BT_INIT_OK);
        STATUS *p_tone = get_tone_config();
        tone_play_index(IDEX_TONE_POWER_ON, 1);
        //delay(1000);//无效函数
        os_time_dly(200);//*10ms单位
```

# 三方通话

`apps\earphone\key_event_deal.c`

```c
#if THREE_CALL_DEAL_ENABLE
extern u8 get_second_call_status(); //三方通话状态获取
/*
返回0 当前正在和第一个手机通话，没有来电
返回2 当前正在和第一个手机通话，第二个电话进来
返回8 当前已经保留了一个电话，正在和另外一个手机通话
*/
/*  当前正在和第一个号码通话中，没有来电*/
#define bt_second_call_active()     (get_second_call_status()==BT_THREE_CALL_ACTIVE)
/*  当前正在和第一个号码通话中，第二个电话进来*/
#define bt_second_call_incoming()   (get_second_call_status()==BT_THREE_CALL_INCOMING)
/*  当前已经保留了一个电话，正在和另外一个手机通话*/
#define bt_second_call_coming()     (get_second_call_status()==BT_THREE_CALL_COMING)
#endif
```

之前接口调用错了。

```c
typedef enum{
    BT_THREE_CALL_ACTIVE   = 0,//当前正在和第一个号码通话中，没有来电
    BT_THREE_CALL_INCOMING = 2,//当前正在和第一个号码通话中，第二个电话进来
    BT_THREE_CALL_COMING   = 8,//当前已经保留了一个电话，正在和另外一个手机通话
}BT_THREE_CALL_IND_STA;

			if ((BT_STATUS_CONNECTING == get_bt_connect_status()) ||
                (BT_STATUS_TAKEING_PHONE == get_bt_connect_status()) ||
                (BT_STATUS_PLAYING_MUSIC == get_bt_connect_status())){ 

                printf("*************get_second_call_status() = %d*****",get_second_call_status());
                if (get_call_status() == BT_CALL_INCOMING){
                    //单击第一方来电接听
                    user_send_cmd_prepare(USER_CTRL_HFP_CALL_ANSWER, 0, NULL);
                }
                else if(get_second_call_status() == BT_THREE_CALL_INCOMING){
                    //单击挂断当前去听另一个（未接听或者在保留状态都可以）
                    user_send_cmd_prepare(USER_CTRL_HFP_THREE_WAY_ANSWER1, 0, NULL);
                }else if(get_call_status()== BT_CALL_ACTIVE){
                    //单击挂断当前通话
                    user_send_cmd_prepare(USER_CTRL_HFP_CALL_HANGUP, 0, NULL);
                }else if(get_call_status() == BT_CALL_OUTGOING){
                    //单击取消拨打
                    user_send_cmd_prepare(USER_CTRL_HFP_CALL_HANGUP, 0, NULL);
                }else {
                    //单击音乐的播放与暂停
                    user_send_cmd_prepare(USER_CTRL_AVCTP_OPID_PLAY, 0, NULL); 
                    y_printf("*********USER_CTRL_AVCTP_OPID_PLAY*****");
                }
            }

if(get_second_call_status() == BT_THREE_CALL_INCOMING || get_second_call_status() == BT_THREE_CALL_COMING){
            //优先判断三方通话状态
            //保持当前通话，接听第二个来电
            user_send_cmd_prepare(USER_CTRL_HFP_THREE_WAY_ANSWER2, 0, NULL);
            //切换通话。
        }else if (get_call_status() == BT_CALL_INCOMING){
            //双击第一方来电挂断
            user_send_cmd_prepare(USER_CTRL_HFP_CALL_HANGUP, 0, NULL);
        }else if (get_bt_connect_status() >= BT_STATUS_CONNECTING) {
            //du一声,打断音乐会有割裂感
            tone_play_index(IDEX_TONE_DU, 0);
            //双击控制音量
            key_tws_lr_diff_deal(event,ONE_KEY_CTL_NEXT_PREV);
        }
```

# TWS

## 主动发起TWS配对

```c
case KEY_FIVE_CLICK:
    if (bt_tws_start_search_sibling()) {
        // tone_play_index(IDEX_TONE_NORMAL, 1);
        break;
    }
break;
```

- **场景**
  - 主要是恢复出厂设置后的TWS配对
  - 不是开机自动配对的模式
  - 掉配对的情况。
- 要开启按键配对功能。

```c
//*********************************************************************************//
//                                 对耳配置方式配置                                    //
//*********************************************************************************//
#define CONFIG_TWS_CONNECT_SIBLING_TIMEOUT    4    /* 开机或超时断开后对耳互连超时时间，单位s */
#define CONFIG_TWS_POWEROFF_SAME_TIME         1    /*按键关机时两个耳机同时关机*/

#define ONE_KEY_CTL_DIFF_FUNC                 1    /*通过左右耳实现一个按键控制两个功能*/
#define CONFIG_TWS_SCO_ONLY_MASTER			  0	   /*通话的时候只有主机出声音*/

/* 配对方式选择 */
#define CONFIG_TWS_PAIR_BY_CLICK            0      /* 按键发起配对 */
#define CONFIG_TWS_PAIR_BY_AUTO             1      /* 开机自动配对 */
#define CONFIG_TWS_PAIR_BY_FAST_CONN        2      /* 开机快速连接,连接速度比自动配对快,不支持取消配对操作 */

#define CONFIG_TWS_DIFF_NAME_NOT_MATCH      1      /*tws 不同名字不进行配对*/

#define CONFIG_TWS_PAIR_MODE           CONFIG_TWS_PAIR_BY_AUTO /*注意:自动配对或者按键配对开启, 可能会产生生产线混配情况，
																  也就是客户反馈调配对，产线最好是通过是测试盒串口配对,TCFG_TEST_BOX_ENABLE,默认取消按键配对,已拦截*/


#define  CONFIG_DEVELOPER_MODE                1 //开发者模式debug ,开启后可以进行按键双击配对

#define ESCO_AUTO_POWER_BALANCE_ROLE_SWITCH_ENABLE    0  /*通话过程根据电量主从切换，电量平衡*/
#define A2DP_PLAY_AUTO_ROLE_SWITCH_ENABLE             1  /*播歌根据主从信号质量自动主从切换*/
#define  CONFIG_TWS_PAIR_BY_BOTH_SIDES                0//同时按下按键才配对 CONFIG_DEVELOPER_MOD=1 CONFIG_TWS_PAIR_MODE=CONFIG_TWS_PAIR_BY_CLICK

```



## 不同步关机

```c
    case  KEY_POWEROFF_HOLD:
#if (TCFG_USER_TWS_ENABLE && CONFIG_TWS_POWEROFF_SAME_TIME == 0)
        if ((u32)event->arg == KEY_EVENT_FROM_TWS) {
            break;
        }
#endif
        log_info("poweroff flag:%d cnt:%d\n", goto_poweroff_flag, goto_poweroff_cnt);

        if (goto_poweroff_flag) {
            //200累加一次
            goto_poweroff_cnt++;
#if CONFIG_TWS_POWEROFF_SAME_TIME
            if (goto_poweroff_cnt == POWER_OFF_CNT) {
                if (get_tws_sibling_connect_state()) {
                    if ((u32)event->arg != KEY_EVENT_FROM_TWS) {
                        tws_api_sync_call_by_uuid('T', SYNC_CMD_POWER_OFF_TOGETHER, TWS_SYNC_TIME_DO);
                    } else {
                        goto_poweroff_cnt--;
                    }
                } else {
                    sys_enter_soft_poweroff(NULL);
                }
            }
#else//注释这个就可以单耳关机，不进行同步。
            if (goto_poweroff_cnt >= POWER_OFF_CNT) {
                goto_poweroff_cnt = 0;
                sys_enter_soft_poweroff(NULL);
            }
#endif //CONFIG_TWS_POWEROFF_SAME_TIME

        }
        break;
```

## 相关接口

**获取左右声道：**

```c
if (bt_tws_get_local_channel()=='L'){
    gpio_led_mode_set(GPIO_LED0_LED1_FAST_FLASH);
}else{
    gpio_led_mode_set(GPIO_LED0_ONE_FLASH_5S);
}
```

**tws连接状态**：

```c
if(tws_api_get_tws_state() & TWS_STA_SIBLING_CONNECTED){
    gpio_led_mode_set(GPIO_LED0_ONE_FLASH_5S);//wang
}else{
    gpio_led_mode_set(GPIO_LED0_ONE_FLASH_5S);//wang
}
//不起作用，直接搜索接口的其他调用案例。
```

## TWS自动配对，可以随意组队??

`apps\earphone\include\app_config.h`

```c
#if CONFIG_TWS_PAIR_MODE != CONFIG_TWS_PAIR_BY_CLICK
#if (CONFIG_TWS_CHANNEL_SELECT == CONFIG_TWS_LEFT_START_PAIR) ||\
    (CONFIG_TWS_CHANNEL_SELECT == CONFIG_TWS_RIGHT_START_PAIR)
#undef CONFIG_TWS_CHANNEL_SELECT
#define CONFIG_TWS_CHANNEL_SELECT             CONFIG_TWS_MASTER_AS_LEFT
#endif

#if CONFIG_TWS_PAIR_MODE == CONFIG_TWS_PAIR_BY_AUTO
#if CONFIG_DEVELOPER_MODE
#define CONFIG_TWS_AUTO_PAIR_WITHOUT_UNPAIR     /* 不取消配对也可以配对新的耳机 */
#endif
#endif
#endif
```

# 灯效

- 单IO推灯
  - pwm推灯
  - 高低电平推灯
- 双IO推灯
  - pwm推灯
  - 高低电平推灯

**IO高低电平驱动LED确实不如PWM驱动来得平滑，特别是在状态切换时。**

**高低电平驱动的问题**

- **突变效应**：IO直接切换高低电平时，LED从完全亮到完全灭是瞬间完成的，这种突变在视觉上显得生硬，特别是频繁切换状态时会有明显的闪烁感。

- **无中间状态**：只有开/关两种状态，无法实现渐变效果。

**PWM驱动的优势**

- **亮度渐变**：PWM可以通过调节占空比实现不同亮度级别，让LED在状态切换时有一个渐变过程，视觉上更加柔和。

- **更丰富的效果**：可以实现呼吸灯、淡入淡出等效果，用户体验更好。

**在TWS耳机中的应用**

- 对于TWS蓝牙耳机的红蓝LED状态指示，PWM驱动确实更合适：

- **配对状态**：可以用蓝色呼吸灯表示配对模式，比单纯的闪烁更优雅 **充电状态**：红色LED可以从暗到亮渐变，直观显示充电进度 **连接状态**：可以用不同的淡入淡出速度区分不同状态

不过需要注意的是，PWM驱动会稍微增加功耗和代码复杂度。对于追求极致续航的设备，有时候简单的IO控制也是合理选择。但从用户体验角度看，PWM驱动的"丝滑"效果确实更胜一筹。

## 单IO双IO推灯的原理

### 单IO推双灯

这种方案通常使用**共阴极**或**共阳极**的双色LED，最常见的是红绿双色LED。

**核心原理：利用LED的"电压差"**

想象一下，红色LED和绿色LED就像两个不同高度的"门槛"：

- 红色LED的"门槛"高一些（通常需要1.8-2.2V才亮）
- 绿色LED的"门槛"低一些（通常需要2.0-3.2V才亮）

电路就像一个"水管系统"

```c
单IO口 ——— 红色LED ——— 绿色LED ——— 地线(GND)
   |                              |
   +——————————————————————————————+
```

把这个电路想象成一个水管，水从IO口流向地线。

**当IO输出高电平（比如3.3V）时：**

- 就像打开水龙头，水压很足
- 水流方向：IO → 红色LED → 绿色LED → 地线
- 但是！红色LED的"门槛"比较容易跨过，所以红色LED先亮起来
- 红色LED亮了之后，电压被它"吃掉"了大部分，绿色LED得到的电压不够，所以不亮
- **结果：只有红灯亮**

**当IO输出低电平（0V）时：**

- 水龙头关闭，但是...
- 这时候绿色LED那边的电压通过内部电路有一个反向的小电流
- 绿色LED更容易在低电压下工作，所以绿灯亮
- **结果：只有绿灯亮**

**用PWM控制**

- **PWM高占空比**：大部分时间是高电平，红灯亮得多
- **PWM低占空比**：大部分时间是低电平，绿灯亮得多
- **PWM中等占空比**：红绿快速切换，眼睛看起来像黄色/橙色

就像两个灯泡快速轮流闪烁，我们眼睛看起来就像混合的颜色！

#### 疑问

**电路原理也看不出共阴极或共阳极的双色LED啊？硬件是有两个单独的LED还是一个硬件上有两个LED结构？**

硬件结构分为两种情况

真正的双色LED（一个封装，两个芯片）

- 这是**一个物理器件**，内部有两个LED芯片：

共阴极双色LED：

```c
    红色LED阳极 ——— 引脚1
         |
    LED芯片1 ——— 共同阴极 ——— 引脚2（接GND）
         |
     绿色LED阳极 ——— 引脚3
         |  
    LED芯片2 ——— 共同阴极 ——— 引脚2（接GND）
```

共阳极双色LED：

```c
红色LED阴极 ——— 引脚1
         |
    LED芯片1 ——— 共同阳极 ——— 引脚2（接VCC）
         |
     绿色LED阴极 ——— 引脚3
         |
    LED芯片2 ——— 共同阳极 ——— 引脚2（接VCC）
```

**两个独立的LED**

- 这是**两个分离的LED器件**，通过特殊的电路连接实现单IO控制。

单IO控制的真正电路

以共阴极双色LED为例：

```c
IO口 ——— 限流电阻 ——— 红色LED阳极
                        |
                    双色LED
                        |
                   绿色LED阳极
                        |
                    共同阴极 ——— GND
```

但这样连接还是需要两个IO！

**真正的单IO推双灯电路**

- 实际上是这样的：

```c
VCC ——— 限流电阻1 ——— 红色LED阳极
                        |
                    双色LED  
                        |
                   绿色LED阳极 ——— 限流电阻2 ——— IO口
                        |
                    共同阴极 ——— GND
```

**工作原理：**

- **IO输出高电平**：绿色LED导通发光
- **IO输出低电平**：红色LED通过VCC导通发光
- **PWM控制**：可以混合两种颜色

所以答案是：**通常使用一个硬件的共阴极或共阳极双色LED**，而不是两个独立的LED。这种双色LED在外观上就是一个LED，但内部有两个不同颜色的芯片。

### 双IO推双灯

这种方案更灵活，可以实现更多状态：

```c
IO1 ——— 限流电阻1 ——— 红色LED阳极
                      |
                  红色LED阴极 ——— GND

IO2 ——— 限流电阻2 ——— 绿色LED阳极  
                      |
                  绿色LED阴极 ——— GND
```

**状态控制**

- **IO1=1, IO2=0**：红灯亮
- **IO1=0, IO2=1**：绿灯亮
- **IO1=1, IO2=1**：双灯同时亮（橙色）
- **IO1=0, IO2=0**：双灯灭
- **使用PWM**：两个IO都可以独立PWM控制，实现更丰富的颜色和亮度组合

**在TWS耳机中的应用**

对于你提到的红蓝LED，双IO方案更常见：

- 红色LED：充电/低电量指示
- 蓝色LED：蓝牙连接状态指示
- 可以通过PWM实现呼吸灯效果

单IO推双灯在成本敏感的场景下很有用，但颜色组合相对固定。双IO方案虽然多用一个IO，但控制更灵活，特别是配合PWM使用时效果更佳。

## 双IO口高低电平推灯

这个LED灯效控制代码通过状态机和定时器的组合来实现各种灯效模式。

### 核心实现机制

**初始化清理**

```c
led_cnt=0;
led_priv=0;
sys_timer_del(led_time);
led_time = 0;
```

每次设置新的LED模式前，先清理计数器、私有参数和定时器，确保状态干净。

**GPIO控制基础**

- `gpio_set_direction()`: 设置GPIO方向（0=输出，1=输入）

- `gpio_set_output_value()`: 设置GPIO输出电平（0=低电平，1=高电平）

- 通过控制两个LED引脚（GPIO_LED0_PIN和GPIO_LED1_PIN）实现不同效果

**定时器驱动的动态效果**

对于需要闪烁的效果，使用定时器机制：

```c
led_time = sys_timer_add(NULL, gpio_led_mode_display, 频率);
```

- 设置私有参数（`led_priv`）标识当前模式
- 添加定时器，定期调用`gpio_led_mode_display`函数
- 通过不同的频率实现快闪、慢闪效果

### 蓝灯慢闪

```c
void  gpio_led_mode_set(u8 led_mode)
{
    led_cnt=0;
    led_priv=0;
    sys_timer_del(led_time);
    led_time = 0;
    /**每次更新LED状态之前把计数器、私有参数、定时器都删除避免遗漏**/

    switch(led_mode){
            //......
        case GPIO_LED0_SLOW_FLASH:
            led_priv=_LED0_SLOW_FLASH_TIMER_PRIV;
            //频率为1000ms调用一次
            led_time=sys_timer_add(NULL,gpio_led_mode_display,CFG_GPIO_LED_SINGLE_SLOW_FLASH_FREQ);
        break;
```

**gpio_led_mode_display**

```c
void  gpio_led_mode_display()
{
       switch(led_priv){
               case _LED0_SLOW_FLASH_TIMER_PRIV://蓝灯1s闪一次
                   led_cnt^=1;
                   if(led_cnt){
                       gpio_set_direction(GPIO_LED0_PIN, 0);         //0：输出  1：输入
                       gpio_set_direction(GPIO_LED1_PIN , 0);         //0：输出  1：输入
                       gpio_set_output_value(GPIO_LED0_PIN,1);       //输出的状态
                       gpio_set_output_value(GPIO_LED1_PIN ,0);       //输出的状态
                   }
                   else{
                       gpio_set_direction(GPIO_LED0_PIN, 1);         //0：输出  1：输入
                       gpio_set_direction(GPIO_LED1_PIN , 1);         //0：输出  1：输入
                   }
               break;
```

**状态切换机制**

```c
led_cnt^=1;  // 关键：每次调用都翻转led_cnt的值（0变1，1变0）
```

这是一个**异或翻转操作**，实现了状态的自动切换：

- 第1次调用：`led_cnt = 0^1 = 1`
- 第2次调用：`led_cnt = 1^1 = 0`
- 第3次调用：`led_cnt = 0^1 = 1`
- 以此类推...

**根据状态控制LED**

```c
if(led_cnt){  // led_cnt=1时，点亮LED0
    gpio_set_direction(GPIO_LED0_PIN, 0);     // 设为输出模式
    gpio_set_direction(GPIO_LED1_PIN, 0);     // 设为输出模式
    gpio_set_output_value(GPIO_LED0_PIN,1);   // LED0输出高电平（亮）
    gpio_set_output_value(GPIO_LED1_PIN,0);   // LED1输出低电平（灭）
}
else{  // led_cnt=0时，关闭所有LED
    gpio_set_direction(GPIO_LED0_PIN, 1);     // 设为输入模式（相当于关闭）
    gpio_set_direction(GPIO_LED1_PIN, 1);     // 设为输入模式（相当于关闭）
}
```

**完整工作流程**

1. **初始化**：设置定时器，比如每1秒调用一次`gpio_led_mode_display()`
2. **第1秒**：`led_cnt`变为1 → LED0亮，LED1灭
3. **第2秒**：`led_cnt`变为0 → 两个LED都灭
4. **第3秒**：`led_cnt`变为1 → LED0亮，LED1灭
5. **循环往复**...

**关键技巧**

1. 异或翻转（`^=1`）

这是一个非常巧妙的状态切换技巧：

- 比`if-else`判断更简洁
- 自动实现0和1之间的切换
- 代码更紧凑

2.输入模式关闭LED

```c
gpio_set_direction(GPIO_LED0_PIN, 1);  // 设为输入模式
```

将GPIO设为输入模式是一种关闭LED的方式，因为输入模式下GPIO不会输出电流。

3.私有参数区分模式

通过`led_priv`参数，同一个回调函数可以处理多种不同的闪烁模式，每种模式有不同的状态切换逻辑。

这种设计非常适合嵌入式系统，因为它：

- 资源占用少
- 逻辑清晰
- 易于扩展新的闪烁模式
- 定时精确

### 改变亮灯的持续时间

```c
led_cnt^=1;  // 这种方式只能实现1:1的亮灭比例
```

**借鉴 五秒蓝灯闪烁一次，一次0.5s**

```c
void  gpio_led_mode_set(u8 led_mode)
{
    led_cnt=0;
    led_priv=0;
    sys_timer_del(led_time);
    led_time = 0;
    /**每次更新LED状态之前把计数器、私有参数、定时器都删除避免遗漏**/

    switch(led_mode){
            case GPIO_LED0_ONE_FLASH_5S:
               led_priv=_LED0_ONE_FLASH_5S_TIMER_PRIV;
               led_time=sys_timer_add(NULL,gpio_led_mode_display,500);
            break;
            
void  gpio_led_mode_display()
{
       switch(led_priv){
        case _LED0_ONE_FLASH_5S_TIMER_PRIV://蓝灯5s闪一次，一次维持0.5s
            led_cnt++;
            if(led_cnt<10) {
                gpio_set_direction(GPIO_LED0_PIN, 1);         //0：输出  1：输入
                gpio_set_direction(GPIO_LED1_PIN , 1);         //0：输出  1：输入
            } else {
                gpio_set_direction(GPIO_LED0_PIN, 0);         //0：输出  1：输入
                gpio_set_direction(GPIO_LED1_PIN , 0);         //0：输出  1：输入
                gpio_set_output_value(GPIO_LED0_PIN,1);       //输出的状态
                gpio_set_output_value(GPIO_LED1_PIN ,0);       //输出的状态
                led_cnt=0;
            }
        break;
```

我想两秒蓝灯闪烁一次的话。

```c
led_time=sys_timer_add(NULL,gpio_led_mode_display,500);
```

200ms调用一次。前9次熄灭，最后一次亮。2秒一个总周期，一次小周期的时间是。

### 关机闪烁三次

`apps\earphone\ui_manage.c`的`ui_manage_scan`

```c
case STATUS_POWEROFF:
        log_info("[STATUS_POWEROFF]\n");
        //判断配置是不是自定义灯效
        if (p_led->power_off != GPIO_LED1_FLASH_THREE) {
            //读取demo.c中的配置
            gpio_led_mode_set(p_led->power_off);
        } else {
            if (sys_ui_var.ui_flash_cnt) {
                //红灯闪烁三次
                if (sys_ui_var.ui_flash_cnt % 2) {
                    gpio_led_mode_set(GPIO_LED1_OFF);
                } else {
                    gpio_led_mode_set(GPIO_LED1_ON);
                }
            }
        }
break;
```

**目前是关机灯效没有生效，是关机前的灯效状态**

这样就行？？？狗东西

**果然读取配置是有问题的。判断也不要**

```c
if (sys_ui_var.ui_flash_cnt) {
    //红灯闪烁三次
    if (sys_ui_var.ui_flash_cnt % 2) {
        gpio_led_mode_set(GPIO_LED1_OFF);
    } else {
        gpio_led_mode_set(GPIO_LED1_ON);
    }
}
```

**这个也不行。**

在把关机回调函数的时间延长至1000，因为这个300ms调用一次。

```c
case STATUS_POWEROFF:
        log_info("[STATUS_POWEROFF]\n");
        //判断配置是不是自定义灯效
        //if (p_led->power_off != GPIO_LED1_FLASH_THREE) {
            //读取demo.c中的配置
            //gpio_led_mode_set(p_led->power_off);
        //} else {
            // if (sys_ui_var.ui_flash_cnt) {
            //     //红灯闪烁三次
            //     if (sys_ui_var.ui_flash_cnt % 2) {
            //         gpio_led_mode_set(GPIO_LED1_ON);
            //         //gpio_led_mode_set(GPIO_LED1_OFF);
            //     } else {
            //         //gpio_led_mode_set(GPIO_LED1_ON);
            //         gpio_led_mode_set(GPIO_LED1_OFF);
            //     }
            // }
            gpio_led_mode_set(GPIO_LED_flash_three);
        //}
        break;
```

```c
case  KEY_POWEROFF_HOLD:
#if (TCFG_USER_TWS_ENABLE && CONFIG_TWS_POWEROFF_SAME_TIME == 0)
        if ((u32)event->arg == KEY_EVENT_FROM_TWS) {
            break;
        }
#endif
        log_info("poweroff flag:%d cnt:%d\n", goto_poweroff_flag, goto_poweroff_cnt);

        if (goto_poweroff_flag) {
            //200累加一次
            goto_poweroff_cnt++;
#if CONFIG_TWS_POWEROFF_SAME_TIME
            if (goto_poweroff_cnt == POWER_OFF_CNT) {
                if (get_tws_sibling_connect_state()) {
                    if ((u32)event->arg != KEY_EVENT_FROM_TWS) {
                        //1000ms
                        tws_api_sync_call_by_uuid('T', SYNC_CMD_POWER_OFF_TOGETHER, TWS_SYNC_TIME_DO);
                    } else {
                        goto_poweroff_cnt--;
                    }
                } else {
                    sys_enter_soft_poweroff(NULL);
                }
            }
#else
            if (goto_poweroff_cnt >= POWER_OFF_CNT) {
                goto_poweroff_cnt = 0;
                sys_enter_soft_poweroff(NULL);
            }
#endif //CONFIG_TWS_POWEROFF_SAME_TIME

        }
        break;
```



### 软件配置分析

```c
//*********************************************************************************//
//                                  LED 配置                                       //
//*********************************************************************************//
//*********************************************************************************//
//      目前带anc的案子暂不使用pwm推灯模块，避免pwm推灯产生的噪声   2023.12.04
//      适用普通高低电平推灯流程   
//      驱动文件：.\cpu\br36\gpio_led.c  
//      头文件：.\include_lib\driver\cpu\br36\asm\gpio_led.h
//      驱动文件编译路径vscode需要在makefile添加，codeblck头文件跟C文件都要添加
//      gpio推灯默认流程给高电平灯亮，具体要跟硬件门同事核对，样机实际灯光颜色对应软件配置以实际验证为准
//*********************************************************************************//
#define TCFG_PWMLED_ENABLE					DISABLE_THIS_MOUDLE			//是否支持PMW LED推灯模块
#define TCFG_PWMLED_IOMODE					LED_TWO_IO_MODE				//LED模式，单IO还是两个IO推灯
#define TCFG_PWMLED_PIN0				    IO_PORTB_05					//LED使用的IO口
#define TCFG_PWMLED_PIN1					IO_PORTG_05					//LED使用的IO口


/*  普通高低电平推灯引脚*/
#define TCFG_GPIO_LED                       1//CONFIG_ANC_ENABLE
#define BULE_LED_PIN                        IO_PORTB_05     //红灯
#define RED_LED_PIN                         IO_PORTG_05     //蓝灯
#define GPIO_LED0_PIN				        BULE_LED_PIN	//LED1使用的IO口
#define GPIO_LED1_PIN					    RED_LED_PIN	    //LED2使用的IO口


#if (TCFG_GPIO_LED == ENABLE_THIS_MOUDLE)
#define TCFG_PWMLED_ENABLE					DISABLE_THIS_MOUDLE			//开了gpio推灯就不要开pwm推灯了
```

设置灯效的接口：

```c
gpio_led_mode_set(GPIO_LED0_LED1_FAST_FLASH);

void  gpio_led_mode_set(u8 led_mode)
{
    led_cnt=0;
    led_priv=0;
    sys_timer_del(led_time);
    led_time = 0;
    /**每次更新LED状态之前把计数器、私有参数、定时器都删除避免遗漏**/

    switch(led_mode){
        case GPIO_LED_ALL_OFF:
               gpio_set_direction(GPIO_LED0_PIN,1);         //0：输出  1：输入
               gpio_set_direction(GPIO_LED1_PIN,1);         //0：输出  1：输入
            break;
        case GPIO_LED0_LED1_FAST_FLASH://快闪
            gpio_set_direction(GPIO_LED0_PIN, 0);         //0：输出  1：输入
            gpio_set_direction(GPIO_LED1_PIN, 0);         //0：输出  1：输入
            led_priv=_LED0_LED1_FAST_FLASH_TIMER_PRIV;      
            led_time=sys_timer_add(NULL,gpio_led_mode_display,CFG_GPIO_LED_DOUBLE_FAST_FLASH_FREQ);
        	break;
```

利用非超时定时器实现周期灯效：

```c
int   led_time;
int   led_priv;
int   led_cnt;
void ui_manage_scan(void *priv);
void  gpio_led_mode_set(u8 led_mode);
void  gpio_led_mode_display()
{
       switch(led_priv){
           case _LED0_LED1_FAST_FLASH_TIMER_PRIV://红蓝0.5s交替闪
                led_cnt = !led_cnt;
                if(led_cnt>=10)led_cnt=0;   
                if(led_cnt){//红亮关蓝灯
                    gpio_set_output_value(GPIO_LED0_PIN,0);       //输出的状态
                    gpio_set_output_value(GPIO_LED1_PIN ,1);       //输出的状态
                } else {//蓝亮关红灯
                    gpio_set_output_value(GPIO_LED0_PIN,1);       //输出的状态
                    gpio_set_output_value(GPIO_LED1_PIN ,0);       //输出的状态
                }
               break;
           case _LED0_LED1_SLOW_FLASH_TIMER_PRIV://红蓝0.5s交替闪
                led_cnt = !led_cnt;
                if(led_cnt>=10)led_cnt=0;   
                if(led_cnt){//红亮关蓝灯
                    gpio_set_output_value(GPIO_LED0_PIN,0);       //输出的状态
                    gpio_set_output_value(GPIO_LED1_PIN ,1);       //输出的状态
                } else {//蓝亮关红灯
                    gpio_set_output_value(GPIO_LED0_PIN,1);       //输出的状态
                    gpio_set_output_value(GPIO_LED1_PIN ,0);       //输出的状态
                }
               break;
```

设置GPIO口的电平传输方向和高低电平。

## 灯效分了主从？

**TWS连接后双灯一起闪烁不是在：**

```c
case STATUS_BT_TWS_CONN:
        log_info("[STATUS_BT_TWS_CONN]\n");
        // earphone_tws_ledstatus(GPIO_LED0_LED1_FAST_FLASH,GPIO_LED0_ONE_FLASH_5S);
        //双耳同时慢闪
        //gpio_led_mode_set(GPIO_LED0_ONE_FLASH_5S);//wang
#if 1
        if (bt_tws_get_local_channel()=='L'){
		    gpio_led_mode_set(GPIO_LED0_ONE_FLASH_5S);
     	}else{
		    gpio_led_mode_set(GPIO_LED0_ONE_FLASH_5S);
		}
#endif
        break;
```

增加APP后有地方影响了TWS同步灯效：

```c
#if (TCFG_GPIO_LED == ENABLE_THIS_MOUDLE)
void ui_manage_scan(void *priv)
{

    STATUS *p_led = get_led_config();

    sys_ui_var.sys_ui_timer = 0;

    log_info("ui_flash_cnt:%d cur_ui_status:%d", sys_ui_var.ui_flash_cnt, sys_ui_var.current_status);
//......注释掉
#if 0 // ((RCSP_ADV_EN)&&(JL_EARPHONE_APP_EN))
    if (tws_api_get_role() == TWS_ROLE_SLAVE) {
        gpio_led_mode_set(GPIO_LED_ALL_OFF);
        return;
    }
#endif
```

## 超距断开灯效

### 问题

- 会出现蓝灯闪烁两次的问题，即使调用的是5s一次

`apps\earphone\earphone.c`的`bt_hci_event_handler`

- 这个函数是主事件分发自动调用的。

```c
#if USER_CONNECTION_TIMEOUT_LED
u8 dhf_connection_timeout_flag = 0;
#endif
//......
case ERROR_CODE_CONNECTION_TIMEOUT:
	log_info(" ERROR_CODE_CONNECTION_TIMEOUT \n");
#if USER_CONNECTION_TIMEOUT_LED
	dhf_connection_timeout_flag = 1;
#endif
	bt_hci_event_connection_timeout(bt);
break;
```

`apps\earphone\ui_manage.c`

```c
case STATUS_BT_DISCONN:
        log_info("[STATUS_BT_DISCONN]\n");
#if USER_CONNECTION_TIMEOUT_LED
        //单耳超距断开最后走这里
        extern u8 dhf_connection_timeout_flag;
        if (dhf_connection_timeout_flag) {
            dhf_connection_timeout_flag = 0;
            log_info("[2222222222222222222222222222222]**********************************************\n");
            pwm_led_mode_set(PWM_LED0_ONE_FLASH_5S);
        } else {
            //正常单双耳断开？？
            if(tws_api_get_tws_state() & TWS_STA_SIBLING_CONNECTED){
            // if(tws_api_get_local_channel()=='L'){
            pwm_led_mode_set(PWM_LED0_LED1_FAST_FLASH);//pwm_led_mode_set(PWM_LED0_LED1_FAST_FLASH);
            // }else{
            //     pwm_led_mode_set(PWM_LED0_SLOW_FLASH);//pwm_led_mode_set(PWM_LED0_ONE_FLASH_5S);
            // }
            }else{
                pwm_led_mode_set(PWM_LED0_LED1_FAST_FLASH);
            }
#endif
        break;
     
            //......
case STATUS_BT_TWS_CONN:
        log_info("[STATUS_BT_TWS_CONN]\n");
        // pwm_led_mode_set(p_led->tws_connect_ok);
        // if (bt_tws_get_local_channel()=='L'){
		//pwm_led_mode_set(PWM_LED0_LED1_SLOW_FLASH);//pwm_led_mode_set(PWM_LED0_LED1_FAST_FLASH);
     	// }else{
		//     pwm_led_mode_set(PWM_LED0_SLOW_FLASH);//pwm_led_mode_set(PWM_LED0_ONE_FLASH_5S);
		// }
#if USER_CONNECTION_TIMEOUT_LED
        //双耳超距断开，最后会走这里
        extern u8 dhf_connection_timeout_flag;
        if (dhf_connection_timeout_flag) {
            dhf_connection_timeout_flag = 0;
            log_info("[333333333333333333333333333333333]**********************************************\n");
            pwm_led_mode_set(PWM_LED0_ONE_FLASH_5S);
        } else {
            if(tws_api_get_tws_state() & TWS_STA_SIBLING_CONNECTED){
                // if(tws_api_get_local_channel()=='L'){
                pwm_led_mode_set(PWM_LED0_LED1_FAST_FLASH);//pwm_led_mode_set(PWM_LED0_LED1_FAST_FLASH);
                // }else{
                //     pwm_led_mode_set(PWM_LED0_SLOW_FLASH);//pwm_led_mode_set(PWM_LED0_ONE_FLASH_5S);
                // }
            }else{
                pwm_led_mode_set(PWM_LED0_LED1_FAST_FLASH);
            }
        }
#endif
        break;
```

**其他可以借鉴的地方**

`apps\earphone\board\br30\board_ad697n_demo_cfg.h`

```c
//*********************************************************************************//
//                                 自定义配置                                     //
//*********************************************************************************//
#define    CTMU_SHORT_LONG_DETECT_EN                1   //多击+长按

#define    CHARGE_FULL_LED_TIME                    10//30  //满电后亮灯持续时长，30秒

#define    THREE_CALL_DEAL_ENABLE                  1//三方通话使能

#define DAC_PA_EN         1//0
#define DAC_PA_PORT       IO_PORTC_03

#define USER_CONNECTION_TIMEOUT_LED     1//自定义超距断开连接灯效
#define USER_IO_CLICK_LONG_EN           1//io按键多击+长按
#define USER_LOW_TWS_POWEROFF_EN        1//低电同步关机
#define USER_LOW_POWER_LED_EN           1//低电LED灯效
```

697-241仓库可以借鉴

![image-20250721142721966](./开发问题.assets/image-20250721142721966.png)

## 开盖开机灯效状态

```c
    1.在耳机在仓内，开盖后更新的状态为：STATUS_CHARGE_LDO5V_OF,随后更新为BT_STATUS_INIT_OK，
    2.开机时更新两个STATUS_POWERON，随后BT_STATUS_INIT_OK.
    3.开机灯效建议设置在BT_STATUS_INIT_OK状态，因为如果设在STATUS_POWERON会由于更新两次，所以开机灯效会执行两次且期间会进行蓝牙初始化，耗时.
    4.耳机在仓充电，打开仓（如果有霍尔），更新的状态为STATUS_CHARGE_LDO5V_OF
    5.耳机和手机连接，更新状态为：STATUS_BT_CONN    耳机和手机断连：双耳未配对-STATUS_BT_DISCONN  双耳配对-STATUS_BT_TWS_CONN
    6.没电池充电-STATUS_CHARGE_CLOSE
    7.pwm_led_mode_set(0)灯会灭
    8.无法实现一个灯亮的同时另一个灯闪
```

## 充电闪灭问题

- `apps\earphone\ui_manage.c`

```c
case STATUS_POWEROFF:
        log_info("[STATUS_POWEROFF]\n");
#if (LED_IO_CHOOSE == 1)
        // pwm_led_mode_set(PWM_LED0_ON);
        // pwm_led_mode_set(PWM_LED_ALL_OFF);
        pwm_led_mode_set(PWM_LED1_ON);//关机亮灯
        // if (sys_ui_var.ui_flash_cnt) {
        //        if (sys_ui_var.ui_flash_cnt % 2) {
        //            pwm_led_mode_set(PWM_LED_ALL_OFF);
        //        } else {
        //            pwm_led_mode_set(PWM_LED1_ON);
        //        }
        //    }
#elif (LED_IO_CHOOSE == 2)
        // led_status_set(LED1_ON);
        if (p_led->power_off != PWM_LED1_FLASH_THREE) {
           pwm_led_mode_set(p_led->power_off);
       } else {
           if (sys_ui_var.ui_flash_cnt) {
               if (sys_ui_var.ui_flash_cnt % 2) {
                   led_status_set(ALL_OFF);
               } else {
                   led_status_set(LED1_ON);
               }
           }
       }
#endif
        break;
```

- `cpu\br36\charge.c`

```c
static void charge_full_detect(void *priv)
{
    static u16 charge_full_cnt = 0;

    if (CHARGE_FULL_FILTER_GET()) {
        /* putchar('F'); */
        if (CHARGE_FULL_FLAG_GET() && LVCMP_DET_GET()) {
            /* putchar('1'); */
            if (charge_full_cnt < 50) {//10改成50
                charge_full_cnt++;
            } else {
                charge_full_cnt = 0;
#if TCFG_CHARGE_CALIBRATION_ENABLE
                if (__this->result_flag && (__this->full_time == 0)) {
                    //第一次判满退出校准模式
                    __this->full_time = 1;
                    charge_exit_calibration_mode();
                    return;
                }
#endif
                power_awakeup_disable_with_port(IO_CHGFL_DET);
                usr_timer_del(__this->charge_timer);
                __this->charge_timer = 0;
                charge_event_to_user(CHARGE_EVENT_CHARGE_FULL);
            }
        } else {
            /* putchar('0'); */
            charge_full_cnt = 0;
        }
    } else {
        /* putchar('K'); */
        charge_full_cnt = 0;
        usr_timer_del(__this->charge_timer);
        __this->charge_timer = 0;
    }
}
```

不清楚为什么。

# 硬件配置

## MIC的配置

`apps\earphone\board\br36\board_ac700n_demo_cfg.h`以及`apps\earphone\board\br36\board_ac700n_demo.c`赋值的结构体数据。

### 双麦ANC+ENC

`apps\earphone\board\br36\board_ac700n_demo_cfg.h`

```c
/**************
 *ANC配置
 *************/
#define TCFG_AUDIO_ANC_ENABLE				CONFIG_ANC_ENABLE		//ANC总使能,根据global_bulid_cfg板级定义
#define TCFG_ANC_TOOL_DEBUG_ONLINE 			1//DISABLE_THIS_MOUDLE		//ANC工具蓝牙spp调试
#define TCFG_ANC_EXPORT_RAM_EN				DISABLE_THIS_MOUDLE		//ANCdebug数据释放RAM使能
#if TCFG_ANC_EXPORT_RAM_EN
#define TCFG_AUDIO_CVP_CODE_AT_RAM			DISABLE_THIS_MOUDLE
#define TCFG_AUDIO_AAC_CODE_AT_RAM			DISABLE_THIS_MOUDLE
#endif/*TCFG_ANC_EXPORT_RAM_EN*/
/*
 *当通话与ANC共用FF MIC，并且通话要求更大的MIC模拟增益时，使能TCFG_AUDIO_DYNAMIC_ADC_GAIN，
 *则通话MIC模拟增益以配置工具通话参数为准,通话时，ANC使用通话MIC模拟增益
 */
#define TCFG_AUDIO_DYNAMIC_ADC_GAIN			ENABLE_THIS_MOUDLE//anc模式下必须打开

#define ANC_TRAIN_MODE						ANC_FF_EN				//ANC类型配置：单前馈，单后馈，混合馈
#define ANC_CH 			 					ANC_R_CH //| ANC_R_CH	//ANC通道使能：左通道 | 右通道   什么通道就在什么通道中选择降噪麦
#define ANCL_FF_MIC							MIC_NULL					//ANC左通道FFMIC类型
#define ANCL_FB_MIC							MIC_NULL					//ANC左通道FBMIC类型
#define ANCR_FF_MIC							A_MIC0				//ANC右通道FFMIC类型看原理图FFMIC是什么麦，降噪MIC是pin16,PA1是MIC0，MIC1是PIN3对应的PB8，图中标注了。
#define ANCR_FB_MIC							MIC_NULL                //ANC右通道FBMIC类型   FB麦一般不用。
/*ANC最大滤波器阶数限制，若设置超过10，ANC配置区则占用8K(range: 10-20)*/
#define ANC_MAX_ORDER						10


/*限幅器-噪声门限*/
#define TCFG_AUDIO_NOISE_GATE				DISABLE_THIS_MOUDLE

/*通话下行降噪使能*/
#define TCFG_ESCO_DL_NS_ENABLE				DISABLE_THIS_MOUDLE

// AUTOMUTE
#if (TCFG_AUDIO_HEARING_AID_ENABLE && TCFG_AUDIO_DHA_AND_MUSIC_MUTEX)
#define AUDIO_OUTPUT_AUTOMUTE   			ENABLE_THIS_MOUDLE
#else
#define AUDIO_OUTPUT_AUTOMUTE   			DISABLE_THIS_MOUDLE
#endif/*TCFG_AUDIO_HEARING_AID_ENABLE*/


/*
 *系统音量类型选择
 *软件数字音量是指纯软件对声音进行运算后得到的
 *硬件数字音量是指dac内部数字模块对声音进行运算后输出
 */
#define VOL_TYPE_DIGITAL		0	//软件数字音量(调节解码输出数据的音量)
#define VOL_TYPE_ANALOG			1	//(暂未支持)硬件模拟音量
#define VOL_TYPE_AD				2	//(暂未支持)联合音量(模拟数字混合调节)
#define VOL_TYPE_DIGITAL_HW		3  	//硬件数字音量(调节DAC模块的硬件音量)
/*注意:ANC使能情况下使用软件数字音量*/
#if (TCFG_AUDIO_ANC_ENABLE || TCFG_AD2DA_LOW_LATENCY_ENABLE || TCFG_AUDIO_HEARING_AID_ENABLE)
#define SYS_VOL_TYPE            VOL_TYPE_DIGITAL
#else
#define SYS_VOL_TYPE            VOL_TYPE_DIGITAL_HW
#endif/*TCFG_AUDIO_ANC_ENABLE*/
/*
 *通话的时候使用数字音量
 *0：通话使用和SYS_VOL_TYPE一样的音量调节类型
 *1：通话使用数字音量调节，更加平滑
 */
#define TCFG_CALL_USE_DIGITAL_VOLUME		0

//第三方清晰语音开发使能
#define TCFG_CVP_DEVELOP_ENABLE             DISABLE_THIS_MOUDLE

/*通话降噪模式配置*/
#define CVP_ANS_MODE	0	/*传统降噪*/
#define CVP_DNS_MODE	1	/*神经网络降噪*/
#define TCFG_AUDIO_CVP_NS_MODE				CVP_DNS_MODE

/*
 * ENC(双mic降噪)配置
 * 双mic降噪包括DMS_NORMAL和DMS_FLEXIBLE，在使能TCFG_AUDIO_DUAL_MIC_ENABLE
 * 的前提下，根据具体需求，选择对应的DMS模式
 */
/*ENC(双mic降噪)使能*/
#define TCFG_AUDIO_DUAL_MIC_ENABLE			1//DISABLE_THIS_MOUDLE

/*DMS模式选择*/
#define DMS_NORMAL		1	//普通双mic降噪(mic距离固定)
#define DMS_FLEXIBLE	2	//适配mic距离不固定且距离比较远的情况，比如头戴式话务耳机
#define TCFG_AUDIO_DMS_SEL					DMS_NORMAL

/*ENC双mic配置主mic副mic对应的mic port*/
#define DMS_MASTER_MIC0		0 //mic0是主mic
#define DMS_MASTER_MIC1		1 //mic1是主mic
#define TCFG_AUDIO_DMS_MIC_MANAGE			DMS_MASTER_MIC1   //选择通话麦
/*双mic降噪/单麦mic降噪 DUT测试模式，配合设备测试mic频响和(双mic)降噪量*/
#define TCFG_AUDIO_DMS_DUT_ENABLE			1//DISABLE_THIS_MOUDLE 产测 必须要开

//MIC通道配置
#if TCFG_AUDIO_DUAL_MIC_ENABLE
#define TCFG_AUDIO_ADC_MIC_CHA				(LADC_CH_MIC_L | LADC_CH_MIC_R)  //选择双麦配置就是两个通道
#else
#define TCFG_AUDIO_ADC_MIC_CHA				LADC_CH_MIC_L                    //这是单麦通过，具体是左还是右。
#endif/*TCFG_AUDIO_DUAL_MIC_ENABLE*/
        /*mic信号输入端口配置：跟通话主麦的对应IO口一样的。
         *mic0:PA1
         *mic1:PB8*/
//#if (TCFG_AUDIO_ADC_MIC_CHA & LADC_CH_MIC_L)
        //audio_mic_pwr_io(IO_PORTA_01, 0);//MIC0
//#endif/*TCFG_AUDIO_ADC_MIC_CHA*/

//#if (TCFG_AUDIO_ADC_MIC_CHA & LADC_CH_MIC_R)
        //audio_mic_pwr_io(IO_PORTB_08, 0);//MIC1
//#endif/*TCFG_AUDIO_ADC_MIC_CHA*/
        //break;

/*MIC模式配置:单端隔直电容模式/差分隔直电容模式/单端省电容模式*/
#if (TCFG_AUDIO_ANC_ENABLE || TCFG_AUDIO_HEARING_AID_ENABLE)
/*注意:ANC/辅听功能使能情况下，使用差分mic*/
#define TCFG_AUDIO_MIC_MODE					AUDIO_MIC_CAP_DIFF_MODE
#define TCFG_AUDIO_MIC1_MODE				AUDIO_MIC_CAP_MODE
#else
#define TCFG_AUDIO_MIC_MODE					AUDIO_MIC_CAP_MODE
#define TCFG_AUDIO_MIC1_MODE				AUDIO_MIC_CAP_MODE
#endif/*TCFG_AUDIO_ANC_ENABLE*/

/*
 *>>MIC电源管理:根据具体方案，选择对应的mic供电方式
 *(1)如果是多种方式混合，则将对应的供电方式或起来即可，比如(MIC_PWR_FROM_GPIO | MIC_PWR_FROM_MIC_BIAS)
 *(2)如果使用固定电源供电(比如dacvdd)，则配置成DISABLE_THIS_MOUDLE
 */
#define MIC_PWR_FROM_GPIO		(1UL << 0)	//使用普通IO输出供电
#define MIC_PWR_FROM_MIC_BIAS	(1UL << 1)	//使用内部mic_ldo供电(有上拉电阻可配)
#define MIC_PWR_FROM_MIC_LDO	(1UL << 2)	//使用内部mic_ldo供电
//配置MIC电源
#if ((TCFG_AUDIO_MIC_MODE == AUDIO_MIC_CAP_DIFF_MODE) || (TCFG_AUDIO_MIC1_MODE == AUDIO_MIC_CAP_DIFF_MODE))
#define TCFG_AUDIO_MIC_PWR_CTL				    MIC_PWR_FROM_GPIO
#else
#define TCFG_AUDIO_MIC_PWR_CTL				MIC_PWR_FROM_GPIO//MIC_PWR_FROM_MIC_BIAS
#endif/*TCFG_AUDIO_MIC_MODE*/

//使用普通IO输出供电:不用的port配置成NO_CONFIG_PORT
#if (TCFG_AUDIO_MIC_PWR_CTL & MIC_PWR_FROM_GPIO)
#define TCFG_AUDIO_MIC_PWR_PORT				IO_PORTC_02
#define TCFG_AUDIO_MIC1_PWR_PORT			IO_PORTC_02
#define TCFG_AUDIO_MIC2_PWR_PORT			NO_CONFIG_PORT
#endif/*MIC_PWR_FROM_GPIO*/

//使用内部mic_ldo供电(有上拉电阻可配)
#if (TCFG_AUDIO_MIC_PWR_CTL & MIC_PWR_FROM_MIC_BIAS)
#define TCFG_AUDIO_MIC0_BIAS_EN				ENABLE_THIS_MOUDLE/*Port:PA2*/
#define TCFG_AUDIO_MIC1_BIAS_EN				ENABLE_THIS_MOUDLE/*Port:PB7*/
#endif/*MIC_PWR_FROM_MIC_BIAS*/

//使用内部mic_ldo供电(Port:PA0)
#if (TCFG_AUDIO_MIC_PWR_CTL & MIC_PWR_FROM_MIC_LDO)
#define TCFG_AUDIO_MIC_LDO_EN				ENABLE_THIS_MOUDLE
#endif/*MIC_PWR_FROM_MIC_LDO*/
/*>>MIC电源管理配置结束*/

/*Audio数据导出配置:通过蓝牙spp导出或者sd写卡导出*/
#define AUDIO_DATA_EXPORT_USE_SD	1
#define AUDIO_DATA_EXPORT_USE_SPP 	2
#define TCFG_AUDIO_DATA_EXPORT_ENABLE		DISABLE_THIS_MOUDLE

/*通话清洗语音处理数据导出*/
//#define AUDIO_PCM_DEBUG

/*通话参数在线调试*/
#define TCFG_AEC_TOOL_ONLINE_ENABLE         DISABLE_THIS_MOUDLE

/*麦克风在线调试*/
#define TCFG_AUDIO_MIC_DUT_ENABLE         	DISABLE_THIS_MOUDLE
```

主要修改：

- `TCFG_ANC_TOOL_DEBUG_ONLINE`

- `TCFG_AUDIO_DYNAMIC_ADC_GAIN`
- `ANCR_FF_MIC`
- `TCFG_AUDIO_CVP_NS_MODE`
- `TCFG_AUDIO_DUAL_MIC_ENABLE`
- `TCFG_AUDIO_DMS_DUT_ENABLE`
- MIC模式配置:单端隔直电容模式/差分隔直电容模式/单端省电容模式
- 配置MIC电源
- 使用普通IO输出供电:不用的port配置成NO_CONFIG_PORT

根据PIN脚的IO口判断是什么MIC：

- SDK跳转

```c
typedef enum {
    A_MIC0 = 0x0,			//模拟MIC0 PA1 PA2
    A_MIC1,                 //模拟MIC1 PB7 PB8
    D_MIC0,                 //数字MIC0(plnk_dat0_pin-上升沿采样)
    D_MIC1,                 //数字MIC1(plnk_dat1_pin-上升沿采样)
    D_MIC2,                 //数字MIC2(plnk_dat0_pin-下降沿采样)
    D_MIC3,                 //数字MIC3(plnk_dat1_pin-下降沿采样)
    MIC_NULL = 0XFF,		//没有定义相关的MIC
} ANC_mic_type_t;
```

工具中的通话配置跟这里一致。

### 单麦+ANC

一般都是差分，然后配置引脚共用。

## LED的配置

- `apps\earphone\board\br36\board_ac700n_demo_cfg.h`

```c
//多少个IO控制LED 
#define LED_IO_CHOOSE

//*********************************************************************************//
//                                  LED 配置                                       //
//*********************************************************************************//
#if (LED_IO_CHOOSE == 1)
#define TCFG_PWMLED_ENABLE					_TCFG_PWMLED_ENABLE			//是否支持PMW LED推灯模块
#define TCFG_PWMLED_IOMODE					_TCFG_PWMLED_IOMODE			//LED模式，单IO还是两个IO推灯
#define TCFG_PWMLED_PIN						_TCFG_PWMLED_PIN			//LED使用的IO口

#elif(LED_IO_CHOOSE == 2)

#define TCFG_PWMLED_ENABLE					0			//是否支持PMW LED推灯模块
#define TCFG_PWMLED_IOMODE					LED_ONE_IO_MODE				//LED模式，单IO还是两个IO推灯
#define TCFG_PWMLED_PIN						NO_CONFIG_PORT		        //LED使用的IO口

/*  普通高低电平推灯引脚*/
#define TCFG_GPIO_LED                       1
#define TCFG_PWMLED_PIN0				    IO_PORTA_08					//LED使用的IO口
#define TCFG_PWMLED_PIN1					IO_PORTA_06					//LED使用的IO口
```

# 电源

## 关机电压参数

`apps\earphone\include\app_power_manage.h`

```c
#define LOW_POWER_SHUTDOWN      300  //低电直接关机电压-拔出不开机-开盖不开机
#define LOW_POWER_OFF_VAL   	310  //低电关机电压
#define LOW_POWER_WARN_VAL   	340  //低电提醒电压
#define LOW_POWER_WARN_TIME   	(5 * 60 * 1000)  //低电提醒时间----单位是毫秒
```

## 关机方式

```c
sys_enter_soft_poweroff(NULL);//这个有关机灯效和提示音
//power_set_soft_poweroff();//这个直接关，啥都没有。
```

## 按键(上电)开机

`apps\earphone\board\br36\board_ac700n_demo_cfg.h`

```c
//*********************************************************************************//
//                                  系统配置                                         //
//*********************************************************************************//
#define TCFG_AUTO_SHUT_DOWN_TIME		          180   //没有蓝牙连接自动关机时间
#define TCFG_SYS_LVD_EN						      1   //电量检测使能
#define TCFG_POWER_ON_NEED_KEY                    1  //是否需要按按键开机配置
```

- 这是升级完是否自动开机的配置。
- 1就是升级完不开机，需要按键开机
- 0就是升级完自动开机，有一些机器可能就无法手动按键开机了。

# 硬件区分左右

![d041b58df968b90c380e215b239aa9f4](./开发问题.assets/d041b58df968b90c380e215b239aa9f4.png)

- 配对方式选择
- 那个引脚接了电阻
- 出现不能自动配对现象。

# D8改D4芯片带ANC

`cpu\br36\tools\isd_config_rule.c`

```c
/*******************用户配置区************************/
//加载ANC增益配置文件使能
#define CONFIG_ANCIF_GAINS_FILE_ENABLE		1
//加载ANC系数配置文件使能
#define CONFIG_ANCIF1_COEFF_FILE_ENABLE		1

//ANC配置区起始地址配置(跟进芯片flash容量进行配置)
//4Mbit:0x7E000 8Mbit:0xFE000 16Mbit:0x1FE000
#ifndef CONFIG_ANCIF_ADDR
#if ANC_MAX_ORDER > 10
#define CONFIG_ANCIF_ADDR	0xFD000
#else
    #if _IC_Model == 2
        #define CONFIG_ANCIF_ADDR	0x7E000 //AC7003D4
    #else
        #define CONFIG_ANCIF_ADDR	0xFE000 //AC7003D8
    #endif
#endif/*ANC_MAX_ORDER > 10 */
#endif/*CONFIG_ANCIF_ADDR*/

#ifndef CONFIG_ANCIF1_ADDR
#if ANC_MAX_ORDER > 10
#define CONFIG_ANCIF1_ADDR	0xFD100
#else
    #if _IC_Model == 2
        #define CONFIG_ANCIF1_ADDR	0x7E100 //AC7003D4
    #else
        #define CONFIG_ANCIF1_ADDR	0xFE100 //AC7003D8
    #endif
#endif/*ANC_MAX_ORDER > 10 */
#endif/*CONFIG_ANCIF1_ADDR*/
```

- 带ANC需要修改这里，其他不用修改。不然升级错误。

# 通话问题

## 单MIC带ANC

- 通话麦和降噪麦公用。配置写一样的。

## 双麦带ANC ENC

- 开启双麦DNS后，通话不正常，断断续续。

`apps\earphone\board\br36\board_ac700n_demo_cfg.h`

```c
#define CONFIG_BT_CALL_DNS_HZ           (128 * 1000000L)//(96 * 1000000L) 提高通话频率
```

`cpu\br36\setup.c`

```c
// clock_set_pll_target_frequency(240); FLASH数据校验失败就注释掉。
```

# 放电曲线

`apps\earphone\power_manage\app_power_manage.c`

根据表格去填范围：

```c
u8 get_vbat_percent(void)
{
    u16 tmp_bat_val;
    u16 bat_val = get_vbat_level();
    if (battery_full_value == 0) {
#if TCFG_CHARGE_ENABLE
        battery_full_value = (get_charge_full_value() - 100) / 10; //防止部分电池充不了这么高电量，充满显示未满的情况
#else
        battery_full_value = 420;
#endif
    }

    if (bat_val <= app_var.poweroff_tone_v) {
        return 0;
    }
    if(bat_val >= 406){        // 4.06V-4.3V区间都显示100%
    	tmp_bat_val = 100;
    }else if(bat_val >= 397){
        tmp_bat_val = 90;
    }else if(bat_val >= 389){
        tmp_bat_val = 80;
    }else if(bat_val >= 383){
        tmp_bat_val = 70;
    }else if(bat_val >= 377){
        tmp_bat_val = 60;
    }else if(bat_val >= 372){
        tmp_bat_val = 50;
    }else if(bat_val >= 367){
        tmp_bat_val = 40;
    }else if(bat_val >= 364){
        tmp_bat_val = 30;
    }else if(bat_val >= 360){
        tmp_bat_val = 20;
    }else if(bat_val >= 320){  // 可以调整这个值，手机最少显示10%，而且会在这个值附近关机。大于设置的低电关机电压时。
        tmp_bat_val = 10;
    }
    //else if(bat_val > 310){
        //tmp_bat_val = 5;
    //}else{
        //tmp_bat_val = 0;
    //}
    // tmp_bat_val = remap_calculate_vbat_percent(bat_val);
    // if (!tmp_bat_val) {
    //     tmp_bat_val = ((u32)bat_val - app_var.poweroff_tone_v) * 100 / (battery_full_value - app_var.poweroff_tone_v);
    //     if (tmp_bat_val > 100) {
    //         tmp_bat_val = 100;
    //     }
    // }
    return (u8)tmp_bat_val;
}
```

## 似乎改数组更加合理？

- 有更加严谨的判断与防抖。

```c
const struct VBAT_V_TO_LEVEL vbat_value_to_percent[] = {
    {405, 396, 90},
    {396, 390, 80},
    {393, 386, 70},
    {386, 380, 60},
    {380, 377, 50},
    {377, 370, 40},
    {370, 360, 30},
    {360, LOW_POWER_WARN_VAL, 20},
    {LOW_POWER_WARN_VAL, LOW_POWER_OFF_VAL, 10},
    {LOW_POWER_OFF_VAL, LOW_POWER_SHUTDOWN, 0},
};

__attribute__((weak)) u8 remap_calculate_vbat_percent(u16 bat_val)
{
    u8 i = 0;
    u8 percent = 0;
    u8 temp_percent = percent_save;
    static u32 time_ms = 0;
    if(bat_val >= vbat_value_to_percent[0].upper){
        percent = 100;
        local_detail_percent = 100;
        i = 0;
    }
    else if(bat_val < vbat_value_to_percent[ARRAY_SIZE(vbat_value_to_percent) - 1].lower){
        percent = 10;
        local_detail_percent = 0;
        i = ARRAY_SIZE(vbat_value_to_percent) - 1;
    }
    else{
        for (i = 0; i < ARRAY_SIZE(vbat_value_to_percent); i++)
        {
            if(bat_val >= vbat_value_to_percent[i].lower && bat_val < vbat_value_to_percent[i].upper){
                percent = vbat_value_to_percent[i].level;// + 9*(bat_val - vbat_value_to_percent[i].lower)/(vbat_value_to_percent[i].upper - vbat_value_to_percent[i].lower);
                local_detail_percent = vbat_value_to_percent[i].level + 9*(bat_val - vbat_value_to_percent[i].lower)/(vbat_value_to_percent[i].upper - vbat_value_to_percent[i].lower);
                break;
            }
        }
    }
    if(percent > 100){
        percent = 100;
    }
    else if(percent < 10){
        percent = 10;
    }
    if(temp_percent == 0xff 
        || (is_power_up && sys_timer_get_ms() < 2000 && get_lvcmp_det() == 0 
        && percent < temp_percent && abs((int)(temp_percent/10*10) - (int)(percent)) > 20))
    {
        printf("temp_percent abnormal, reset!!!\n");
        temp_percent = percent;//第一次上电开机，重置电量
    }
    if(get_charge_online_flag()){//if(get_lvcmp_det()){ //充电中
        if(sys_timer_get_ms() >= time_ms + CHARGING_POWER_PERCENT_UPDATE_TIME){
            time_ms = sys_timer_get_ms();
            if(temp_percent < percent){
                temp_percent++; //只允许变大
            }
            printf("bat_val %d --> percent %d, temp_percent %d %d %d\n", bat_val, percent, temp_percent, percent_save, local_detail_percent);
        }
        if(percent == 100 && temp_percent > 90 && bat_val >= 414){
            temp_percent = 100;//避免跳100慢
        }
    }
    else{ //非充电中
        if(sys_timer_get_ms() >= time_ms + NORMAL_POWER_PERCENT_UPDATE_TIME){
            time_ms = sys_timer_get_ms();
            u8 change = 0;
            if(temp_percent > percent){
                temp_percent--; //只允许变小
            }
            printf("bat_val %d --> percent %d, temp_percent %d %d %d\n", bat_val, percent, temp_percent, percent_save, local_detail_percent);
        }
    }
    percent_save = temp_percent;
    return percent_save;
}
```

![image-20250925093726895](./开发问题.assets/image-20250925093726895.png)

![image-20250925093850105](./开发问题.assets/image-20250925093850105.png)

使用表格中的这种数据。选一段完整放电的部分。

## 公式计算

- 满电电压到关机电压的持续放电时间。

![image-20250925094406486](./开发问题.assets/image-20250925094406486.png)

![image-20250925094428844](./开发问题.assets/image-20250925094428844.png)

只留下必要部分

![image-20250925094608237](./开发问题.assets/image-20250925094608237.png)

计算

![image-20250925095316554](./开发问题.assets/image-20250925095316554.png)

选最接近的就行。

```c
const struct VBAT_V_TO_LEVEL vbat_value_to_percent[] = {
    {433, 417, 90},
    {417, 406, 80},
    {406, 396, 70},
    {396, 388, 60},
    {388, 381, 50},
    {381, 376, 40},
    {376, 373, 30},
    {373, 369, 20},
    {369, 364, 10},
    {364, 302, 0},
};
```

宏替换的是值，不影响显示百分比。低电提醒电压依然可以独立。

但是我不知道怎么填入这个表格了，

```c
4.33为100%
4.17为90
4.06为80
3.96为70
3.88为60
3.81为50
3.76为40
3.73为30
3.69为20
3.64为10
2.99为0
```

**问题根源**：

- 100% 仅在 bat_val >= 433（4.33V）时触发，没有独立的 100% 区间。
- 4.33V 到 4.17V（16mV）直接映射到 90%，这意味着电压稍有下降（例如，4.32V），电量就会跳到 90%，导致 100% 持续时间过短。
- 锂电池在满电（通常 4.2V–4.35V）时，电压下降较慢，100% 应该覆盖一个更宽的电压范围（例如，4.35V–4.25V）。

4.33改为95%的电压值比如4.23，让100%持续就一点。

## 百分比映射原理（需要看代码）

该代码通过测量电池电压（bat_val，单位为毫伏）并结合预定义的电压-百分比对照表，计算电池的剩余电量百分比。以下是核心原理：

### **电压-百分比对照表**

代码定义了一个结构体数组 vbat_value_to_percent，用于映射电压范围到电池百分比：

```c
const struct VBAT_V_TO_LEVEL vbat_value_to_percent[] = {
    {433, 417, 90}, // 电压 4.33V–4.17V → 90%
    {417, 406, 80}, // 电压 4.17V–4.06V → 80%
    {406, 396, 70}, // ...
    {396, 388, 60},
    {388, 381, 50},
    {381, 376, 40},
    {376, 373, 30},
    {373, 369, 20},
    {369, 364, 10},
    {364, 302, 0},  // 电压 3.64V–3.02V → 0%
};
```

- **结构**：每个条目包含 upper（上限电压）、lower（下限电压）和 level（对应电量百分比，步进10%）。

- **作用**：通过电压范围确定电池电量的基础百分比。

### **计算逻辑**

函数 remap_calculate_vbat_percent 根据输入电压 bat_val 计算电池百分比 (percent_save)，主要步骤如下：

#### **电压范围匹配**

- 边界情况：
  - 如果 bat_val ≥ 4.33V，电量设为 **100%**。
  - 如果 bat_val < 3.02V，电量设为 **0%**（但显示为10%以避免过低）。

- **范围查找**：

  - 遍历对照表，找到 bat_val 所在的电压范围。

  - 基础百分比 (percent) 设为该范围的 level。

  - 使用线性插值计算更精确的百分比 (local_detail_percent)：

  ```c
  local_detail_percent = level + 9 * (bat_val - lower) / (upper - lower)
  ```

  示例：若 bat_val = 4.10V 落在 {417, 406, 80} 范围：

  - percent = 80
  - local_detail_percent = 80 + 9 * (410 - 406) / (417 - 406) ≈ 83.27%

#### **百分比限制**

- 确保 percent 在 10%–100% 之间：

```c
if (percent > 100) percent = 100;
else if (percent < 10) percent = 10;
```

#### **平滑处理**

- 使用 temp_percent（保存为 percent_save）避免电量显示快速波动：
  - 充电状态：
    - 每隔 CHARGING_POWER_PERCENT_UPDATE_TIME 毫秒更新。
    - temp_percent 只能增加（避免充电时电量下降）。
    - 特殊情况：若 percent = 100，temp_percent > 90，且 bat_val ≥ 4.14V，直接设为 100%。
  - 非充电状态：
    - 每隔 NORMAL_POWER_PERCENT_UPDATE_TIME 毫秒更新。
    - temp_percent 只能减少（避免电量突然上升）。
  - 初始化处理：
    - 若 temp_percent 未初始化（0xFF）或开机初期（2秒内，无低电压检测，且电量下降异常），重置为当前 percent。

#### **返回结果**

- 最终 temp_percent 保存为 percent_save 并返回，作为显示的电池百分比。

#### **核心原理总结**

1. **电压映射**：通过查找表将电压映射到电量百分比，结合线性插值提高精度。
2. **平滑机制**：通过 temp_percent 限制电量变化速度（充电时只增，非充电时只减）。
3. **边界处理**：电压高于 4.33V 为 100%，低于 3.02V 为 0%（显示 10%）。
4. **时间控制**：定期更新（充电和非充电状态使用不同时间间隔）。
5. **充电优化**：快速达到 100% 的逻辑，避免显示延迟。

##### **示例**

假设 bat_val = 4.10V，非充电状态：

1. 匹配范围 {417, 406, 80}，percent = 80，local_detail_percent ≈ 83.27%。
2. 若 temp_percent = 85，且时间间隔足够，temp_percent 减小到 84。
3. 返回 percent_save = 84。

##### **注意事项**

- 电压单位为毫伏（bat_val 表示实际电压 × 100，如 433 表示 4.33V）。
- 依赖外部函数（如 get_charge_online_flag()）判断充电状态。
- 插值公式仅用于 local_detail_percent，percent 当前未使用插值（注释掉）。

# 获取是否播放音乐的状态

```c
if(a2dp_get_status() == BT_MUSIC_STATUS_STARTING){
	//音乐状态下不进入siri
}else {
	user_send_cmd_prepare(USER_CTRL_HFP_GET_SIRI_OPEN, 0, NULL);
}
```

# 超距断开回连超时时间设置

## 对耳与手机超距

- `apps\earphone\earphone.c`

```c
#define TIMEOUT_CONN_TIME         60 //超时断开之后回连的时间s
#define POWERON_AUTO_CONN_TIME    12  //开机去回连的时间
#define TWS_RETRY_CONN_TIMEOUT    ((rand32() & BIT(0)) ? 200 : 400)
#define PHONE_DLY_DISCONN_TIME    0//4000  //超时断开，快速连接上不播提示音

static void bt_hci_event_connection_timeout(struct bt_event *bt)//这是手机断开的
{
    earphone_change_pwr_mode(PWR_LDO15, 0);

    if (chargestore_get_ex_enter_dut_flag()) {
        bt_discovery_and_connectable_using_loca_mac_addr(1, 1);
        return;
    }

    if (!get_remote_test_flag() && !get_esco_busy_flag()) {
        bt_user_priv_var.auto_connection_counter = (TIMEOUT_CONN_TIME * 1000);
        memcpy(bt_user_priv_var.auto_connection_addr, bt->args, 6);
#if TCFG_USER_TWS_ENABLE
        bt_tws_phone_connect_timeout();
#else
        //......
```

## 耳机回连时间长



## 对耳之间超距

暂时不知道。

## 对耳回连超时

`apps\earphone\include\app_config.h`

```c
//*********************************************************************************//
//                                 对耳配置方式配置                                    //
//*********************************************************************************//
#define CONFIG_TWS_CONNECT_SIBLING_TIMEOUT    4    /* 开机或超时断开后对耳互连超时时间，单位s */ 15s的话，单耳回连手机的时间会增加，因为回连对耳的时间太久。
#define CONFIG_TWS_REMOVE_PAIR_ENABLE              /* 不连手机的情况下双击按键删除配对信息 */
#define CONFIG_TWS_POWEROFF_SAME_TIME         0//1    /*按键关机时两个耳机同时关机*/

#define ONE_KEY_CTL_DIFF_FUNC                 1    /*通过左右耳实现一个按键控制两个功能*/
#define CONFIG_TWS_SCO_ONLY_MASTER			  0	   /*通话的时候只有主机出声音*/
```

# 接口

## 获取TWS连接状态

```c
bool get_tws_sibling_connect_state(void)
{
    if (gtws.state & BT_TWS_SIBLING_CONNECTED) {
        return TRUE;
    }
    return FALSE;
}
```

# 是否带APP

```c
//*********************************************************************************//
//                                  AI配置                                       //
//*********************************************************************************//
#define CONFIG_APP_BT_ENABLE

#ifdef CONFIG_APP_BT_ENABLE
#define    TRANS_DATA_EN             0
#define    RCSP_BTMATE_EN            0
#define    RCSP_ADV_EN               1
#define    AI_APP_PROTOCOL           0
#define    LL_SYNC_EN                0
#define    TUYA_DEMO_EN              0
#else
#define    TRANS_DATA_EN             0
#define    RCSP_BTMATE_EN            0
#define    RCSP_ADV_EN               0
#define    AI_APP_PROTOCOL           0
#define    LL_SYNC_EN                0
#define    TUYA_DEMO_EN              0
#endif


#if BLE_CONNECT_SMARTBOX
#define CONFIG_APP_BT_ENABLE
#define    RCSP_ADV_EN               1
#endif

// #include "board_config.h"

#if CONFIG_UPDATE_WITH_MD5_CHECK_EN
#define UPDATE_MD5_ENABLE			1
#else
#define UPDATE_MD5_ENABLE			0
#endif
```

## 固件生成脚本的变化

```bash
@echo off
Setlocal enabledelayedexpansion
@echo ********************************************************************************
@echo SDK BR36
@echo ********************************************************************************
@echo %date%


cd /d %~dp0

set OBJDUMP=C:\JL\pi32\bin\llvm-objdump.exe
set OBJCOPY=C:\JL\pi32\bin\llvm-objcopy.exe
set ELFFILE=sdk.elf
set bankfiles=
set LZ4_PACKET=.\lz4_packet.exe

REM %OBJDUMP% -D -address-mask=0x1ffffff -print-dbg $1.elf > $1.lst
%OBJCOPY% -O binary -j .text %ELFFILE% text.bin
%OBJCOPY% -O binary -j .data %ELFFILE% data.bin
%OBJCOPY% -O binary -j .data_code %ELFFILE% data_code.bin
%OBJCOPY% -O binary -j .overlay_aec %ELFFILE% aec.bin
%OBJCOPY% -O binary -j .overlay_aac %ELFFILE% aaco.bin
%OBJCOPY% -O binary -j .overlay_aptx %ELFFILE% aptx.bin

%OBJCOPY% -O binary -j .common %ELFFILE% common.bin

remove_tailing_zeros -i aaco.bin -o aac.bin -mark ff

for /L %%i in (0,1,20) do (
            %OBJCOPY% -O binary -j .overlay_bank%%i %ELFFILE% bank%%i.bin
                set bankfiles=!bankfiles! bank%%i.bin 0x0
        )


%LZ4_PACKET% -dict text.bin -input common.bin 0 aec.bin 0 aac.bin 0 !bankfiles! -o bank.bin

%OBJDUMP% -section-headers -address-mask=0x1ffffff %ELFFILE%
REM %OBJDUMP% -t %ELFFILE% > symbol_tbl.txt

copy /b text.bin + data.bin + data_code.bin + bank.bin app.bin

del !bankfiles! common.bin text.bin data.bin bank.bin
copy eq_cfg_hw_less.bin eq_cfg_hw.bin
call download/earphone/download_app_ota.bat

copy eq_cfg_hw_less.bin eq_cfg_hw.bin
这是复制并覆盖操作，具体行为是：
复制 eq_cfg_hw_less.bin 的内容
创建或覆盖 eq_cfg_hw.bin 文件
保留原文件 eq_cfg_hw_less.bin（源文件不会被删除）
```

调用ota后缀脚本

```bash
@echo off

cd %~dp0

..\..\json_to_res.exe json.txt
copy ..\..\script.ver .
copy ..\..\tone.cfg .
copy ..\..\p11_code.bin .
copy ..\..\anc_coeff.bin .
copy ..\..\anc_gains.bin .
copy ..\..\br36loader.bin .
copy ..\..\ota.bin .


..\..\isd_download.exe ..\..\isd_config.ini -tonorflash -dev br36 -boot 0x20000 -div8 -wait 300 -uboot ..\..\uboot.boot -app ..\..\app.bin -res ..\..\cfg_tool.bin tone.cfg p11_code.bin ..\..\config.dat eq_normal.bin eq_pop.bin eq_rock.bin eq_class.bin eq_jazz.bin eq_film.bin eq_music.bin eq_game.bin -uboot_compress -key 141-AMW-AC690X-41C3.key  -format vm -reboot 2500
::-format vm

::-key AC690X-8029.key
::-reboot 2500

@rem ɾ    ʱ ļ -format all
if exist *.mp3 del *.mp3 
if exist *.PIX del *.PIX
if exist *.TAB del *.TAB
if exist *.res del *.res
if exist *.sty del *.sty

..\..\ufw_maker.exe -fw_to_ufw jl_isd.fw
copy jl_isd.ufw update.ufw
del jl_isd.ufw

@REM          ļ      ļ 
::ufw_maker.exe -chip AC800X %ADD_KEY% -output config.ufw -res bt_cfg.cfg

::IF EXIST jl_696x.bin del jl_696x.bin 

@rem         ˵  
@rem -format vm        //    VM     
@rem -format cfg       //    BT CFG     
@rem -format 0x3f0-2   //  ʾ ӵ  0x3f0    sector   ʼ         2    sector(  һ      Ϊ16   ƻ 10   ƶ  ɣ  ڶ             10    )

ping /n 2 127.1>null
IF EXIST null del null

```

使用多个独立的eq的bin文件，在程序中切换。之前的`eq_cfg_hw.bin`只包含音乐eq和通话eq。如果有多个音乐风格的需求就不行了。

## 程序中切换不同eq文件

`cpu\br36\audio\eq_config.c`

```c
u8 curr_eq_index = 0;
const u8 *eq_file_list[] = {
    (u8 *)SDFILE_RES_ROOT_PATH"eq_normal.bin",//0
    (u8 *)SDFILE_RES_ROOT_PATH"eq_rock.bin",//1
    (u8 *)SDFILE_RES_ROOT_PATH"eq_pop.bin",//2
    (u8 *)SDFILE_RES_ROOT_PATH"eq_class.bin",//3
    (u8 *)SDFILE_RES_ROOT_PATH"eq_jazz.bin",//4

    //音效界面
    (u8 *)SDFILE_RES_ROOT_PATH"eq_film.bin",//5
    (u8 *)SDFILE_RES_ROOT_PATH"eq_music.bin",//6
    (u8 *)SDFILE_RES_ROOT_PATH"eq_game.bin",//7

};

void eq_effect_switch(u8 index)
{
    if(index == 0xff){
        //u8下标越界保护
        curr_eq_index++;
        if(curr_eq_index >= ARRAY_SIZE(eq_file_list)){
            //重新回到第一个
            curr_eq_index = 0;
        }
    }else{
        if(index >= ARRAY_SIZE(eq_file_list)){
            //越界返回
            return;
        }
        curr_eq_index = index;
    }

#if (!TCFG_EQ_ONLINE_ENABLE) //如果是在线调试eq，这个失效
    EQ_CFG *eq_cfg = get_eq_cfg_hdl();
    if(!eq_cfg){
        return;
    }
    eq_cfg->eq_type = EQ_TYPE_FILE;
    int ret = eq_file_get_cfg(eq_cfg, eq_file_list[curr_eq_index]);
    printf("eq_effect_switch %d ret %d\n", curr_eq_index, ret);
#endif
}
```

# 回连速度慢

## 有连接记录，耳机入仓再出仓回连速度慢（单耳）

- 单耳似乎会先回连TWS对耳，再回连手机

减少对耳的回连时间就可以提升回连手机的速度

```c
//*********************************************************************************//
//                                 对耳配置方式配置                                    //
//*********************************************************************************//
#define CONFIG_TWS_CONNECT_SIBLING_TIMEOUT    4    /* 开机或超时断开后对耳互连超时时间，单位s */ 之前改成15了，导致回连速度慢
```

# 关闭断言

`apps\earphone\log_config\lib_system_config.c`

```c
///异常中断，asser打印开启
#ifdef CONFIG_RELEASE_ENABLE
const int config_asser         = 0;//开启设置为1，试产要关闭
#else
const int config_asser         = 1;
#endif
```

