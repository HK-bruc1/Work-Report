# 开低功耗

- 功耗不行
  - 先看有没有开低功耗
  - 再看在EQ有没有关
  - 看官方文档

开低功耗可以1mA以下。不开一般5mA以内。

```c
//*********************************************************************************//
//                                  低功耗配置                                     //
//*********************************************************************************//
#define TCFG_LOWPOWER_POWER_SEL				PWR_DCDC15//PWR_LDO15                    //电源模式设置，可选DCDC和LDO
#define TCFG_LOWPOWER_BTOSC_DISABLE			0                            //低功耗模式下BTOSC是否保持
#define TCFG_LOWPOWER_LOWPOWER_SEL			1//0   //芯片是否进入powerdown
/*强VDDIO等级配置,可选：
    VDDIOM_VOL_20V    VDDIOM_VOL_22V    VDDIOM_VOL_24V    VDDIOM_VOL_26V
    VDDIOM_VOL_30V    VDDIOM_VOL_30V    VDDIOM_VOL_32V    VDDIOM_VOL_36V*/
#define TCFG_LOWPOWER_VDDIOM_LEVEL			VDDIOM_VOL_28V
/*弱VDDIO等级配置，可选：
    VDDIOW_VOL_21V    VDDIOW_VOL_24V    VDDIOW_VOL_28V    VDDIOW_VOL_32V*/
#define TCFG_LOWPOWER_VDDIOW_LEVEL			VDDIOW_VOL_26V               //弱VDDIO等级配置
#define TCFG_LOWPOWER_OSC_TYPE              OSC_TYPE_LRC
#define TCFG_LOWPOWER_LIGHT_SLEEP_ATTRIBUTE 	LOWPOWER_LIGHT_SLEEP_ATTRIBUTE_KEEP_CLOCK 		//低功耗LIGHT模式属性, 可以选择是否保持住一些电源和时钟

```

看是否带ANC，可能会影响ANC效果以及灯效。

`apps\earphone\board\br36\board_ac700n_demo_cfg.h`

```c
/**************
 *ANC配置
 *************/
#define TCFG_AUDIO_ANC_ENABLE				CONFIG_ANC_ENABLE		//ANC总使能,根据global_bulid_cfg板级定义
#define TCFG_ANC_TOOL_DEBUG_ONLINE 			1//DISABLE_THIS_MOUDLE		//ANC工具蓝牙spp调试
#define TCFG_ANC_EXPORT_RAM_EN				DISABLE_THIS_MOUDLE		//ANCdebug数据释放RAM使能
#if TCFG_ANC_EXPORT_RAM_EN
#define TCFG_AUDIO_CVP_CODE_AT_RAM			DISABLE_THIS_MOUDLE
#define TCFG_AUDIO_AAC_CODE_AT_RAM			DISABLE_THIS_MOUDLE
#endif/*TCFG_ANC_EXPORT_RAM_EN*/
```

**要保护的IO口**

`apps\earphone\board\br36\board_ac700n_demo.c`

```c
#if TCFG_AUDIO_ANC_ENABLE
	if(anc_status_get() && (!is_softoff)){
		//ANC 低功耗状态下需要保持的IO口
		port_protect(port_group, TCFG_AUDIO_MIC_PWR_PORT); 
	}
#endif/*TCFG_AUDIO_ANC_ENABLE*/
	gpio_set_pull_up(IO_PORT_DP, 0);
    gpio_set_pull_down(IO_PORT_DP, 0);
    gpio_set_die(IO_PORT_DP, 0);
    gpio_set_dieh(IO_PORT_DP, 0);
    gpio_set_direction(IO_PORT_DP, 1);
    //冲突了？保护PC2但是DM脚与它共用？
    //DM的状态有消耗？还是不行。。。
    // gpio_set_pull_up(IO_PORT_DM, 0);
    // gpio_set_pull_down(IO_PORT_DM, 0);
    // gpio_set_die(IO_PORT_DM, 0);
    // gpio_set_dieh(IO_PORT_DM, 0);
    // gpio_set_direction(IO_PORT_DM, 1);
```



## 连接状态进入低功耗后，功耗会跳变

- **公版也会跳动。**

**解决**

# ANC

## 记忆模式

`cpu\br36\audio\audio_anc.h`

```c
#define ANC_INFO_SAVE_ENABLE	1//0	/*ANC信息记忆:保存上一次关机时所处的降噪模式等等*/
```

## 每次都保存ANC模式

`cpu\br36\audio\audio_anc.c`

```c
/*ANC信息保存*/
void anc_info_save()
{
    if (anc_hdl) {
        anc_info_t anc_info;
        int ret = syscfg_read(CFG_ANC_INFO, &anc_info, sizeof(anc_info));
        if (ret == sizeof(anc_info)) {
#if INEAR_ANC_UI
            if (anc_info.mode == anc_hdl->param.mode && anc_info.inear_tws_mode == inear_tws_ancmode) {
#else
            if (anc_info.mode == anc_hdl->param.mode) {
#endif/*INEAR_ANC_UI*/
                user_anc_log("anc info.mode == cur_anc_mode");
                return;
            }
        } else {
            user_anc_log("read anc_info err");
        }

        user_anc_log("save anc_info");
        //anc_info.mode = anc_hdl->param.mode;//anc_hdl->param.mode = ANC_OFF;
        anc_info.mode = ANC_ON; //打开记忆功能，每次都保存ANC，保证每次开机都是ANC_ON状态
#if INEAR_ANC_UI
        anc_info.inear_tws_mode = inear_tws_ancmode;
#endif/*INEAR_ANC_UI*/
        ret = syscfg_write(CFG_ANC_INFO, &anc_info, sizeof(anc_info));
        if (ret != sizeof(anc_info)) {
            user_anc_log("anc info save err!\n");
        }

    }
}
```

## 开降噪测试

在降噪测试仪上测降噪。

跟调ANC参数同理。开SPP。

![image-20250710153357644](./开发问题.assets/image-20250710153357644.png)

![23a65beb4289055848245fd3e3cc493](./开发问题.assets/23a65beb4289055848245fd3e3cc493.png)

`apps\earphone\board\br36\board_ac700n_demo_cfg.h`

![image-20250710153742390](./开发问题.assets/image-20250710153742390.png)

![image-20250710154312652](./开发问题.assets/image-20250710154312652.png)

- 自动打开SPP和在线调试功能

- **`TCFG_AEC_TOOL_ONLINE_ENABLE`** - 回音消除（AEC）参数在线调试功能开启
- **`TCFG_AUDIO_DMS_DUT_ENABLE`** - 双麦克风降噪DUT（Device Under Test）模式开启
- **`TCFG_ANC_TOOL_DEBUG_ONLINE`** - ANC（主动降噪）工具蓝牙SPP调试功能开启
- **`TCFG_COMM_TYPE == TCFG_SPP_COMM`** - 通信类型配置为SPP通信模式

当上述任意条件满足时，代码会：

```c
#undef USER_SUPPORT_PROFILE_SPP    // 取消之前的定义
#undef APP_ONLINE_DEBUG            // 取消之前的定义
#define USER_SUPPORT_PROFILE_SPP 1  // 启用SPP配置文件支持
#define APP_ONLINE_DEBUG 1          // 启用应用在线调试功能
```

允许在需要调试功能时自动启用SPP支持，避免在正常产品中包含不必要的调试代码。

- **还是要手动打开`APP_ONLINE_DEBUG`，降噪仪器才能使用。**
- **开对应的调试宏，开SPP，开在线调试宏。**

![image-20250710154601430](./开发问题.assets/image-20250710154601430.png)



# EQ

## 音乐整体音量

- 播放整体音量降1db
- 直接在 音乐eq 上去减

![image-20250709164603161](./开发问题.assets/image-20250709164603161.png)

![image-20250709164627274](./开发问题.assets/image-20250709164627274.png)

![image-20250709164718048](./开发问题.assets/image-20250709164718048.png)

- 根据是否开ANC，选择EQ文件进行修改

![image-20250709164802179](./开发问题.assets/image-20250709164802179.png)

![image-20250709164847505](./开发问题.assets/image-20250709164847505.png)

![image-20250709164945597](./开发问题.assets/image-20250709164945597.png)

![image-20250709165045040](./开发问题.assets/image-20250709165045040.png)

**编译后，最终eq会被替换。最明显的标志就是两者的修改时间是一样的。但是这一次校验码没变，不知道为什么。**

## 支持eq配置bin文件切换

可以切换`NORMAL`和`BASS`的EQ

`apps\earphone\board\br36\board_ac700n_demo_cfg.h`

```c
#define TCFG_USE_EQ_FILE                          1    //离线eq使用配置文件还是默认系数表 1：使用文件  0 使用默认系数表
#define TCFG_EQ_FILE_SWITCH_EN                    1//0     //支持eq配置文件切换(需使能TCFG_USE_EQ_FILE)
```

**切换时的提示音**

`apps\earphone\include\tone_player.h`

使用工具转换。

```c
#define TONE_NORMAL_EQ  		SDFILE_RES_ROOT_PATH"tone/normal_eq.*"
#define TONE_BASS_EQ  	    	SDFILE_RES_ROOT_PATH"tone/bass_eq.*"

IDEX_TONE_NORMAL_EQ,
IDEX_TONE_BASS_EQ,
```

`eq_file_switch();`

```c
#if TCFG_EQ_FILE_SWITCH_EN
//根据eq_file_switch_list切换到指定的eq文件
void eq_file_set_by_index(u8 index)
{
    if (index >= ARRAY_SIZE(eq_file_switch_list)) {
        printf("err, max index %d\n", ARRAY_SIZE(eq_file_switch_list));
        return;
    }
    EQ_CFG *eq_cfg = get_eq_cfg_hdl();
    if (!eq_cfg) {
        return;
    }
    int ret = eq_file_get_cfg(eq_cfg, eq_file_switch_list[index]);
    printf("eq_file_switch : %d, ret : %d", index, ret);
}

//根据eq_file_switch_list成员个数顺序切换eq文件
void eq_file_switch()
{
    static u8 index = 0;
    // index++;
    // if (index >= ARRAY_SIZE(eq_file_switch_list)) {
    //     index = 0;
    // }
    if(index){
        tone_play_index(IDEX_TONE_NORMAL_EQ,1);
    }else{
        tone_play_index(IDEX_TONE_BASS_EQ,1);
    }
    index = !index;
    eq_file_set_by_index(index);
}
#endif
```

`cpu\br36\audio\eq_config.c`

```c
#if TCFG_EQ_FILE_SWITCH_EN
const u8 *eq_file_switch_list[] = {
    (u8 *)SDFILE_RES_ROOT_PATH"eq_cfg_hw.bin",
    (u8 *)SDFILE_RES_ROOT_PATH"eq_cfg_hw1.bin",
    // (u8 *)SDFILE_RES_ROOT_PATH"eq_cfg_hw2.bin",
};
#endif
```

使用不同的eq的bin文件实现不同音效模式。

## 在线调EQ

不定义就会报错：

![image-20250710154816244](./开发问题.assets/image-20250710154816244.png)

# 提示音

## 生效

`apps\earphone\include\tone_player.h`工具转换了，但是代码不引用也是不生效的。

![image-20250710144010243](./开发问题.assets/image-20250710144010243.png)

![image-20250710144117998](./开发问题.assets/image-20250710144117998.png)

## 最大提示音需要打断（抢断）音乐

`apps\earphone\key_event_deal.c`

```c
void volume_up(u8 inc)
{
    u8 test_box_vol_up = 0x41;
    s8 cur_vol = 0;
    u8 call_status = get_call_status();

    if (tone_get_status() && volume_flag) {
        if (get_call_status() == BT_CALL_INCOMING) {
            volume_up_down_direct(1);
        }
        return;
    }

    /*打电话出去彩铃要可以调音量大小*/
    if ((call_status == BT_CALL_ACTIVE) || (call_status == BT_CALL_OUTGOING)) {
        cur_vol = app_audio_get_volume(APP_AUDIO_STATE_CALL);
    } else {
        cur_vol = app_audio_get_volume(APP_AUDIO_STATE_MUSIC);
    }
    if (get_remote_test_flag()) {
        user_send_cmd_prepare(USER_CTRL_TEST_KEY, 1, &test_box_vol_up); //音量加
    }

    if (cur_vol >= app_audio_get_max_volume()) {
#if TCFG_USER_TWS_ENABLE
        if (get_tws_sibling_connect_state()) {
            if (tws_api_get_role() == TWS_ROLE_MASTER && replay_tone_flag) {
                replay_tone_flag = 0;               //防止提示音被打断标志
                bt_tws_play_tone_at_same_time(SYNC_TONE_MAX_VOL, 400);
                max_tone_timer_hdl = sys_timeout_add(NULL, max_tone_timer, TWS_SYNC_TIME_DO + 100);  //同步在TWS_SYNC_TIME_DO之后才会播放提示音，所以timer需要在这个时间之后才去检测提示音状态
            }
        } else
#endif
        {
#if TCFG_MAX_VOL_PROMPT
            STATUS *p_tone = get_tone_config();
            //1是抢断，0是叠加---------------这是单耳的
            tone_play_index(p_tone->max_vol, 0);
#endif
        }

//...
```

双耳调用的是`bt_tws_play_tone_at_same_time(SYNC_TONE_MAX_VOL, 400);`

```c
TWS_SYNC_CALL_REGISTER(tws_tone_play) = {
    .uuid = 0x123A9E50,
    .task_name = "app_core",
    .func = play_tone_at_same_time,
};

void bt_tws_play_tone_at_same_time(int tone_name, int msec)
{
    tws_api_sync_call_by_uuid(0x123A9E50, tone_name, msec);
}
```

`apps\earphone\bt_tws.c`

```c
/*
 * 提示音同步播放
 */
static void play_tone_at_same_time(int tone_name, int err)
{
    STATUS *p_tone = get_tone_config();
    int state;

    switch (tone_name) {
#if TCFG_EAR_DETECT_ENABLE
    //...
    case SYNC_TONE_MAX_VOL:
#if TCFG_MAX_VOL_PROMPT
        if (p_tone->max_vol != IDEX_TONE_NONE) {
            //1是可以抢断音乐
            tone_play_index(p_tone->max_vol, 1);
        } else {
            /* tone_sin_play(150, 1); */
        }
#endif
        break;
```



# 三方通话

# TWS

## 发起TWS配对

```c
case KEY_FIVE_CLICK:
    if (bt_tws_start_search_sibling()) {
        // tone_play_index(IDEX_TONE_NORMAL, 1);
        break;
    }
break;
```

- **场景**
  - 主要是恢复出厂设置后的TWS配对
  - 不是开机自动配对的模式

# 灯效

- 单IO推灯
  - pwm推灯
  - 高低电平推灯
- 双IO推灯
  - pwm推灯
  - 高低电平推灯

## 双IO口高低电平推灯

这个LED灯效控制代码通过状态机和定时器的组合来实现各种灯效模式。

### 核心实现机制

**初始化清理**

```c
led_cnt=0;
led_priv=0;
sys_timer_del(led_time);
led_time = 0;
```

每次设置新的LED模式前，先清理计数器、私有参数和定时器，确保状态干净。

**GPIO控制基础**

- `gpio_set_direction()`: 设置GPIO方向（0=输出，1=输入）

- `gpio_set_output_value()`: 设置GPIO输出电平（0=低电平，1=高电平）

- 通过控制两个LED引脚（GPIO_LED0_PIN和GPIO_LED1_PIN）实现不同效果

**定时器驱动的动态效果**

对于需要闪烁的效果，使用定时器机制：

```c
led_time = sys_timer_add(NULL, gpio_led_mode_display, 频率);
```

- 设置私有参数（`led_priv`）标识当前模式
- 添加定时器，定期调用`gpio_led_mode_display`函数
- 通过不同的频率实现快闪、慢闪效果

### 蓝灯慢闪

```c
void  gpio_led_mode_set(u8 led_mode)
{
    led_cnt=0;
    led_priv=0;
    sys_timer_del(led_time);
    led_time = 0;
    /**每次更新LED状态之前把计数器、私有参数、定时器都删除避免遗漏**/

    switch(led_mode){
            //......
        case GPIO_LED0_SLOW_FLASH:
            led_priv=_LED0_SLOW_FLASH_TIMER_PRIV;
            //频率为1000ms调用一次
            led_time=sys_timer_add(NULL,gpio_led_mode_display,CFG_GPIO_LED_SINGLE_SLOW_FLASH_FREQ);
        break;
```

**gpio_led_mode_display**

```c
void  gpio_led_mode_display()
{
       switch(led_priv){
               case _LED0_SLOW_FLASH_TIMER_PRIV://蓝灯1s闪一次
                   led_cnt^=1;
                   if(led_cnt){
                       gpio_set_direction(GPIO_LED0_PIN, 0);         //0：输出  1：输入
                       gpio_set_direction(GPIO_LED1_PIN , 0);         //0：输出  1：输入
                       gpio_set_output_value(GPIO_LED0_PIN,1);       //输出的状态
                       gpio_set_output_value(GPIO_LED1_PIN ,0);       //输出的状态
                   }
                   else{
                       gpio_set_direction(GPIO_LED0_PIN, 1);         //0：输出  1：输入
                       gpio_set_direction(GPIO_LED1_PIN , 1);         //0：输出  1：输入
                   }
               break;
```

**状态切换机制**

```c
led_cnt^=1;  // 关键：每次调用都翻转led_cnt的值（0变1，1变0）
```

这是一个**异或翻转操作**，实现了状态的自动切换：

- 第1次调用：`led_cnt = 0^1 = 1`
- 第2次调用：`led_cnt = 1^1 = 0`
- 第3次调用：`led_cnt = 0^1 = 1`
- 以此类推...

**根据状态控制LED**

```c
if(led_cnt){  // led_cnt=1时，点亮LED0
    gpio_set_direction(GPIO_LED0_PIN, 0);     // 设为输出模式
    gpio_set_direction(GPIO_LED1_PIN, 0);     // 设为输出模式
    gpio_set_output_value(GPIO_LED0_PIN,1);   // LED0输出高电平（亮）
    gpio_set_output_value(GPIO_LED1_PIN,0);   // LED1输出低电平（灭）
}
else{  // led_cnt=0时，关闭所有LED
    gpio_set_direction(GPIO_LED0_PIN, 1);     // 设为输入模式（相当于关闭）
    gpio_set_direction(GPIO_LED1_PIN, 1);     // 设为输入模式（相当于关闭）
}
```

**完整工作流程**

1. **初始化**：设置定时器，比如每1秒调用一次`gpio_led_mode_display()`
2. **第1秒**：`led_cnt`变为1 → LED0亮，LED1灭
3. **第2秒**：`led_cnt`变为0 → 两个LED都灭
4. **第3秒**：`led_cnt`变为1 → LED0亮，LED1灭
5. **循环往复**...

**关键技巧**

1. 异或翻转（`^=1`）

这是一个非常巧妙的状态切换技巧：

- 比`if-else`判断更简洁
- 自动实现0和1之间的切换
- 代码更紧凑

2.输入模式关闭LED

```c
gpio_set_direction(GPIO_LED0_PIN, 1);  // 设为输入模式
```

将GPIO设为输入模式是一种关闭LED的方式，因为输入模式下GPIO不会输出电流。

3.私有参数区分模式

通过`led_priv`参数，同一个回调函数可以处理多种不同的闪烁模式，每种模式有不同的状态切换逻辑。

这种设计非常适合嵌入式系统，因为它：

- 资源占用少
- 逻辑清晰
- 易于扩展新的闪烁模式
- 定时精确

### 改变亮灯的持续时间

```c
led_cnt^=1;  // 这种方式只能实现1:1的亮灭比例
```

**借鉴 五秒蓝灯闪烁一次，一次0.5s**

```c
void  gpio_led_mode_set(u8 led_mode)
{
    led_cnt=0;
    led_priv=0;
    sys_timer_del(led_time);
    led_time = 0;
    /**每次更新LED状态之前把计数器、私有参数、定时器都删除避免遗漏**/

    switch(led_mode){
            case GPIO_LED0_ONE_FLASH_5S:
               led_priv=_LED0_ONE_FLASH_5S_TIMER_PRIV;
               led_time=sys_timer_add(NULL,gpio_led_mode_display,500);
            break;
            
void  gpio_led_mode_display()
{
       switch(led_priv){
        case _LED0_ONE_FLASH_5S_TIMER_PRIV://蓝灯5s闪一次，一次维持0.5s
            led_cnt++;
            if(led_cnt<10) {
                gpio_set_direction(GPIO_LED0_PIN, 1);         //0：输出  1：输入
                gpio_set_direction(GPIO_LED1_PIN , 1);         //0：输出  1：输入
            } else {
                gpio_set_direction(GPIO_LED0_PIN, 0);         //0：输出  1：输入
                gpio_set_direction(GPIO_LED1_PIN , 0);         //0：输出  1：输入
                gpio_set_output_value(GPIO_LED0_PIN,1);       //输出的状态
                gpio_set_output_value(GPIO_LED1_PIN ,0);       //输出的状态
                led_cnt=0;
            }
        break;
```

我想两秒蓝灯闪烁一次的话。

```c
led_time=sys_timer_add(NULL,gpio_led_mode_display,500);
```

200ms调用一次。前9次熄灭，最后一次亮。2秒一个总周期，一次小周期的时间是。

### 关机闪烁三次

`apps\earphone\ui_manage.c`的`ui_manage_scan`

```c
case STATUS_POWEROFF:
        log_info("[STATUS_POWEROFF]\n");
        //判断配置是不是自定义灯效
        if (p_led->power_off != GPIO_LED1_FLASH_THREE) {
            //读取demo.c中的配置
            gpio_led_mode_set(p_led->power_off);
        } else {
            if (sys_ui_var.ui_flash_cnt) {
                //红灯闪烁三次
                if (sys_ui_var.ui_flash_cnt % 2) {
                    gpio_led_mode_set(GPIO_LED1_OFF);
                } else {
                    gpio_led_mode_set(GPIO_LED1_ON);
                }
            }
        }
break;
```

**目前是关机灯效没有生效，是关机前的灯效状态**

**这个也不行。**

在把关机回调函数的时间延长至1000，因为这个300ms调用一次。

```c
case STATUS_POWEROFF:
        log_info("[STATUS_POWEROFF]\n");
        //判断配置是不是自定义灯效
        //if (p_led->power_off != GPIO_LED1_FLASH_THREE) {
            //读取demo.c中的配置
            //gpio_led_mode_set(p_led->power_off);
        //} else {
            // if (sys_ui_var.ui_flash_cnt) {
            //     //红灯闪烁三次
            //     if (sys_ui_var.ui_flash_cnt % 2) {
            //         gpio_led_mode_set(GPIO_LED1_ON);
            //         //gpio_led_mode_set(GPIO_LED1_OFF);
            //     } else {
            //         //gpio_led_mode_set(GPIO_LED1_ON);
            //         gpio_led_mode_set(GPIO_LED1_OFF);
            //     }
            // }
            gpio_led_mode_set(GPIO_LED_flash_three);
        //}
        break;
```

```c
case  KEY_POWEROFF_HOLD:
#if (TCFG_USER_TWS_ENABLE && CONFIG_TWS_POWEROFF_SAME_TIME == 0)
        if ((u32)event->arg == KEY_EVENT_FROM_TWS) {
            break;
        }
#endif
        log_info("poweroff flag:%d cnt:%d\n", goto_poweroff_flag, goto_poweroff_cnt);

        if (goto_poweroff_flag) {
            //200累加一次
            goto_poweroff_cnt++;
#if CONFIG_TWS_POWEROFF_SAME_TIME
            if (goto_poweroff_cnt == POWER_OFF_CNT) {
                if (get_tws_sibling_connect_state()) {
                    if ((u32)event->arg != KEY_EVENT_FROM_TWS) {
                        //1000ms
                        tws_api_sync_call_by_uuid('T', SYNC_CMD_POWER_OFF_TOGETHER, TWS_SYNC_TIME_DO);
                    } else {
                        goto_poweroff_cnt--;
                    }
                } else {
                    sys_enter_soft_poweroff(NULL);
                }
            }
#else
            if (goto_poweroff_cnt >= POWER_OFF_CNT) {
                goto_poweroff_cnt = 0;
                sys_enter_soft_poweroff(NULL);
            }
#endif //CONFIG_TWS_POWEROFF_SAME_TIME

        }
        break;
```



### 软件配置分析

```c
//*********************************************************************************//
//                                  LED 配置                                       //
//*********************************************************************************//
//*********************************************************************************//
//      目前带anc的案子暂不使用pwm推灯模块，避免pwm推灯产生的噪声   2023.12.04
//      适用普通高低电平推灯流程   
//      驱动文件：.\cpu\br36\gpio_led.c  
//      头文件：.\include_lib\driver\cpu\br36\asm\gpio_led.h
//      驱动文件编译路径vscode需要在makefile添加，codeblck头文件跟C文件都要添加
//      gpio推灯默认流程给高电平灯亮，具体要跟硬件门同事核对，样机实际灯光颜色对应软件配置以实际验证为准
//*********************************************************************************//
#define TCFG_PWMLED_ENABLE					DISABLE_THIS_MOUDLE			//是否支持PMW LED推灯模块
#define TCFG_PWMLED_IOMODE					LED_TWO_IO_MODE				//LED模式，单IO还是两个IO推灯
#define TCFG_PWMLED_PIN0				    IO_PORTB_05					//LED使用的IO口
#define TCFG_PWMLED_PIN1					IO_PORTG_05					//LED使用的IO口


/*  普通高低电平推灯引脚*/
#define TCFG_GPIO_LED                       1//CONFIG_ANC_ENABLE
#define BULE_LED_PIN                        IO_PORTB_05     //红灯
#define RED_LED_PIN                         IO_PORTG_05     //蓝灯
#define GPIO_LED0_PIN				        BULE_LED_PIN	//LED1使用的IO口
#define GPIO_LED1_PIN					    RED_LED_PIN	    //LED2使用的IO口


#if (TCFG_GPIO_LED == ENABLE_THIS_MOUDLE)
#define TCFG_PWMLED_ENABLE					DISABLE_THIS_MOUDLE			//开了gpio推灯就不要开pwm推灯了
```

设置灯效的接口：

```c
gpio_led_mode_set(GPIO_LED0_LED1_FAST_FLASH);

void  gpio_led_mode_set(u8 led_mode)
{
    led_cnt=0;
    led_priv=0;
    sys_timer_del(led_time);
    led_time = 0;
    /**每次更新LED状态之前把计数器、私有参数、定时器都删除避免遗漏**/

    switch(led_mode){
        case GPIO_LED_ALL_OFF:
               gpio_set_direction(GPIO_LED0_PIN,1);         //0：输出  1：输入
               gpio_set_direction(GPIO_LED1_PIN,1);         //0：输出  1：输入
            break;
        case GPIO_LED0_LED1_FAST_FLASH://快闪
            gpio_set_direction(GPIO_LED0_PIN, 0);         //0：输出  1：输入
            gpio_set_direction(GPIO_LED1_PIN, 0);         //0：输出  1：输入
            led_priv=_LED0_LED1_FAST_FLASH_TIMER_PRIV;      
            led_time=sys_timer_add(NULL,gpio_led_mode_display,CFG_GPIO_LED_DOUBLE_FAST_FLASH_FREQ);
        	break;
```

利用非超时定时器实现周期灯效：

```c
int   led_time;
int   led_priv;
int   led_cnt;
void ui_manage_scan(void *priv);
void  gpio_led_mode_set(u8 led_mode);
void  gpio_led_mode_display()
{
       switch(led_priv){
           case _LED0_LED1_FAST_FLASH_TIMER_PRIV://红蓝0.5s交替闪
                led_cnt = !led_cnt;
                if(led_cnt>=10)led_cnt=0;   
                if(led_cnt){//红亮关蓝灯
                    gpio_set_output_value(GPIO_LED0_PIN,0);       //输出的状态
                    gpio_set_output_value(GPIO_LED1_PIN ,1);       //输出的状态
                } else {//蓝亮关红灯
                    gpio_set_output_value(GPIO_LED0_PIN,1);       //输出的状态
                    gpio_set_output_value(GPIO_LED1_PIN ,0);       //输出的状态
                }
               break;
           case _LED0_LED1_SLOW_FLASH_TIMER_PRIV://红蓝0.5s交替闪
                led_cnt = !led_cnt;
                if(led_cnt>=10)led_cnt=0;   
                if(led_cnt){//红亮关蓝灯
                    gpio_set_output_value(GPIO_LED0_PIN,0);       //输出的状态
                    gpio_set_output_value(GPIO_LED1_PIN ,1);       //输出的状态
                } else {//蓝亮关红灯
                    gpio_set_output_value(GPIO_LED0_PIN,1);       //输出的状态
                    gpio_set_output_value(GPIO_LED1_PIN ,0);       //输出的状态
                }
               break;
```

设置GPIO口的电平传输方向和
