# 根目录下的`product_compile_image.bat`

```bat
@echo off
@echo ********************************************************************************
@echo SDK BR36
@echo ********************************************************************************
@echo %date%
cd ./
set PATH=tools\utils;%PATH%

del customer_path.conf
set para=%1
@rem  ###-customer +blname or model
@rem  ###-JOYROOM_Funpods_FN3_Left
@rem  ###-JOYROOM_Funpods_FN3_Right
@rem  ###-JOYROOM_Funpods_FN3_NOAPP_Left
@rem  ###-JOYROOM_Funpods_FN3_NOAPP_Right
set CUSTOMER_PATH=JOYROOM_Funpods_FN3_NOAPP_Left
echo CUSTOMER_PATH=%CUSTOMER_PATH%>customer_path.conf
echo CFLAGS_EX+=-D_%CUSTOMER_PATH%>>customer_path.conf
@rem ###-key select
@rem ###  1-default
@rem ###  2-product
set CUSTOMER_CHIPKEY=product
echo CUSTOMER_CHIPKEY=%CUSTOMER_CHIPKEY%>>customer_path.conf
call ".\customer_copy.bat"  %CUSTOMER_PATH%
call ".\apps\earphone\board\br36\output.bat"  %CUSTOMER_PATH%
@echo %para%
if "%para%" neq "all" (
if "%para%" neq "clean" (
     start cmd.exe /k "make clean&&make all -j 16"
 )
 )
```



## 疑问1

**我没记错的话，这是shell脚本吧？他具体干了什么？**

这不是 shell 脚本，而是一个 Windows 批处理脚本（Batch 文件，扩展名通常是 .bat 或 .cmd）。`@echo off` 是批处理脚本的典型开头。

这个脚本的主要功能是：

**1. 环境设置**

- 关闭命令回显（`@echo off`）
- 显示 SDK BR36 的标题信息和当前日期
- 设置工具路径到系统 PATH 中

**2. 配置文件生成**

- 删除旧的 `customer_path.conf` 配置文件
- 设置客户路径为 `JOYROOM_Funpods_FN3_NOAPP_Left`（看起来是某款耳机产品的左耳配置）
- 生成新的配置文件，包含：
  - 客户路径设置
  - 编译标志（CFLAGS_EX）
  - 芯片密钥类型设置为 "product"

**3. 调用其他脚本**

- 执行 `customer_copy.bat` 进行客户配置复制
- 执行 `output.bat` 处理输出相关操作

**4. 编译控制**

- 根据传入参数决定是否启动编译
- 如果参数不是 "all" 或 "clean"，则在新的命令窗口中执行：
  - `make clean` 清理之前的编译结果
  - `make all -j 16` 使用 16 个并行任务进行编译

这看起来是一个嵌入式设备（可能是蓝牙耳机）的固件开发工具链的构建脚本，专门用于编译 JOYROOM 品牌耳机的固件。

## 疑问2

**Windows 批处理脚本双击运行一定会出现命令窗口显示脚本命令吗？所以才要关闭命令回显？这样看起来简洁一点？**

是的，你理解得很对！

**Windows 批处理脚本的默认行为：**

- 双击 .bat 文件运行时，**一定会弹出命令提示符窗口**
- 默认情况下会显示每条执行的命令（回显），看起来像这样：

```bat
C:\>echo SDK BR36
SDK BR36

C:\>echo %date%
2025-06-24

C:\>cd ./
C:\>set PATH=tools\utils;%PATH%
...
```

**`@echo off` 的作用：**

- 关闭命令回显，只显示命令的**输出结果**，不显示命令本身
- 加上 `@echo off` 后就变成：

```bat
SDK BR36
********************************************************************************
2025-06-24
...
```

**为什么要这样做：**

1. **界面更简洁** - 用户只看到有用的信息，不看到冗长的命令
2. **更专业** - 像一个成品软件的输出，而不是原始的脚本调试信息
3. **减少干扰** - 避免技术细节干扰最终用户

**其他相关知识：**

- 如果想完全隐藏命令窗口，需要用 `.vbs` 脚本或其他方法调用
- 单个命令前加 `@` 也能关闭该命令的回显
- `@echo off` 中的 `@` 是为了不显示 `echo off` 这条命令本身

所以你的理解完全正确！这是为了让脚本运行时的界面看起来更加专业和简洁。

## 疑问3

**@echo %date%这个获取的是系统的本地时间吗？什么格式形式？**

是的，`%date%` 获取的是**系统的本地时间**中的日期部分。

**格式形式：** `%date%` 的格式**取决于系统的区域设置**，不同地区显示格式不同：

中文系统（中国大陆）：

```bat
2025-06-24 星期二
```

**英文系统（美国）：**

```bat
Tue 06/24/2025
```

**获取更多时间信息：**

- `%date%` - 只有日期
- `%time%` - 只有时间（如：14:30:25.67）
- `%date% %time%` - 日期和时间都显示

**如果需要固定格式：** 如果你需要固定格式的日期（不受系统区域影响），可以这样：

```bat
@echo off
for /f "tokens=2 delims==" %%a in ('wmic OS Get localdatetime /value') do set "dt=%%a"
set "YY=%dt:~2,2%" & set "YYYY=%dt:~0,4%" & set "MM=%dt:~4,2%" & set "DD=%dt:~6,2%"
echo %YYYY%-%MM%-%DD%
```

所以在你的脚本中，`@echo %date%` 会根据运行脚本的电脑的区域设置来显示相应格式的当前日期。

## 疑问4

```bat
cd ./
set PATH=tools\utils;%PATH%
```

`cd ./`

- **作用**：切换到当前目录
- **看起来多余**：因为 `./` 就是当前目录，理论上这条命令没有实际效果
  - 如果这个脚本不在正确位置上的话，也没用
  - 如果在正确位置上的的话，这句话没用。
- 实际意义：
  - 可能是为了**确保工作目录**确实在脚本所在目录
  - 有些情况下，批处理脚本的当前目录可能不是脚本文件所在目录
  - 起到一种"重置"作用，确保后续操作都在正确的目录进行

`set PATH=tools\utils;%PATH%`

- **作用**：修改系统 PATH 环境变量
- 具体功能：
  - 将 `tools\utils` 目录添加到 PATH 的**最前面**
  - `%PATH%` 是原来的 PATH 变量内容
  - 用分号 `;` 分隔多个路径

### 疑问1

**每一个工程的tools\utils目录都添加进path环境变量，工程多了path中路径太多会不会有什么隐患？将tools\utils目录添加进path中，是为什么在任何地方都可以精准引用tools\utils目录中的东西？`set PATH=tools\utils;%PATH%`是在path中新建一个路径还是替换最前面的路径？，我看你说`%PATH%` 是原来的 PATH 变量内容？**

#### **PATH 路径过多的隐患**

**确实存在隐患：**

1. **性能影响** - PATH 路径越多，**系统查找可执行文件时遍历时间越长**
2. **命令冲突** - 不同工程可能有同名工具，优先级按 PATH 顺序决定
   - 看谁在最前面
3. **安全风险** - 可能意外执行了错误路径下的程序
4. **维护困难** - PATH 变得臃肿，难以管理

#### **PATH 的工作原理**

当你输入命令时，系统会**按顺序**搜索 PATH 中的每个目录：

```bat
PATH=tools\utils;C:\Windows\System32;C:\Windows

执行 mytool.exe 时：
1. 先在 tools\utils 找
2. 找不到再在 C:\Windows\System32 找  
3. 还找不到再在 C:\Windows 找
```

#### **`set PATH=tools\utils;%PATH%` 是新建还是替换？**

**是新建/追加**，不是替换！

```bat
# 假设原来的 PATH 是：
PATH=C:\Windows\System32;C:\Windows

# 执行后：
PATH=tools\utils;C:\Windows\System32;C:\Windows
```

**工作过程：**

1. `%PATH%` 获取原来的完整 PATH 内容
2. `tools\utils;` 添加到最前面
3. **整个 PATH 被重新赋值**，包含新旧所有路径

**为什么添加到最前面？**

- **优先级最高** - 确保使用的是当前工程的工具版本
- **避免版本冲突** - 不会被系统中的同名工具干扰

**更好的做法**

很多项目会这样做：

```bat
# 保存原始 PATH
set ORIGINAL_PATH=%PATH%

# 添加工具路径
set PATH=tools\utils;%PATH%

# 脚本结束时恢复（可选）
set PATH=%ORIGINAL_PATH%
```

或者直接用完整路径调用工具，避免修改 PATH。

### 疑问2？？？？

**感觉脚本执行顺序是从右边到左边的？set PATH=tools\utils;%PATH%，先获取完整的path内容，然后在最前面添加一条变量？tools\utils相对路径可以这么写吗？因为脚本的位置在工程根目录中7003D8_V138_Middware，而tool目录7003D8_V138_Middware\cpu\br36\tools，utils目录还没有这种情况下还是脚本还可以往下执行？ **

你的观察很敏锐！让我逐一回答：

**执行顺序问题**

你理解错了！批处理中 `=` 右边是**先计算，再赋值**：

```bat
set PATH=tools\utils;%PATH%
```

**执行顺序：**

1. **先计算右边**：`tools\utils;%PATH%` → `tools\utils;C:\Windows\System32;...`
2. **再赋值给左边**：`PATH=计算结果`

这是**从右到左**的计算，然后赋值给左边变量。

**相对路径问题**

`tools\utils` 这样写是**有问题的**！

**当前情况分析：**

```bat
工程结构：
7003D8_V138_Middware/          ← 脚本在这里
├── 脚本.bat  
└── cpu/
    └── br36/
        └── tools/
            └── utils/         ← 实际工具在这里
```

正确的相对路径应该是：

```bat
set PATH=cpu\br36\tools\utils;%PATH%
```

**为什么脚本还能继续执行？**

**原因有几个：**

1. **PATH 添加不会导致脚本停止**

```bat
set PATH=不存在的路径;%PATH%
echo 这行还是会执行  # 不会报错
```

2. **工具可能还没被调用**

   - 脚本可能在后面才调用工具

   - 此时只是设置了 PATH，还没有实际使用

3. **可能有其他机制**

   - 脚本可能用完整路径调用工具
   - 或者在 `customer_copy.bat` 中会复制工具到正确位置

验证方法：

```bat
@echo off
set PATH=tools\utils;%PATH%
echo 当前PATH: %PATH%
where some_tool.exe 2>nul && echo 找到工具 || echo 工具不存在
```

**结论：** 这个脚本的 PATH 设置很可能是**错误的**，但因为：

- 批处理容错性强
- 工具可能通过其他方式调用
- 或者在后续脚本中会修正路径

所以脚本表面上能继续执行。

## 疑问5？？？？？

**这几个脚本语句呢？删除现有配置文件，自动加载customer目录下的文件名，然后呢？写入新的配置文件中？**

```bat
del customer_path.conf
set para=%1
@rem  ###-customer +blname or model
@rem  ###-JOYROOM_Funpods_FN3_Left
@rem  ###-JOYROOM_Funpods_FN3_Right
@rem  ###-JOYROOM_Funpods_FN3_NOAPP_Left
@rem  ###-JOYROOM_Funpods_FN3_NOAPP_Right
set CUSTOMER_PATH=JOYROOM_Funpods_FN3_NOAPP_Left
echo CUSTOMER_PATH=%CUSTOMER_PATH%>customer_path.conf
echo CFLAGS_EX+=-D_%CUSTOMER_PATH%>>customer_path.conf
```

**获取命令行参数**

```bat
set para=%1
```

- `%1` 是第一个命令行参数
- 比如运行 `script.bat JOYROOM_Left`，则 `para=JOYROOM_Left`
  - 问题是双击后不会有输入参数的机会，后面直接硬编码了
  - 获取的是谁的参数？这是一个批处理脚本，获取的应该是脚本内容？毕竟人为没有输入参数啊。

**注释说明**

```bat
@rem  ###-customer +blname or model
@rem  ###-JOYROOM_Funpods_FN3_Left
@rem  ###-JOYROOM_Funpods_FN3_Right
```

- 这些是注释，说明支持的客户/型号选项

- 但实际上**脚本没有使用这些参数**！
- 有脚本获取了customer目录下的各文件名

**硬编码设置**

```bat
set CUSTOMER_PATH=JOYROOM_Funpods_FN3_NOAPP_Left
```

- **关键问题**：这里硬编码了路径，**完全忽略了命令行参数**！

- 不管你传什么参数，都会使用 `JOYROOM_Funpods_FN3_NOAPP_Left`

**写入新配置文件**

```bat
echo CUSTOMER_PATH=%CUSTOMER_PATH%>customer_path.conf
echo CFLAGS_EX+=-D_%CUSTOMER_PATH%>>customer_path.conf
```

生成的 `customer_path.conf` 内容：

```bat
CUSTOMER_PATH=JOYROOM_Funpods_FN3_NOAPP_Left
CFLAGS_EX+=-D_JOYROOM_Funpods_FN3_NOAPP_Left
```

### **问题分析**

**设计缺陷：**

1. **获取了参数但没使用** - `para=%1` 设置了但后面没用到
2. **硬编码配置** - 应该根据参数动态设置，但实际是固定值
3. **注释与实现不符** - 注释说支持多种型号，但代码只支持一种

正确的实现应该是：

```bat
set CUSTOMER_PATH=%1
if "%CUSTOMER_PATH%"=="" set CUSTOMER_PATH=JOYROOM_Funpods_FN3_NOAPP_Left
echo CUSTOMER_PATH=%CUSTOMER_PATH%>customer_path.conf
echo CFLAGS_EX+=-D_%CUSTOMER_PATH%>>customer_path.conf
```

**结论：** 这个脚本目前是**半成品**，准备了参数处理框架但没有实际使用，只能编译固定的一种产品配置。