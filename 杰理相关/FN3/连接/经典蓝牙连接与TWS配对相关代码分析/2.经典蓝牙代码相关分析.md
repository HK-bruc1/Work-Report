# 经典蓝牙的完整过程

## 系统初始化与应用启动

从`app_main.c`中的`app_main`函数开始：

```c
void app_main()
{
    // ...系统初始化
    struct intent it;
    
    // 初始化意图结构体
    init_intent(&it);
    it.name = "earphone";
    it.action = ACTION_EARPHONE_MAIN;
    start_app(&it); // 启动耳机应用
}
```

## 耳机应用入口

`start_app`会调用**应用的状态机函数**。在`earphone.c`中，应用注册为：

```c
REGISTER_APPLICATION(app_earphone) = {
    .name    = "earphone",
    .action  = ACTION_EARPHONE_MAIN,
    .ops     = &app_earphone_ops,
    .state   = APP_STA_DESTROY,
};
```

其中`app_earphone_ops`定义了两个操作函数：状态机函数事件处理函数：

- 整个SDK的运作都是基于这两个函数向外围扩散的。

```c
static const struct application_operation app_earphone_ops = {
    .state_machine  = state_machine,
    .event_handler  = event_handler,
};
```

## 状态机部分

### 蓝牙初始化过程

在`state_machine`函数中，处理`APP_STA_START`状态：

```c
case APP_STA_START:
    if (!it) {
        break;
    }
    switch (it->action) {
    case ACTION_EARPHONE_MAIN:
        // 设置系统时钟
        clk_set("sys", BT_NORMAL_HZ);
        u32 sys_clk = clk_get("sys");
        bt_pll_para(TCFG_CLOCK_OSC_HZ, sys_clk, 0, 0);
        
        // 蓝牙功能初始化
        bt_function_select_init(); 
        bredr_handle_register();
        EARPHONE_STATE_INIT();
        DHFAppCommand_init();
        btstack_init();
        
        // 设置蓝牙版本
        set_bt_version(BLUETOOTH_CORE_SPEC_54);//不可见，跳转是直接填写宏定义的
        
        #if TCFG_USER_TWS_ENABLE
        tws_profile_init();
        sys_key_event_filter_disable();
        #endif
        
        // 系统功能初始化
        sys_key_event_enable();
        sys_auto_shut_down_enable();
        bt_sniff_feature_init();
        sys_auto_sniff_controle(MY_SNIFF_EN, NULL);
        break;
    // ...其他情况处理
    }
```

#### 蓝牙功能选择初始化

此函数在蓝牙模块初始化阶段（如设备启动或模式切换）被调用，负责动态配置蓝牙协议栈的关键参数，确保设备在不同硬件平台、编译选项和使用场景下能够正常运行。其核心目标是：

1. **适配硬件差异**（如芯片型号、MAC 地址分配）。
2. **优化性能与功耗**（如 QoS、增强电源控制）。
3. **支持多协议功能**（如 BLE、mSBC/AAC 编码）。
4. **提供调试与测试能力**（如电量上报、SDK 版本获取）。

通过条件编译（如 `#if TCFG_USER_BLE_ENABLE`）实现功能开关，确保代码灵活性与可移植性。

`bt_function_select_init`设置蓝牙参数：

```c
void bt_function_select_init()
{
    // 设置蓝牙连接参数
    __set_user_ctrl_conn_num(TCFG_BD_NUM);//设置最大连接设备数量（TCFG_BD_NUM定义）
    __set_support_msbc_flag(1);//启用mSBC编码
    __set_aac_bitrate(131 * 1000);//设置AAC编码比特率为131kbps
    __set_support_aac_flag(1);//强制启用AAC音频编码支持
    
    // 设置蓝牙连接超时参数
    __set_page_timeout_value(8000);//设置蓝牙页面超时时间为8000ms（回连搜索时间）
    __set_super_timeout_value(8000);// 设置超级定时器超时时间为8000ms（主机连接超时参数）
    
    // 配对参数设置
    __set_simple_pair_param(3, 0, 2);//设置简单配对参数
    
    // 其他BLE相关初始化
    #if TCFG_USER_BLE_ENABLE
    {
        u8 tmp_ble_addr[6];
        memcpy(tmp_ble_addr, (void *)bt_get_mac_addr(), 6);
        le_controller_set_mac((void *)tmp_ble_addr);
    }
    #endif
    
    // 设置增强功率控制
    set_bt_enhanced_power_control(1);// 启用增强型电源控制（LE Enhanced Power Control）
    
    // 设置延迟报告时间
    set_delay_report_time(CONFIG_A2DP_DELAY_TIME);//设置A2DP媒体数据延迟报告时间
}
```

- 设置蓝牙连接参数
  - 设置最大连接设备数量（**宏定义**）
- 设置蓝牙连接超时参数
  - 设置蓝牙页面超时时间为8000ms（回连搜索时间）
  - 设置超级定时器超时时间为8000ms（主机连接超时参数）
    - **主机回连也会超时？？？不是什么都是会回连从机吗？？？**
- 配对参数设置

#### 蓝牙事件处理注册

从 `bredr_handle_register` 的现有代码看，它注册的是**上层业务逻辑的回调**，而非底层事件处理函数：

```c
// 注册SPP数据处理回调（仅限SPP Profile）
spp_data_deal_handle_register(...);

// 注册快速测试接口（测试盒专用）
bt_fast_test_handle_register(...);

// 音量同步回调（音乐/通话音量联动）
music_vol_change_handle_register(...);

// 电量显示回调（手机端显示电量）
get_battery_value_register(...);

// DUT模式处理函数（产线测试用）
bt_dut_test_handle_register(...);
```

这些是**特定功能模块的回调**，不涉及蓝牙协议栈事件（如连接、配对、HCI状态）。

~~`bredr_handle_register`注册蓝牙事件处理函数：~~

##### 疑问

**这一些注册的函数在什么时候被调用？在哪里可以看到调用？**

比如在earphone.c中注册了耳机应用：

```c
/*
 * 注册earphone模式
 */
REGISTER_APPLICATION(app_earphone) = {
    .name 	= "earphone",
    .action	= ACTION_EARPHONE_MAIN,
    .ops 	= &app_earphone_ops,
    .state  = APP_STA_DESTROY,
};
```

在app_main.c中的app_main中发生了调用：

```c
        init_intent(&it);
        it.name = "earphone";
        it.action = ACTION_EARPHONE_MAIN;
        start_app(&it);
```

**SPP数据处理回调函数 (spp_data_deal_handle_register)**

```c
spp_data_deal_handle_register(user_spp_data_handler);  // 在线调试模式
spp_data_deal_handle_register(spp_data_handler);      // 普通模式
```

- **调用时机**：当蓝牙SPP（Serial Port Profile）连接建立后，每当从主设备（如手机）接收到SPP数据包时
- **用途**：处理通过蓝牙SPP协议传输的串口数据
- **注释信息**：在头文件中定义为"支持串口功能的数据处理接口"
- 根据应用场景不同选择不同的处理函数：
  - 在线调试模式使用user_spp_data_handler
  - 普通模式使用spp_data_handler
- 位置呢？源码不可见？？？

**蓝牙快速测试接口 (bt_fast_test_handle_register)**

```c
bt_fast_test_handle_register(bt_fast_test_api);
```

- **调用时机**：当蓝牙设备被测试盒连接上并进入快速测试模式时
- **用途**：用于工厂测试场景，提供蓝牙性能和功能的快速测试能力
- **注释信息**：在wireless_mic模块中注释为"被测试盒链接上进入快速测试回调"
- 此回调函数通常用于生产测试阶段，帮助验证蓝牙设备的基本功能

**音乐音量同步回调函数 (music_vol_change_handle_register)**

```c
music_vol_change_handle_register(set_music_device_volume, phone_get_device_vol);
```

- **调用时机**：当连接的手机更改音乐播放音量时
- **用途**：实现手机与蓝牙设备之间的音量同步功能
- **注释信息**：头文件中定义为"手机更样机音乐模式的音量同步"
- 包含两个回调：
  - set_music_device_volume：接收手机音量变化并设置设备音量
  - phone_get_device_vol：获取当前设备音量值返回给手机

**电量获取回调函数 (get_battery_value_register)**

```c
get_battery_value_register(bt_get_battery_value);
```

- **调用时机**：当连接的手机请求蓝牙设备电量信息时
- **用途**：向手机提供蓝牙设备的电量信息，用于在手机上显示
- **注释信息**：头文件中定义为"电量发送时获取电量等级的接口注册"
- 通过bt_get_battery_value函数返回电量数值，使手机能够显示蓝牙设备的电量状态

**DUT测试模式处理函数 (bt_dut_test_handle_register)**

```c
bt_dut_test_handle_register(bt_dut_api);
```

- **调用时机**：当蓝牙设备进入DUT(Device Under Test)测试模式时
- **用途**：用于专业测试设备进行蓝牙性能和规范符合性测试
- **注释信息**：定义为"进入蓝牙DUT模式时的特定处理流程"
- 与快速测试不同，DUT模式通常用于更严格的实验室测试环境，测试设备与蓝牙标准的符合性

总结来说，这些回调函数是在SDK的蓝牙协议栈中预留的接口，允许应用层代码针对不同的蓝牙事件进行响应。bredr_handle_register函数的作用是将这些应用层回调函数注册到协议栈中，使得当特定事件发生时，协议栈能够调用这些函数来处理相应的业务逻辑。这种设计模式使协议栈和应用逻辑分离，提高了代码的模块化和可维护性。

##### 蓝牙事件处理的实际位置

在 `earphone.c` 中，蓝牙事件的处理由以下几个关键函数完成：

- 主事件分发函数：`event_handler`
  - **系统事件处理函数中有有关蓝牙事件`SYS_BT_EVENT`处理的分支**


这是整个应用层的系统事件处理入口，负责将不同类型的事件（按键、蓝牙、设备等）分发到对应的处理函数。

- **文件位置**：`c:\Users\admin\Desktop\工作\FN3\apps\earphone\earphone.c`
- **行号范围**：L2446 - L2640
- 作用：
  - 处理按键事件 (`SYS_KEY_EVENT`)
  - 处理蓝牙事件 (`SYS_BT_EVENT`)，包括连接状态变化和底层HCI事件
  - 处理设备事件 (`SYS_DEVICE_EVENT`)，如充电、电源、TWS、耳检测等
  - 处理红外传感器事件 (`SYS_IR_EVENT`)
  - 处理PB消息事件 (`SYS_PBG_EVENT`)

```c
case SYS_BT_EVENT:
        /*
         * 蓝牙事件处理
         * 包含以下几种事件类型：
         * 1. 默认处理的事件：
         *    - SYS_BT_EVENT_TYPE_CON_STATUS: 蓝牙连接状态事件，处理连接、断开等状态变化
         *    - SYS_BT_EVENT_TYPE_HCI_STATUS: 蓝牙HCI协议事件，处理底层协议通信状态
         * 2. 宏控制的事件：
         *    - TCFG_ADSP_UART_ENABLE控制: UART相关命令事件
         *    - TCFG_USER_TWS_ENABLE控制: TWS真无线立体声事件
         */
        if ((u32)event->arg == SYS_BT_EVENT_TYPE_CON_STATUS) {
            /* 处理蓝牙连接状态事件，如配对、连接、断开等 */
            bt_connction_status_event_handler(&event->u.bt);
        } else if ((u32)event->arg == SYS_BT_EVENT_TYPE_HCI_STATUS) {
            /* 处理蓝牙HCI协议事件，如命令完成、状态改变等 */
            bt_hci_event_handler(&event->u.bt);
        }
#if TCFG_ADSP_UART_ENABLE
        else if (!strcmp(event->arg, "UART")) {
            /* 处理蓝牙UART命令事件，用于UART调试接口的命令处理 */
            extern void bt_uart_command_handler(struct uart_event * event);
            bt_uart_command_handler(&event->u.uart);
        } else if (!strcmp(event->arg, "UART_CMD")) {
            /* 处理ADSP（音频数字信号处理器）UART命令事件 */
            extern void adsp_uart_command_event_handle(struct uart_cmd_event * uart_cmd);
            adsp_uart_command_event_handle(&event->u.uart_cmd);
        }
#endif
#if TCFG_USER_TWS_ENABLE
        else if (((u32)event->arg == SYS_BT_EVENT_FROM_TWS)) {
            /*
             * 处理TWS（真无线立体声）事件
             * 用于左右耳机之间的通信和同步，如主从切换、同步状态等
             */
            bt_tws_connction_status_event_handler(&event->u.bt);
        }
#endif
        break;
```

1. 默认情况下系统可以处理两种蓝牙事件：
   - 蓝牙连接状态事件(SYS_BT_EVENT_TYPE_CON_STATUS)
   - 蓝牙HCI协议事件(SYS_BT_EVENT_TYPE_HCI_STATUS)
2. 宏控制的事件有：
   - TCFG_ADSP_UART_ENABLE宏控制：处理"UART"和"UART_CMD"两种UART相关事件
   - TCFG_USER_TWS_ENABLE宏控制：处理SYS_BT_EVENT_FROM_TWS事件，用于真无线立体声功能

这些宏控制的功能是可选的，只有在相应宏定义开启时才会编译进代码。

##### 疑问2

**这个耳机应用下的状态机函数是轮询模型呢？还是事件驱动模型？比如一个事件发生，改变了it->action的状态，状态机才会执行一次对应分支？**

这个`state_machine`函数明显是一个**事件驱动模型**，而非轮询模型。理由如下：

1. **函数参数结构**：
   - 函数接收`struct intent *it`参数，这是一个事件或意图对象
   - 代码中有明显的判断`if (!it) { break; }`，说明**这个函数是在事件触发时被调用的**
2. **执行流程**：
   - 状态机根据当前的`state`和`it->action`执行相应的处理分支
     - **在什么样的状态分支中的操作分支下**
       - 比如刚刚启动耳机应用的状态：
       - 在`APP_STA_START`状态的`ACTION_EARPHONE_MAIN`动作分支下
   - 每次函数被调用时处理一个特定状态和动作组合
   - 不是连续检查所有可能的状态（这才是轮询模型的特征）
3. **状态转换机制**：
   - 代码中使用`r_printf("bt_state_machine=%d\n", state);`打印当前状态，表明**状态是由外部传入的**
   - 在**不同状态和事件组合下执行不同的功能**，比如蓝牙初始化、音频解码开启等
4. **处理逻辑**：
   - 整个函数是被动响应外部调用，而不是主动轮询检查状态
   - 只有在特定事件（如ACTION_EARPHONE_MAIN、ACTION_A2DP_START等）发生时才执行对应代码块

**工作流程**

1. 当系统中发生一个事件（比如按键按下、蓝牙连接等）时，某处代码会创建一个`intent`对象，设置其`action`字段
2. 然后调用此`state_machine`函数，传入当前应用状态和该intent对象
3. 状态机根据当前状态和意图动作执行相应的处理逻辑
4. 处理完成后返回错误码（如有）

例如，当系统需要进入蓝牙模式时：

- 设置`state = APP_STA_START`

- 设置`it->action = ACTION_EARPHONE_MAIN`

- 调用`state_machine(app, state, it)`

  - ```c
    		init_intent(&it);
            it.name = "earphone";
            it.action = ACTION_EARPHONE_MAIN;
            start_app(&it);
    ```

- 状态机执行蓝牙初始化的一系列操作

这种模式下，状态机不会持续运行或轮询检查状态变化，而是在事件发生时被调用一次，响应特定的状态转换需求。

总结：这是一个典型的**事件驱动型状态机**，它响应外部事件并执行相应的状态转换操作，而不是通过连续轮询来检查状态变化。

#### 蓝牙协议栈初始化

`btstack_init`启动蓝牙协议栈，并开始运行蓝牙任务。这会最终触发蓝牙初始化完成事件。

- **看不到源码**

`include_lib\btstack\btstack_task.h`

```c
/**
 * @brief 蓝牙协议栈核心初始化
 * 该函数负责：
 * 1. 初始化蓝牙协议栈核心数据结构
 * 2. 创建蓝牙任务/线程处理协议栈事件
 * 3. 初始化HCI接口（UART/USB等物理接口）
 * 4. 注册协议栈事件回调函数
 * 5. 加载蓝牙配置参数（如MAC地址、安全数据库等）
 * @return 成功返回0，失败返回错误码
 */
int btstack_init();

/**
 * @brief 蓝牙协议栈资源释放
 * 该函数负责：
 * 1. 停止所有蓝牙协议栈线程/任务
 * 2. 释放动态分配的内存资源
 * 3. 关闭并释放HCI接口
 * 4. 清理协议栈状态机
 * 5. 保存必要的持久化配置数据
 * @return 成功返回0，失败返回错误码
 */
int btstack_exit();

/**
 * @brief BQB认证测试专用线程初始化
 * 该函数用于：
 * 1. 创建专门处理BQB认证测试的线程
 * 2. 初始化测试专用的GATT服务和特征值
 * 3. 注册测试模式下的事件处理回调
 * 4. 配置协议分析仪需要的调试接口
 * 5. 设置测试所需的特殊协议参数
 */
void ble_bqb_test_thread_init(void);
```

这些函数在蓝牙协议栈中的典型调用场景：

1. **btstack_init()** 在系统启动时调用，完成蓝牙协议栈的初始化
2. **ble_bqb_test_thread_init()** 仅在工程编译为BQB认证测试模式时调用，用于创建测试专用线程
3. **btstack_exit()** 在系统关机或蓝牙功能关闭时调用，确保资源正确释放

## 系统主事件处理函数

### 处理蓝牙连接状态事件`bt_connction_status_event_handler`

#### 蓝牙初始化完成事件处理

在调用`btstack_init()`后，蓝牙协议栈会在后台启动并执行初始化流程。当初始化完成时，最有可能是在蓝牙协议栈内部（即SDK库中）通过系统事件通知机制发送`BT_STATUS_INIT_OK`事件。

1. 虽然我们在开源代码中没有直接找到发送该事件的确切函数，但这很可能是在SDK的封闭源码部分（如`btstack.a`或

   `btctrler.a`库）中实现的。

2. 根据蓝牙协议栈的标准实现方式，通常在蓝牙控制器初始化成功后，协议栈会通过事件通知机制向应用层发送初始化完成事件。

3. 在您的SDK中，可能是通过`sys_event_notify`或类似机制发送这些事件，然后被主事件循环捕获并分发到`bt_connction_status_event_handler`函数处理。

总结来说，`btstack_init()`函数启动蓝牙协议栈，但不直接触发`BT_STATUS_INIT_OK`事件。该事件是由协议栈内部在完成所有初始化步骤后异步触发的，很可能是在SDK库的内部实现中（即我们看不到源码的部分）。

**但是大差不差因为`btstack_init()`后面不涉及蓝牙相关代码**

当蓝牙初始化完成后，会触发`BT_STATUS_INIT_OK`事件，在`bt_connction_status_event_handler`函数中处理：

- 这个函数是在`SYS_BT_EVENT`蓝牙相关消息处理分支下的函数

代码可以分为以下几大类操作：  

1. 蓝牙功能初始化和配置 
   1. 设置SBC编码参数 `(__set_sbc_cap_bitpool(38))` 
   2. 初始化蓝牙搜索索引 `(bt_init_ok_search_index())` 
   3. BLE初始化 `(bt_ble_init())` 蓝牙连接控制策略设置 
2. 测试模式相关操作 
   1. 定频测试接口（注释掉的代码） 
   2. DUT测试模式设置 
   3. BQB测试初始化 
3. 硬件和外设初始化 
   1. 初始化按键 `(EARPHONE_CUSTOM_EARPHONE_KEY_INIT())` 
   2. ANC主动降噪功能初始化 `(anc_poweron())` 
4. 通知和状态更新
   1.  UI状态更新 `(ui_update_status(STATUS_BT_INIT_OK))` 
   2. 充电盒状态设置 `(chargestore_set_bt_init_ok(1))` 
5. 连接控制逻辑 
   1. 根据不同工作模式设置连接策略 
   2. TWS对耳连接初始化 `(bt_tws_poweron())` 
   3. 手机连接控制 `(bt_wait_phone_connect_control(1))`

**默认执行的操作** 以下操作是无条件执行的（默认操作）：  

- 按键初始化 (EARPHONE_CUSTOM_EARPHONE_KEY_INIT()) 
- SBC编码参数设置 (__set_sbc_cap_bitpool(38)) 
- 蓝牙搜索索引初始化 (bt_init_ok_search_index()) 
- UI状态更新 (ui_update_status(STATUS_BT_INIT_OK))

**通过宏控制的操作** 以下操作是通过宏控制的：  

- 测试模式相关: 
  - TCFG_NORMAL_SET_DUT_MODE: 控制DUT测试模式 
  - TCFG_USER_BLE_ENABLE: 控制BLE功能初始化 
  - CONFIG_BT_MODE == BT_BQB: BQB测试模式控制 
- 音频功能: 
  - TCFG_AUDIO_DATA_EXPORT_ENABLE: 音频数据导出功能 
  - TCFG_AUDIO_ANC_ENABLE: ANC降噪功能 
- 设备连接: 
  - TCFG_USER_TWS_ENABLE: TWS对耳功能 
  - TCFG_CHARGESTORE_ENABLE || TCFG_TEST_BOX_ENABLE: 充电盒功能 
- 无线麦克风: 
  - TCFG_WIRELESS_MIC_ENABLE: 控制无线麦克风功能 
- 其他功能: 
  - TCFG_ADSP_UART_ENABLE: ADSP UART功能 
  - JL_EARPHONE_APP_EN && RCSP_UPDATE_EN: RCSP升级功能 
  - TCFG_BLE_DEMO_SELECT: BLE演示功能选择 
  - TCFG_BD_NUM: 蓝牙设备连接数量控制

##### **蓝牙相关操作**

与蓝牙直接相关的操作包括：  

- 蓝牙协议栈配置: 
  - SBC编码参数配置 
  - 角色切换支持设置 (lmp_hci_set_role_switch_supported(0)) 
- 连接管理: 
  - 蓝牙初始化搜索索引 (bt_init_ok_search_index()) 
  - 根据模式选择连接策略: 
    - BQB/PER测试模式: bt_wait_phone_connect_control(1) 
    - TWS模式: bt_tws_poweron() 
    - 普通模式: bt_wait_connect_and_phone_connect_switch(0) 
- BLE功能: 
  - BLE初始化 (bt_ble_init()) 
  - BLE测试模式 (ble_bqb_test_thread_init(), ble_standard_dut_test_init()) 
  - BLE图标状态管理 
- TWS对耳功能: 
  - TWS电源管理 (bt_tws_poweron()) 
  - TWS连接状态检测 (get_bt_tws_connect_status()) 
  - TWS角色切换 (tws_conn_switch_role())

这段代码展示了一个典型的蓝牙耳机方案，在蓝牙协议栈初始化完成后，根据不同的配置和工作模式，执行相应的初始化和连接策略。代码通过大量的宏控制来适应不同的产品需求和功能配置。

```c
case BT_STATUS_INIT_OK:
    // 蓝牙协议栈初始化完成
    log_info("BT_STATUS_INIT_OK\n");
#if 0
    printf("fix test rx if\n");  //定频测试用例接口
    fix_rxtx_lt_addr_set(5);
    bt_fix_txrx_api(1, fix_rx_mac_addr, 8, 5, 1);
    sys_timer_add(NULL, link_fix_rx_dump_result, 1000);
    return 0;
#endif
    // 初始化按键
    EARPHONE_CUSTOM_EARPHONE_KEY_INIT();
    /* bt_bredr_enter_dut_mode(0, 0); */
#if TCFG_NORMAL_SET_DUT_MODE
    log_info("edr set dut mode\n");
    bredr_set_dut_enble(1, 1);
    /* #if TCFG_USER_BLE_ENABLE */
    log_info("ble set dut mode\n");
    ble_standard_dut_test_init();
    /* #endif */
#endif
#if TCFG_AUDIO_DATA_EXPORT_ENABLE
#if (TCFG_AUDIO_DATA_EXPORT_ENABLE == AUDIO_DATA_EXPORT_USE_SPP)
    lmp_hci_set_role_switch_supported(0);
#endif/*AUDIO_DATA_EXPORT_USE_SPP*/
    extern int audio_capture_init();
    audio_capture_init();
#endif/*TCFG_AUDIO_DATA_EXPORT_ENABLE*/

#if TCFG_AUDIO_ANC_ENABLE
    anc_poweron();
#endif/*TCFG_AUDIO_ANC_ENABLE*/
    // 设置SBC编码参数
    __set_sbc_cap_bitpool(38);

#if (TCFG_USER_BLE_ENABLE)
    if (BT_MODE_IS(BT_BQB)) {
        ble_bqb_test_thread_init();
    } else {
#if !TCFG_WIRELESS_MIC_ENABLE
        // 初始化BLE
        bt_ble_init();
#endif
    }

#endif

#if TCFG_USER_TWS_ENABLE
    extern void pbg_demo_init(void);
    pbg_demo_init();
#endif

    // 初始化搜索索引
    bt_init_ok_search_index();
    ui_update_status(STATUS_BT_INIT_OK);
#if TCFG_CHARGESTORE_ENABLE || TCFG_TEST_BOX_ENABLE
    chargestore_set_bt_init_ok(1);
#endif


#if ((CONFIG_BT_MODE == BT_BQB)||(CONFIG_BT_MODE == BT_PER))
    // BQB测试模式或PER测试模式下，直接启用手机连接控制
    // 参数1表示开启可发现/可连接状态，允许设备被手机发现和连接
    bt_wait_phone_connect_control(1);
#else
    // 正常运行模式下的连接策略
    // 根据DAC（数模转换器）电源状态选择不同的连接方式
    if (is_dac_power_off()) {
        #if TCFG_USER_TWS_ENABLE
            // TWS双耳模式下：执行TWS专用的电源初始化流程
            // 该函数会处理双耳间的同步连接逻辑
            bt_tws_poweron();
        #else
            // 单耳模式：启动连接流程
            // 参数0表示主动连接记忆设备，发起蓝牙连接请求
            bt_wait_connect_and_phone_connect_switch(0);
        #endif
    } else {
        // DAC处于工作状态时：
        // 创建100ms后触发的定时器，用于延迟执行蓝牙连接
        // play_poweron_ok_timer是连接完成后的回调函数
        // 主要用于处理连接成功后的UI提示和状态更新
        app_var.wait_timer_do = sys_timeout_add(NULL, play_poweron_ok_timer, 100);
    }
#endif

    /*if (app_var.play_poweron_tone) {
        tone_play_index(p_tone->power_on, 1);
    }*/
    break;
    case BT_STATUS_SECOND_CONNECTED:
        // 清除当前开机记忆的设备搜索索引（针对第二个设备连接）
        clear_current_poweron_memory_search_index(0);
    case BT_STATUS_FIRST_CONNECTED:
        // 蓝牙设备连接成功通用处理流程
        // 包含首次连接（主设备）和第二个设备连接场景
        log_info("BT_STATUS_CONNECTED\n");
        
        // 切换电源模式到DCDC15（1.5V），3秒后生效
        earphone_change_pwr_mode(PWR_DCDC15, 3000);
        // 禁用自动关机功能（保持设备运行）
        sys_auto_shut_down_disable();

#if TCFG_ADSP_UART_ENABLE
        // 启用ADSP专用UART接口
        ADSP_UART_Init();
#endif

#if(JL_EARPHONE_APP_EN && RCSP_UPDATE_EN)
        // RCSP升级模式下的角色切换处理
        extern u8 rcsp_update_get_role_switch(void);
        if (rcsp_update_get_role_switch()) {
            // 执行TWS角色切换并禁用自动切换
            tws_conn_switch_role();
            tws_api_auto_role_switch_disable();
        }
#endif

#if(TCFG_BLE_DEMO_SELECT == DEF_BLE_DEMO_ADV)
        // BLE广播图标状态管理
        {
            u8 connet_type;
            // 根据是否为自动重连设置图标类型
            if (get_auto_connect_state(bt->args)) {
                connet_type = ICON_TYPE_RECONNECT; // 自动重连
            } else {
                connet_type = ICON_TYPE_CONNECTED; // 首次连接
            }

#if TCFG_USER_TWS_ENABLE
            // TWS模式下仅主耳显示BLE连接状态
            if (tws_api_get_role() == TWS_ROLE_MASTER) {
                bt_ble_icon_open(connet_type);
            } else {
                // 从耳可能已显示过，避免重复操作
                bt_ble_icon_close(0);
            }
#else
            // 单耳模式直接显示BLE连接状态
            bt_ble_icon_open(connet_type);
#endif
        }
#endif

#if (TCFG_BD_NUM == 2)
        // 双设备模式下管理手机连接状态
        if (get_current_poweron_memory_search_index(NULL) == 0) {
            // 当前设备为开机记忆的第一个设备，启用手机连接控制
            bt_wait_phone_connect_control(1);
        }
#endif

#if TCFG_USER_TWS_ENABLE
        // TWS模式下连接状态管理
        if (!get_bt_tws_connect_status()) {   // 对耳未连接时
            // 更新UI为蓝牙连接状态
            ui_update_status(STATUS_BT_CONN);
        }

#if TCFG_CHARGESTORE_ENABLE
        // 通知充电盒手机已连接
        chargestore_set_phone_connect();
#endif
        // 触发底层硬件状态机更新
        EARPHONE_STATE_BT_CONNECTED();
        
        // 如果对耳已连接则跳过后续处理
        if (bt_tws_phone_connected()) {
            break;
        }
#else
        // 单耳模式直接更新UI
        ui_update_status(STATUS_BT_CONN);
        
#if (TCFG_AUTO_STOP_PAGE_SCAN_TIME && TCFG_BD_NUM == 2)
        // 双设备模式下的页面扫描控制
        if (get_total_connect_dev() == 1) {   // 当前仅一个设备连接
            // 创建定时器停止页面扫描
            if (app_var.auto_stop_page_scan_timer == 0) {
                app_var.auto_stop_page_scan_timer = sys_timeout_add(NULL, bt_close_page_scan, (TCFG_AUTO_STOP_PAGE_SCAN_TIME * 1000));
            }
        } else {
            // 多设备连接时删除定时器
            if (app_var.auto_stop_page_scan_timer) {
                sys_timeout_del(app_var.auto_stop_page_scan_timer);
                app_var.auto_stop_page_scan_timer = 0;
            }
        }
#endif   // AUTO_STOP_PAGE_SCAN_TIME
#endif
        
        // 处理连接提示音播放
        log_info("tone status:%d\n", tone_get_status());
        if (get_call_status() == BT_CALL_HANGUP) {
            // 如果当前无通话，处理延迟断开场景
            if (app_var.phone_dly_discon_time) {
                sys_timeout_del(app_var.phone_dly_discon_time);
                app_var.phone_dly_discon_time = 0;
            } else {
                // 1.6秒后播放连接提示音
                app_var.wait_timer_do = sys_timeout_add(NULL, play_bt_connect_dly, 1600);
            }
        }
        break;
```

1. **按键初始化**`EARPHONE_CUSTOM_EARPHONE_KEY_INIT();`
   
   - 初始化耳机的物理按键功能，可能涉及按键事件注册、防抖设置等。
2. **DUT模式设置**`#if TCFG_NORMAL_SET_DUT_MODE`
   - 如果启用`TCFG_NORMAL_SET_DUT_MODE`，进入DUT（Device Under Test）模式：
     - `bredr_set_dut_enble(1, 1);`：启用BR/EDR模式的DUT测试功能。
     - `ble_standard_dut_test_init();`：初始化BLE标准DUT测试环境。
3. **音频数据导出功能**`#if TCFG_AUDIO_DATA_EXPORT_ENABLE`
   - 如果启用音频数据导出功能：
     - `lmp_hci_set_role_switch_supported(0)`：禁用角色切换（仅在SPP导出模式下需要）。
     - `audio_capture_init();`：初始化音频捕获模块，用于将音频数据通过SPP或其它接口导出。
4. **ANC（主动降噪）初始化**`#if TCFG_AUDIO_ANC_ENABLE`
   - 启动ANC模块电源：`anc_poweron();`。
5. **SBC编码参数设置**`__set_sbc_cap_bitpool(38);`
   - 设置SBC编码的位池参数为38，优化音频传输质量。
6. **BLE模块初始化**`#if TCFG_USER_BLE_ENABLE`
   - 如果启用BLE支持：
     - 在BQB测试模式下初始化BLE BQB测试线程。
     - 在普通模式下初始化BLE协议栈：`bt_ble_init();`。
7. **TWS（True Wireless Stereo）初始化**`#if TCFG_USER_TWS_ENABLE`
   
   - 初始化TWS功能：`pbg_demo_init();`，用于双耳同步连接。
8. **搜索索引与UI更新**
   
   - `bt_init_ok_search_index();`：初始化蓝牙设备搜索索引，用于快速回连历史设备。
   - `ui_update_status(STATUS_BT_INIT_OK);`：更新用户界面状态为“蓝牙初始化完成”。
   - `chargestore_set_bt_init_ok(1);`：通知充电仓模块蓝牙已初始化。
9. **连接模式决策**
   
   - 如果处于BQB或PER测试模式：`bt_wait_phone_connect_control(1);`开启可发现可连接状态。
   - 否则根据DAC电源状态决定连接策略：
     - DAC关闭时：进入TWS模式或直接回连设备。
     - DAC开启时：延迟播放启动提示音（通过`sys_timeout_add`调用 `play_poweron_ok_timer`）。
     
   - 策略解析：
     
     1. **测试模式** (`BT_BQB`/`BT_PER`)：
        - 直接开启可发现/可连接状态，用于测试场景
     2. **正常模式**：
        - **DAC电源关闭时**：
          - 双耳模式使用TWS专用连接流程
          - 单耳模式直接发起主动连接
        - **DAC电源工作时**：
          - 延迟100ms后执行连接操作，主要考虑：
            - 需等待DAC电源稳定
            - 给用户更流畅的连接体验（如播放开机提示音后再连接）
     3. **策略优势**：
        - 智能选择连接时机，兼顾电源管理和用户体验
        - 支持单双耳模式自动适配
        - 测试模式与正常模式分离，保证测试准确性
     
     这种设计既满足了测试需求，又能根据不同硬件配置（是否支持TWS）和系统状态（DAC电源状态）智能选择最合适的连接方式。
10. **开机提示音（可选）**
    - 注释代码段显示可通过`tone_play_index` 播放开机提示音，但实际功能被条件编译控制。

##### 疑问

**其实蓝牙初始化完成消息处理分支之前，耳机应用模式的状态机中，也有按键，蓝牙，tws，ble相关的内容，他们有什么关系？一个是定义参数？一个是利用参数做初始化？**

**`ACTION_EARPHONE_MAIN` (先执行)** 

这是基础参数配置和底层初始化阶段，主要完成：  

- 系统时钟配置 (clk_set, bt_pll_para) 
- 蓝牙功能模块选择 (bt_function_select_init) 
- 蓝牙协议栈初始化和启动 (btstack_init) 
- 蓝牙版本设置 (set_bt_version) 
- 硬件层面的功能准备 

这个阶段是启动蓝牙协议栈的过程，相当于给蓝牙系统"上电"并启动运行。

**`BT_STATUS_INIT_OK` (后执行)**

这是**功能逻辑初始化**阶段，当协议栈成功初始化后触发，主要完成：

- 基于已初始化的协议栈进行功能配置
- 连接策略设置
- 用户交互层面的功能准备
- 具体业务逻辑的启动

这个阶段是在协议栈准备就绪后，**根据参数配置各种功能模块**的过程。

**关键组件的关系**

**按键处理** 

- ACTION_EARPHONE_MAIN: 调用sys_key_event_enable()启用按键消息系统 
- BT_STATUS_INIT_OK: 调用EARPHONE_CUSTOM_EARPHONE_KEY_INIT()初始化具体按键功能

**蓝牙核心功能**

ACTION_EARPHONE_MAIN: 

- bt_function_select_init(): 选择蓝牙功能模块 
- btstack_init(): 启动蓝牙协议栈 

BT_STATUS_INIT_OK: 

- 配置连接策略 
- 处理连接控制逻辑

**TWS对耳功能** 

ACTION_EARPHONE_MAIN: 

- tws_profile_init(): 初始化TWS配置文件 

BT_STATUS_INIT_OK: 

- bt_tws_poweron(): 执行TWS电源管理和连接逻辑

**BLE功能** 

ACTION_EARPHONE_MAIN: 

- 设置蓝牙频偏校准回调 

BT_STATUS_INIT_OK: 

- bt_ble_init(): 初始化BLE具体功能

**工作流程总结**

这两段代码实际上体现了一个**分层初始化**的设计理念：

1. **第一阶段**(`ACTION_EARPHONE_MAIN`):
   - 负责**底层参数定义和协议栈启动**
   - 建立基础硬件和协议支持
   - 相当于"安装驱动程序"
2. **第二阶段**(`BT_STATUS_INIT_OK`):
   - 利用第一阶段建立的基础进行**功能初始化和业务逻辑配置**
   - 根据参数配置实际功能
   - 相当于"配置应用程序"

这种分层设计使得蓝牙初始化过程更加模块化和可维护，同时也反映了蓝牙协议栈的运行机制 - 先启动核心协议栈，然后在其基础上构建具体的应用功能。

#### 蓝牙初始化后设置了连接策略

在`BT_STATUS_INIT_OK`分支处理中设置了连接策略，这段代码决定了设备如何与手机或其他蓝牙设备建立连接。

```c
#if ((CONFIG_BT_MODE == BT_BQB)||(CONFIG_BT_MODE == BT_PER))
    // BQB测试模式或PER测试模式下，直接启用手机连接控制
    // 参数1表示开启可发现/可连接状态，允许设备被手机发现和连接
    bt_wait_phone_connect_control(1);
#else
    // 正常运行模式下的连接策略
    // 根据DAC（数模转换器）电源状态选择不同的连接方式
    if (is_dac_power_off()) {
        #if TCFG_USER_TWS_ENABLE
            // TWS双耳模式下：执行TWS专用的电源初始化流程
            // 该函数会处理双耳间的同步连接逻辑
            bt_tws_poweron();
        #else
            // 单耳模式：启动连接流程
            // 参数0表示主动连接记忆设备，发起蓝牙连接请求
            bt_wait_connect_and_phone_connect_switch(0);
        #endif
    } else {
        // DAC处于工作状态时：
        // 创建100ms后触发的定时器，用于延迟执行蓝牙连接
        // play_poweron_ok_timer是连接完成后的回调函数
        // 主要用于处理连接成功后的UI提示和状态更新
        app_var.wait_timer_do = sys_timeout_add(NULL, play_poweron_ok_timer, 100);
    }
#endif
```

蓝牙连接策略主要包含以下几个路径：

1. **测试模式路径**：
   - BQB测试或PER测试模式下，直接启用`bt_wait_phone_connect_control(1)`，让设备处于可发现可连接状态
2. **正常模式路径**：
   - DAC电源关闭时：
     - TWS双耳模式：执行`bt_tws_poweron()`，处理双耳间的同步连接
     - 单耳模式：执行`bt_wait_connect_and_phone_connect_switch(0)`，主动连接记忆设备
   - DAC电源开启时：
     - 延迟100ms后执行连接，创建定时器调用`play_poweron_ok_timer`
     - 这个定时后的回调函数中依旧走的是上面的两个路径

在`bt_wait_connect_and_phone_connect_switch`函数是核心的蓝牙连接函数：

```c
int bt_wait_connect_and_phone_connect_switch(void *p)
{
    int ret = 0;
    int timeout = 0;
    s32 wait_timeout;

    // 当自动连接计时器归零时，结束连接尝试流程
    if (bt_user_priv_var.auto_connection_counter <= 0) {
        bt_user_priv_var.auto_connection_timer = 0;
        bt_user_priv_var.auto_connection_counter = 0;

        // 取消蓝牙页面扫描（停止寻找新设备）
        EARPHONE_STATE_CANCEL_PAGE_SCAN();
        log_info("auto_connection_counter = 0\n");
        // 发送取消页面扫描命令
        user_send_cmd_prepare(USER_CTRL_PAGE_CANCEL, 0, NULL);

        // 如果存在开机记忆的设备索引
        if (get_current_poweron_memory_search_index(NULL)) {
            // 重新初始化设备搜索索引
            bt_init_ok_search_index();
            // 递归调用自身进行下一台设备连接尝试
            return bt_wait_connect_and_phone_connect_switch(0);
        } else {
            // 进入可发现/可连接状态，等待新设备连接
            bt_wait_phone_connect_control(1);
            return 0;
        }
    }

    // 根据参数p决定连接模式：
    // p=0: 主动连接记忆设备；p!=0: 被动等待新连接
    if ((int)p == 0) {
        if (bt_user_priv_var.auto_connection_counter) {
            // 主动连接模式：设置较长的超时时间
            timeout = 5600;
            // 关闭可发现/可连接状态（专注连接指定设备）
            bt_wait_phone_connect_control(0);
            // 发送通过地址连接指定设备的命令
            user_send_cmd_prepare(USER_CTRL_START_CONNEC_VIA_ADDR, 
                                 6, bt_user_priv_var.auto_connection_addr);
            ret = 1; // 返回1表示已发起连接请求
        }
    } else {
        // 被动连接模式：设置较短的超时时间
        timeout = 400;
        // 取消当前页面扫描
        user_send_cmd_prepare(USER_CTRL_PAGE_CANCEL, 0, NULL);
        // 启用可发现/可连接状态（进入配对模式）
        bt_wait_phone_connect_control(1);
    }

    // 更新剩余自动连接时间
    if (bt_user_priv_var.auto_connection_counter) {
        bt_user_priv_var.auto_connection_counter -= timeout;
        log_info("do=%d\n", bt_user_priv_var.auto_connection_counter);
    }

    // 设置新的超时定时器，再次调用本函数形成循环
    // 参数说明：(!(int)p)用于区分模式（0:主动连接 1:被动等待）
    bt_user_priv_var.auto_connection_timer = sys_timeout_add(
        (void *)(!(int)p),
        bt_wait_connect_and_phone_connect_switch, 
        timeout);

    return ret;
}
```

主要负责以下功能：

1. **自动连接记忆设备**
   - 当参数 `p=0` 时，**主动发起连接**存储的设备地址（通过 `USER_CTRL_START_CONNEC_VIA_ADDR`命令）
     - **非TWS模式下的回连**
   - 使用 5600ms 超时机制，**持续尝试**连接直到超时
   - 连接成功后通过 `ret=1` 返回状态
2. **被动等待新连接**
   - 当参数 `p≠0` 时，进入**可发现模式等待新设备连接**
   - 使用 400ms 短超时快速响应新连接请求
   - 通过 `bt_wait_phone_connect_control(1)`启用设备可发现性
3. **超时重试机制**
   - 使用 `sys_timeout_add`创建递归定时器，实现连接重试循环
   - 主动连接模式传递 `!(int)p` 标志保持连续尝试
   - 被动模式传递 `!(int)p` 标志维持低功耗监听
4. **多设备回连逻辑**
   - 当检测到开机记忆设备索引时，递归调用自身实现多设备回连（如双耳模式下的第二台设备连接）
   - 通过 `get_current_poweron_memory_search_index()`判断记忆设备存在性
5. **状态清理**
   - 当计时器归零时：
     - 取消页面扫描`EARPHONE_STATE_CANCEL_PAGE_SCAN`
     - 若有记忆设备则重新初始化搜索索引
     - 无记忆设备时进入可发现状态等待新连接

该函数是蓝牙连接流程的关键控制单元，协调着设备开机后的自动回连、连接失败后的重试、以及新设备配对的切换，是实现蓝牙设备稳定连接的核心逻辑。

##### 参数为0的执行流程

1.**初始进入函数**

- 当参数为0时，表示要主动连接记忆设备。

2.检查自动连接计数器

- 首先检查`auto_connection_counter`是否小于等于0
  - 如果是，表示已经没有回连时间了，进入超时处理
  - 如果否，继续执行主动连接流程

3.主动连接流程

- 因为参数p=0，进入主动连接分支
- 检查`auto_connection_counter`是否大于0
  - 如果是，设置超时时间为5600ms
  - 关闭可发现可连接状态：`bt_wait_phone_connect_control(0)`
  - 发送连接指定地址的命令：`user_send_cmd_prepare(USER_CTRL_S）`
  - 减少`auto_connection_counter`的值（减去5600）
  - 创建新的定时器，超时后以参数`(void *)(!(int)0)` = `(void *)1`再次调用本函数
  - 返回1（表示已发起连接）

4.超时后再次进入（参数为1）

- 当第3步的定时器超时，会以参数1再次调用本函数
- 因为参数p!=0，进入被动连接分支
- 设置超时时间为400ms
- 取消当前页面扫描
- 启用可发现可连接状态：`bt_wait_phone_connect_control(1)`
- 减少`auto_connection_counter`的值（减去400）
- 创建新的定时器，超时后以参数`(void *)(!(int)1)` = `(void *)0`再次调用本函数
- 返回0

5.超时后再次进入（参数为0）

- 重复第3步和第4步，在主动连接和被动连接之间交替
- 这个过程会不断减少`auto_connection_counter`的值

6.连接尝试结束处理

- 当`auto_connection_counter`减到小于等于0时：
  - 重置`auto_connection_timer = 0`和`auto_connection_counter = 0`
  - 取消页面扫描
  - 检查是否还有其他记忆设备可尝试连接：`get_current_poweron_memory_search_index(NULL)`
    - 如果有，重置搜索索引并再次调用`bt_wait_connect_and_phone_connect_switch(0)`尝试下一个设备
    - 如果没有，调用`bt_wait_phone_connect_control(1)`进入可发现可连接状态，并返回0

**原理解释**

这个函数的核心原理是：

1. **交替尝试策略**：在主动连接（寻找指定设备）和被动等待（允许被发现和连接）之间交替
2. 时间控制机制：通过`auto_connection_counter`控制总的尝试时间
3. **递归调用链**：函数通过定时器和递归调用自身形成循环，直到连接成功或尝试时间耗尽
4. **多设备尝试**：如果一个设备连接失败，会尝试连接下一个记忆设备

**函数是否会结束？**

函数确实会结束，但通过定时器和递归调用形成了一个"循环"机制：

1. 单次调用会结束，但会创建定时器再次调用自身
2. 当`auto_connection_counter`耗尽且没有更多记忆设备时，函数才会真正"结束循环"
3. **如果连接成功，蓝牙协议栈会触发连接事件，可能会在事件处理函数中取消这个定时器**

所以从用户角度看，函数会持续工作直到：

- 成功连接到某个设备
- 尝试了所有记忆设备后进入可发现可连接状态
- 被其他事件中断（如手动取消、关机等）

这种设计确保了设备能够尽可能地恢复之前的连接，同时又不会无限期地尝试连接不可用的设备。

##### 非TWS模式蓝牙耳机开机的蓝牙连接流程

1. **初始调用**
   - 蓝牙初始化完成后，调用`bt_wait_connect_and_phone_connect_switch(0)`开始回连
   - 参数0表示主动尝试连接记忆设备
2. **回连时间机制**
   - 系统使用`auto_connection_counter`变量控制总回连时间
   - 这是**所有记忆设备共享的总时间**，而非每台设备单独计时
   - 每次尝试连接会减少这个计数器：主动连接减5600ms，被动等待减400ms
3. **每台记忆设备的回连尝试**
   - 系统会使用记忆设备索引（通过`get_current_poweron_memory_search_index`获取）
   - 对每个记忆设备进行尝试连接
   - 没有明确设置每台设备的尝试次数，而是由总时间控制
     - 每一个主动连接的时间呗5600
   - 一个设备连接失败后，会尝试下一个记忆设备（如果总时间允许）
4. **回连策略**
   - 采用交替策略：主动连接(5600ms) → 被动等待(400ms) → 主动连接 → ...
   - **主动连接时关闭可发现可连接状态，专注连接指定设备**
   - **被动等待时开启可发现可连接状态，短暂允许被连接**
5. **回连不成功后的处理**
   - 当所有记忆设备都尝试连接失败，或总时间耗尽：
   - 系统会调用`bt_wait_phone_connect_control(1)`
   - 这会将耳机设置为**可发现可连接状态**
   - 此时耳机可以被新的设备发现并配对
6. **回连流程结束**
   - 回连成功：蓝牙事件会处理连接成功，停止后续尝试
   - 回连失败：尝试所有记忆设备后，进入可发现可连接状态
   - 程序不会"死循环"尝试连接，会有明确的结束条件

**要点总结**

- 回连时间是所有设备共享的，不是每台设备单独计时
- 系统会尝试连接所有记忆设备，直到连接成功或时间耗尽
- 最终，如果回连不成功，耳机会进入可发现可连接状态，等待新连接
- 这种设计既保证了尝试恢复已有连接，又不会无限期阻止新连接的建立

这种机制确保了耳机能优先尝试连接用户熟悉的设备，同时在必要时也能与新设备配对，提供了良好的用户体验。

#### 耳机连接成功

非TWS模式会调用bt_wait_connect_and_phone_connect_switch(0);进入记忆设备回连操作。假如回连设备成功的话，会进入BT_STATUS_SECOND_CONNECTED或者    case BT_STATUS_FIRST_CONNECTED:
分支吗？两者有什么区别？

## 手机连接请求

当手机发起连接请求时，会触发HCI事件，在`bt_hci_event_handler`函数中处理：

```c
int bt_hci_event_handler(struct bt_event *bt)
{
    switch (bt->event) {
    case HCI_EVENT_CONNECTION_REQUEST:
        // 接受连接请求
        user_send_cmd_prepare(USER_CTRL_ACCEPT_CONN, 1, bt->args);
        break;
    
    case HCI_EVENT_CONNECTION_COMPLETE:
        // 连接完成事件处理
        bt_hci_event_connection(bt);
        break;
    
    // ...其他事件处理
    }
    
    // 处理连接状态事件
    bt_connction_status_event_handler(bt);
    
    return 0;
}
```

[bt_hci_event_handler](javascript:void(0)) 函数是蓝牙协议栈的底层事件处理函数，主要负责处理蓝牙主机控制器接口（HCI）触发的各种事件，其核心功能包括：

**厂商自定义事件处理**

- 远程测试事件
  - HCI_EVENT_VENDOR_REMOTE_TEST:
    - 当设备因远端测试断开连接时，清除测试状态并复位系统（用于产测场景）。
    - 在经典蓝牙模式下连接时，禁用BLE广播；非TWS连接时关闭TWS功能。

**标准HCI事件处理**

通过 `switch` 分支处理以下核心事件：

- 元事件
  - [HCI_EVENT_VENDOR_META](javascript:void(0)): 调用厂商自定义事件处理函数 `bt_vendor_meta_event_handle`（如耳检测测试指令）。
- 设备发现
  - [HCI_EVENT_INQUIRY_COMPLETE](javascript:void(0)): 查询设备完成后的处理（如关闭发射器搜索）。
- 配对交互
  - `HCI_EVENT_USER_CONFIRMATION_REQUEST/PIN_CODE_REQUEST`: 自动接受配对请求（无需用户交互）。
- 连接状态管理
  - HCI_EVENT_CONNECTION_COMPLETE: 处理连接完成事件（成功或失败）。
    - 成功（[ERROR_CODE_SUCCESS](javascript:void(0))）：记录连接地址并触发连接状态更新。
    - 超时（[ERROR_CODE_CONNECTION_TIMEOUT](javascript:void(0))）：标记远端断开并尝试重连。
  - [HCI_EVENT_DISCONNECTION_COMPLETE](javascript:void(0)): 断开连接时更新设备状态（如切换LED模式、进入低功耗）。
- 错误处理
  - 处理配对失败、连接拒绝、资源不足等错误码（如 [ERROR_CODE_PIN_OR_KEY_MISSING](javascript:void(0))）。

**关键逻辑说明**

- 自动连接机制
  - 在连接成功后，通过 `user_conn_addr` 记录设备地址，支持后续自动重连（[USER_AUTO_CONN_A2DP](javascript:void(0)) 宏启用时生效）。
- 低功耗控制
  - 在断开连接或超时后，调用 [sys_auto_shut_down_enable()](javascript:void(0)) 启动自动关机定时器。
- TWS同步
  - 在多设备场景中，通过 [bt_tws_poweroff()](javascript:void(0)) 和 [bt_tws_phone_disconnected()](javascript:void(0)) 维护双耳同步状态。

**核心作用**

该函数是蓝牙设备连接管理的核心逻辑，负责：

1. 响应手机/设备的连接请求。
2. 处理配对、连接、断开等底层协议交互。
3. 维护设备状态（如低功耗、TWS同步）。
4. 错误恢复（如超时重试、自动重连）。

此函数直接影响蓝牙设备的连接稳定性与用户体验（如自动配对、断开提示音播放等）。

```c
case ERROR_CODE_SUCCESS:
            // 连接成功 - 记录设备地址
            #if USER_AUTO_CONN_A2DP
            memcpy(user_conn_addr, bt->args, 6);
            #endif
            testbox_in_ear_detect_test_flag_set(0);
            bt_hci_event_connection(bt);
            break;
```

## 连接完成事件处理

在`bt_hci_event_connection`中处理连接完成事件：

```c
/**
 * 连接完成事件处理函数 - 处理蓝牙设备连接完成后的协议栈交互
 * 参数:
 *   bt - 指向蓝牙事件结构体的指针
 * 功能描述:
 *   1. 维护TWS双耳同步状态
 *   2. 清理自动连接定时器
 *   3. 退出Sniff低功耗模式
 *   4. 管理设备发现/连接使能状态
 */
static void bt_hci_event_connection(struct bt_event *bt)
{
    //【调试信息】记录当前TWS连接状态（主从角色、连接标志位）
    log_info("tws_conn_state=%d\n", bt_user_priv_var.tws_conn_state);

#if TCFG_USER_TWS_ENABLE
    //【TWS模式】通知TWS模块连接建立事件
    bt_tws_hci_event_connect();

#ifndef CONFIG_NEW_BREDR_ENABLE
    //【传统EDR模式】关闭TWS自动重连机制（防止连接后重复触发）
    tws_try_connect_disable();
#endif
#else
    //【单耳模式】清理自动连接资源
    if (bt_user_priv_var.auto_connection_timer) {
        // 删除自动连接定时器
        sys_timeout_del(bt_user_priv_var.auto_connection_timer);
        bt_user_priv_var.auto_connection_timer = 0;
    }
    // 重置自动连接计数器
    bt_user_priv_var.auto_connection_counter = 0;
    
    // 关闭手机的可发现/可连接状态（连接完成后停止广播）
    bt_wait_phone_connect_control(0);
    
    // 退出Sniff低功耗模式（保持正常通信状态）
    user_send_cmd_prepare(USER_CTRL_ALL_SNIFF_EXIT, 0, NULL);
#endif

}
```

1. **TWS模式处理**
   - 通过[bt_tws_hci_event_connect()](javascript:void(0))同步双耳连接状态
   - 在传统EDR模式下禁用[tws_try_connect_disable()](javascript:void(0))防止重复连接
2. **单耳模式资源管理**
   - 清理自动连接定时器与计数器
   - 关闭设备发现/连接使能状态
   - 强制退出Sniff低功耗模式
3. **系统状态维护**
   - 记录调试日志用于连接状态追踪
   - 确保连接建立后维持稳定通信链路

注释清晰解释了不同编译配置下的差异化处理逻辑，以及连接完成后的协议栈状态维护机制。

## 连接状态事件处理

- `bt_connction_status_event_handler`

当设备连接状态变化时，会触发`BT_STATUS_FIRST_CONNECTED`或`BT_STATUS_SECOND_CONNECTED`事件：

```c
case BT_STATUS_SECOND_CONNECTED:
    clear_current_poweron_memory_search_index(0);
case BT_STATUS_FIRST_CONNECTED:
    log_info("BT_STATUS_CONNECTED\n");
    
    // 调整电源模式
    earphone_change_pwr_mode(PWR_DCDC15, 3000);
    
    // 禁用自动关机
    sys_auto_shut_down_disable();
    
    // 更新UI状态
    #if TCFG_USER_TWS_ENABLE
    if (!get_bt_tws_connect_status()) {
        ui_update_status(STATUS_BT_CONN);
    }
    #else
    ui_update_status(STATUS_BT_CONN);
    #endif
    
    // 更新耳机状态
    EARPHONE_STATE_BT_CONNECTED();
    
    // 播放连接提示音
    tone_play_index(p_tone->bt_connect, 1);
    break;
```

已为蓝牙连接状态处理分支添加专业注释，重点说明：

1. **双设备管理逻辑**
   - 通过[clear_current_poweron_memory_search_index](javascript:void(0))维护开机记忆索引
   - 使用[get_current_poweron_memory_search_index](javascript:void(0))控制多设备连接策略
2. **TWS同步机制**
   - [tws_conn_switch_role](javascript:void(0))实现主从角色切换
   - [bt_tws_phone_connected](javascript:void(0))判断对耳连接状态
3. **BLE图标控制**
   - 根据[get_auto_connect_state](javascript:void(0))区分首次连接与重连场景
   - 使用[ICON_TYPE_RECONNECT/ICON_TYPE_CONNECTED](javascript:void(0))显示不同连接状态
4. **电源管理**
   - [earphone_change_pwr_mode](javascript:void(0))切换到高效供电模式
   - [sys_auto_shut_down_disable](javascript:void(0))防止连接状态下自动关机
5. **用户提示**
   - 通过[play_bt_connect_dly](javascript:void(0))实现延迟播放连接提示音

注释清晰解释了在[BT_STATUS_FIRST_CONNECTED](javascript:void(0))和[BT_STATUS_SECOND_CONNECTED](javascript:void(0))事件中，系统如何协调TWS双耳状态、管理BLE广播、控制电源模式以及提供用户反馈的完整处理流程。

## 连接断开处理

当蓝牙连接断开时，会触发`HCI_EVENT_DISCONNECTION_COMPLETE`事件：

```c
	bt_hci_event_handler()
        
	case HCI_EVENT_VENDOR_NO_RECONN_ADDR:
    case HCI_EVENT_DISCONNECTION_COMPLETE:
        // 连接断开事件处理
        bt_hci_event_disconnect(bt);
        break;


/*
 * 蓝牙连接断开事件处理函数 - 处理蓝牙连接断开后的协议栈行为
 * 参数:
 *   bt - 指向蓝牙事件结构体的指针，包含断开事件详细信息
 * 功能描述:
 * 1. 管理电源模式切换
 * 2. 更新UI状态指示
 * 3. 控制自动关机功能
 * 4. 处理测试盒模式下的特殊需求
 * 5. 管理页面扫描定时器
 * 6. 处理双设备连接时的回连逻辑
 */
static void bt_hci_event_disconnect(struct bt_event *bt)
{
    // 如果设备正在关机流程中，直接返回
    if (app_var.goto_poweroff_flag) {
        return;
    }

    // 断开连接后切换到LDO15电源模式（低功耗模式）
    // 参数0表示立即执行电源模式切换
    earphone_change_pwr_mode(PWR_LDO15, 0);

    // 获取当前连接设备数量
    log_info("<<<<<<<<<<<<<<total_dev: %d>>>>>>>>>>>>>\n", get_total_connect_dev());

    // 如果当前没有活动的通道连接
    if (!get_curr_channel_state()) {
        // 非TWS模式下处理
#if (TCFG_USER_TWS_ENABLE == 0)
        // 如果不是关机流程，更新UI为蓝牙断开状态
        if (!app_var.goto_poweroff_flag) {
            ui_update_status(STATUS_BT_DISCONN);
        }
#endif
        // 启用自动关机功能（若配置了自动关机时间）
        sys_auto_shut_down_enable();
    }

    // 双设备模式下的连接状态检查
#if (TCFG_BD_NUM == 2)
    log_info("get_bt_connect_status = 0x%x,%x\n", get_bt_connect_status(), get_curr_channel_state());
    // 如果当前没有活动通道连接
    if (!get_curr_channel_state()) {
        // 启用自动关机功能
        sys_auto_shut_down_enable();
    }
#endif

    // 测试盒模式特殊处理
#if TCFG_TEST_BOX_ENABLE
    // 如果处于测试盒特殊DUT模式
    extern u8 chargestore_get_ex_enter_dut_flag(void);
    if (chargestore_get_ex_enter_dut_flag()) {
        // 保持设备可发现/可连接状态
        bt_discovery_and_connectable_using_loca_mac_addr(1, 1);
        return;
    }

    // 如果处于测试盒模式
    if (chargestore_get_testbox_status()) {
        // 保持设备可连接但不可发现
        bt_discovery_and_connectable_using_loca_mac_addr(0, 1);
        return;
    }
#endif

    // 双设备模式下的页面扫描管理
#if (TCFG_AUTO_STOP_PAGE_SCAN_TIME && TCFG_BD_NUM == 2)
    // 当前有一台设备连接
    if (get_total_connect_dev() == 1) {
        // 创建定时器停止页面扫描
        if (app_var.auto_stop_page_scan_timer == 0) {
            app_var.auto_stop_page_scan_timer = sys_timeout_add(NULL, bt_close_page_scan, (TCFG_AUTO_STOP_PAGE_SCAN_TIME * 1000)); // 延迟TCFG_AUTO_STOP_PAGE_SCAN_TIME秒后停止页面扫描
        }
    } else {
        // 删除定时器
        if (app_var.auto_stop_page_scan_timer) {
            sys_timeout_del(app_var.auto_stop_page_scan_timer);
            app_var.auto_stop_page_scan_timer = 0;
        }
    }
#endif

    // 双设备模式错误处理
#if (TCFG_BD_NUM == 2)
    // 处理特定错误码导致的连接失败
    if ((bt->event == ERROR_CODE_CONNECTION_REJECTED_DUE_TO_UNACCEPTABLE_BD_ADDR) ||
        (bt->event == ERROR_CODE_CONNECTION_ACCEPT_TIMEOUT_EXCEEDED) ||
        (bt->event == ERROR_CODE_ROLE_SWITCH_FAILED) ||
        (bt->event == ERROR_CODE_ACL_CONNECTION_ALREADY_EXISTS)) {
        /*
         * 连接接受超时等错误处理
         * 如果支持1t2连接，尝试回连下一台设备
         * get_current_poweron_memory_search_index()检查是否还有待连接设备
         */
        if (get_current_poweron_memory_search_index(NULL)) {
            // 准备重新连接下一台设备
            user_send_cmd_prepare(USER_CTRL_START_CONNECTION, 0, NULL);
            return;
        }
    }
#endif

    // TWS模式下的特殊处理
#if TCFG_USER_TWS_ENABLE
    // 根据错误码类型调用TWS专用处理函数
    if (bt->value == ERROR_CODE_CONNECTION_TIMEOUT) {
        // 连接超时处理
        bt_tws_phone_connect_timeout();
    } else {
        // 普通断开连接处理
        bt_tws_phone_disconnected();
    }
#else
    // 非TWS模式下允许重新连接
    bt_wait_phone_connect_control(1);
#endif
}
```

1. 电源模式管理
   - 切换电源模式
   - 断开连接后调用 earphone_change_pwr_mode(PWR_LDO15, 0)，将设备切换至低功耗电源模式（LDO15），以降低功耗。

2. UI状态更新

   - 非TWS模式
     - 如果未启用 TWS（True Wireless Stereo）功能，且设备未处于关机流程，则通过 ui_update_status(STATUS_BT_DISCONN) 更新用户界面状态为“蓝牙断开”。

   - 双设备模式
     - 检查当前连接设备数量（get_total_connect_dev()）和通道状态（get_curr_channel_state()），若无活动连接则触发自动关机逻辑。

3. 自动关机控制
   - 启用自动关机
     - 若配置了自动关机时间（TCFG_AUTO_SHUT_DOWN_TIME），通过 sys_auto_shut_down_enable() 启动定时器，超时后执行关机操作。

4. 测试盒模式处理

- 特殊DUT模式
  - 若设备处于测试盒的特殊DUT模式（通过 chargestore_get_ex_enter_dut_flag() 判断），保持设备可发现且可连接状态（调用 bt_discovery_and_connectable_using_loca_mac_addr(1, 1)）。

- 普通测试盒模式
  - 若仅处于测试盒模式（非DUT），保持设备可连接但不可发现状态（调用 bt_discovery_and_connectable_using_loca_mac_addr(0, 1)）。

5. 页面扫描定时器管理

   - 双设备模式下的扫描控制

     - 若当前仅剩一台设备连接：

     - 创建定时器（sys_timeout_add），延迟 TCFG_AUTO_STOP_PAGE_SCAN_TIME 秒后关闭页面扫描（调用 bt_close_page_scan）。

   - 若无设备连接：
     - 删除定时器（sys_timeout_del），停止页面扫描管理。

6. 双设备回连逻辑
   - 错误码处理
     - 针对特定错误码（如连接拒绝、超时等），检查是否支持多设备回连（通过 get_current_poweron_memory_search_index() 判断），若存在待连接设备则触发重新连接（调用 user_send_cmd_prepare(USER_CTRL_START_CONNECTION)）。

7. TWS模式特殊处理

   - TWS专用逻辑

     - 若断开原因为连接超时（ERROR_CODE_CONNECTION_TIMEOUT），调用 bt_tws_phone_connect_timeout() 处理超时逻辑。

     - 其他断开情况调用 bt_tws_phone_disconnected() 更新TWS状态。

   - 非TWS模式
     - 调用 bt_wait_phone_connect_control(1) 允许设备重新进入可连接状态。

8. 其他功能

   - 日志记录

   - 输出当前连接设备数量（get_total_connect_dev()）和连接状态（get_bt_connect_status()）的调试信息。

**关键配置影响**

- 宏定义控制功能
  - [TCFG_USER_TWS_ENABLE](javascript:void(0))：启用/禁用TWS双耳同步逻辑。
  - [TCFG_TEST_BOX_ENABLE](javascript:void(0))：启用/禁用测试盒模式下的特殊处理。
  - `TCFG_BD_NUM == 2`：启用双设备连接管理逻辑。
  - [TCFG_AUTO_STOP_PAGE_SCAN_TIME](javascript:void(0))：控制页面扫描定时器行为。

该函数通过上述处理确保设备在蓝牙断开后的行为符合预期，包括低功耗管理、用户交互、自动重连策略及测试场景适配。

## 断开延迟处理与回连

- 谁来调用？
- 什么时候调用？

当断开连接一段时间后，执行回连操作：

```c
static void bt_discon_dly_handle(void *priv)
{
    // 清除延迟断开定时器
    app_var.phone_dly_discon_time = 0;

    STATUS *p_tone = get_tone_config();

    // 双设备模式下的断开处理
#if(TCFG_BD_NUM == 2)
    /* tone_play(TONE_DISCONN); */
    // 播放蓝牙断开提示音（单设备模式）
    tone_play_index(p_tone->bt_disconnect, 1);
#else

    // 单设备模式下：
    // 仅当TWS未连接或未处于延迟断开状态时播放提示音
#if TCFG_USER_TWS_ENABLE
    if (!get_bt_tws_connect_status() && !get_bt_tws_discon_dly_state())
#endif
    {
        tone_play_index(p_tone->bt_disconnect, 1);
    }
#endif

    // TWS相关处理
#if TCFG_USER_TWS_ENABLE
    STATUS *p_led = get_led_config();
    if (get_bt_tws_connect_status()) {
#if TCFG_CHARGESTORE_ENABLE
        // 通知充电盒手机已断开
        chargestore_set_phone_disconnect();
#endif
        // 主耳通过TWS同步播放断开提示音
        if (tws_api_get_role() == TWS_ROLE_MASTER) {
            bt_tws_play_tone_at_same_time(SYNC_TONE_PHONE_DISCONNECTED, 400);
        }
    } else {
        // 单耳模式下特殊处理：
        // 切换LED时钟到RC模式以降低功耗
        pwm_led_clk_set((!TCFG_LOWPOWER_BTOSC_DISABLE) ? PWM_LED_CLK_RC32K : PWM_LED_CLK_BTOSC_24M);
        // 更新UI状态为蓝牙断开
        ui_update_status(STATUS_BT_DISCONN);
    }
#endif

}
```

1. **清除延迟断开定时器**：停止与断开相关的定时器。
2. 播放提示音：
   - 在双设备模式下直接播放断开提示音。
   - 在单设备模式下根据 TWS 状态决定是否播放提示音。
3. TWS 相关处理：
   - 如果对耳仍连接，主耳通过 TWS 同步播放断开提示音。
   - 如果对耳未连接，更新 LED 时钟模式以降低功耗，并将 UI 状态更新为蓝牙断开。
4. **充电盒支持**：通知充电盒手机已断开。

该函数专注于断开后的清理和状态更新，并不直接参与回连逻辑。回连通常由其他函数（如 [bt_wait_connect_and_phone_connect_switch](javascript:void(0))）管理。

## 完整调用链小结

经典蓝牙的完整调用链：

系统启动: `main() → app_main() → start_app(&it)`

耳机初始化: `state_machine(APP_STA_START, ACTION_EARPHONE_MAIN)`

蓝牙功能初始化: `bt_function_select_init() → bredr_handle_register() → btstack_init()`

蓝牙初始化完成: `BT_STATUS_INIT_OK → bt_wait_connect_and_phone_connect_switch(0)`

等待连接: 开启可发现可连接 → `USER_CTRL_WRITE_SCAN_ENABLE + USER_CTRL_WRITE_CONN_ENABLE`

连接建立: `HCI_EVENT_CONNECTION_REQUEST → HCI_EVENT_CONNECTION_COMPLETE → bt_hci_event_connection()`

连接状态更新: `BT_STATUS_FIRST_CONNECTED → EARPHONE_STATE_BT_CONNECTED()`

连接断开: `HCI_EVENT_DISCONNECTION_COMPLETE → bt_hci_event_disconnect() → bt_discon_dly_handle()`

回连或搜索: `USER_CTRL_START_CONNEC_VIA_ADDR` 或 重新进入可被发现状态