# 按键

`apps\earphone\board\br36\board_ac700n_demo.c`

```c
/************************** KEY MSG****************************/
/*各个按键的消息设置，如果USER_CFG中设置了USE_CONFIG_KEY_SETTING为1，则会从配置文件读取对应的配置来填充改结构体*/
u8 key_table[KEY_NUM_MAX][KEY_EVENT_MAX] = {
    // SHORT           LONG              HOLD              UP              DOUBLE           TRIPLE              四击
#if TCFG_APP_LINEIN_EN
    {KEY_ANC_SWITCH,   KEY_POWEROFF,  KEY_POWEROFF_HOLD,  KEY_NULL,     KEY_MODE_SWITCH,     KEY_LOW_LANTECY},   //KEY_0
#else
    {KEY_MUSIC_PP,   KEY_POWEROFF,  KEY_POWEROFF_HOLD,  KEY_NULL,     KEY_ANC_SWITCH,     KEY_LOW_LANTECY,      KEY_OPEN_SIRI},   //KEY_0
#endif
    {KEY_MUSIC_NEXT, KEY_VOL_UP,    KEY_VOL_UP,         KEY_NULL,     KEY_OPEN_SIRI,        KEY_NULL},   //KEY_1
    {KEY_MUSIC_PREV, KEY_VOL_DOWN,  KEY_VOL_DOWN,       KEY_NULL,     KEY_HID_CONTROL,      KEY_NULL},   //KEY_2

    // 上滑               下滑          左滑               右滑
    {KEY_MUSIC_NEXT, KEY_MUSIC_PREV, KEY_NULL,           KEY_NULL,        KEY_NULL,             KEY_NULL},          //触摸按键滑动时的消息
};
```

- 不读取配置工具的文件，当发生按键事件时，直接走对应的处理分支：单击，长按，长按后的hold，长按后的UP，双击，三击，四击。

- 分支名称可以自定义，也可以直接修改原分支的源码逻辑

## 长按识别以及hold发生时间间隔

`include_lib\driver\cpu\br36\asm\lp_touch_key_hw.h`

```c
/**********************************************************算法流程配置**********************************************************************************/
#define CTMU_SAMPLE_RATE_PRD 			20 //kick start采样周期, 单位: ms

#define CTMU_SHORT_CLICK_DELAY_TIME 	400 	//单击事件后等待下一次单击时间(ms)
#define CTMU_HOLD_CLICK_DELAY_TIME 		200 	//long事件产生后, 发hold事件间隔(ms)
#define CTMU_LONG_KEY_DELAY_TIME 		2000 	//从按下到产生long事件的时间(ms
```

## 关闭长按开机

`apps\earphone\board\br36\board_ac700n_demo_cfg.h`

```c
//*********************************************************************************//
//                                  系统配置                                         //
//*********************************************************************************//
#define TCFG_AUTO_SHUT_DOWN_TIME		          180   //没有蓝牙连接自动关机时间
#define TCFG_SYS_LVD_EN						      1   //电量检测使能
#define TCFG_POWER_ON_NEED_KEY                    0//!DHF_DUBUG_PRINTF  //是否需要按按键开机配置
```

如果还不行：

把`cpu\br36\lp_touch_key.c`中所有的**带触摸关机**修改为**普通关机**

- 带触摸关机的意思是关机后触摸按键可以使用，也就可以通过触摸按键实现开机操作。

```c
	//__this->softoff_mode = LP_TOUCH_SOFTOFF_MODE_ADVANCE;
    __this->softoff_mode = LP_TOUCH_SOFTOFF_MODE_LEGACY;
```

`apps\earphone\board\br36\board_ac700n_demo_cfg.h`

- 有一些版本似乎没有这个配置

```c
//*********************************************************************************//
//                                 自定义配置                                       //
//*********************************************************************************//
#define YUEER_APP_ENABLE                 0   //接入原上APP

#define TCFG_LP_SOFTOFF_KEEP                 1  //关机关闭内置触摸(不需要手动关机)    
```

**原理后面分析**,后面两个应该是可以搞一个就行了，但是需要分析。

## 长按开机时间

`include_lib\driver\cpu\br36\asm\lp_touch_key_api.h`

```c
/**************************************************USER配置************************************************************************/
//长按开机时间:
#define CFG_M2P_CTMU_SOFTOFF_LONG_TIME 			    1000	//单位: ms

//触摸按键长按复位时间配置
#define CTMU_RESET_TIME_CONFIG			            0//8000	//长按复位时间(ms), 配置为0关闭
```



## 七击以上实现

### AD实体按键

**十击按键事件实现恢复出产设置**

`apps\common\device\key\key_driver.c`添加对应的连击检测，必须按照顺序判断，中间的必须补上不然识别不到，不知道原因。

```c
if (scan_para->click_delay_cnt > scan_para->click_delay_time) { //按键被抬起后延时到
                    //TODO: 在此可以添加任意多击事件
                    if(scan_para->click_cnt >= 10){
                        //新增加十击检测
                        key_event = KEY_EVENT_TENTH_CLICK;
                    } else if(scan_para->click_cnt >= 9) {
                        key_event = KEY_EVENT_NINTH_CLICK;
                    } else if(scan_para->click_cnt >= 8) {
                        key_event = KEY_EVENT_EIGHTH_CLICK;
                    } else if(scan_para->click_cnt >= 7) {
                        key_event = KEY_EVENT_SEVEN_CLICK;
                    } else if(scan_para->click_cnt >= 6){
                        key_event = KEY_EVENT_SIXTH_CLICK;
                    } else if (scan_para->click_cnt >= 5) {
                        key_event = KEY_EVENT_FIRTH_CLICK;  //五击
                    } else if (scan_para->click_cnt >= 4) {
                        key_event = KEY_EVENT_FOURTH_CLICK;  //4击
                    } else if (scan_para->click_cnt >= 3) {
                        key_event = KEY_EVENT_TRIPLE_CLICK;  //三击
                    } else if (scan_para->click_cnt >= 2) {
                        key_event = KEY_EVENT_DOUBLE_CLICK;  //双击
                    } else {
                        key_event = KEY_EVENT_CLICK;  //单击
                    }
                    key_value = scan_para->notify_value;
                    goto _notify;
                }
```

按键事件的枚举值自己定义，值不能超过`KEY_EVENT_MAX`。只是为了标识一下？感觉没啥作用，暂时没有看出来。

`apps\earphone\include\key_event_deal.h`定义对应的处理分支名，也是一个枚举值。`KEY_TENTH_CLICK,//十击处理分支`

`apps\earphone\board\br36\board_ac700n_demo.c`中的按键处理表中添加定义好的处理分支名

```c
/************************** KEY MSG****************************/
/*各个按键的消息设置，如果USER_CFG中设置了USE_CONFIG_KEY_SETTING为1，则会从配置文件读取对应的配置来填充改结构体*/
u8 key_table[KEY_NUM_MAX][KEY_EVENT_MAX] = {
    // SHORT                  LONG             HOLD                   UP                   DOUBLE          TRIPLE             四击              五击        六击            七击         八击         九击         十击     
    {KEY_MUSIC_PP,          KEY_POWEROFF,  KEY_POWEROFF_HOLD,        KEY_NULL,     KEY_CALL_LAST_NO,     KEY_OPEN_SIRI,    KEY_LOW_LANTECY,   KEY_NULL,    KEY_NULL,    KEY_DUT_MODE,  KEY_NULL,    KEY_NULL,   KEY_TENTH_CLICK},   //KEY_0
    {KEY_VOL_UP,            KEY_MUSIC_NEXT,    KEY_NULL,         KEY_NULL,          KEY_NULL,        KEY_NULL},   //KEY_1
    {KEY_VOL_DOWN,          KEY_MUSIC_PREV,  KEY_NULL,       KEY_NULL,          KEY_NULL,      KEY_NULL},   //KEY_2

    // 上滑               下滑          左滑               右滑
    {KEY_MUSIC_NEXT, KEY_MUSIC_PREV, KEY_NULL,           KEY_NULL,        KEY_NULL,             KEY_NULL},          //触摸按键滑动时的消息
};
```

这两个宏代表什么？

- `KEY_NUM_MAX`
  - 按键可以处理分支的最大数量？
- `KEY_EVENT_MAX`
  - 可以检测到的按键事件数量？

`apps\earphone\key_event_deal.c`中的`app_earphone_key_event_handler`添加处理分支的具体操作逻辑

```c
case KEY_TENTH_CLICK:
        //十击恢复出产设置
        //tone_play_index(IDEX_TONE_NORMAL, 1);//出包注释掉
        log_info("KEY_TENTH_CLICK");
        if(get_bt_connect_status() < BT_STATUS_CONNECTING){//不连接手机才能操作，状态枚举值44-42都不行
            user_send_cmd_prepare(USER_CTRL_DISCONNECTION_HCI,0,NULL); //双耳断开蓝牙连接
            user_send_cmd_prepare(USER_CTRL_DEL_ALL_REMOTE_INFO,0,NULL); //删除蓝牙所有配对信息
            //bt_tws_remove_pairs();  //解除配对，删除双耳TWS配对信息,挂脖不行。
            //ui_update_status(STATUS_FACTORY_RESET);//添加恢复出厂设置灯效以及利用灯效更新函数实现操作等，参数伊动XA91-7006F8
            sys_enter_soft_poweroff(NULL);//这个带提示音
            //power_set_soft_poweroff();//这个不带提示音
        }
        break;

case KEY_TENTH_CLICK:
        if(get_bt_connect_status() < BT_STATUS_CONNECTING){//不连接手机才能操作
            user_send_cmd_prepare(USER_CTRL_DISCONNECTION_HCI,0,NULL); //disconneted ihpone
            user_send_cmd_prepare(USER_CTRL_DEL_ALL_REMOTE_INFO,0,NULL); //disconneted ihpone
            bt_tws_remove_pairs();  
            ui_update_status(STATUS_FACTORY_RESET);
        }
        break;
```



# 是否读取配置工具的配置

`apps\earphone\user_cfg.c`使用宏控制`USE_CONFIG_KEY_SETTING`：

```c
#define USE_CONFIG_BIN_FILE                  0

#define USE_CONFIG_STATUS_SETTING            1                          //状态设置，提示音（不包含音量）以及蓝牙名
#define USE_CONFIG_AUDIO_SETTING             USE_CONFIG_BIN_FILE        //音频设置
#define USE_CONFIG_CHARGE_SETTING            USE_CONFIG_BIN_FILE        //充电设置
#define USE_CONFIG_KEY_SETTING               USE_CONFIG_BIN_FILE        //按键消息设置
#define USE_CONFIG_MIC_TYPE_SETTING          USE_CONFIG_BIN_FILE        //MIC类型设置
#define USE_CONFIG_LOWPOWER_V_SETTING        USE_CONFIG_BIN_FILE        //低电提示设置
#define USE_CONFIG_AUTO_OFF_SETTING          USE_CONFIG_BIN_FILE        //自动关机时间设置
#define USE_CONFIG_COMBINE_VOL_SETTING       1					        //联合音量读配置
```

**少部分读取配置工具的配置**

# 固定左右耳烧录

`apps\earphone\include\app_config.h`

```c
/* 声道确定方式选择 */
#define CONFIG_TWS_MASTER_AS_LEFT             0 //主机作为左耳
#define CONFIG_TWS_AS_LEFT_CHANNEL            1 //固定左耳
#define CONFIG_TWS_AS_RIGHT_CHANNEL           2 //固定右耳
#define CONFIG_TWS_LEFT_START_PAIR            3 //双击发起配对的耳机做左耳
#define CONFIG_TWS_RIGHT_START_PAIR           4 //双击发起配对的耳机做右耳
#define CONFIG_TWS_EXTERN_UP_AS_LEFT          5 //外部有上拉电阻作为左耳
#define CONFIG_TWS_EXTERN_DOWN_AS_LEFT        6 //外部有下拉电阻作为左耳
#define CONFIG_TWS_SECECT_BY_CHARGESTORE      7 //充电仓决定左右耳
#define CONFIG_TWS_CHANNEL_SELECT             CONFIG_TWS_AS_LEFT_CHANNEL //配对方式选择
```

# 识别芯片型号

`apps\earphone\board\br36\board_ac700n_demo_cfg.h`**公司通过左右声道区分。**

```c
/*DAC硬件上的连接方式,可选的配置：
    DAC_OUTPUT_MONO_L               单左声道差分
    DAC_OUTPUT_MONO_R               单右声道差分
    DAC_OUTPUT_LR                   双声道差分
*/
#define TCFG_AUDIO_DAC_CONNECT_MODE         DAC_OUTPUT_MONO_L //左声道为7006芯片
// #define TCFG_AUDIO_DAC_CONNECT_MODE         DAC_OUTPUT_MONO_R
// #define TCFG_AUDIO_DAC_CONNECT_MODE         DAC_OUTPUT_LR
```

# 充电参数配置，软件确认

`apps\earphone\board\br36\board_ac700n_demo_cfg.h`

**这是内置充电的参数位置，外置充电不知道。**

![image-20250527153142972](./其他开发记录.assets/image-20250527153142972.png)

# 实体ad按键机器使用io按键板子开打印

`apps\earphone\board\br36\board_ac700n_demo_cfg.h`

```c
//                                 UART配置                                        //
//*********************************************************************************//
#define TCFG_UART0_ENABLE					1//0//ENABLE_THIS_MOUDLE                     //串口打印模块使能
#define TCFG_UART0_RX_PORT					NO_CONFIG_PORT                         //串口接收脚配置（用于打印可以选择NO_CONFIG_PORT）
#define TCFG_UART0_TX_PORT  				IO_PORT_DP                             //串口发送脚配置
#define TCFG_UART0_BAUDRATE  				1000000                                //串口波特率配置
//*********************************************************************************//

//*********************************************************************************//
//                                 iokey 配置                                      //
//*********************************************************************************//
#define TCFG_IOKEY_ENABLE					1//0//ENABLE_THIS_MOUDLE //是否使能IO按键

#define TCFG_IOKEY_POWER_CONNECT_WAY		ONE_PORT_TO_LOW    //按键一端接低电平一端接IO
#define TCFG_IOKEY_POWER_ONE_PORT			IO_PORTB_01        //IO按键端口


//*********************************************************************************//
//                                 adkey 配置                                      //
//*********************************************************************************//
#define TCFG_ADKEY_ENABLE                   0//1//DISABLE_THIS_MOUDLE//是否使能AD按键
#define TCFG_ADKEY_PORT                     IO_PORTB_01//IO_PORTC_05//IO_PORT_DM         //AD按键端口(需要注意选择的IO口是否支持AD功能)

#define TCFG_ADKEY_AD_CHANNEL               AD_CH_PC5//AD_CH_DM
#define TCFG_ADKEY_EXTERN_UP_ENABLE         0//ENABLE_THIS_MOUDLE //是否使用外部上拉
```

`apps\earphone\include\app_config.h`

```c
/*
 * 系统打印总开关
 */

#define LIB_DEBUG    1//0
#define CONFIG_DEBUG_LIB(x)         (x & LIB_DEBUG)

#define CONFIG_DEBUG_ENABLE

#ifndef CONFIG_DEBUG_ENABLE
//#define CONFIG_DEBUG_LITE_ENABLE  //轻量级打印开关, 默认关闭
#endif
```

`apps\earphone\board\br36\board_ac700n_demo_global_build_cfg.h`

```c
#define CONFIG_LP_TOUCH_KEY_EN					0		//配置是否使用内置触摸
```

- 使用IO按键看打印的话

# 提示音

## 内部提示音引用路径位置

`apps\earphone\include\tone_player.h`

```c
#define TONE_LOW_LATENCY_IN     	DEFAULT_SINE_TONE(SINE_WTONE_LOW_LATENRY_IN)//SDFILE_RES_ROOT_PATH"tone/game_mode.*"//DEFAULT_SINE_TONE(SINE_WTONE_LOW_LATENRY_IN)
#define TONE_LOW_LATENCY_OUT    	SDFILE_RES_ROOT_PATH"tone/music_mode.*"//DEFAULT_SINE_TONE(SINE_WTONE_LOW_LATENRY_OUT)
```

- 使用内部和弦音或者引用外部提示音配置

## 提示音不同步

以工程区分机器左右耳的话，如果代码层面没有查出问题的话。而烧录同一个工程又可以同步时。

可以`AC897N_AD697N_earphone_release_V2.3.0-left\cpu\br30\tools\earphone\standard`查看tone.cfg文件大小不一样的话，需要同步替换一下。

其中一个工程修改过提示音的音质的话，两边音质不一样，提示音文件解析速度不一样就导致了双耳提示音不同步。

## 两个提示音函数

了解两者的使用方式

### `tone_play_index(TONE_LOW_LATENCY_IN, 1);`

```c
/*
 *index:提示音索引
 *preemption:抢断标志
 */
__BANK_TONE_ENTRY
int tone_play_index(u8 index, u8 preemption)
{
    printf("tone_play_index:%d,preemption:%d", index, preemption);
    if (index >= IDEX_TONE_NONE) {
        return 0;
    }
    return tone_play(tone_index[index], preemption);
}
```

这意味着`apps\earphone\include\tone_player.h`需要定义类似的枚举变量`IDEX_TONE_NONE`，值不能超过`IDEX_TONE_NONE`，也就是添加在它的前面。

`tone_play_index(TONE_LOW_LATENCY_OUT, 1);`直接使用的话。`TONE_LOW_LATENCY_OUT`这是一个宏（提示音引用路径），可能过不了那个if判断而出错（**经过验证**）。

#### 疑问

`apps\earphone\board\br36\board_ac700n_demo.c`中定义的提示音又是怎么使用呢？

`STATUS_CONFIG status_config`

```c
	//提示音设置
    .tone = {
        .charge_start  = IDEX_TONE_NONE,
        .charge_full   = IDEX_TONE_NONE,
        .power_on      = IDEX_TONE_POWER_ON,
        .power_off     = IDEX_TONE_POWER_OFF,
        .lowpower      = IDEX_TONE_LOW_POWER,
        .max_vol       = IDEX_TONE_MAX_VOL,
        .phone_in      = IDEX_TONE_NONE,
        .phone_out     = IDEX_TONE_NONE,
        .phone_activ   = IDEX_TONE_NONE,
        .bt_init_ok    = IDEX_TONE_BT_MODE,
        .bt_connect_ok = IDEX_TONE_BT_CONN,
        .bt_disconnect = IDEX_TONE_BT_DISCONN,
        .tws_connect_ok   = IDEX_TONE_TWS_CONN,
        .tws_disconnect   = IDEX_TONE_TWS_DISCONN,
    }
```



### `tone_play(TONE_LOW_LATENCY_IN, 1);`

提示音的底层播放函数是，可以直接传入提示音的宏定义（引用路径）

## 外部提示音的宏定义怎么来的？

使用配置工具添加并保存提示音后，也没有宏定义。难道是手动写？工具只是转换以及保存到`tone.cfg`以及`cfg_tool.bin`

如果是可视化的话，自动生成。如果是配置工具的话，就是自己写。

# DAC硬件功放与DAC解码以及提示音播放的先后关系

## 典型的信号处理流程

**1. 系统初始化阶段**

- 硬件功放电路上电
- DAC芯片初始化和配置
- 音频子系统驱动加载

**2. 音频播放准备阶段**

- DAC解码器准备就绪
- 功放电路进入工作状态
- 音量控制和增益设置

**3. 实际播放阶段**

- 数字音频数据输入DAC
- DAC执行数模转换
- 模拟信号送入功放放大
- 扬声器输出声音

## 具体的时序关系

**DAC解码 → 功放放大 → 声音输出**

这是信号流的基本路径。数字信号必须先经过DAC转换为模拟信号，然后才能被功放电路放大驱动扬声器。

**提示音播放的时机**

- 通常在系统启动完成后播放
- **需要DAC和功放都已就绪**
- 有些系统会在功放稳定后延迟几百毫秒再播放提示音，避免"爆音"

## 设计考虑

现代音频系统通常采用软启动机制，确保各组件按正确顺序启动，避免在DAC或功放未就绪时播放音频造成的噪声或损坏。

## 关机无提示音分析

`apps\earphone\earphone.c`

```c
#if  DAC_PA_EN
void user_pa_deal(u8 enable){
    // u8 pa_enable = DAC_PA_UMUTE;
    gpio_set_pull_up(DAC_PA_PORT, enable);
    gpio_set_pull_down(DAC_PA_PORT, !enable);
    //   gpio_set_die(DAC_PA_PORT, 1);
    gpio_set_direction(DAC_PA_PORT, 0);
    gpio_set_output_value(DAC_PA_PORT, enable);

}

void audio_dac_power_state(u8 state)
{
    switch(state){
       // case DAC_ANALOG_OPEN_FINISH://开dac前
       case DAC_ANALOG_OPEN_PREPARE://开dac前
            user_pa_deal(1);
            break;
        case DAC_ANALOG_CLOSE_PREPARE://关dac后
       //case DAC_ANALOG_CLOSE_PREPARE://关dac前
            user_pa_deal(0);
            break;
    }
}
#endif


void sys_enter_soft_poweroff(void *priv)
{
    int detach_phone = 1;
    struct sys_event clear_key_event = {.type =  SYS_KEY_EVENT, .arg = "key"};

    log_info("%s, %d\n", __func__, (int)priv);

// #if  DAC_PA_EN
//     user_pa_deal(1);
// #endif


    if (app_var.goto_poweroff_flag) {
        return;
    }

    // gpio_set_pull_up(DAC_PA_PORT, 0);
    // gpio_set_pull_down(DAC_PA_PORT, 1);
    // gpio_set_direction(DAC_PA_PORT, 0);
    // gpio_set_output_value(DAC_PA_PORT, 0);
```

**核心问题：PA功放过早关闭**

在你注释掉的代码中：

```c
// #if  DAC_PA_EN
//     user_pa_deal(1);  // 这里实际是关闭PA功放
// #endif
```

虽然参数是1，但从`user_pa_deal()`函数实现来看，这里实际是**开启PA功放**，而不是关闭。但在关机流程的开始就调用这个函数是有问题的。

### 时序问题分析

**正常的关机音频播放流程应该是：**

1. 开始关机流程
2. 播放关机提示音（需要DAC + PA功放都工作）
3. 提示音播放完成后，关闭PA功放
4. 关闭DAC
5. 完全断电

**你原来的代码问题：**

- 在关机流程最开始就操作了PA功放
- 同时注释掉的GPIO操作也在过早地拉低PA控制信号
- 这导致提示音还没播放，功放就已经被关闭或干扰

### 解决方案建议

1. 移除关机开始时的PA操作
   - 让PA功放保持开启状态，直到提示音播放完成
2. 在适当的时机关闭PA
   - 应该在`wait_exit_btstack_flag`回调或者音频播放完成回调中关闭PA
   - 而不是在关机流程开始时就关闭
3. 检查DAC关闭时序
   - 确保`audio_dac_power_state()`中的`DAC_ANALOG_CLOSE_PREPARE`在提示音播放完成后才被调用

你注释掉这些代码后关机提示音能正常播放，说明问题确实是PA功放被过早关闭导致的。建议将PA关闭操作移到关机流程的最后阶段。

# V300以前的所有可视化版本可能问题

**如果检测到提示音 就不跑自动关机流程  自动关机要放到前边**

# ANC降噪命名方式

**命名方式把降噪参数的校验码加进去，合降噪的必须这样命名   把这个加进去 ，避免出现降噪参数对不上 或者改的次数多了找不到的问题。**

![image-20250530173318718](./其他开发记录.assets/image-20250530173318718.png)

# 是否支持智能仓

`sdk\apps\earphone\board\br36\board_ac700n_demo_cfg.h`

![image-20250605155448316](./其他开发记录.assets/image-20250605155448316.png)

`sdk\apps\earphone\board\br36\board_ac700n_demo.c`

![image-20250605155507231](./其他开发记录.assets/image-20250605155507231.png)

**暂时不清楚为什么**、

# 非TWS模式下下区分左右耳

```c
case ONE_KEY_CTL_NEXT_PREV:
        if (channel == 'L') {
            user_send_cmd_prepare(USER_CTRL_AVCTP_OPID_PREV, 0, NULL);
        } else if (channel == 'R') {
            user_send_cmd_prepare(USER_CTRL_AVCTP_OPID_NEXT, 0, NULL);
        } else {
//************      单耳使用情况    具体视客户UI而定    ************************/
#if (CONFIG_TWS_CHANNEL_SELECT == CONFIG_TWS_AS_LEFT_CHANNEL)
         user_send_cmd_prepare(USER_CTRL_AVCTP_OPID_PREV, 0, NULL); /*  软件固定左耳*/
#elif(CONFIG_TWS_CHANNEL_SELECT == CONFIG_TWS_AS_RIGHT_CHANNEL)
         user_send_cmd_prepare(USER_CTRL_AVCTP_OPID_NEXT, 0, NULL); /*  软件固定右耳*/
#else   
            user_send_cmd_prepare(USER_CTRL_AVCTP_OPID_NEXT, 0, NULL); /*  左右耳共软件*/
#endif   
//*****************************************************************************/  单耳使用情况选择，可固定
        }
        break;
```

