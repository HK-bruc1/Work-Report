# 提示音音量增强函数使用文档

## 概述

在SDK中直接封装了一个提示音音量临时增强函数，可以在整个SDK中调用，实现提示音音量的临时增大和自动恢复功能。

## 核心函数

### `app_audio_tone_volume_boost()`

```c
int app_audio_tone_volume_boost(u8 tone_type, s16 volume);
```

**功能描述：**
临时设置提示音音量并自动恢复（3秒后自动恢复到原始音量）

**参数说明：**
- `tone_type`: 提示音类型
  - `0`: 系统提示音 (对应可视化工具中的 Vol_SysTone)
  - `1`: 按键提示音 (对应可视化工具中的 Vol_SysKTone)
- `volume`: 目标音量值
  - 范围：`0` ~ `app_audio_get_max_volume()`
  - 超出范围会自动限制

**返回值：**
- `0`: 成功
- `-1`: 失败（定时器创建失败）

## 追溯路径验证

```
可视化工具修改 (系统模式.x6flow)
    ↓ id_1690535811640_0 (Vol_SysTone), id_1676801188975_0 (Vol_SysKTone)
配置文件解析 (volume_ioc_get_cfg)
    ↓ user_cfg.c:261-262
系统变量赋值
    ↓ app_var.wtone_volume, app_var.ktone_volume (user_cfg.c:277-278)
SDK封装函数
    ↓ app_audio_tone_volume_boost() (audio_volume_mixer.c:1632)
底层音量控制
    ↓ app_audio_set_volume() (audio_volume_mixer.c:1658)
硬件输出
    ↓ audio_dac_set_volume() (audio_volume_mixer.c:1283)
```

## 使用示例

### 1. 低电量警告音量增强
```c
void low_battery_warning(void) {
    // 系统提示音增强到最大音量
    app_audio_tone_volume_boost(0, app_audio_get_max_volume());

    // 播放低电量提示音
    tone_play(TONE_LOW_BATTERY);

    // 3秒后自动恢复原始音量，无需手动处理
}
```

### 2. 按键音增强
```c
void key_press_feedback(void) {
    // 按键提示音增强到80%音量
    s16 boost_vol = (app_audio_get_max_volume() * 80) / 100;
    app_audio_tone_volume_boost(1, boost_vol);

    // 播放按键音
    tone_play(TONE_KEY_PRESS);
}
```

### 3. 重要通知增强
```c
void important_notification(void) {
    // 系统提示音增强到90%音量
    s16 boost_vol = (app_audio_get_max_volume() * 90) / 100;
    app_audio_tone_volume_boost(0, boost_vol);

    // 播放重要通知音
    tone_play(TONE_NOTIFICATION);
}
```

### 4. 蓝牙连接状态增强
```c
void bt_connected_notification(void) {
    // 系统提示音增强到70%音量
    s16 boost_vol = (app_audio_get_max_volume() * 70) / 100;
    app_audio_tone_volume_boost(0, boost_vol);

    // 播放连接成功提示音
    tone_play(TONE_BT_CONNECTED);
}
```

## 使用说明

### 1. 包含头文件
```c
#include "audio_config.h"  // 函数声明在此文件中
```

### 2. 自动恢复机制
- 函数调用后会启动3秒定时器
- 3秒后自动恢复到调用前的原始音量
- 无需手动调用恢复函数

### 3. 重复调用处理
- 如果在恢复前再次调用，会：
  - 取消之前的定时器
  - 重新设置新的音量
  - 重新启动3秒定时器

### 4. 音量范围保护
- 自动限制音量值在合法范围内
- 超出最大值时设置为最大音量
- 小于0时设置为0

## 实现位置

**声明位置：** `SDK/audio/cpu/br56/audio_config.h:229`
```c
int app_audio_tone_volume_boost(u8 tone_type, s16 volume);
```

**实现位置：** `SDK/audio/common/audio_volume_mixer.c:1632`

## 调试信息

函数执行时会输出调试信息：

```
[TONE_BOOST] 系统提示音音量增强: 12 -> 20
[TONE_BOOST] 音量自动恢复: wtone=12, ktone=12
```

## 注意事项

1. **定时器资源**：使用系统定时器，如果定时器资源不足可能创建失败
2. **并发安全**：函数内部处理了重复调用的情况
3. **系统关闭**：系统关闭时定时器会自动清理
4. **音量类型**：
   - `tone_type=0`: 影响系统提示音（如低电量、连接状态等）
   - `tone_type=1`: 影响按键提示音（如按键反馈音）

## 快速开始

最简单的使用方式：

```c
// 增强系统提示音到最大音量
app_audio_tone_volume_boost(0, app_audio_get_max_volume());

// 增强按键提示音到最大音量
app_audio_tone_volume_boost(1, app_audio_get_max_volume());
```

这样就可以在播放提示音前临时增大音量，3秒后自动恢复，无需任何额外处理。



```
audio\cpu\br56\audio_config.h

/*
*********************************************************************
*          app_audio_tone_volume_boost
* Description: 临时设置提示音音量并自动恢复
* Arguments  : tone_type   提示音类型 (0:系统提示音, 1:按键提示音)
*              volume      目标音量值 (0-最大音量值)
* Return	 : 0成功, -1失败
* Note(s)    : 会保存原始音量，播放完提示音后自动恢复
*********************************************************************
*/
int app_audio_tone_volume_boost(u8 tone_type, s16 volume);

audio\common\audio_volume_mixer.c
// 提示音音量临时增强功能
static struct {
    u8 is_active;              // 是否处于增强状态
    s16 original_wtone_volume; // 原始系统提示音音量
    s16 original_ktone_volume; // 原始按键提示音音量
    int timer_id;              // 自动恢复定时器ID
} tone_boost_state = {0, -1, -1, 0};

// 定时器回调函数 - 自动恢复音量
static void tone_volume_restore_callback(void *priv)
{
    if (tone_boost_state.is_active) {
        // 恢复原始音量
        app_audio_set_volume(APP_AUDIO_STATE_WTONE, tone_boost_state.original_wtone_volume, 1);
        app_var.ktone_volume = tone_boost_state.original_ktone_volume;

        printf("[TONE_BOOST] 音量自动恢复: wtone=%d, ktone=%d\n",
               tone_boost_state.original_wtone_volume, tone_boost_state.original_ktone_volume);

        // 重置状态
        tone_boost_state.is_active = 0;
        tone_boost_state.original_wtone_volume = -1;
        tone_boost_state.original_ktone_volume = -1;
        tone_boost_state.timer_id = 0;
    }
}

/*
*********************************************************************
*          app_audio_tone_volume_boost
* Description: 临时设置提示音音量并自动恢复
* Arguments  : tone_type   提示音类型 (0:系统提示音, 1:按键提示音)
*              volume      目标音量值 (0-最大音量值)
* Return	 : 0成功, -1失败
* Note(s)    : 会保存原始音量，3秒后自动恢复
*********************************************************************
*/
int app_audio_tone_volume_boost(u8 tone_type, s16 volume)
{
    // 如果已经处于增强状态，先清理
    if (tone_boost_state.is_active && tone_boost_state.timer_id) {
        sys_timer_del(tone_boost_state.timer_id);
        tone_boost_state.timer_id = 0;
    }

    // 保存当前音量
    if (!tone_boost_state.is_active) {
        tone_boost_state.original_wtone_volume = app_var.wtone_volume;
        tone_boost_state.original_ktone_volume = app_var.ktone_volume;
    }

    // 限制音量范围
    s16 max_vol = app_audio_get_max_volume();
    if (volume > max_vol) {
        volume = max_vol;
    }
    if (volume < 0) {
        volume = 0;
    }

    // 设置提示音音量
    if (tone_type == 0) {
        // 系统提示音
        app_audio_set_volume(APP_AUDIO_STATE_WTONE, volume, 1);
        printf("[TONE_BOOST] 系统提示音音量增强: %d -> %d\n", tone_boost_state.original_wtone_volume, volume);
    } else {
        // 按键提示音
        app_var.ktone_volume = volume;
        printf("[TONE_BOOST] 按键提示音音量增强: %d -> %d\n", tone_boost_state.original_ktone_volume, volume);
    }

    // 设置3秒后自动恢复
    tone_boost_state.timer_id = sys_timer_add(NULL, tone_volume_restore_callback, 3000);
    if (tone_boost_state.timer_id == 0) {
        printf("[TONE_BOOST] 错误: 创建自动恢复定时器失败\n");
        return -1;
    }

    tone_boost_state.is_active = 1;
    return 0;
}
```

