# 彩屏仓通信协议架构分析

## 系统架构概述

本系统实现了TWS耳机与彩屏充电仓之间的完整通信方案，通过两阶段通信机制：**串口初始握手 + BLE数据交互**，具备高度的模块化设计和出色的移植性。

## 架构设计特点

### 1. 高内聚低耦合设计
- **内部闭环处理**: 彩屏仓模块内部完成数据传输、协议解析、AES加密等核心功能
- **外部接口最小化**: 仅暴露4个关键接口供外部调用
- **功能封装完整**: BLE协议栈集成、缓冲区管理、错误处理全部内置

### 2. 分层架构设计（新模块化架构）

```
┌─────────────────────────────────────────────────────────────┐
│                    外部系统集成层                             │
│  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐│
│  │  app_main.c     │  │ vol_sync.c      │  │ app_testbox.c   ││
│  │ sbox_app_init() │  │sbox_cb_func.*() │  │data_deal()      ││
│  └─────────────────┘  └─────────────────┘  └─────────────────┘│
└─────────────────┬───────────────────────────────────────────┘
                  │ 4个核心外部接口
┌─────────────────┼───────────────────────────────────────────┐
│                 ▼          彩屏仓模块内部                     │
│ ┌─────────────────────────────────────────────────────────┐ │
│ │              sbox_user_app.c/h                          │ │
│ │           业务应用层 (对外接口层)                        │ │
│ │  • 回调函数集合(sbox_cb_func)                           │ │
│ │  • 业务逻辑实现(状态同步、控制处理)                     │ │
│ │  • 系统事件响应                                         │ │
│ └─────────────────┬───────────────────────────────────────┘ │
│                   │                                         │
│ ┌─────────────────▼───────────────────────────────────────┐ │
│ │              sbox_protocol.c/h                          │ │
│ │             BLE协议通信层                               │ │
│ │  • BLE Profile管理                                      │ │
│ │  • 连接状态管理                                         │ │
│ │  • 广播参数配置                                         │ │
│ └─────────────────┬───────────────────────────────────────┘ │
│                   │                                         │
│ ┌─────────────────▼───────────────────────────────────────┐ │
│ │                模块化功能层 (替代sbox_core_code.c)       │ │
│ │  ┌─────────────────┐ ┌─────────────────┐ ┌──────────────┐ │ │
│ │  │ edr_hid_user.c  │ │user_video_ctr.c │ │sbox_eq_switch│ │ │
│ │  │   HID通信专员   │ │  视频控制专员   │ │   EQ音效专员 │ │ │
│ │  │• Android/iOS适配│ │• 抖音手势控制   │ │• 动态EQ调节  │ │ │
│ │  │• HID描述符管理  │ │• 相机拍照控制   │ │• 多频段处理  │ │ │
│ │  │• TWS通道同步    │ │• 坐标校准存储   │ │• 音频流集成  │ │ │
│ │  └─────────────────┘ └─────────────────┘ └──────────────┘ │ │
│ │  ┌─────────────────┐ ┌─────────────────────────────────────┐ │ │
│ │  │sbox_connect_    │ │         lib_esbox.a                 │ │ │
│ │  │emitter.c        │ │      核心算法静态库                 │ │ │
│ │  │连接管理专员     │ │  • AES128加密解密算法               │ │ │
│ │  │• 设备地址管理   │ │  • 协议数据包编解码引擎             │ │ │
│ │  │• TWS信息同步    │ │  • 校验算法和错误检测               │ │ │
│ │  │• 连接状态恢复   │ │  • 底层通信协议栈                   │ │ │
│ │  └─────────────────┘ └─────────────────────────────────────┘ │ │
│ └─────────────────────────────────────────────────────────┘ │
│                   │                                         │
│ ┌─────────────────▼───────────────────────────────────────┐ │
│ │          sbox_core_config.c/h                           │ │
│ │           底层适配配置层                                 │ │
│ │  • BLE发送接口适配                                      │ │
│ │  • 数据保护机制(CBUF)                                   │ │
│ │  • 平台兼容性配置                                       │ │
│ └─────────────────┬───────────────────────────────────────┘ │
│                   │                                         │
│ ┌─────────────────▼───────────────────────────────────────┐ │
│ │            sbox_uart_app.c                              │ │
│ │             串口通信层                                   │ │
│ │  • Mac地址交换                                          │ │
│ │  • 初始握手协议                                         │ │
│ └─────────────────┬───────────────────────────────────────┘ │
└───────────────────┼─────────────────────────────────────────┘
                    │
          ┌─────────▼─────────┐
          │   SDK底层接口     │
          │ • BLE协议栈       │
          │ • UART驱动        │
          │ • 系统服务        │
          └───────────────────┘
```

**架构变化说明**：
1. **原sbox_core_code.c**被移除，功能分解为4个专门模块+1个静态库
2. **模块化设计**：每个模块专注特定功能域，职责更加清晰
3. **静态库保护**：核心算法封装在lib_esbox.a中，提升安全性
4. **并行开发支持**：不同模块可由不同团队并行开发维护
5. **功能扩展便利**：新增功能只需修改对应专门模块

## 核心文件架构分析

### 1. sbox_user_app.c/h - 业务应用层 (对外接口层)

- **角色**: 彩屏仓模块与外部系统的唯一接口层

- **特点**: 向上提供服务，向下调用协议层

**对外提供的核心接口**:

```c
// 系统初始化接口
void sbox_app_init(void);                        // 缓冲区和基础设施初始化

// 串口数据处理接口
int user_app_chargestore_data_deal(u8 *buf, u8 len);  // 处理UART通信

// 回调函数集合 (外部可直接调用)
extern struct s_box_app_cb sbox_cb_func;
    - sbox_sync_volume_info()      // 同步音量状态
    - sbox_sync_all_info()         // 同步所有状态
    - sbox_sync_battery_info()     // 同步电量信息
    - sbox_control_music_state()   // 音乐控制处理
    // ... 其他业务功能
```

**内部功能**:
- 实现所有业务逻辑函数 (custom_sync_*, custom_control_*)
- 协议命令分发和处理
- 系统事件响应和状态管理
- 调用下层协议接口进行实际通信

### 2. sbox_protocol.c/h - BLE协议通信层 (内部核心)

**角色**: BLE通信的核心实现，完全内部调用
**特点**: 不对外暴露，由user_app层调用

**核心功能**:
```c
// 协议栈管理 (内部调用)
void sbox_demo_all_init(void);           // 协议栈初始化
int custom_demo_ble_send(u8 *data, u32 len);  // BLE数据发送
int custom_demo_adv_enable(u8 enable);   // 广播控制
```

**内部实现**:
- BLE Profile注册和管理 (自定义UUID: ae00)
- 连接状态监控和参数优化
- 数据传输和重发机制
- 与底层SDK的BLE接口交互

### 3. sbox_core_code.c - 协议解析引擎 (内部核心)

**角色**: 数据包处理的核心引擎，完全内部调用
**特点**: 纯算法实现，不涉及外部接口

**核心功能**:
- 协议数据包编码/解码 (5Aa5头格式)
- AES128-ECB加密/解密处理
- 命令解析和数据校验
- 错误检测和异常处理

### 4. sbox_core_config.c/h - 底层适配配置层 (内部核心)

**角色**: 平台适配和配置管理，完全内部调用
**特点**: 封装平台差异，提供统一接口

**核心功能**:
```c
// BLE发送接口适配 (内部使用)
int custom_send_data_to_box(u8 *data, u16 len) {
    return app_ble_att_send_data(sbox_demo_ble_hdl, ...);  // 调用SDK接口
}
```

**内部实现**:
- CBUF环形缓冲区数据保护机制
- BLE发送接口的SDK适配封装
- 调试输出和错误处理配置
- 缓冲区大小和安全参数配置

**关键配置参数**:
```c
#define SBOX_UART_FUNCTION          1    // 串口通信功能开关
#define SBOX_OPEN_DATA_PROTECT      1    // CBUF数据保护开关
#define SBOX_CORE_DEBUG            (BIT(0)) // 调试信息输出级别
```

### 5. sbox_uart_app.c - 串口通信层 (半内部)

**角色**: 串口通信处理，部分功能对外暴露
**特点**: 主要内部调用，一个函数供外部使用

**对外接口**:
```c
int user_app_chargestore_data_deal(u8 *buf, u8 len);  // 被app_testbox.c调用
```

**内部功能**:
- Mac地址封装和发送
- 串口协议格式处理 (0xAA头格式)
- 与彩屏仓982芯片的初始握手

**配置控制**:
```c
#if SBOX_UART_FUNCTION  // 串口功能可通过宏开关控制
// 串口相关代码
#endif
```

## 外部集成点分析

### 系统集成的4个关键调用点

1. **app_main.c:386-387** - 系统启动初始化 (**无条件编译**)
   ```c
   extern void sbox_app_init(void);
   sbox_app_init();  // 缓冲区等基础设施初始化 (始终执行)
   ```

2. **multi_protocol_main.c:460-462** - 协议栈初始化 (**有条件编译**)
   ```c
   #if (THIRD_PARTY_PROTOCOLS_SEL & JL_SBOX_EN)
   sbox_demo_all_init();  // BLE协议栈初始化 (仅在彩屏仓启用时)
   #endif
   ```

3. **vol_sync.c:117** - 业务状态同步示例
   
   ```c
   sbox_cb_func.sbox_sync_volume_info();  // 音量变化时自动同步
   ```
   
4. **app_testbox.c:534** - 串口数据处理
   
   ```c
   user_app_chargestore_data_deal(buf,len);  // 处理串口接收数据
   ```

## 移植性优势

### 1. SDK接口依赖分析
**BLE相关接口**:

- `app_ble_att_send_data()` - BLE数据发送核心接口
- `ble_att_server_set_update_send()` - BLE服务器更新配置
- `att_server_register()` - ATT服务注册

**系统服务接口**:
- `sys_timeout_add()` - 定时器服务
- `cbuf_*()` - 环形缓冲区操作接口
- `put_buf()`, `printf()` - 调试输出接口

**串口驱动接口**:

- 依赖具体平台的串口发送接口 (需要适配)

**外部调用**: 只需集成4个函数调用点

### 2. 模块化封装
- **完整功能封装**: 所有通信逻辑都在模块内部完成
- **配置集中管理**: 平台差异通过config层统一处理
- **错误处理完备**: 内置重发、校验、异常恢复机制

### 3. 扩展性设计
- **回调函数机制**: 业务功能通过回调函数灵活扩展
- **命令标准化**: 新增功能只需添加命令码和对应处理函数
- **协议版本兼容**: 支持协议升级和向后兼容

## 重要发现和注意事项

### 1. 条件编译差异
- `sbox_app_init()` **无条件编译保护**，始终会被调用（可能导致未启用时的资源占用）
- `sbox_demo_all_init()` **有条件编译保护**，只在彩屏仓启用时才调用
- 串口功能通过 `SBOX_UART_FUNCTION` 宏可单独控制

### 2. 内部配置灵活性
模块内部提供了丰富的配置选项，支持功能的精细化控制：
- 数据保护机制可选
- 调试信息输出可配置
- 串口通信功能可独立开关

### 3. 架构设计优势
这种架构设计使得彩屏仓通信模块具备了**"拿来即用"**的特性，移植到其他平台时只需要适配少数几个底层接口，大大降低了集成成本和开发难度。但需要注意无条件初始化可能带来的资源消耗问题。

## 调用闭环性分析

### 初始化流程（两阶段机制）
```
系统启动 → app_main.c:sbox_app_init() → 缓冲区初始化
         ↓
蓝牙初始化 → multi_protocol_main.c:sbox_demo_all_init() → BLE协议栈 → 广播启动
```

### 入仓连接流程
```
耳机入仓 → UART发送Mac地址 → 彩屏仓获取地址 → 开始BLE扫描 → 建立BLE连接 → 数据通道就绪
```

### 数据同步流程
```
状态变化 → 调用sync函数 → 打包协议数据 → AES加密 → BLE发送 → 彩屏仓显示更新
```

### 控制命令流程
```
彩屏仓操作 → BLE发送控制命令 → 协议解析 → AES解密 → 命令分发 → 业务处理 → 状态反馈
```

### 核心API接口

#### 对外接口（移植时需要调用）
```c
// 1. 初始化接口
void custom_demo_all_init(void);           // 模块初始化
void custom_demo_all_exit(void);           // 模块退出

// 2. 控制接口
int custom_demo_adv_enable(u8 enable);     // BLE广播控制
int custom_demo_ble_send(u8 *data, u32 len); // BLE数据发送
int custom_demo_spp_send(u8 *data, u32 len); // SPP数据发送

// 3. 状态同步接口
void custom_sync_all_info_to_box(void);           // 同步所有信息
void custom_sync_bt_connect_state(u8 value);      // 同步BT连接状态
void custom_sync_ble_connect_state(u8 value);     // 同步BLE连接状态
void custom_sync_vbat_percent_state(void);        // 同步电量信息
void custom_sync_volume_state(void);              // 同步音量状态
void custom_sync_eq_info_to_box(void);           // 同步EQ信息
void custom_sync_anc_info_to_box(void);          // 同步ANC信息

// 4. UART通信接口
void Send_Mac(u8 event, u8 *addr, u8 len);       // 发送Mac地址
```

## 移植性分析

### 高移植性设计特点

#### 1. 模块化设计
- **清晰分层**: 协议层、配置层、应用层分离
- **接口统一**: 通过回调函数集合统一业务接口
- **配置集中**: 所有配置项集中在config文件中

#### 2. 平台适配性
- **配置开关**: 通过JL_SBOX_EN和SBOX_UART_FUNCTION控制功能开启
- **接口抽象**: BLE发送接口可根据不同协议栈适配
- **缓冲区配置**: 可根据平台资源调整缓冲区大小

#### 3. 业务解耦
- **回调机制**: 业务功能通过s_box_app_cb结构体回调实现
- **命令标准化**: 使用统一的命令码定义，易于扩展
- **状态管理**: 通过sbox_state_info统一管理状态信息

### 移植步骤指南

#### 第1步：基础配置
```c
// 在app_config.h中启用功能
#define JL_SBOX_EN             (1 << 31)
#define THIRD_PARTY_PROTOCOLS_SEL  (JL_SBOX_EN)

// 配置功能选项
#define SBOX_UART_FUNCTION     1    // 启用串口功能
#define SBOX_OPEN_DATA_PROTECT 1    // 启用数据保护
```

#### 第2步：适配BLE接口
```c
// 修改sbox_core_config.c中的发送接口
int custom_send_data_to_box(u8 *data, u16 len)
{
    // 适配具体平台的BLE发送接口
    return platform_ble_send(data, len);
}
```

#### 第3步：适配UART接口
```c
// 修改sbox_uart_app.c中的串口发送接口
void Send_Mac(u8 event, u8 *addr, u8 len)
{
    // 适配具体平台的串口发送接口
    platform_uart_send(data, len);
}
```

#### 第4步：集成业务逻辑
```c
// 主程序两阶段初始化 (app_main.c:386-387)
void app_main(void)
{
    // 系统初始化...

    extern void sbox_app_init(void);
    sbox_app_init();  // 阶段1：缓冲区等基础设施初始化

    // 其他初始化...
    // 蓝牙初始化时会调用 multi_protocol_main.c:461
    // 自动执行 sbox_demo_all_init(); // 阶段2：协议初始化
}

// 系统集成示例 (vol_sync.c:117)
void app_audio_set_volume_down(void)
{
    // 音量调整逻辑...
    app_audio_set_volume_def_state(0);
    sbox_cb_func.sbox_sync_volume_info();  // 自动同步到彩屏仓
}
```

### 关键移植点

#### 1. 系统集成适配
- **初始化序列**: 确保两阶段初始化正确调用
  - `app_main.c` 中调用 `sbox_app_init()`
  - `multi_protocol_main.c` 中自动调用 `sbox_demo_all_init()`
- **第三方协议管理**: 确保在 `multi_protocol_main.c` 中正确集成
- **配置开关**: 在 `app_config.h` 中正确配置 `JL_SBOX_EN`

#### 2. BLE协议栈适配
- **Profile注册**: 需要适配目标平台的BLE Profile注册接口
- **特征值Handle**: 可能需要调整BLE特征值的Handle定义
- **发送接口**: 适配 `sbox_core_config.c:35-42` 中的BLE发送函数
- **连接参数**: 根据平台特性调整BLE连接参数

#### 3. 外设接口适配
- **UART驱动**: 适配 `sbox_uart_app.c:47` 中的 `chargestore_api_write`
- **系统资源**: 根据RAM大小调整缓冲区配置 `SBOX_TR_BUF_LEN`
- **调试接口**: 适配 `put_buf()` 等调试输出接口

#### 4. 业务逻辑集成
- **状态同步点**: 在系统相关模块中添加彩屏仓同步调用
- **回调函数**: 根据需要实现 `s_box_app_cb` 结构体中的回调函数
- **TWS同步**: 如需要TWS功能，需要集成相关的同步机制

## 技术特点总结

### 优势
1. **高度模块化**: 各层职责清晰，便于理解和维护
2. **强移植性**: 接口标准化，适配工作量小
3. **安全性好**: AES加密传输，协议校验完善
4. **稳定性高**: 数据保护机制，错误处理完善
5. **易于扩展**: 命令码标准化，新功能易于添加

### 应用场景
- TWS耳机与智能充电仓的交互
- 耳机状态实时显示和控制
- 充电仓作为耳机功能扩展终端
- 多设备协同控制场景

# 彩屏仓使能原理

## 位运算使能模块原理分析

### 位运算条件编译机制

经过对SDK代码的深入分析，这种条件编译方式是基于**位掩码(Bit Mask)**的模块使能机制，原理如下：

#### 1. 基本原理
```c
// 每个协议都分配一个独立的位
#define RCSP_MODE_EN             (1 << 0)   // 第0位：0x00000001
#define TRANS_DATA_EN            (1 << 1)   // 第1位：0x00000002
#define LL_SYNC_EN               (1 << 2)   // 第2位：0x00000004
#define TUYA_DEMO_EN             (1 << 3)   // 第3位：0x00000008
#define ANCS_CLIENT_EN           (1 << 4)   // 第4位：0x00000010
//...
#define JL_SBOX_EN               (1 << 31)  // 第31位：0x80000000

// 使用按位与(&)运算检测模块是否启用
#if (THIRD_PARTY_PROTOCOLS_SEL & JL_SBOX_EN)
// 彩屏仓相关代码只有在 JL_SBOX_EN 位被设置时才会编译
#endif
```

#### 2. 工作流程

**步骤1：位定义** (`app_config.h:79`)

- 每个第三方协议分配一个32位整数中的一个位
- `JL_SBOX_EN`占用第31位，值为 `0x80000000`

**步骤2：配置选择** (`app_config.h:82-87`)

```c
#if TCFG_THIRD_PARTY_PROTOCOLS_ENABLE
#define THIRD_PARTY_PROTOCOLS_SEL  TCFG_THIRD_PARTY_PROTOCOLS_SEL
#else
#define THIRD_PARTY_PROTOCOLS_SEL  0  // 完全关闭所有第三方协议
#endif
```

- 所以第三方协议使能一定要开启。`TCFG_THIRD_PARTY_PROTOCOLS_ENABLE`
- 使得`THIRD_PARTY_PROTOCOLS_SEL`生效，将`TCFG_THIRD_PARTY_PROTOCOLS_SEL`替换为可视化工具的配置
  - 假设可视化工具没有具体的第三方协议配置的话。这里为0.
  - 可视化工具中协议选择时没有`JL_SBOX_EN`，这个协议是硬编码上去的。

**步骤3：在线调试特殊处理** (`app_config.h:954-961`)

```c
情况1：
/*spp数据导出配置*/ //在这个场景下APP_ONLINE_DEBUG会置1开启
#if ((TCFG_AUDIO_DATA_EXPORT_DEFINE == AUDIO_DATA_EXPORT_VIA_SPP) || TCFG_AUDIO_MIC_DUT_ENABLE)
#undef TCFG_USER_TWS_ENABLE
#undef TCFG_USER_BLE_ENABLE
#undef TCFG_BD_NUM
#undef TCFG_BT_SUPPORT_SPP
#undef TCFG_BT_SUPPORT_A2DP
#define TCFG_USER_TWS_ENABLE        0//spp数据导出，关闭tws
#define TCFG_USER_BLE_ENABLE        0//spp数据导出，关闭ble
#define TCFG_BD_NUM					1//连接设备个数配置
#define TCFG_BT_SUPPORT_SPP	1
#define TCFG_BT_SUPPORT_A2DP   0
#define APP_ONLINE_DEBUG            1//通过spp导出数据
#else
#define APP_ONLINE_DEBUG            0//在线APP调试,发布默认不开
#endif/*TCFG_AUDIO_DATA_EXPORT_DEFINE*/
    
情况2：
//*********************************************************************************//
//                    需要spp调试的配置                                            //
//*********************************************************************************//
#if ( \
     TCFG_AEC_TOOL_ONLINE_ENABLE                                        || \
     TCFG_AUDIO_DUT_ENABLE      	                                    || \
     TCFG_ANC_TOOL_DEBUG_ONLINE                                         || \
     TCFG_LP_TOUCH_KEY_BT_TOOL_ENABLE                                   || \
     (TCFG_CFG_TOOL_ENABLE && (TCFG_COMM_TYPE == TCFG_SPP_COMM))        || \
     TCFG_SPEAKER_EQ_NODE_ENABLE                                        || \
     (TCFG_SENSOR_DATA_EXPORT_ENABLE == SENSOR_DATA_EXPORT_USE_SPP)     || \
     TCFG_SPATIAL_EFFECT_ONLINE_ENABLE                                  || \
     (TCFG_AUDIO_HEARING_AID_ENABLE && TCFG_AUDIO_DHA_FITTING_ENABLE) /*辅听*/  \
    )
//任何之前的定义（如果存在）都会被 #undef 清除，因此不会受到之前代码或头文件中可能存在的同名宏的影响。
#undef TCFG_BT_SUPPORT_SPP
#undef APP_ONLINE_DEBUG
#define TCFG_BT_SUPPORT_SPP	1
#define APP_ONLINE_DEBUG            1
#endif
         
#if APP_ONLINE_DEBUG
#undef THIRD_PARTY_PROTOCOLS_SEL
// 如果可视化工具配置了其他协议
#if (TCFG_THIRD_PARTY_PROTOCOLS_ENABLE && (TCFG_THIRD_PARTY_PROTOCOLS_SEL & (其他协议)))
#define THIRD_PARTY_PROTOCOLS_SEL  (TCFG_THIRD_PARTY_PROTOCOLS_SEL | ONLINE_DEBUG_EN)
#else
// 如果没有配置其他协议，强制启用 JL_SBOX_EN
#define THIRD_PARTY_PROTOCOLS_SEL  (ONLINE_DEBUG_EN|JL_SBOX_EN)
#endif
#endif
```

- 在`APP_ONLINE_DEBUG`开启的情况下，如果使能了第三方协议
  - 可视化工具又配置了具体的第三方协议，那么就一起使能
    - `TCFG_THIRD_PARTY_PROTOCOLS_SEL`这个会被替换为可视化工具配置的值。
    - `ONLINE_DEBUG_EN`
  - 可视化工具没有配置具体的第三方协议，就会使能
    - `ONLINE_DEBUG_EN`
    - `JL_SBOX_EN`

#### 3. 条件编译检查

在彩屏仓模块中的每个文件开头都有：
```c
#if (THIRD_PARTY_PROTOCOLS_SEL & JL_SBOX_EN)
// 所有彩屏仓相关代码
#endif
```

**位运算逻辑**：
- 如果 `THIRD_PARTY_PROTOCOLS_SEL = 0x80000001`（启用了RCSP和彩屏仓）
- 检查：`0x80000001 & 0x80000000 = 0x80000000`（非零，条件为真）
- 结果：彩屏仓代码会被编译

- 如果 `THIRD_PARTY_PROTOCOLS_SEL = 0x00000001`（只启用了RCSP）
- 检查：`0x00000001 & 0x80000000 = 0x00000000`（为零，条件为假）
- 结果：彩屏仓代码不会被编译

因为`APP_ONLINE_DEBUG`一直是开启的。所以`THIRD_PARTY_PROTOCOLS_SEL`只能是：

- `(TCFG_THIRD_PARTY_PROTOCOLS_SEL | ONLINE_DEBUG_EN)`
- `(ONLINE_DEBUG_EN|JL_SBOX_EN)`

#### 4. 官方设计的协议互斥机制

**关键发现**：通过代码分析发现，JL_SBOX_EN只出现在第959行的定义中：

```c
// app_config.h:956-960
#if (TCFG_THIRD_PARTY_PROTOCOLS_ENABLE && (TCFG_THIRD_PARTY_PROTOCOLS_SEL & (RCSP_MODE_EN | GFPS_EN | MMA_EN | FMNA_EN | REALME_EN | SWIFT_PAIR_EN | DMA_EN | CUSTOM_DEMO_EN | XIMALAYA_EN | AURACAST_APP_EN))) || ((TCFG_LE_AUDIO_APP_CONFIG & (LE_AUDIO_UNICAST_SINK_EN | LE_AUDIO_JL_UNICAST_SINK_EN)))
#define THIRD_PARTY_PROTOCOLS_SEL  (TCFG_THIRD_PARTY_PROTOCOLS_SEL | ONLINE_DEBUG_EN)  // 不包含JL_SBOX_EN
#else
#define THIRD_PARTY_PROTOCOLS_SEL  (ONLINE_DEBUG_EN|JL_SBOX_EN)  // 只有这里包含JL_SBOX_EN
#endif
```

**详细验证分析**：

**情况1：配置了其他协议（如RCSP）**

```c
// 可视化工具配置了RCSP协议
TCFG_THIRD_PARTY_PROTOCOLS_SEL = RCSP_MODE_EN = (1 << 0) = 0x00000001

// 条件判断为真，走第957行
THIRD_PARTY_PROTOCOLS_SEL = (TCFG_THIRD_PARTY_PROTOCOLS_SEL | ONLINE_DEBUG_EN)
                          = (0x00000001 | 0x00004000)
                          = 0x00004001

// 彩屏仓条件编译检查
#if (THIRD_PARTY_PROTOCOLS_SEL & JL_SBOX_EN)
= (0x00004001 & 0x80000000)
= 0x00000000  // 结果为0，条件为假，彩屏仓代码不会被编译！
```

**情况2：没有配置其他协议**

```c
// 可视化工具没有配置任何第三方协议
TCFG_THIRD_PARTY_PROTOCOLS_SEL = 0

// 条件判断为假，走第959行
THIRD_PARTY_PROTOCOLS_SEL = (ONLINE_DEBUG_EN | JL_SBOX_EN)
                          = (0x00004000 | 0x80000000)
                          = 0x80004000

// 彩屏仓条件编译检查
#if (THIRD_PARTY_PROTOCOLS_SEL & JL_SBOX_EN)
= (0x80004000 & 0x80000000)
= 0x80000000  // 结果非零，条件为真，彩屏仓代码会被编译！
```

**关键发现**：
- **第957行**：`(TCFG_THIRD_PARTY_PROTOCOLS_SEL | ONLINE_DEBUG_EN)` **不包含JL_SBOX_EN**
- **第959行**：`(ONLINE_DEBUG_EN | JL_SBOX_EN)` **包含JL_SBOX_EN**
- 只有当没有配置其他协议时，JL_SBOX_EN才会被添加到最终配置中

**重要限制**：
- 当可视化工具配置了RCSP、GFPS等其他协议时，最终的`THIRD_PARTY_PROTOCOLS_SEL`**不包含JL_SBOX_EN**
- JL_SBOX_EN只有在**没有配置任何其他第三方协议**时才会被自动添加
- 这意味着彩屏仓通信模块**无法与其他第三方协议共存**

**启用条件总结**：
彩屏仓通信模块的启用需要同时满足：
```c
APP_ONLINE_DEBUG = 1
AND
TCFG_THIRD_PARTY_PROTOCOLS_ENABLE = 1
AND
TCFG_THIRD_PARTY_PROTOCOLS_SEL = 0 (可视化工具未配置其他协议)
```

**最终结果**：
```c
THIRD_PARTY_PROTOCOLS_SEL = (ONLINE_DEBUG_EN | JL_SBOX_EN) = 0x80004000
```

**设计意图分析**：
杰理官方这样设计可能是因为：
1. **资源冲突**：彩屏仓与其他协议存在BLE资源、内存占用等冲突
2. **协议栈限制**：多协议并发可能导致系统不稳定
3. **功能定位**：彩屏仓作为开发调试辅助工具，非产品级功能
4. **简化维护**：避免多协议组合的复杂测试场景

**实际应用结论**：
在不修改官方SDK代码的前提下，彩屏仓通信模块只能与`ONLINE_DEBUG_EN`协议共存运行，这是官方有意的设计限制。要启用彩屏仓功能，**最关键的是确保TCFG_THIRD_PARTY_PROTOCOLS_ENABLE开启，且不配置其他第三方协议**。

- 可视化工具使能第三方协议时，BLE会自动打开。
- 智能仓打开。

```c
#define TCFG_USER_BLE_ENABLE 1 // BLE
#if TCFG_USER_BLE_ENABLE
#define TCFG_BT_BLE_TX_POWER 9 // 最大发射功率
#define TCFG_BT_BLE_BREDR_SAME_ADDR 1 // 和2.1同地址
#define TCFG_BT_BLE_ADV_ENABLE 0 // 广播
#define TCFG_BLE_HIGH_PRIORITY_ENABLE 0 // 高优先级
#endif // TCFG_USER_BLE_ENABLE

#define TCFG_THIRD_PARTY_PROTOCOLS_ENABLE 1 // 第三方协议配置
#if TCFG_THIRD_PARTY_PROTOCOLS_ENABLE
#define TCFG_BT_RCSP_DUAL_CONN_ENABLE 0 // 支持连接两路RCSP
#define TCFG_THIRD_PARTY_PROTOCOLS_SEL 0 // 第三方协议选择
#endif // TCFG_THIRD_PARTY_PROTOCOLS_ENABLE
```

# 重构

## sbox_core_code.c功能重构架构分析

### 重构背景

在最新的代码版本中，原先的`sbox_core_code.c`文件从编译配置中移除（文件仍存在但不参与编译），其功能被重新设计和分解到多个专门的模块中，同时引入了静态库`lib_esbox.a`。这种重构体现了更好的模块化设计理念和代码维护性。

**重要说明**：`sbox_core_code.c`文件本身仍然存在于源码目录中，但已从`SDK/build/Makefile.mk`的编译列表中移除，不再参与实际编译过程。其原有功能通过新的模块化架构实现。

### 功能分解对照表

#### 原sbox_core_code.c功能分析
根据文件头部注释和彩屏仓通信协议分析，`sbox_core_code.c`原先承担以下核心功能：
- **协议解析引擎**：5Aa5协议格式的数据包编解码
- **数据加密解密**：AES128-ECB模式的加密解密处理
- **命令分发处理**：协议命令解析和路由分发
- **数据校验**：协议头校验、长度校验、错误检测
- **缓冲区管理**：环形缓冲区管理数据收发
- **应用层控制**：具体的业务逻辑实现

#### 新架构功能分布

| 原功能模块 | 新实现方式 | 负责文件 | 功能描述 |
|-----------|-----------|----------|----------|
| **协议解析引擎** | 静态库封装 | `lib_esbox.a` | 5Aa5协议格式处理、AES128-ECB加密解密算法封装 |
| **HID通信层** | 专门模块 | `edr_hid_user.c/.h` | EDR HID协议栈管理、设备兼容性处理 |
| **视频控制应用** | 专门模块 | `user_video_ctr.c/.h` | 抖音控制、相机操作、手势识别 |
| **音频EQ处理** | 专门模块 | `sbox_eq_switch.c` | 实时EQ参数调整、音频效果管理 |
| **设备连接管理** | 专门模块 | `sbox_connect_emitter.c` | 外部设备管理、TWS同步、连接状态处理 |
| **缓冲区管理** | 分散到各模块 | 各模块内部 | 环形缓冲区功能分散到具体使用的模块中 |

### 新架构优势分析

#### 1. 模块化程度提升
```
原架构：
sbox_core_code.c (单一大文件，从编译中移除)
├── 5Aa5协议解析
├── AES128-ECB加密解密
├── 命令分发处理
├── 应用逻辑控制
├── 数据校验和缓冲区管理
└── 错误检测和异常处理

新架构：
lib_esbox.a (核心算法静态库)
├── edr_hid_user.c (HID通信专门模块)
├── user_video_ctr.c (视频控制专门模块)
├── sbox_eq_switch.c (音频EQ专门模块)
└── sbox_connect_emitter.c (连接管理专门模块)
```

#### 2. 职责分离更清晰

##### edr_hid_user.c/.h - HID通信层
- **专责**：EDR HID协议栈管理
- **核心功能**：
  - Android/iOS设备类型检测和适配
  - HID报告描述符动态切换
  - TWS耳机间HID通道同步
  - 环形缓冲区管理确保数据传输可靠性
- **替代原功能**：HID协议相关的命令处理和数据传输

##### user_video_ctr.c/.h - 应用控制层
- **专责**：视频和媒体应用控制
- **核心功能**：
  - 抖音/TikTok手势控制（滑动、点赞）
  - 相机焦点调整和拍照控制
  - iOS/Android平台兼容的触摸坐标仿真
  - 坐标校准和持久化存储
- **替代原功能**：应用层的具体控制逻辑和用户交互处理

##### sbox_eq_switch.c - 音频处理层
- **专责**：实时音频效果管理
- **核心功能**：
  - 动态EQ参数配置和验证
  - 多频段EQ实时调整（最多10段）
  - 音频流处理集成
  - 淡入/淡出平滑过渡
- **替代原功能**：音频相关的命令处理和效果应用

##### sbox_connect_emitter.c - 连接管理层
- **专责**：外部设备连接管理
- **核心功能**：
  - 发射器设备（手机/平板）地址管理
  - TWS间连接信息同步
  - 链路密钥管理和设备认证
  - 连接状态恢复和重连策略
- **替代原功能**：设备管理和连接状态处理

##### lib_esbox.a - 核心算法库
- **专责**：核心协议处理算法
- **推测功能**：
  - AES128-ECB加密解密算法实现
  - 5Aa5协议格式的数据包编解码引擎
  - 协议头校验和长度校验算法
  - 错误检测和异常处理机制
  - 底层通信协议栈核心逻辑
- **替代原功能**：原`sbox_core_code.c`中的协议解析引擎和加密算法部分

### 架构演进的技术收益

#### 1. 代码维护性提升
- **单一职责原则**：每个模块专注于特定功能域
- **接口清晰化**：模块间依赖关系明确
- **测试便利性**：可以独立测试各个功能模块

#### 2. 开发效率优化
- **并行开发**：不同团队可同时开发不同模块
- **功能扩展**：新增功能时只需修改对应模块
- **问题定位**：bug更容易定位到具体模块

#### 3. 代码复用性增强
- **lib_esbox.a**：核心算法可被其他项目复用
- **模块化设计**：各功能模块可在不同产品中复用
- **平台移植**：更容易适配到不同硬件平台

#### 4. 安全性改善
- **核心算法保护**：敏感的加密算法封装在静态库中
- **代码隔离**：不同功能域的代码隔离，降低安全风险
- **接口标准化**：减少了直接操作底层协议的风险

### 新架构的系统集成

#### 编译配置更新
```makefile
# 原编译配置 (SDK/build/Makefile.mk)
c_SRC_FILES := \
    apps/common/third_party_profile/jl_earbox/sbox_core_code.c \  # 已移除
    apps/common/third_party_profile/jl_earbox/sbox_core_config.c \
    apps/common/third_party_profile/jl_earbox/sbox_protocol.c \

# 新编译配置 (SDK/build/Makefile.mk)
c_SRC_FILES := \
    apps/common/third_party_profile/jl_earbox/sbox_core_config.c \
    apps/common/third_party_profile/jl_earbox/sbox_protocol.c \
    apps/common/third_party_profile/jl_earbox/sbox_eq_switch.c \      # 新增
    apps/common/third_party_profile/jl_earbox/user_video_ctr.c \     # 新增
    apps/common/third_party_profile/jl_earbox/edr_hid_user.c \       # 新增
    apps/common/third_party_profile/jl_earbox/sbox_connect_emitter.c # 新增

# 新增静态库链接
LFLAGS := \
    cpu/br56/liba/lib_esbox.a \  # 新增核心算法库
```

#### 数据流处理更新
```
原数据流：
彩屏仓BLE命令 → sbox_protocol.c → sbox_core_code.c → 统一处理
                                      ↓
                             5Aa5协议解析 + AES解密 + 命令分发

新数据流：
彩屏仓BLE命令 → sbox_protocol.c → lib_esbox.a (协议解析 + AES解密) → {
    HID相关命令 → edr_hid_user.c
    视频控制命令 → user_video_ctr.c
    EQ调整命令 → sbox_eq_switch.c
    连接管理命令 → sbox_connect_emitter.c
}
```

### 结论

新架构完全能够替代原`sbox_core_code.c`的功能（虽然原文件仍存在但不参与编译），并且在以下方面有显著改善：

1. **功能完整性**：所有原有功能都得到保留和重新实现
   - 5Aa5协议解析 → `lib_esbox.a`静态库实现
   - AES128-ECB加密解密 → `lib_esbox.a`静态库实现
   - HID通信功能 → `edr_hid_user.c`专门模块
   - 视频控制功能 → `user_video_ctr.c`专门模块
   - EQ音效处理 → `sbox_eq_switch.c`专门模块
   - 连接管理功能 → `sbox_connect_emitter.c`专门模块

2. **架构合理性**：符合软件工程的模块化设计原则
   - 单一职责原则：每个模块负责特定功能域
   - 开放封闭原则：易于扩展新功能而不影响现有代码
   - 依赖倒置原则：通过接口而非具体实现进行交互

3. **维护便利性**：问题定位和功能扩展更加容易
   - 模块独立性强，便于单独测试和调试
   - 代码结构清晰，新人容易理解和上手
   - 支持增量开发和功能迭代

4. **安全性提升**：核心算法通过静态库保护
   - 敏感的加密算法封装在二进制库中
   - 协议解析逻辑不直接暴露源码
   - 降低核心算法被逆向的风险

5. **开发效率**：支持团队并行开发和独立测试
   - 不同功能模块可并行开发
   - 模块间依赖关系清晰
   - 便于实施持续集成和自动化测试

这种重构体现了从"单体架构"向"模块化架构"的演进，是软件工程实践中**重构优化**的典型案例，而非简单的文件删除。

## 最新业务功能扩展分析（2025-09-17提交）

### 扩展背景
在完成彩屏仓模块重构后，最新的提交（7f1bb84）中主要针对业务功能层进行了大量扩展，新增了多个实用的业务特性，这些扩展主要集中在**用户交互体验**和**多媒体控制**两个方面。

### 新增业务功能模块

#### 1. HID通信增强功能（edr_hid_user.c）
**功能目标**：提供完整的HID设备交互能力
- **Android/iOS兼容性管理**：根据连接设备类型动态切换HID报告描述符
- **TWS HID通道同步**：确保左右耳机的HID命令协调执行
- **设备类型自动检测**：智能识别连接的手机平台并适配相应协议
- **环形缓冲区管理**：提供可靠的HID数据传输机制

**业务价值**：为后续的视频控制、媒体操作奠定了稳定的底层通信基础

#### 2. 视频/媒体控制功能（user_video_ctr.c）
**功能目标**：实现手势控制短视频和相机应用
- **抖音/TikTok手势控制**：
  - 上下滑动切换视频
  - 左右滑动浏览相关内容
  - 双击点赞功能
  - 坐标校准和持久化存储
- **相机控制功能**：
  - 焦点调整控制
  - 拍照快门触发
  - 实时坐标仿真
- **平台适配机制**：iOS/Android不同的HID报告格式支持

**业务价值**：将TWS耳机从纯音频设备扩展为智能交互终端

#### 3. 实时EQ音效管理（sbox_eq_switch.c）
**功能目标**：提供动态音频效果调节能力
- **多频段EQ支持**：最多10段可配置EQ参数
- **实时参数验证**：频率、增益、Q因子的边界检查
- **音频流集成**：与底层音频处理管道直接对接
- **平滑过渡效果**：支持淡入/淡出的参数切换

**业务价值**：让用户可以通过彩屏仓实时调节音效，提升音频体验

#### 4. 设备连接管理（sbox_connect_emitter.c）
**功能目标**：优化多设备连接体验
- **发射器地址管理**：智能记忆最后连接的手机设备
- **TWS同步机制**：左右耳机间的设备信息同步
- **连接状态恢复**：断线重连的智能策略
- **VM持久化存储**：设备信息的可靠保存

**业务价值**：提升多设备使用场景下的连接稳定性和用户体验

#### 5. 蓝牙音乐信息同步（earphone.c扩展）
**功能目标**：增强音乐播放信息的获取和同步
- **歌词同步支持**：通过`bt_music_info_handle_register()`注册歌词获取回调
- **ID3标签解析**：支持ID3 V1/V2格式的音乐元数据
- **AVCTP命令扩展**：启用更多音乐控制命令支持
- **自定义拨号功能**：新增`APP_MSG_CUSTOM_CONTROL_PHONE_OUT`消息处理

**业务价值**：为彩屏仓显示歌词、专辑信息等提供数据支持

### 功能扩展的技术驱动因素

#### 1. 用户体验升级需求
- **交互方式多样化**：从纯按键控制扩展到手势控制
- **视觉反馈增强**：彩屏仓需要显示更丰富的信息（歌词、EQ设置等）
- **场景适配能力**：针对不同应用（抖音、相机、音乐）的专门优化

#### 2. 竞品差异化要求
- **短视频控制**：抖音手势控制是当前TWS市场的热门功能
- **实时EQ调节**：通过充电仓调节音效是产品独特卖点
- **多平台兼容**：iOS/Android的全面支持提升市场适应性

#### 3. 技术架构演进
- **模块化设计**：每个功能独立模块，便于测试和维护
- **静态库保护**：核心算法通过lib_esbox.a保护知识产权
- **接口标准化**：为后续功能扩展预留了标准化接口

### 实现策略分析

#### 设计原则
1. **职责分离**：每个模块专注特定业务域（HID、视频、音频、连接）
2. **平台兼容**：同一套代码适配iOS/Android不同特性
3. **性能优化**：通过缓冲区和异步处理确保实时响应
4. **用户友好**：坐标校准、设备记忆等提升易用性

#### 技术亮点
1. **HID报告描述符动态切换**：根据设备类型智能适配
2. **坐标持久化存储**：抖音点赞位置可以记忆和调整
3. **TWS间信息同步**：确保左右耳机的协调操作
4. **实时音频参数更新**：EQ变化即时生效

### 业务价值总结

这些业务功能扩展将TWS耳机从传统的**音频播放设备**升级为**智能交互终端**：

1. **交互维度扩展**：音频 → 音频+视觉+触控
2. **应用场景拓宽**：音乐播放 → 音乐+视频+拍照+通话
3. **用户体验提升**：被动接收 → 主动控制+个性化调节
4. **产品差异化**：标准功能 → 独特功能+智能适配

这种功能扩展策略体现了**以用户体验为中心**的产品设计理念，通过技术创新为用户创造更多价值，是TWS耳机产品向智能化、场景化发展的典型实践。

## TCFG_USER_EDR_ENABLE 技术使能分析

### 宏定义背景
在最新的提交中，新增了关键配置宏`TCFG_USER_EDR_ENABLE`，这是实现智能交互功能的核心技术使能开关。

### EDR技术原理
**EDR = Enhanced Data Rate（增强数据速率）**
- EDR是蓝牙2.0+EDR规范的核心特性
- 提供2-3 Mbps的高速数据传输能力（相比经典蓝牙1.0的1 Mbps）
- 为实时HID控制提供足够的带宽保障

### 配置变更详情

#### 新增配置项（app_config.h）
```c
//*********************************************************************************//
//                              彩屏仓功能新增业务                                 //
//*********************************************************************************//
#define TCFG_USER_EDR_ENABLE    1    // 启用EDR HID功能
#define CFG_USER_TIKTOK_X       13   // 抖音点赞按钮X坐标存储位置
#define CFG_USER_TIKTOK_Y       14   // 抖音点赞按钮Y坐标存储位置
```

#### 条件编译机制
```c
#if TCFG_USER_EDR_ENABLE && (TCFG_BT_SUPPORT_HID ==1) && (!TCFG_BT_DUAL_CONN_ENABLE)
// EDR HID相关功能代码
#endif
```

**启用条件分析**：
- `TCFG_USER_EDR_ENABLE = 1`：主开关，启用EDR协议支持
- `TCFG_BT_SUPPORT_HID = 1`：启用HID Profile协议栈
- `!TCFG_BT_DUAL_CONN_ENABLE`：与双连接功能互斥（避免资源冲突）

### 技术架构支撑

#### HID设备身份转换
启用`TCFG_USER_EDR_ENABLE`后，TWS耳机获得以下能力：
1. **HID设备模拟**：耳机可作为鼠标、键盘、触摸板等HID设备
2. **多平台适配**：通过动态HID报告描述符适配iOS/Android
3. **实时坐标仿真**：精确模拟手指在屏幕上的触摸操作

#### 蓝牙Profile配置（bt_profile_config.c）
```c
#if TCFG_USER_EDR_ENABLE
//定义产品信息,用于HID设备识别
#define  PNP_VID_SOURCE   0x02
#define  PNP_VID          0x05ac //苹果厂商ID（模拟苹果设备）
#define  PNP_PID          0x022C //产品ID
#define  PNP_PID_VERSION  0x011b //版本号1.1.11
```

**厂商ID策略**：
- 使用苹果厂商ID（0x05ac）提升iOS设备兼容性
- 通过标准PnP信息让手机正确识别HID设备类型

### 实现的核心功能

#### 1. 抖音/短视频控制
**技术实现**：
- **上下滑动**：发送触摸坐标序列模拟垂直滑动手势
- **左右滑动**：水平方向的坐标变化模拟横向浏览
- **双击点赞**：在存储的坐标位置发送双击事件
- **坐标记忆**：通过VM存储用户校准的点赞按钮位置

**关键代码路径**：
```
彩屏仓BLE命令 → user_video_ctr.c → edr_hid_user.c → HID报告发送
```

#### 2. 相机应用控制
**功能特性**：
- **焦点调整**：模拟点击屏幕进行对焦
- **快门触发**：发送音量键或屏幕点击事件拍照
- **实时预览控制**：支持变焦、切换摄像头等操作

#### 3. 系统级交互
**扩展能力**：
- **音量控制**：音量加减的HID键盘事件
- **系统导航**：返回、主页、多任务切换
- **Siri/语音助手**：长按Home键或特定手势唤醒

### 平台兼容性处理

#### iOS平台适配
```c
// iOS使用HID报告ID 2/5进行触摸坐标仿真
#define IOS_TOUCH_REPORT_ID_2    0x02
#define IOS_TOUCH_REPORT_ID_5    0x05
```

#### Android平台适配
```c
// Android使用HID报告ID 2进行触点仿真
#define ANDROID_TOUCH_REPORT_ID  0x02
```

**自适应机制**：根据连接设备类型自动切换HID报告描述符，确保跨平台兼容性。

### 业务价值分析

#### 产品差异化优势
1. **独特交互体验**：TWS耳机变身为智能遥控器
2. **使用场景拓展**：从音频播放扩展到视频娱乐、拍照等
3. **竞品技术壁垒**：复杂的多平台HID适配形成技术门槛

#### 用户体验提升
1. **操作便利性**：无需拿出手机即可控制应用
2. **个性化定制**：可调节的坐标位置适应不同用户习惯
3. **场景适配性**：运动、通勤等场景下的便捷操作

#### 技术架构优势
1. **模块化设计**：EDR HID功能独立封装，易于维护
2. **扩展性良好**：可轻松添加新的手势控制功能
3. **平台无关性**：一套代码适配多种操作系统

### 实施风险与限制

#### 技术限制
1. **资源互斥**：不能与蓝牙双连接同时启用
2. **延迟敏感**：实时控制对蓝牙连接质量要求较高
3. **功耗影响**：HID连接会增加额外功耗开销

#### 兼容性考虑
1. **系统版本依赖**：不同Android/iOS版本的HID支持差异
2. **应用适配性**：某些应用可能对外部HID输入有限制
3. **安全策略**：部分系统安全设置可能阻止HID设备连接

### 结论

`TCFG_USER_EDR_ENABLE`的引入是本次业务功能扩展的**技术基石**，它不仅启用了EDR高速传输能力，更重要的是为TWS耳机赋予了**HID设备**的身份，使其从单纯的音频外设演进为**多功能智能交互终端**。

这种技术架构设计体现了**软硬件协同创新**的理念，通过软件层面的协议扩展，充分挖掘硬件平台的潜力，为用户创造了全新的交互体验，是TWS耳机产品智能化发展的重要里程碑。

# 业务功能逻辑？？？

## 同步音乐状态音量给仓

SDK中`apps\earphone\mode\bt\earphone.c`，打开音量同步时：

```c
#if TCFG_BT_VOL_SYNC_ENABLE
    bt_music_vol_change_handle_register(set_music_device_volume, phone_get_device_vol);
#endif

//注册给库的回调函数，用户手机设置设备音量
void set_music_device_volume(int volume)
{
    r_printf("set_music_device_volume=%d\n", volume);
#if TCFG_BT_VOL_SYNC_ENABLE
    s16 music_volume;

    //音量同步最大是127，请计数比例
    if (volume > 127) {
        /*log_info("vol %d invalid\n",  volume);*/
#if TCFG_VOL_RESET_WHEN_NO_SUPPORT_VOL_SYNC
        /*不支持音量同步的设备，默认设置到最大值，可以根据实际需要进行修改。
         注意如果不是最大值，设备又没有按键可以调音量到最大，则输出也就达不到最大*/
        music_volume = app_audio_volume_max_query(AppVol_BT_MUSIC);
        log_i("unsupport vol_sync,reset vol:%d\n", music_volume);
        app_audio_set_volume(APP_AUDIO_STATE_MUSIC, music_volume, 1);
#endif
        return;
    }
    if (tone_player_runing() || ring_player_runing() || bt_get_esco_coder_busy_flag()) {
        log_i("It's not smart to sync a2dp vol now\n");
        //app_var.music_volume = vol_sys_tab[(volume + 1) / 8];
        app_var.music_volume = ((volume + 1) * 16) / 127;
        app_var.opid_play_vol_sync = vol_sync_tab[(volume + 1) / 8];
        return;
    }

#if 1
    /*
     *0~16,总共17级
     *这里将手机的0~127的音量值换成实际的dac音量等级
     *手机的音量等级映射到耳机的音量等一
     */
    music_volume = ((volume + 1) * 16) / 127;
#else
    music_volume = vol_sys_tab[(volume + 1) / 8];
#endif
    y_printf("phone_vol:%d,dac_vol:%d", volume, music_volume);
    app_var.opid_play_vol_sync = vol_sync_tab[(volume + 1) / 8];

    app_audio_set_volume(APP_AUDIO_STATE_MUSIC, music_volume, 1);

    app_audio_set_volume_def_state(0);
    
#if (THIRD_PARTY_PROTOCOLS_SEL & JL_SBOX_EN)
    sbox_cb_func.sbox_sync_volume_info();
#endif

#endif
}

//注册给库的回调函数，用于手机获取当前设备音量
int phone_get_device_vol(void)
{
    //音量同步最大是127，请计数比例
#if 0
    return (app_var.sys_vol_l * app_audio_volume_max_query(AppVol_BT_MUSIC) / 127) ;
#else
    return app_var.opid_play_vol_sync;
#endif
}

//彩屏仓接口回调指向：apps\common\third_party_profile\jl_earbox\sbox_user_app.c
//同步耳机播歌音量给仓
__attribute__((weak))
void custom_sync_volume_state(void)
{
    log_info("%s \n",__func__);
    u8 cur_vol = 0; 
    cur_vol = app_audio_get_volume(APP_AUDIO_STATE_MUSIC);
    sbox_ble_att_send_data(CUSTOM_BLE_VOLUMEN_CMD, &cur_vol, sizeof(cur_vol)); //将当前音量发给仓
}
```

- 也就是说音量先设置好了，最后同步给仓的。
  - 这个流程不知道是耳机设置音量，然后同步到手机与仓？
  - 还是手机设置音量，传给耳机后。再同步到仓？
- 仓主动设置音量的流程？
- 耳机主动设置音量的流程？
- 手机主动设置音量的流程？

# 疑问

## 仓的电量是如何获取的？是通过982芯片还是通过BLE连接从耳机获取或者手机获取？
