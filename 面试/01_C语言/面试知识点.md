# 关键字

## const关键字

### 作用

在 C 语言中，const 关键字的主要作用是**声明一个常量（constant）**，表示被修饰的对象的值不能被修改。这是一种**编译时检查机制**，用于防止意外修改数据。

- **修饰变量**：如 const int x = 5;，表示 x 的值不能被改变。如果有其他地方试图赋值（如 x = 10;），**编译器会报错。**
- **修饰指针**：可以有两种形式：
  - const int *p;：指针指向的内容不可修改，但指针本身可以改变指向。
  - int *const p;：指针本身不可修改，但指向的内容可以改变。
  - const int *const p;：两者均不可修改。
    - 可以简单理解为const修饰的是值的类型还是指针。
    - 如果修饰的是值的类型，那么const会在*的前面。
    - 如果修饰的时指针，那么const会在*的后面。
- **修饰函数参数**：如 void func(const char *str);，表示函数不会修改传入的参数。
  - 一般这种形参都是指针，使用const确保指针的指向或者指向的内容不被修改。

### 被 const 修饰的变量存储位置（一般情况）

- **全局或静态的 const 变量**：一定会放入**常量区（.rodata）**，享受运行时只读保护。

- **局部的 const 变量**：名义上在**栈区**，但由于值不可变，编译器在优化时（如-O1及以上）通常直接替换为立即数，几乎不占用运行时内存。

- **const 本身不改变堆区内存属性**：堆上分配的内存始终可写，const 只提供编译期检查。
  - **编译时检查机制**

#### 局部const变量

const 对象必须声明时初始化，名义上存储在栈区，但编译器通常会优化掉实际存储。

```c
int func() {
    const int a = 5;
    const int b = a + 3;
    return b * 2;
}
```

优化后，编译器直接计算出返回值是 16，整个函数可能被内联或简化为 return 16;，根本不会为 a 和 b 分配任何栈空间，也不会生成加载 a、b 的指令。

- 函数结束后，绝对不能再访问这个局部 const 变量，无论是否被优化。

### 与指针的位置关系

当 `const` 关键字与指针一起使用时，它的位置决定了被修饰的对象是什么：

**`const` 在 `*` 前面 (例如: `const char *pStr`)**:

- 这意味着指针 `pStr` 所**指向的值是常量，不能通过这个指针来修改所指向内存地址的内容**。
- 但是，指针 `pStr` 本身的值（即它所指向的内存地址）是可以改变的，**可以指向其他的内存地址**。
- 也可以写作 `char const *pStr`，含义相同。

**`const` 在 `*` 后面 (例如: `char * const pStr`)**:

- 这意味着指针 `pStr` 本身是一个常量，一旦初始化后，它的 **指向** 就不能再改变，即**不能指向其他的内存地址**。
- 但是，**可以通过这个指针来修改所指向内存地址的内容**（前提是所指向的数据类型本身不是 `const` 的）。

**`const` 在 `*` 前后都有 (例如: `const char * const pStr`)**:

- 这意味着指针 `pStr` 本身是一个常量，并且它所指向的值也是常量。**既不能修改指针的指向，也不能通过这个指针来修改所指向内存地址的内容。**

#### `const` 在 `*` 前：指向常量的指针

- `const char *pStr`（等价于 `char const *pStr`）

```c
#include <stdio.h>

int main(void)
{
    char str1[] = "Hello";
    char str2[] = "World";

    const char *pStr = str1;   // 指针指向常量字符

    /* 合法操作：可以改变指针的指向 */
    pStr = str2;

    /* 非法操作：不能通过指针修改所指向的内容 */
    // pStr[0] = 'h';           // ❌ 编译错误

    printf("%s\n", pStr);
    return 0;
}
```

#### `const` 在 `*` 后：常量指针

- char * const pStr

```c
#include <stdio.h>

int main(void)
{
    char str1[] = "Hello";
    char str2[] = "World";

    char * const pStr = str1;  // 常量指针，必须初始化

    /* 合法操作：可以修改所指向的内容 */
    pStr[0] = 'h';

    /* 非法操作：不能改变指针的指向 */
    // pStr = str2;             // ❌ 编译错误

    printf("%s\n", pStr);
    return 0;
}
```

#### `const` 在 `*` 前后都有：指向常量的常量指针

- const char * const pStr

```c
#include <stdio.h>

int main(void)
{
    char str[] = "Hello";

    const char * const pStr = str;

    /* 非法操作：不能修改所指向的内容 */
    // pStr[0] = 'h';           // ❌ 编译错误

    /* 非法操作：不能改变指针的指向 */
    // pStr = "World";          // ❌ 编译错误

    printf("%s\n", pStr);
    return 0;
}
```

# 指针



# 内联（inline 函数）与宏定义（#define）的区别

它们表面上看都是“替换文本”，都能避免函数调用开销，实现类似“内联”的效果。但在 C/C++ 中，二者本质完全不同，实现机制、适用场景、安全性和行为都有很大差异。

## 类型安全（最重要区别）

```c
#define SQUARE(x) ((x)*(x))          // 宏

inline int square(int x) {           // 内联函数
    return x * x;
}

int a = 5;
double b = 5.5;

int r1 = SQUARE(a);        // 正确 → 25
int r2 = SQUARE(b);        // 危险！b 被转换为 int，得到 25（丢失小数）

int r3 = square(a);        // 正确 → 25
int r4 = square(b);        // 编译错误！类型不匹配（安全）
```

- 宏无类型检查，参数 x 直接替换，可能导致隐式转换错误或意外行为。 
- 内联函数有完整类型检查，更安全。

## 参数副作用问题

副作用指的是：表达式在计算值的同时，还改变了程序的状态（最典型的就是修改了变量的值）。

常见有副作用的操作：

- i++、++i、i--、--i
- i = 10
- i += 1
- 调用有修改全局/静态变量的函数，如 printf()（修改文件流）、rand()（修改内部状态）

无副作用的操作（纯表达式）：

- i + 5
- i * 2
- 调用不修改任何外部状态的函数（如 strlen(str) 如果 str 不变）

```c
#define MAX(a, b) ((a) > (b) ? (a) : (b))

inline int max(int a, int b) {
    return a > b ? a : b;
}

int i = 6;                  // 改成大于5的情况
int result1 = max(i++, 5);  // 内联函数
// → i++ 只算一次：返回6，i变成7
// → max(6, 5) 返回 6
// 最终：result1 = 6, i = 7

int result2 = MAX(i++, 5);  // 宏
// 展开：((i++) > 5 ? (i++) : 5)
// → 条件：i++ 返回6，i变成7，6>5 为 true
// → 取左边：又一次 i++ 返回7，i变成8
// 最终：result2 = 7, i = 8
```

- 这是宏最经典的陷阱：参数有副作用时会被多次求值。
  - 函数形参 vs. 宏参数 的求值次数区别
  - **宏参数（#define）**：属于**纯文本替换**，在预处理阶段展开。 宏展开后，参数出现的每一个位置都会**独立求值一次**。

-  内联函数参数只求值一次，完全避免这个问题。

## 表达式优先级问题

```c
#define ADD(x, y) (x) + (y)

int result = ADD(1, 2) * 3;        // 预期 9，实际也是 9（加了括号还好）

#define BAD_ADD(x,y) x + y         // 危险写法 没有整体性，不知道替换哪一个
int bad = BAD_ADD(1, 2) * 3;       // 展开为 1 + 2 * 3 → 7！（优先级错误）
```

- 好的宏必须全程加括号防优先级问题，但很多人写不好。 

- 内联函数完全不受此影响。

