#separator:tab
#html:true
#tags column:3
#deck:C语言面试
"<b>【选择】const修饰符位置</b><br><br>以下代码，哪些操作是<b>合法</b>的？<br><br><pre>const char *p1 = str;<br>p1 = otherStr;  // 操作A<br>p1[0] = 'X';    // 操作B<br><br>char * const p2 = str;<br>p2 = otherStr;  // 操作C<br>p2[0] = 'X';    // 操作D</pre>"	"<b>✓ 答案：A、D</b><br><br><b>规则：</b><br>• <code>const char *p</code> → const在*左侧<br>&nbsp;&nbsp;- 值不能改（B非法）<br>&nbsp;&nbsp;- 指针可改（A合法）<br><br>• <code>char * const p</code> → const在*右侧<br>&nbsp;&nbsp;- 指针不能改（C非法）<br>&nbsp;&nbsp;- 值可改（D合法）<br><br><b>记忆：</b>「const修饰它左边的东西」<br><br><b>陷阱：</b>函数返回<code>const char*</code>不能赋给<code>char*</code>"	C语言::指针::const 面试::高频
"<b>【对比】三种指针的区别</b><br><br>简述以下三者的区别：<br>1. 空指针<br>2. 野指针<br>3. 悬空指针"	"<table border='1' cellpadding='6' style='width:100%;border-collapse:collapse;'><tr><th>类型</th><th>定义</th><th>产生原因</th></tr><tr><td><b>空指针</b></td><td>显式赋值为NULL</td><td>主动初始化</td></tr><tr><td><b>野指针</b></td><td>指向不确定的内存</td><td>未初始化</td></tr><tr><td><b>悬空指针</b></td><td>指向已释放的内存</td><td>free后未置NULL</td></tr></table><br><b>关键：</b><br>• 悬空指针是野指针的特殊情况<br>• <code>free(p)</code>后，p不会自动变NULL<br>• 必须手动：<code>p = NULL;</code><br><br><b>危险等级：</b>悬空 > 野指针 > 空指针"	C语言::指针::空指针野指针 面试::高频
"<b>【语法】函数指针定义</b><br><br>定义一个函数指针p，指向函数：<br><code>int func(int x)</code><br><br>如何定义？"	"<b>答案：</b><br><code>int (*p)(int);</code><br><br><b>万能方法（3步）：</b><br>1. 写出函数原型：<code>int func(int)</code><br>2. 函数名换成<code>(*指针名)</code><br>&nbsp;&nbsp;&nbsp;<code>int (*p)(int)</code><br>3. 加分号：<code>int (*p)(int);</code><br><br><b>注意：</b>括号不能省！<br>• <code>int (*p)(int)</code> → 函数指针 ✓<br>• <code>int *p(int)</code> → 返回int*的函数 ✗<br><br><b>扩展：</b><br>• 函数指针数组：<code>int (*p[10])(int);</code>"	C语言::指针::函数指针
"<b>【陷阱】数组指针 vs 指针数组</b><br><br>以下两个定义有什么区别？<br><code>int *p1[10];</code><br><code>int (*p2)[10];</code><br><br>1. 分别是什么类型？<br>2. p1+1和p2+1偏移多少字节？<br>（假设int=4字节，指针=8字节）"	"<b>1. 类型：</b><br>• <code>int *p1[10]</code> → <b>指针数组</b><br>&nbsp;&nbsp;（10个指向int的指针）<br>• <code>int (*p2)[10]</code> → <b>数组指针</b><br>&nbsp;&nbsp;（指向包含10个int的数组）<br><br><b>2. 步长：</b><br>• <code>p1+1</code> → 8字节 (sizeof(int*))<br>• <code>p2+1</code> → 40字节 (10×sizeof(int))<br><br><b>判断技巧：</b><br>• <code>int *p[10]</code> → []优先级高 → 先数组后指针<br>• <code>int (*p)[10]</code> → ()改优先级 → 先指针后数组<br><br><b>记忆：</b>「()能抢优先级」"	C语言::指针::数组指针 C语言::陷阱::优先级
"<b>【代码阅读】volatile的作用</b><br><br>以下代码，哪个函数可能不返回平方值？<br><br><code>int Test1(volatile int *p) {<br>&nbsp;&nbsp;&nbsp;&nbsp;return (*p) * (*p);<br>}<br><br>int Test2(int *p) {<br>&nbsp;&nbsp;&nbsp;&nbsp;return (*p) * (*p);<br>}</code>"	"<b>答案：Test1可能不返回平方值</b><br><br><b>原因：</b><br><br>Test2（正常）：<br><code>// 编译器优化<br>temp = *p;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 读一次<br>return temp * temp;</code><br><br>Test1（volatile）：<br><code>// 强制每次从内存读取<br>val1 = *p;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 第1次读：值=5<br>// 此时中断修改了*p=6<br>val2 = *p;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 第2次读：值=6<br>return 5 * 6;&nbsp;&nbsp;&nbsp;// 不是平方！</code><br><br><b>volatile的作用：</b><br>• 阻止编译器优化<br>• 每次都从内存重新读取<br><br><b>应用场景：</b><br>• 硬件寄存器<br>• 中断修改的变量<br>• 多线程共享变量<br><br><b>注意：</b>volatile ≠ 线程安全"	C语言::关键字::volatile C语言::陷阱::编译器优化
"<b>【对比】结构体 vs 联合体</b><br><br>从4个维度对比：<br>1. 内存布局<br>2. 大小计算<br>3. 成员地址<br>4. 典型应用"	"<table border='1' cellpadding='6' style='width:100%;border-collapse:collapse;'><tr><th>维度</th><th>结构体</th><th>联合体</th></tr><tr><td><b>内存布局</b></td><td>成员依次排列</td><td>成员共享内存</td></tr><tr><td><b>大小</b></td><td>所有成员之和+对齐</td><td>最大成员+对齐</td></tr><tr><td><b>成员地址</b></td><td>地址递增</td><td>地址相同</td></tr><tr><td><b>访问</b></td><td>可同时访问所有成员</td><td>只能访问最后赋值的成员</td></tr></table><br><b>示例：</b><br><code>struct S {<br>&nbsp;&nbsp;&nbsp;&nbsp;int a;&nbsp;&nbsp;&nbsp;&nbsp;// 偏移0<br>&nbsp;&nbsp;&nbsp;&nbsp;char b;&nbsp;&nbsp;&nbsp;// 偏移4<br>};&nbsp;&nbsp;// sizeof(S) = 8<br><br>union U {<br>&nbsp;&nbsp;&nbsp;&nbsp;int a;&nbsp;&nbsp;&nbsp;&nbsp;// 偏移0<br>&nbsp;&nbsp;&nbsp;&nbsp;char b;&nbsp;&nbsp;&nbsp;// 偏移0(共享)<br>};&nbsp;&nbsp;// sizeof(U) = 4</code><br><br><b>联合体应用：</b><br>• 判断大小端<br>• 节省内存（互斥状态）<br>• 类型双关（需谨慎）"	C语言::数据结构::结构体联合体
"<b>【陷阱】字符串字面量</b><br><br>以下代码有什么问题？<br><br><code>void Test(void) {<br>&nbsp;&nbsp;&nbsp;&nbsp;char *str = NULL;<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char *p = ""hello"";<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;str = p;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;printf(str);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// ①<br>&nbsp;&nbsp;&nbsp;&nbsp;str[0] = 'H';&nbsp;&nbsp;&nbsp;&nbsp;// ②<br>&nbsp;&nbsp;&nbsp;&nbsp;printf(str);<br>}</code>"	"<b>① 没问题</b> - 能正常打印""hello""<br><b>② 严重错误</b> - 修改只读内存，未定义行为<br><br><b>原因：</b><br><code>""hello""</code>是字符串字面量：<br>• 存储在只读数据段（.rodata）<br>• 生命周期 = 整个程序<br>• 不可修改！<br><br><b>执行流程：</b><br>1. <code>p</code>指向只读区的""hello""<br>2. <code>str = p</code> → str也指向只读区<br>3. 代码块结束，p失效，但""hello""仍在<br>4. ① 读取成功（地址有效）<br>5. ② 写入崩溃（只读保护）<br><br><b>对比：</b><br><code>char p[] = ""hello"";&nbsp;&nbsp;// 栈数组，可修改<br>char *p = ""hello"";&nbsp;&nbsp;&nbsp;// 只读，不可修改</code>"	C语言::字符串::字符串字面量 C语言::内存::只读段 面试::高频
"<b>【经典陷阱】函数参数传递</b><br><br>以下代码能否正常工作？<br><br><code>void GetMemory(char *p) {<br>&nbsp;&nbsp;&nbsp;&nbsp;p = (char*)malloc(100);<br>}<br><br>void Test(void) {<br>&nbsp;&nbsp;&nbsp;&nbsp;char *str = NULL;<br>&nbsp;&nbsp;&nbsp;&nbsp;GetMemory(str);<br>&nbsp;&nbsp;&nbsp;&nbsp;strcpy(str, ""hello"");<br>}</code><br><br>strcpy会成功吗？"	"<b>strcpy会失败 → 段错误</b><br><br><b>核心原因：C语言是按值传递</b><br><br><b>执行流程：</b><br><code>// 1. 调用GetMemory(str)<br>// str的值(NULL)被复制给参数p<br>// p是局部变量，与str无关<br><br>// 2. 函数内 p = malloc(100)<br>// 只修改了局部变量p<br>// str仍然是NULL<br><br>// 3. 函数返回<br>// p销毁，malloc的内存泄漏<br>// str依然是NULL<br><br>// 4. strcpy(NULL, ""hello"")<br>// 向NULL地址写入 → 段错误💥</code><br><br><b>正确写法：</b><br><code>// 方法1：传指针的指针<br>void GetMemory(char **p) {<br>&nbsp;&nbsp;&nbsp;&nbsp;*p = malloc(100);<br>}<br>GetMemory(&str);<br><br>// 方法2：返回指针<br>char* GetMemory(void) {<br>&nbsp;&nbsp;&nbsp;&nbsp;return malloc(100);<br>}<br>str = GetMemory();</code><br><br><b>口诀：</b>要改指针，传指针的指针"	C语言::指针::指针传递 C语言::内存::内存泄漏 C语言::陷阱::按值传递 面试::高频
"<b>【快速判断】堆和栈的5个区别</b><br><br>从以下维度说明：<br>1. 分配方式<br>2. 释放方式<br>3. 大小限制<br>4. 生长方向<br>5. 访问速度"	"<table border='1' cellpadding='6' style='width:100%;border-collapse:collapse;'><tr><th>维度</th><th>栈</th><th>堆</th></tr><tr><td>分配方式</td><td>自动（编译器）</td><td>手动（malloc）</td></tr><tr><td>释放方式</td><td>自动（离开作用域）</td><td>手动（free）</td></tr><tr><td>大小限制</td><td>小（1-8MB）</td><td>大（GB级）</td></tr><tr><td>生长方向</td><td>向下（高→低地址）</td><td>向上（低→高地址）</td></tr><tr><td>访问速度</td><td>快（移指针）</td><td>慢（查找空闲块）</td></tr></table><br><b>记忆主线：</b><br>• 栈是<b>自动</b>的：自动分配、自动释放、空间小、速度快<br>• 堆是<b>手动</b>的：手动分配、手动释放、空间大、速度慢<br><br><b>常见追问：</b><br>• 栈溢出：无限递归、超大局部数组<br>• 堆问题：内存泄漏、碎片化"	C语言::内存::堆栈对比 面试::高频
"<b>【代码阅读】自增运算符陷阱</b><br><br>假设初始a=0, b=0，执行以下代码：<br><code>a = a++;<br>b = a++;</code><br><br>最终a和b的值是多少？"	"<b>答案：a=1, b=0</b><br><br><b>执行步骤：</b><br><br>第1行 <code>a = a++</code>：<br><code>temp = a;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 1. 返回当前值 = 0<br>a = a + 1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 2. a自增 = 1<br>a = temp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 3. 赋值 = 0</code><br>结果：a = 0<br><br>第2行 <code>b = a++</code>：<br><code>temp = a;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 1. 返回当前值 = 0<br>a = a + 1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 2. a自增 = 1<br>b = temp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 3. 赋值 = 0</code><br>结果：a = 1, b = 0<br><br><b>后缀++本质：</b><br>1. 先返回当前值<br>2. 再自增<br>3. 最后赋值<br><br><b>对比：</b><br>• <code>++x</code> → 先增后返回<br>• <code>x++</code> → 先返回后增<br><br><b>警告：</b>避免写<code>a = a++</code>！"	C语言::运算符::自增 C语言::陷阱::表达式求值
"<b>【陷阱】有符号无符号混合运算</b><br><br>以下代码输出什么？<br><br><code>unsigned int a = 1;<br>int b = -1;<br>if (a > b)<br>&nbsp;&nbsp;&nbsp;&nbsp;printf(""a > b"");<br>else<br>&nbsp;&nbsp;&nbsp;&nbsp;printf(""a <= b"");</code>"	"<b>输出：a <= b</b> （违反直觉！）<br><br><b>原因：类型提升规则</b><br><br>C语言规则：<br>• 有符号与无符号运算 → <b>有符号转为无符号</b><br><br><b>转换过程：</b><br><code>// 1. b = -1 (int)<br>// 二进制补码：0xFFFFFFFF<br><br>// 2. 转为unsigned int<br>// 0xFFFFFFFF解释为无符号<br>// = 4294967295 (2³²-1)<br><br>// 3. 比较<br>// 1 > 4294967295 → false<br>// 输出 ""a <= b""</code><br><br><b>避免方法：</b><br><code>// 方法1：显式转换<br>if ((int)a > b)<br><br>// 方法2：统一类型<br>int a = 1;<br><br>// 方法3：先判断符号<br>if (b < 0 || a > (unsigned)b)</code><br><br><b>记住：</b>有符号→无符号的转换规则"	C语言::类型转换::隐式转换 C语言::陷阱::类型提升 面试::高频
"<b>【语法】数组定义规则</b><br><br>以下哪个数组定义是正确的？<br><br>A. <code>int num[0..100];</code><br>B. <code>int num[];</code><br>C. <code>int N=100; int num[N];</code><br>D. <code>#define N 100; int num[N];</code>"	"<b>正确答案：C (C99), D (所有标准)</b><br><br><b>分析：</b><br><br>A. <code>int num[0..100]</code> - ✗<br>• C语言不支持范围表示法<br><br>B. <code>int num[]</code> - ✗<br>• 不指定大小必须：<br>&nbsp;&nbsp;① 提供初始化列表 或<br>&nbsp;&nbsp;② 作为函数参数<br><br>C. <code>int N=100; int num[N]</code> - ✓ (C99)<br>• C99引入VLA（变长数组）<br>• 允许用变量定义数组大小<br>• C89不支持<br><br>D. <code>#define N 100; int num[N]</code> - ✓<br>• #define是预处理替换<br>• 生成编译时常量<br>• 所有标准都支持<br><br><b>记忆：</b>#define总是安全的"	C语言::数组::定义规则
"<b>【陷阱】数组名退化</b><br><br>列举数组名退化和不退化的场景"	"<b>会退化为指针：</b><br>1. 作为右值在表达式中<br>&nbsp;&nbsp;&nbsp;<code>int *p = arr;</code><br>2. 作为函数参数<br>&nbsp;&nbsp;&nbsp;<code>void f(int arr[])</code> 等价于 <code>int *arr</code><br>3. 指针运算<br>&nbsp;&nbsp;&nbsp;<code>arr + 1</code><br><br><b>不会退化：</b><br>1. sizeof运算<br>&nbsp;&nbsp;&nbsp;<code>sizeof(arr)</code> → 整个数组大小<br>2. &运算<br>&nbsp;&nbsp;&nbsp;<code>&arr</code> → 指向整个数组的指针<br>3. 初始化时<br>&nbsp;&nbsp;&nbsp;<code>int arr[] = {1,2,3};</code><br><br><b>示例：</b><br><code>char arr[] = ""abcde"";<br>sizeof(arr);&nbsp;&nbsp;// 6 (不退化)<br>arr + 1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 退化为指针<br>&arr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// char(*)[6] (不退化)</code>"	C语言::数组::数组退化
"<b>【语法】sizeof表达式</b><br><br>给定：<br><code>char szName[] = ""abcde"";<br>char *pName = szName;</code><br><br>sizeof(szName)和sizeof(pName)的值是？"	"<b>答案：</b><br>• <code>sizeof(szName)</code> = <b>6</b><br>• <code>sizeof(pName)</code> = <b>4或8</b><br><br><b>原因：</b><br><br>sizeof(szName)：<br>• szName是数组<br>• ""abcde"" + '\\0' = 6字节<br>• 数组名在sizeof中<b>不退化</b><br><br>sizeof(pName)：<br>• pName是指针<br>• 32位系统 = 4字节<br>• 64位系统 = 8字节<br><br><b>记忆：</b><br>sizeof(数组) → 看整体<br>sizeof(指针) → 看指针本身"	C语言::sizeof C语言::数组
"<b>【陷阱】返回局部变量地址</b><br><br>以下代码有什么问题？<br><br><code>char *GetStr() {<br>&nbsp;&nbsp;&nbsp;&nbsp;char p[] = ""hello"";<br>&nbsp;&nbsp;&nbsp;&nbsp;return p;<br>}</code>"	"<b>问题：返回悬空指针</b><br><br><b>分析：</b><br>1. p是局部数组，在栈上分配<br>2. 函数返回后，栈内存被释放或覆盖<br>3. 返回的指针指向无效内存<br>4. 使用该指针 → 未定义行为<br><br><b>正确做法：</b><br><br>方法1：返回字符串字面量<br><code>char *GetStr() {<br>&nbsp;&nbsp;&nbsp;&nbsp;return ""hello"";&nbsp;&nbsp;// 只读区，生命周期=程序<br>}</code><br><br>方法2：使用static<br><code>char *GetStr() {<br>&nbsp;&nbsp;&nbsp;&nbsp;static char p[] = ""hello"";<br>&nbsp;&nbsp;&nbsp;&nbsp;return p;<br>}</code><br><br>方法3：动态分配<br><code>char *GetStr() {<br>&nbsp;&nbsp;&nbsp;&nbsp;char *p = malloc(6);<br>&nbsp;&nbsp;&nbsp;&nbsp;strcpy(p, ""hello"");<br>&nbsp;&nbsp;&nbsp;&nbsp;return p;&nbsp;&nbsp;// 调用者需要free<br>}</code><br><br><b>对比：</b><br>• <code>char *p = ""hello"";</code> → 返回安全（只读区）<br>• <code>char p[] = ""hello"";</code> → 返回危险（栈）"	C语言::函数::局部变量 C语言::指针::悬空指针 面试::高频
"<b>【关键字】static的作用</b><br><br>说明static在不同位置的作用"	"<b>static局部变量：</b><br>• 存储在<b>静态区</b>（非栈）<br>• 只初始化<b>一次</b><br>• 生命周期 = 程序运行期<br>• 作用域 = 函数内部<br><br>示例：<br><code>void func() {<br>&nbsp;&nbsp;&nbsp;&nbsp;static int count = 0;&nbsp;&nbsp;// 只初始化一次<br>&nbsp;&nbsp;&nbsp;&nbsp;count++;<br>&nbsp;&nbsp;&nbsp;&nbsp;printf(""%d"", count);&nbsp;&nbsp;// 累加<br>}</code><br><br><b>static全局变量/函数：</b><br>• 限定在<b>当前文件</b><br>• 避免命名冲突<br>• 其他文件不可访问<br><br>示例：<br><code>static int global = 10;&nbsp;&nbsp;// 仅本文件可见<br>static void helper() {}&nbsp;&nbsp;&nbsp;// 仅本文件可调用</code><br><br><b>记忆：</b><br>static = 静态 = 生命周期长 + 作用域窄"	C语言::关键字::static
"<b>【内存】结构体内存对齐</b><br><br>以下结构体的大小是？（32位系统）<br><br><code>struct Test {<br>&nbsp;&nbsp;&nbsp;&nbsp;char a;<br>&nbsp;&nbsp;&nbsp;&nbsp;int b;<br>&nbsp;&nbsp;&nbsp;&nbsp;char c;<br>};</code>"	"<b>答案：12字节</b><br><br><b>内存布局：</b><br><code>偏移0:&nbsp;&nbsp;&nbsp;char a&nbsp;&nbsp;&nbsp;&nbsp;(1字节)<br>偏移1-3: padding&nbsp;&nbsp;&nbsp;(3字节，对齐int)<br>偏移4-7: int b&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(4字节)<br>偏移8:&nbsp;&nbsp;&nbsp;char c&nbsp;&nbsp;&nbsp;&nbsp;(1字节)<br>偏移9-11:padding&nbsp;&nbsp;&nbsp;(3字节，整体对齐)</code><br><br><b>对齐规则：</b><br>1. 每个成员对齐到<b>自身大小</b>的倍数<br>2. 结构体对齐到<b>最大成员</b>的倍数<br>3. 结构体总大小是<b>最大成员对齐</b>的倍数<br><br><b>优化技巧：</b><br><code>// 优化前（12字节）<br>struct Test {<br>&nbsp;&nbsp;&nbsp;&nbsp;char a;&nbsp;&nbsp;// 浪费3字节padding<br>&nbsp;&nbsp;&nbsp;&nbsp;int b;<br>&nbsp;&nbsp;&nbsp;&nbsp;char c;&nbsp;&nbsp;// 浪费3字节padding<br>};<br><br>// 优化后（8字节）<br>struct Test {<br>&nbsp;&nbsp;&nbsp;&nbsp;int b;&nbsp;&nbsp;&nbsp;// 4字节<br>&nbsp;&nbsp;&nbsp;&nbsp;char a;&nbsp;&nbsp;// 1字节<br>&nbsp;&nbsp;&nbsp;&nbsp;char c;&nbsp;&nbsp;// 1字节<br>&nbsp;&nbsp;&nbsp;&nbsp;// padding 2字节<br>};</code><br><br><b>记忆：</b>把大的放前面，小的放一起"	C语言::结构体::内存对齐
"<b>【陷阱】段错误的常见原因</b><br><br>列举导致段错误的常见原因"	"<b>常见原因：</b><br><br>1. <b>访问无效内存</b><br><code>int *p = NULL;<br>*p = 10;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 空指针<br><br>int *p;<br>*p = 10;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 野指针<br><br>free(p);<br>*p = 10;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 悬空指针</code><br><br>2. <b>访问受保护内存</b><br><code>char *s = ""hello"";<br>s[0] = 'H';&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 修改只读区</code><br><br>3. <b>数组越界</b>（可能）<br><code>int arr[5];<br>arr[10] = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 越界访问</code><br><br>4. <b>栈溢出</b><br><code>void func() {<br>&nbsp;&nbsp;&nbsp;&nbsp;func();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 无限递归<br>}</code><br><br><b>调试工具：</b><br>• gdb<br>• valgrind<br>• AddressSanitizer"	C语言::调试::段错误 面试::高频
"<b>【内存】内存泄漏的场景</b><br><br>列举导致内存泄漏的常见原因"	"<b>常见场景：</b><br><br>1. <b>忘记free</b><br><code>void f() {<br>&nbsp;&nbsp;&nbsp;&nbsp;char *p = malloc(100);<br>&nbsp;&nbsp;&nbsp;&nbsp;// 忘记free(p)<br>}&nbsp;&nbsp;// 函数返回，p销毁，内存泄漏</code><br><br>2. <b>提前return</b><br><code>char *p = malloc(100);<br>if (error) return;&nbsp;&nbsp;// p泄漏<br>free(p);</code><br><br>3. <b>重复分配</b><br><code>char *p = malloc(100);<br>p = malloc(200);&nbsp;&nbsp;&nbsp;&nbsp;// 前100字节泄漏</code><br><br>4. <b>循环中分配</b><br><code>for (int i = 0; i < 1000; i++) {<br>&nbsp;&nbsp;&nbsp;&nbsp;char *p = malloc(100);<br>&nbsp;&nbsp;&nbsp;&nbsp;// 忘记free(p)<br>}&nbsp;&nbsp;// 泄漏100KB</code><br><br><b>检测工具：</b><br>• valgrind --leak-check=full<br>• AddressSanitizer (-fsanitize=address)"	C语言::内存::内存泄漏 面试::高频
"<b>【对比】malloc/calloc/realloc</b><br><br>说明三个函数的区别"	"<table border='1' cellpadding='6' style='width:100%;border-collapse:collapse;'><tr><th>函数</th><th>初始化</th><th>参数</th><th>用途</th></tr><tr><td><b>malloc</b></td><td>不初始化<br>（内容随机）</td><td>字节数</td><td>分配内存</td></tr><tr><td><b>calloc</b></td><td>初始化为0</td><td>数量+大小</td><td>分配并清零</td></tr><tr><td><b>realloc</b></td><td>保留原内容</td><td>指针+新大小</td><td>调整大小</td></tr></table><br><b>函数原型：</b><br><code>void* malloc(size_t size);<br>void* calloc(size_t n, size_t size);<br>void* realloc(void* ptr, size_t size);</code><br><br><b>关键陷阱：</b><br><code>// 错误写法<br>p = realloc(p, new_size);&nbsp;&nbsp;// 失败时p变NULL<br><br>// 正确写法<br>void *temp = realloc(p, new_size);<br>if (temp) {<br>&nbsp;&nbsp;&nbsp;&nbsp;p = temp;<br>} else {<br>&nbsp;&nbsp;&nbsp;&nbsp;// p仍有效，需要free(p)<br>}</code><br><br><b>记忆：</b><br>• malloc → 快，不清零<br>• calloc → 慢，清零<br>• realloc → 调整，保留内容"	C语言::内存::动态分配 面试::高频
"{{c1::malloc}}分配内存，{{c2::不初始化}}，内容{{c3::随机}}<br>{{c4::calloc}}分配内存，{{c5::初始化为0}}<br>{{c6::realloc}}调整内存大小，{{c7::保留原内容}}"	C语言::内存::动态分配 面试::速记
"const如果在{{c1::*}}前，修饰{{c2::指向的值}}，{{c3::指向}}可变<br>const如果在{{c1::*}}后，修饰{{c4::指向(指针本身)}}，{{c5::指向的值}}可变"	C语言::指针::const 面试::速记
"后缀自增<code>x++</code>：{{c1::先返回}}当前值，{{c2::再自增}}<br>前缀自增<code>++x</code>：{{c3::先自增}}，{{c4::再返回}}新值"	C语言::运算符::自增
"在{{c1::32}}位系统下，任何指针长度都是{{c2::4}}字节<br>在{{c3::64}}位系统下，任何指针长度都是{{c4::8}}字节"	C语言::指针::指针大小
"数组名会退化：<br>1. 作为{{c1::右值}}在表达式中<br>2. 作为{{c2::函数参数}}<br><br>数组名不退化：<br>1. {{c3::sizeof}}运算<br>2. {{c4::&}}运算<br>3. {{c5::初始化}}时"	C语言::数组::数组退化
"static局部变量存储在{{c1::静态区}}，只初始化{{c2::一次}}<br>static全局变量限定在{{c3::当前文件}}<br>static函数只能在{{c4::当前文件}}调用"	C语言::关键字::static
"有符号和无符号混合运算时，{{c1::有符号}}转为{{c2::无符号}}<br>-1转为unsigned int等于{{c3::0xFFFFFFFF}}（{{c4::最大值}}）"	C语言::类型转换::隐式转换
"全局变量存储在{{c1::数据段}}<br>局部变量存储在{{c2::栈}}<br>malloc分配在{{c3::堆}}<br>字符串字面量在{{c4::只读段}}"	C语言::内存::内存分区
"联合体成员{{c1::共享内存}}<br>联合体大小取{{c2::最大成员}}<br>结构体成员{{c3::独立存储}}<br>结构体大小是{{c4::所有成员之和}}（+对齐）"	C语言::结构体联合体
"段错误原因：<br>{{c1::空指针}}解引用<br>{{c2::野指针}}解引用<br>{{c3::悬空指针}}解引用<br>修改{{c4::只读内存}}<br>{{c5::栈溢出}}"	C语言::调试::段错误
