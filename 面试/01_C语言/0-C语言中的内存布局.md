# C语言中有关内存布局的概念

C语言的内存布局（`Memory Layout`）是指C程序在**运行时**，其**进程在内存中的组织结构和分配方式**。这是一个经典的编程概念，主要用于理解程序如何使用内存资源、避免内存错误（如溢出、泄漏），并优化性能。

内存布局指的是：程序被OS加载并执行时，作为进程在内存中的动态结构。可执行文件被加载到内存，OS初始化段，程序运行时堆和栈动态变化。

C语言的内存布局本质上是操作系统中的内存概念：

- 它基于**操作系统的进程内存模型**。OS（如Linux的内核）**为每个进程提供一个独立的虚拟内存空间**（通常从0x00000000到高地址，如64位系统的2^64-1）。
- OS负责内存的分配、保护和分页（paging）。例如，文本段被标记为只读，栈和堆有增长限制。C语言通过标准库（如stdlib.h的malloc）与OS交互，**但底层是OS的系统调用（如brk()或mmap()）**。
- 这不是C语言独有的，而是通用于许多语言（如C++），但C强调手动管理，因此布局概念更突出。如果没有OS（如裸机嵌入式系统），内存布局可能简化，由程序员直接定义。

## 整体布局

- **Linux下32位环境的用户空间内存分布情况**

对于32位环境，理论上程序可以拥有4GB的虚拟地址空间，我们在C语言中使用到的变量、函数、字符串等都会对应内存中的一块区域。

- 但是，在这 4GB 的地址空间中，要拿出一部分给操作系统内核使用，应用程序无法直接访问这一段内存，这一部分内存地址被称为内核空间（Kernel Space）。
- Windows 在默认情况下会将高地址的 2GB 空间分配给内核（也可以配置为1GB），而 Linux默认情况下会将高地址的1GB 空间分配给内核。也就是说，应用程序只能使用剩下的 2GB 或 3GB 的地址空间，称为用户空间（User Space）。

**那如果两个C语言程序正在运行的话。那么他们的内存模型应该是共享内核空间。用户空间再分为具体的独立空间。关于用户空间中的分布可以参考C语言的内存布局。**

![img](./0-C语言中的内存布局.assets/1852906-20220430161404050-235745048.jpg)

## 程序代码区

**存放函数体的二进制代码。一个C语言程序由多个函数构成，C语言程序的执行就是函数之间的相互调用**。

## 常量区

**存放一般的常量、字符串常量等。这块内存只有读取权限，没有写入权限，因此它们的值在程序运行期间不能改变。**

## 全局数据区

**存放全局变量、静态变量等。**这块内存有读写权限，因此它们的值在程序运行期间可以任意改变。

## **堆区**

一般由程序员分配和释放，若程序员不释放，程序运行结束时由操作系统回收。**malloc()、calloc()、free() 等函数操作的就是这块内存**，这也是本章要讲解的重点。

**注意：这里所说的堆区与数据结构中的堆不是一个概念，堆区的分配方式倒是类似于链表。**

(**个人**：这里的堆区上面的未被分配的内存，当我们动态分配内存时，堆区会向上增长，使用它上面的未分配的内存拿来作为堆内存，)

## **动态链接库**

**用于在程序运行期间加载和卸载动态链接库**。(**个人**：静态链接库已经在运行之前的链接阶段链接到可执行程序里面了，所以静态链接库里面的函数此时放置在**程序代码区**)

- **静态链接库**类似makefile中构建时加载的.a库函数文件（构建时（编译链接阶段））。程序中可以直接调用.a库中的库函数。
  - 更新库需重新编译整个程序，代码区指令不可更改。
- **动态链接库**可在程序运行期间动态加载/卸载，多个进程可共享同一份库代码（节省内存）。
  - 更新库只需替换 .so/.dll 文件（.so 在 Linux，.dll 在 Windows），无需重编程序。

## **栈区**

**存放函数的参数值、局部变量的值等**，其操作方式类似于数据结构中的栈**。(个人：**这里的栈区向下增长，使用它下面未被分配的内存**)**。

## 实例

```c
#include <stdio.h>
const char* str1 = "www.baidu.com";  //字符串在常量区，str1在全局数据区
int n;  //全局数据区
const char* func() {
    const char* str = "岳麓书院";  //字符串在常量区，str在栈区
    return str;
}
int main() {
    int a;  //栈区
    const char* str2 = "01234";  //字符串在常量区，str2在栈区
    char  arr[20] = "56789";  //字符串和arr都在栈区
    const char* pstr = func();  //栈区
    int b;  //栈区
    printf("str1: %p\npstr: %p\nstr2: %p\n", str1, pstr, str2);
    puts("--------------");
    printf("&str1: %p\n   &n: %p\n", &str1, &n);
    puts("--------------");
    printf("  &a: %p\n arr: %p\n  &b: %p\n", &a, arr, &b);
    puts("--------------");
    printf("n: %d\na :%d\nb: %d\n", n, a, b);
    puts("--------------");
    printf("%s\n", pstr);
    return 0;
}
```

- **全局变量的内存在编译时就已经分配好了，它的默认初始值是 0（它所占用的每一个字节都是0值），局部变量的内存在函数调用时分配，它默认初始值是不确定的，由编译器决定，一般是垃圾值**
- **函数 func() 中的局部字符串常量"岳麓书院"也被存储到常量区，不会随着 func() 的运行结束而销毁，所以最后依然能够输出**。
- **字符数组 arr[20] 在栈区分配内存，字符串"56789"就保存在这块内存中，而不是在常量区，大家要注意区分**。
  - (**个人**：这里char arr[20] = "56789"是对一个局部数组定义的同时进行初始化，是char arr[20] = {'5','6','7','8','9'\0'}的一种简写形式，而const char* arr = "56789"则是单纯的指针变量定义并初始化，这两者还是有区别的)

## 总结

- **程序代码区用来保存指令**，
- **常量区、全局数据区、堆、栈都用来保存数据**。

- **程序代码区、常量区、全局数据区在程序加载到内存后就分配好了，并且在程序运行期间一直存在，不能销毁也不能增加（大小已被固定），只能等到程序运行结束后由操作系统收回，所以全局变量、字符串常量等在程序的任何地方都能访问，因为它们的内存一直都在**。
- **函数被调用时，会将参数、局部变量、返回地址等与函数相关的信息压入栈中，函数执行结束后，这些信息都将被销毁。**所以局部变量、参数只在当前函数中有效，不能传递到函数外部，因为它们的内存不在了。
- **常量区、全局数据区、栈上的内存由系统自动分配和释放，不能由程序员控制**。
- **程序员唯一能控制的内存区域就是堆（Heap）：它是一块巨大的内存空间，常常占据整个虚拟空间的绝大部分**，在这片空间中，程序可以申请一块内存，并自由地使用（放入任何数据）。堆内存在程序主动释放之前会一直存在，不随函数的结束而失效。在函数内部产生的数据只要放到堆中，就可以在函数外部使用。

## 结合嵌入式

### 在嵌入式系统中（如微控制器），C语言的内存布局

在嵌入式C语言开发中（尤其是基于微控制器MCU的系统中），全局const变量通常会被放置在Flash（只读存储器）中。

大多数微控制器采用**改进的Harvard架构**：

- **Flash**：大容量、非易失性、只读（编程后不可随意修改），用于存储程序代码和常量数据。
- **RAM**：小容量、易失性、读写快速，用于运行时变量（全局非const、栈、堆）。

典型容量对比（常见MCU）：

- Flash：64KB ~ 2MB（甚至更大）
- SRAM（RAM）：几KB ~ 几百KB（如STM32F103：20KB RAM，64KB Flash）

**RAM非常宝贵**，不能随便浪费。因此，任何“运行时不需要修改”的数据，都应该尽量放在Flash中。

### 嵌入式C内存分布典型示意图（以STM32为例）

```c
Flash 区域（只读，非易失性，掉电保留）
0x08000000 ┌────────────────────────────┐
           │ 代码区 (.text)              │  ← 函数机器码，直接执行
           ├────────────────────────────┤
           │ 常量区 (.rodata)            │  ← const 全局变量、字符串、查找表
           ├────────────────────────────┤
           │ .data 初始值（镜像）        │  ← 上电时复制到RAM
           └────────────────────────────┘

RAM 区域（读写，易失性，上电清空）
0x20000000 ┌────────────────────────────┐
           │ .data（已初始化全局变量）   │
           ├────────────────────────────┤
           │ .bss（未初始化全局变量，清0）│
           ├────────────────────────────┤
           │ 堆（Heap，如果启用malloc）   │  ← 向上增长（很少用）
           ├────────────────────────────┤
           │ ... 空闲RAM ...             │
           ├────────────────────────────┤
           │ 栈（Stack）                 │  ← 向下增长（函数调用、局部变量）
           └────────────────────────────┘ 高地址
```

- 如果是 RTOS（最常见的轻量级 SoC + OS）： 是的，内存分布基本和裸机嵌入式一样 —— 代码 + const 放 Flash，全局/堆/栈放 RAM，极大程度节省 RAM。
- 如果是轻量级 Linux： 不再如此，更接近桌面系统，代码和常量加载到 RAM，有虚拟内存。

## 文章参考

[Linux下C语言程序的内存布局（内存模型）](https://www.cnblogs.com/zjuhaohaoxuexi/p/16210498.html)