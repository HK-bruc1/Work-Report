# 操作系统相关

## SMP

### 什么叫SMP

在嵌入式领域中，SMP是指一种对称多处理器架构，在该架构中，多个CPU共享同一个内存和I/O设备，并且所有CPU具有相同的权限和对称性（CPU都是相同的）。

### 有什么特点

- 多个CPU共享同一物理内存，每个CPU访问相同的地址空间
- 所有的CPU权限相同，可均衡的调度任务，没有主从之分。
- 多个CPU通过共享的缓存一致性协议保持数据同步，防止数据不一致问题。
- 任务可以在不同CPU之间动态调度，提高CPU资源利用率。
- 单个操作系统控制多个相同的CPU，实现负载均衡。

### 工作中的体现

比如我们耳机中的JL7016G，JL7096D这些新芯片有一些都是双核的。一般双核的性能要好些，比如心率检测功能在AC710N单核芯片上会跑不动出现复位现象，但是在双核的芯片下运行是没有问题的。

## FreeRTOS和RT-Thread的区别

这两个工作上接触的不多，他们都是开源的硬实时轻量级操作系统，FreeRTOS在国际上更加普遍，生态更加丰富以及解决方案比较成熟，之前有在STM32上使用过，主要是体验一下多线程并发，感受下裸机和库函数开发的差别。RT-Thread是国产的，之前看过官方文档，有较好的 POSIX 接口，移植到Linux比较方便。我接触的比较多的是zephyr，这个是Linux基金会推出的轻量级操作系统。当初接触他的原因是他的构建和编码不依赖于厂商，比如STM32还需要下对应的开发包。初始化还需要对应cubemx工具，太麻烦。而zephyr它硬件和软件是解耦的，硬件统一通过设备树DTS文件描述。而且zephyr支持的架构，SOC，开发板比较多。程序移植芯片和开发板比较方便。只需要修改DTS即可。

## 什么是原子操作

不可被打断、不可分割、对外表现为“瞬间完成”的操作。在多线程/多核环境下，对共享内存的某个操作（或一组紧密相关的操作）从其他所有线程/处理器看来，要么完全没发生，要么已经完整执行完毕，不存在“执行到一半”的中间状态。

### 工作中体现

比如我在切换ANC时，提示音没有报完，流程没有走完。这时我再切换一次ANC，就会触发锁存机制（互斥机制），那么ANC的状态还是上一次流程结束时的状态，这个操作就是原子性的，中途不能被打断。

## freertos中队列的应用场景？？？

freertos中队列的应用场景？ 我可以举一个例子，比如在多任务中，针对按键扫描的处理。 就是按键扫描发按键类型到消息队列中，这个时候一般会有一个地方执行获取消息的函数。从消息队列中拿消息根据消息类型去分发消息做不同的处理。 比如是按键消息就去指定的处理函数中执行。获取消息这个实现一般会有一个接口，没有消息时会一直“卡在”这里，获取到消息就会往下执行。

FreeRTOS 队列最典型的应用场景就是：
 **将“事件或数据”的产生与处理解耦，通过阻塞式消息接收，构建清晰、可扩展、低耦合的事件驱动系统。**

## 为什么FreeRTOS中信号量，队列，互斥量等设计中设置了两套函数实现

在cubemx的初始化代码中你就可以看到,FreeRTOS 为队列、信号量、互斥量等提供普通版本和 FromISR 版本，是因为任务上下文和中断上下文的执行约束完全不同，必须在 API 层面进行严格区分。

主要体现在三点：

1. **ISR 不能阻塞**，而任务版本的 API 允许阻塞和挂起任务；
2. **临界区和调度机制不同**，ISR 只能设置“需要切换任务”的标志，不能直接调度；
3. **保证实时性和可预测性**，避免在 API 内部做上下文判断，减少中断延迟并防止误用。

**信号量和互斥量底层都是基于队列实现的**，因此同样需要区分 `FromISR` 接口。

## FreerRTOS中的线程池

在 FreeRTOS 里，“线程池”通常指：

- **一组预先创建、长期存在的任务**
- 所有任务：
  - 具有相同或相近优先级
  - 执行同一类工作逻辑
- 通过：
  - 队列 / 消息队列
- 从“任务池”中取工作执行

```
        +-------------+
        |  工作队列   |
        +-------------+
          ↑        ↑
     Task A     Task B     Task C
    (Worker)   (Worker)   (Worker)

```

特点是：
 **任务不销毁、不动态创建，只是不断“取活干活”。**

### 线程池 vs 普通线程（任务）的本质区别

和普通任务相比，线程池的核心区别在于：

- **任务不按需创建和销毁，而是复用**
- 目的是**降低创建开销、避免内存碎片、提高实时性确定性**

本质上，线程池关注的是**执行资源的管理**，而普通任务更关注**功能逻辑的实现**。

### 工作中体现

**在 TWS 耳机这类轻量级 RTOS 系统中，通常会在系统初始化阶段一次性创建各类功能任务，运行过程中基本不再动态创建任务。**这是因为任务创建涉及内存分配和内核结构操作，时间和内存开销不可预测，不利于实时性和系统稳定性。因此运行期的高频工作一般通过**队列、事件或线程池模式**在已有任务上完成，而不是通过反复创建新任务。比如耳机中的**音频解码不适合用普通任务模型，是因为解码本身是高频、短时、计算密集的工作单元。**
 如果把解码和任务生命周期绑定，就会产生频繁创建/销毁任务的问题，破坏实时性。
 **线程池通过复用固定数量的 worker，把解码工作从线程中解耦，更容易应对负载波动，也更利于实时系统的确定性分析。**

## 进程（线程）有哪几种状态



# C语言相关

## 左值与右值的区别

### 核心区别

**左值(lvalue)**：指向内存中特定位置的表达式，可以取地址，具有持久的存储空间。 **右值(rvalue)**：临时的值，不占据持久的内存位置，不能取地址。

**常见的左值**

- 一些变量
- 地址与指针

**常见的右值**

- 算术表达式的结果
- 比较表达式的结果

### 关键点

**左值可以出现在赋值符号两边**，右值只能在右边：

```
int a = 5, b = 3;
a = b;      // 正确：左值 = 左值
a = 5;      // 正确：左值 = 右值
5 = a;      // 错误！右值不能被赋值
```

### 工作中的体现

比较常见的地方就是赋值操作，右值赋值给左值。

## 位域

- 位域(bit-field)确实常用于寄存器操作，但它提供了比位运算更直观的方式。
- 位域是结构体中的一种特殊成员，可以指定成员占用的**位(bit)数**，而不是字节数。

```c
struct 结构体名 {
    类型 成员名 : 位数;
};
```

```c
假设我们要操作一个8位的状态寄存器，各位含义如下：

bit 0: 使能位
bit 1-3: 模式选择(3位，0-7)
bit 4-6: 优先级(3位，0-7)
bit 7: 中断标志
```

**传统位运算方式**

```c
uint8_t status_reg = 0;

// 设置使能位
status_reg |= (1 << 0);

// 设置模式为5
status_reg &= ~(0x07 << 1);  // 先清零
status_reg |= (5 << 1);       // 再设置

// 读取优先级
uint8_t priority = (status_reg >> 4) & 0x07;
```

使用位域方式

```c
struct StatusReg {
    uint8_t enable    : 1;  // 占1位
    uint8_t mode      : 3;  // 占3位
    uint8_t priority  : 3;  // 占3位
    uint8_t int_flag  : 1;  // 占1位
};

//实例化一个结构体变量
struct StatusReg status = {0};

// 操作变得非常直观
status.enable = 1;
status.mode = 5;
uint8_t priority = status.priority;
```

## 位域的优缺点

**优点：**

- 代码可读性强，一目了然
- 自动处理位移和掩码
- 节省内存（多个小数据打包存储）

**缺点：**

- 可能影响性能（某些平台）

## 工作中的体现

工作中很少直接操作寄存器的位了。一般都有接口。

