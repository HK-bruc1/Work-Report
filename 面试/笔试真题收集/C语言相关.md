# 一、C语言基础

## 1.1 数据类型与变量

### 1.1.1 结构体内存对齐 【选择题】

> **考点**：结构体大小计算、内存对齐规则（对齐到最大成员大小的整数倍）
> **注意**：`short` 2字节、`char` 1字节、`float` 4字节，对齐后可能有填充字节

设 `struct{ short a; char b; float c; } cs;` 则 `sizeof(cs)` 的值是（  ）

- **A.** 4
- **B.** 5
- **C.** 6
- **D.** 7

------

无论32位还是64位，大小固定：

| 类型        | 大小   |
| ----------- | ------ |
| `char`      | 1 字节 |
| `short`     | 2 字节 |
| `int`       | 4 字节 |
| `long long` | 8 字节 |
| `float`     | 4 字节 |
| `double`    | 8 字节 |

32位 vs 64位 有区别的：

| 类型   | 32位   | 64位                   |
| ------ | ------ | ---------------------- |
| `long` | 4 字节 | 8 字节（Windows仍为4） |
| 指针   | 4 字节 | 8 字节                 |

简单记：**只有 `long` 和指针会变**，其余都固定。

#### 内存大小对齐口诀

结构体不是简单地将成员大小相加，编译器会进行**内存对齐（alignment）**：

1. **成员对齐**：每个成员的起始地址必须是其自身大小的整数倍
2. **结构体总大小**：必须是最大成员大小的整数倍（用于数组时保证每个元素对齐）

```c
最大成员：int = 4字节

char a;  // size=1，offset=0，offnext=0+1=1
int  b;  // size=4，offset=4（填充3字节，4-1=3），offnext=4+4=8
char c;  // size=1，offset=8，offnext=8+1=9

原始大小=9，向上取整到4的倍数，填充3字节 → 总大小=12
```

- 实在忘记了就画内存占用格子示意图

### 1.1.2 共用体的大小

**核心规则**

共用体所有成员**共享同一块内存**，从同一地址开始存放，因此：

1. **大小 = 最大成员的大小**
2. **同样需要内存对齐**，总大小必须是最大成员大小的整数倍

```c
union U1 {
    char  a;   // 1字节
    int   b;   // 4字节
    short c;   // 2字节
};
```

最大成员是 int = 4字节，所以 `sizeof(U1) = 4`

所有成员都从同一地址开始，修改任意一个成员会影响其他成员的值。

#### 与结构体的对比

|          | 结构体 struct               | 共用体 union                 |
| -------- | --------------------------- | ---------------------------- |
| 成员关系 | 各成员独立，顺序存放        | 所有成员共享同一块内存       |
| 大小计算 | 所有成员大小之和 + 填充字节 | 最大成员大小 + 对齐填充      |
| 同时存储 | 可以同时保存所有成员的值    | 同一时刻只能保存一个成员的值 |

### 1.1.2 左值和右值的区别 【问答题】

> **考点**：左值（可被赋值、有明确内存地址的表达式）与右值（临时值、不可取地址）的概念
> **注意**：赋值号左边必须是左值；常量、表达式结果通常是右值

请解释左值和右值的区别。

<details><summary>💡 答案提示</summary>
<ul>
<li><b>左值（lvalue）</b>：有确定内存地址、可出现在赋值运算符左边的表达式。如变量 <code>x</code>、数组元素 <code>a[0]</code>、解引用 <code>*p</code></li>
<li><b>右值（rvalue）</b>：没有持久地址的临时值，只能出现在赋值运算符右边。如字面量 <code>10</code>、表达式 <code>a+b</code>、函数返回值</li>
</ul>
</details>

---

### 1.1.3 浅拷贝与深拷贝的区别 【问答题】

> **考点**：值拷贝 vs 内容拷贝，指针成员的处理方式
> **注意**：浅拷贝仅复制指针值，两个对象共享同一块内存；深拷贝会重新分配内存空间并复制内容

请解释浅拷贝与深拷贝的区别。

<details><summary>💡 答案提示</summary>
<ul>
<li><b>浅拷贝</b>：逐字节复制，指针成员只复制地址值 → 两个对象指向<b>同一块内存</b>，一方修改内容会影响另一方</li>
<li><b>深拷贝</b>：为指针成员<b>重新分配内存</b>并复制内容 → 两个对象完全独立</li>
</ul>
</details>



---

### 1.1.4 字符串赋值方式判断 【选择题】

> **考点**：字符数组初始化与赋值的合法方式
> **注意**：数组名是常量地址，不能用 `=` 直接赋值字符串；`strcpy` 和逐字符初始化是合法的；字符串是末尾带 `\0` 的字符数组，指定长度的初始化会自动补 `\0`，不指定长度则不会

以下对字符数组 `test` 赋值方式**错误**的是（  ）

- **A.** `char test[10]; strcpy(test, "test");`
- **B.** `char test[10]; test = "test";`
- **C.** `char test[] = {'t','e','s','t'};`
- **D.** `char test[10] = {'t','e','s','t'};`

------

```c
数组名 test 是常量地址，不可用 = 赋值。只有在声明时才能用 = 初始化，声明后赋值必须用 strcpy。
另外注意 C 选项 char test[] = {'t','e','s','t'} 长度由内容决定为4，没有 \0，是字符数组而非字符串；D 选项 char test[10] 剩余位置自动补 \0，是合法字符串。
    
字符数组不一定是字符串（没有 \0 就不是）
字符串一定是字符数组
    
声明时可以用 = 初始化：
char test[10] = "test";   // 合法，声明时初始化
char test[] = "test";     // 合法，声明时初始化
声明后不能用 = 赋值，只能用 strcpy
char test[10];
test = "test";            // 非法，数组名是常量地址
strcpy(test, "test");     // 合法    
```

### 2.7 字符串赋值 【选择题】

下面各语句中，能正确进行赋字符串操作的语句是？

```c
A: char s[5] = {'a','b','c','d','e','\0'};
B: char *s; s = "abcde";
C: char *s; scanf("%s", &s);
D: char s[5] = {"abcde"};
```

<details><summary>💡 答案提示</summary>
<p><b>答案：B <code>char *s; s = "abcde";</code></b></p>
<table>
<tr><th>选项</th><th>分析</th></tr>
<tr><td>A</td><td><code>char s[5]</code> 数组大小为5，但初始化列表有6个元素，<b>数组越界</b>，编译器会报错</td></tr>
<tr><td>B</td><td>正确，指针指向字符串字面量首地址 ✓</td></tr>
<tr><td>C</td><td>试图通过一个<b>未初始化的指针</b>来接收输入数据。指针没有指向合法缓冲区</td></tr>
<tr><td>D</td><td><code>"abcde"</code>含隐含的<code>\0</code>共6字节，数组只有5字节，<b><code>\0</code>被截断</b>，结果不是合法的C字符串</td></tr>
</table>
</details>


### 1.1.5 二维数组的初始化方式判断 【选择题】

> **考点**：二维数组初始化语法——花括号嵌套 vs 逗号表达式、行列匹配
> **注意**：`(0,1,2)` 是逗号表达式而非花括号初始化；行数不能超过声明；元素不足自动补0；行数可以省略由编译器推导，但列数必须显式指定；元素总数不能超过声明大小

以下二维数组初始化方式正确的是（  ）

- **A.** `int a[2][3] = ((0,1,2),(3,4,5));` — 圆括号是逗号表达式，非法
- **B.** `int a[2][3] = {{0,1,2},{3,4,5}};` — 标准写法
- **C.** `int a[2][3] = {{0,1},{2,3},{4,5}};` — 3行但只声明了2行，非法
- **D.** `int a[2][3] = {0,1,2,3,4};` — 线性初始化，合法（不足补0）
- **E**. `int a[][3] = {{0,1,2},{3,4,5}};` — 行数省略，由编译器推导为2，合法
- **F**. `int a[2][] = {{0,1,2},{3,4,5}};` — 列数省略，非法
- **G**. `int a[2][3] = {{0,1}};` — 部分初始化，不足补0，合法
- **H**. `int a[2][3] = {0,1,2,3,4,5,6};` — 元素超出总大小6，非法

<details><summary>💡 答案提示</summary>
<p><b>答案：B、D、E、G</b></p>
<ul>
<li>A 错在用了圆括号 <code>()</code>，逗号表达式 <code>(0,1,2)</code> 的值只是 <code>2</code></li>
<li>C 错在花括号内有3组，但行数声明为2</li>
<li>F 错在列数省略，列数必须显式指定</li>
<li>H 错在元素总数7超出声明大小2×3=6</li>
<li>E 合法，行数由编译器自动推导为2</li>
<li>G 合法，不足的元素自动补0</li>
</ul>
</details>



---

### 1.1.6 sizeof 与 strlen 的区别 【问答题】

> **考点**：`sizeof` 是运算符（编译期）、`strlen` 是库函数（运行期）；`sizeof` 包含 `\0`，`strlen` 不包含
> **注意**：`sizeof` 对数组名返回整个数组的总字节大小，对指针返回指针本身大小（4/8字节），这是常见陷阱

简述 `sizeof` 和 `strlen` 的区别。

<details><summary>💡 答案提示</summary>
<table>
<tr><th>区别</th><th><code>sizeof</code></th><th><code>strlen</code></th></tr>
<tr><td>性质</td><td><b>运算符</b>，编译期求值</td><td><b>库函数</b>（<code>&lt;string.h&gt;</code>），运行期求值</td></tr>
<tr><td><code>\0</code></td><td><b>包含</b> <code>\0</code></td><td><b>不包含</b> <code>\0</code></td></tr>
<tr><td>计算对象</td><td>任意类型占用的<b>内存字节数</b></td><td>字符串的<b>有效字符个数</b></td></tr>
<tr><td>参数</td><td>类型或变量</td><td>必须是 <code>char*</code>（以<code>\0</code>结尾）</td></tr>
</table>
<pre><code>char str[] = "hello";
sizeof(str);  // 6（含'\0'）
strlen(str);  // 5（不含'\0'）</code></pre>
<p><b>注意点：</b></p>
<ul>
<li><b>指针 vs 数组</b>：<code>sizeof(p)</code> 得到的是指针本身大小（4或8），不是字符串长度；<code>strlen(p)</code> 正常工作</li>
<li><b>数组退化</b>：数组作为参数传入函数后退化为指针，函数内 <code>sizeof(arr)</code> 只能得到指针大小，不是数组大小</li>
<li><b>没有 <code>\0</code> 时</b>：<code>strlen</code> 会一直往后找直到遇到 <code>\0</code>，造成越界，未定义行为</li>
<li><b><code>strlen</code> 返回值是 <code>size_t</code>（无符号）</b>：做减法时需谨慎。无符号整数遵循<b>环形模运算</b>：
  <ul>
    <li>32位下，无符号数范围是 <code>0 ~ 2^32-1</code>，结果超出范围就对 <code>2^32</code> 取模</li>
    <li>可以理解为一个<b>环形数轴</b>，从0减到头不会变负，而是从最大值那端绕回来，如 <code>0 - 1 = 4294967295</code></li>
    <li>因此 <code>strlen(str) - 10</code> 在结果"应为负"时会变成很大的正数（如 <code>2 - 10 = 4294967288</code>），导致条件判断出错</li>
    <li>这种现象叫<b>整数下溢（underflow）</b>，与之对应的超出最大值叫<b>整数上溢（overflow）</b></li>
    <li>建议改用 <code>></code> 直接比较或强制转换为 <code>int</code>：
      <pre><code>if (strlen(str) > 10) { }         // 推荐
if ((int)strlen(str) - 10 > 0) { } // 或强制转换</code></pre>
    </li>
  </ul>
</li>
</ul>
</details>



---

## 1.2 指针

### 1.2.1 数组指针 vs 指针数组 【问答题】

> **考点**：`int (*p)[5]` 是指向数组的指针，`int *p[5]` 是指针数组——括号位置决定含义
> **注意**：看 `*` 先和谁结合：`(*p)` 先和括号结合，p是指针；`*p[]` 先和 `[]` 结合，p是数组；数组指针必须用 `&数组名` 赋值；解引用要加括号 `(*p)[i]`；可用于指向二维数组的行；两者 `sizeof` 结果完全不同

```c
int a[5];
int (*p)[5] = &a;   // 指向数组的指针
int *q[5];           // 指针数组（5个int指针组成的数组）
```

写出自己定义的数组指针和指针数组。

💡 **答案提示**

| 区别     | 数组指针 `int (*p)[5]`              | 指针数组 `int *p[5]`         |
| -------- | ----------------------------------- | ---------------------------- |
| 本质     | 一个**指针**，指向长度为5的int数组  | 一个**数组**，含5个int指针   |
| 赋值     | 必须用 `&a`，不能用 `a`（一维数组） | 每个元素单独赋值             |
| 解引用   | `(*p)[i]`，括号不能省               | `*p[i]`，取第i个指针指向的值 |
| sizeof   | 4或8（只是一个指针）                | 20或40（5个指针的数组）      |
| 使用场景 | 指向二维数组的行                    | 存储多个指针，如字符串数组   |

**注意点：**

- **赋值方式**：数组指针必须用 `&a`，`a` 是 `int*`，`&a` 才是 `int(*)[5]`
- **解引用**：`(*p)[0]` 才正确，`*p[0]` 因优先级问题等价于 `*(p[0])`，含义完全不同
- **指向二维数组**：`int (*p)[5] = a` 可指向二维数组第一行，`p++` 会跨越一整行（5个int）
- **口诀**：看 `*` 先和谁结合——`(*p)` 先和括号结合，p是指针；`*p[]` 先和 `[]` 结合，p是数组

**示例：**

`int a[3][5];` 声明二维数组，`int (*p)[5] = a;` 指向第一行，`(*p)[0]` 正确解引用，`p++` 跨越一整行。

`int *q[5];` 声明指针数组，`int x = 10; q[0] = &x;` 每个元素单独赋值，`*q[0]` 取第0个指针指向的值即10。

---

### 1.2.2 使用代码声明各类指针与数组 【编程题】

> **考点**：综合考察指针、数组、函数指针等声明语法
> **注意**：熟练区分变量、变量指针、数组、指针数组、数组指针、函数指针

使用代码声明以下各类型（每种至少一个示例，并用注释标注类型名称）：

1. 普通变量
2. 指针变量（变量指针）
3. 数组
4. 指针数组（元素为指针的数组）
5. 数组指针（指向数组的指针）
6. 函数指针

```c
// 用于演示函数指针的函数
int add(int a, int b) {
    return a + b;
}

int main() {

    // 1. 普通变量
    int var = 42;

    // 2. 指针变量（变量指针）—— 存储变量的地址 声明的同时初始化
    int *ptr = &var;

    // 3. 数组 —— 连续存储同类型元素
    int arr[5] = {1, 2, 3, 4, 5};

    // 4. 指针数组 —— 数组的每个元素都是指针
    int *ptr_arr[5] = {&arr[0], &arr[1], &arr[2], &arr[3], &arr[4]};

    // 5. 数组指针 —— 指向整个数组的指针（步长为数组长度）
    int (*arr_ptr)[5] = &arr;

    // 6. 函数指针 —— 指向函数的指针
    int (*func_ptr)(int, int) = &add;
```

**核心记忆口诀**

| 类型     | 声明形式         | 记忆方式                           |
| -------- | ---------------- | ---------------------------------- |
| 指针变量 | `int *p`         | `*`靠近变量名                      |
| 指针数组 | `int *p[n]`      | `[]`优先级高，先是数组，元素是指针 |
| 数组指针 | `int (*p)[n]`    | `()`强制先结合，先是指针，指向数组 |
| 函数指针 | `int (*p)(参数)` | `()`强制先结合，先是指针，指向函数 |

区分指针数组和数组指针的关键就是**括号优先级**：有括号包住 `*p` 就先看指针，没有就先看右边的 `[]`。

#### 注意事项

##### **指针数组 vs 数组指针 —— 解引用方式不同**

```c
int arr[5] = {1, 2, 3, 4, 5};

int *ptr_arr[5];       // 指针数组
ptr_arr[2];            // 得到一个 int*
*ptr_arr[2];           // 才得到 int 值

int (*arr_ptr)[5] = &arr;  // 数组指针
arr_ptr;               // 得到一个 (*)[5]
(*arr_ptr)[2];         // 才得到 int 值，必须先解引用
arr_ptr[0][2];         // 等价写法
```

##### `&arr` vs `arr` —— 值相同但类型不同

```c
int arr[5] = {1, 2, 3, 4, 5};

printf("%p\n", arr);       // 数组首元素地址，类型 int*
printf("%p\n", &arr);      // 整个数组的地址，类型 int(*)[5]

// 值打印出来一样，但步长不同！
printf("%p\n", arr + 1);   // +4字节（跳一个int）
printf("%p\n", &arr + 1);  // +20字节（跳整个数组）
```

##### 函数指针赋值 —— 取地址符可省略但建议统一

```c
int (*func_ptr)(int, int) = &add;  // 显式取地址（推荐，意图清晰）
int (*func_ptr)(int, int) = add;   // 也合法，函数名自动退化为指针

// 调用时同理
func_ptr(3, 4);     // 推荐
(*func_ptr)(3, 4);  // 也合法
```

##### 指针数组指针 —— 指向指针数组的指针

- 后面为主，那就是指向指针数组的指针简单来看就是数组指针！
- [数组指针赋值方式](###1.2.1 数组指针 vs 指针数组 【问答题】)

```c
int *ptr_arr[5];          // 指针数组
int *(*p)[5] = &ptr_arr;  // 指向该指针数组的指针

// 读法：去掉变量名 p，剩下 int*(*)[5]
// 先看 (*) → 是指针，指向 int*[5] → 元素为int*的数组
```

##### const 位置不同含义完全不同

```c
int a = 1, b = 2;

const int *p = &a;   // 指向常量的指针：不能改 *p，但能改 p 的指向
int * const p = &a;  // 常量指针：    能改 *p，但不能改 p 的指向
const int * const p = &a; // 两者都不能改
```

- 记忆技巧：`const` 在 `*` **左边**，保护**值**；在 `*` **右边**，保护**地址**。

##### 数组名作函数参数会退化为指针

```c
void func(int arr[5])  { }  // 实际等价于 👇
void func(int *arr)    { }  // 编译器自动退化，sizeof(arr) = 8（指针大小）

// 若想传数组指针保留维度信息：
void func(int (*arr)[5]) { }  // sizeof(*arr) = 20（数组实际大小）
```



### 1.2.3 指针步长与地址计算 【选择题】

> **考点**：指针类型决定步长——`int*` 步长为4字节，`char*` 步长为1字节
> **注意**：`char` 数组强转为 `int*` 后，`p[1]` 偏移4字节而非1字节

假如 `test` 数组的起始地址为 `0x12345678`，则表达式 `test_p[1]` 的指针地址值是多少？（  ）

```c
char test[8] = { 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08 };
int *test_p = (int *)test;
```

- **A.** 0x12345678
- **B.** 0x1234567C
- **C.** 0x12345679
- **D.** 0x1234567A

------

💡 **答案提示**

**答案：B**

`test_p` 是 `int*`，步长为 `sizeof(int)` = 4 字节。`test_p[1]` = `test_p + 1` = `0x12345678 + 4` = **`0x1234567C`**

---

**⚠️ 注意点一：步长由指针类型决定，与数组原始类型无关**

```c
char  *cp = test;         cp[1];  // 偏移 1字节 → 0x12345679  （选项C的陷阱）
int   *ip = (int*)test;   ip[1];  // 偏移 4字节 → 0x1234567C  ✅
short *sp = (short*)test; sp[1];  // 偏移 2字节 → 0x1234567A  （选项D的陷阱）
```

**⚠️ 注意点二：题目问的是地址，不是值**

```c
test_p[1] 的地址 = 0x1234567C          ← 题目问这个
*(test_p + 1)    = 0x08070605（小端）   ← 这是值，不是题目问的
```

**⚠️ 注意点三：大小端影响值，不影响地址**

```
内存布局：01 02 03 04 | 05 06 07 08
       test_p[0]  | test_p[1]

小端(x86)：test_p[1] 的值 = 0x08070605
大端：     test_p[1] 的值 = 0x05060708
但 test_p[1] 的地址永远是 0x1234567C，与大小端无关
```

**⚠️ 注意点四：强转后越界风险**

```c
test_p[0];  // 访问字节[0~3] ✅
test_p[1];  // 访问字节[4~7] ✅
test_p[2];  // 访问字节[8~11] ❌ 越界！未定义行为
```

`char[8]` 强转为 `int*` 后，只能合法访问下标 `[0]` 和 `[1]`。

---

**选项陷阱对照**

| 选项                  | 地址值             | 陷阱原因               |
| --------------------- | ------------------ | ---------------------- |
| A. `0x12345678`       | `test_p[0]` 的地址 | 误以为下标不偏移       |
| **B. `0x1234567C` ✅** | 正确答案           | +1 × 4字节             |
| C. `0x12345679`       | `char*` 步长偏移1  | 忘记强转改变了步长     |
| D. `0x1234567A`       | `short*` 步长偏移2 | 混淆成 `short*` 的步长 |

### 1.2.4 数组名与指针运算 【选择题】

> **考点**：数组名作为地址常量不可自增；`*a` 等价于 `a[0]`
> **注意**：`a++` 非法，因为数组名不是可修改的左值

数组定义为 `int a[4];`，表达式（  ）是错误的。

- **A.** `*a`
- **B.** `a[0]`
- **C.** `a`
- **D.** `a++`


---

💡 答案提示 

答案：D 数组名 `a` 是地址常量（不可修改的左值），不能执行 `++` 运算。

**⚠️ 注意点一：数组名是常量，但指针变量可以自增**

```c
int a[4] = {1, 2, 3, 4};
int *p = a;

a++;  // ❌ 非法，a 是地址常量
p++;  // ✅ 合法，p 是指针变量，可修改
```

> 两者都能用 `*` 解引用，但只有指针变量能自增，这是最常见的混淆点。

------

**⚠️ 注意点二：`*a`、`a[0]`、`*(a+0)` 三者完全等价**

```c
*a        // 解引用首地址 → a[0] 的值
a[0]      // 下标访问    → 同上
*(a + 0)  // 指针偏移    → 同上

// 同理：
*(a + 1) == a[1]
*(a + 2) == a[2]
```

------

**⚠️ 注意点三：`a` 与 `&a` 值相同但类型不同（同上一题）**

```c
int a[4];

a     // 类型 int*，指向首元素
&a    // 类型 int(*)[4]，指向整个数组

a + 1    // 偏移 4字节（跳一个int）
&a + 1   // 偏移 16字节（跳整个数组）
```

------

**⚠️ 注意点四：`sizeof(a)` 与 `sizeof(p)` 不同**

```c
int a[4];
int *p = a;

sizeof(a);  // 16字节（整个数组大小）
sizeof(p);  // 8字节（指针本身大小，64位系统）
```

> 数组名传入函数后会退化为指针，此时 `sizeof` 就只返回指针大小了，这是另一个高频陷阱。

### 1.2.5 指针偏移与数组元素访问 【分析题】

> **考点**：指针 `p` 指向 `a[5]`，`p[7]` 等价于 `*(p+7)` 即 `a[12]`
> **注意**：指针下标运算基于指针当前位置，而非数组起始位置

下面程序中 `b` 的值是（  ）

```c
int a[15] = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};
int *p = &a[5];
int b = p[7];
```


---

💡 答案提示 

答案：13 `p` 指向 `a[5]`，`p[7]` = `*(p+7)` = `a[5+7]` = `a[12]` = 13

**⚠️ 注意点一：`p = &a[5]` 与 `p = a+5` 完全等价**

```c
int *p = &a[5];  // 两种写法
int *p = a + 5;  // 完全等价

// 同理：
&a[i] == a + i
 a[i] == *(a + i)
```

------

**⚠️ 注意点二：负下标合法，只要不越界**

```c
int *p = &a[5];

p[-1];  // = *(p-1) = a[4] = 5  ✅ 合法
p[-5];  // = *(p-5) = a[0] = 1  ✅ 合法
p[-6];  // ❌ 越界！未定义行为
```

> `p[7]` 让人直觉上以为从数组头开始数第7个，实际是**从p当前位置**偏移7，负下标同理。

------

**⚠️ 注意点三：容易数错下标**

```c
// a 数组下标与值的对应关系：
// 下标： 0  1  2  3  4  5  6  7  8  9  10 11 12 13 14
// 值：   1  2  3  4  5  6  7  8  9  10 11 12 13 14 15

int *p = &a[5];  // p 指向值为 6 的元素，不是值为 5！
```

> `a[5]` 是第6个元素（值为6），下标从0开始，这是最常见的数错原因。

------

**⚠️ 注意点四：越界访问不报错但是未定义行为**

```c
int *p = &a[5];

p[9];   // = a[14] = 15  ✅ 刚好在边界内
p[10];  // = a[15] ❌ 越界！编译不报错，但结果不可预期
```

> C语言不做边界检查，越界访问能编译通过，结果取决于那块内存存了什么。

### 1.2.6 指向整个数组的指针运算 【分析题】

> **考点**：`&数组名` 的类型是 `T (*)[N]`（指向整个数组的指针），+1 跳过整个数组（N×sizeof(T) 字节）；而 `数组名` 类型是 `T*`，+1 仅跳过一个元素
> **注意**：这类题的核心是搞清楚指针 +1 到底移动多少字节——取决于指针所指类型的大小

```c
int32_t var[7] = {2, 4, 6, 8, 10, 12, 14};
int32_t *var_ptr = (int32_t *)(&var + 1);
*(var_ptr - 1) = *(var + 1);
```

上述代码执行后，`var` 数组的值是什么？

<details><summary>💡 答案提示</summary>
<ul>
<li><code>&var + 1</code> 跳过整个数组（7 × 4 = 28字节），指向数组末尾之后</li>
<li><code>var_ptr - 1</code> 回退一个 <code>int32_t</code>（4字节），即指向 <code>var[6]</code></li>
<li><code>*(var + 1)</code> = <code>var[1]</code> = 4</li>
<li>最终 <code>var[6]</code> 从 14 变为 4</li>
</ul>
<p><b>结果：</b><code>{2, 4, 6, 8, 10, 12, 4}</code></p>
</details>

**⚠️ 注意点一：`&var + 1` 指向数组末尾之后，不是最后一个元素**

```c
int32_t var[7] = {2, 4, 6, 8, 10, 12, 14};

// 内存示意：
// [0] [1] [2] [3] [4] [5] [6] | 越界区域
//  2   4   6   8  10  12  14  ↑
//                           &var+1 指向这里（合法指针，但不可解引用）

&var + 1   // 指向 var[7]，越过整个数组
var + 1    // 指向 var[1]，仅越过一个元素
```

> `&var + 1` 作为地址值是合法的（C标准允许指向数组末尾后一位），但对其解引用是未定义行为。

------

**⚠️ 注意点二：强转是关键，没有强转就无法做指针算术**

```c
int32_t *var_ptr = (int32_t *)(&var + 1);
//                 ↑ 必须强转！
// &var + 1 的类型是 int32_t(*)[7]，不能直接赋给 int32_t*
// 强转后 var_ptr 的步长变回 4字节，才能用 -1 回退一个元素
//&var 的类型是 int32_t (*)[7]，所以它的步长是整个数组的大小,不强转的话步长就是28字节
```

------

**⚠️ 注意点三：`*(var + 1)` 与 `*var + 1` 含义完全不同**

```c
*(var + 1)  // 先偏移再解引用 → var[1] = 4   ← 题目用的是这个
*var + 1    // 先解引用再加1 → var[0] + 1 = 3
```

> 运算符优先级：`*` 和 `+` 同级时从右往左，但 `*(var+1)` 有括号强制先算偏移。

------

**⚠️ 注意点四：`int32_t` 与 `int` 的关系**

~~~c
// int32_t 是固定4字节的类型，定义在 <stdint.h>
// 在大多数32/64位平台上 int32_t == int，但不能依赖这一点
// 本题步长计算依赖 sizeof(int32_t) = 4，而非 sizeof(int)
```

> 如果题目改成 `int64_t`，整个数组大小变为 56字节，步长计算结果完全不同，要特别注意类型。

---

**⚠️ 注意点五：画图是解这类题最可靠的方法**
```
地址：  1000  1004  1008  1012  1016  1020  1024  1028
值：    [0]   [1]   [2]   [3]   [4]   [5]   [6]   (越界)
         2     4     6     8    10    12    14
         ↑                                   ↑
        var                              &var+1 → 强转 → var_ptr
                                              var_ptr-1 ↑
                                         指向 var[6]，将其改为 4
~~~

> 遇到多步指针运算，逐步标注每个指针指向哪里，比心算可靠得多。

### 1.2.7 指针交换函数（值传递 vs 地址修改）【选择题】

> **考点**：C语言函数参数是值传递——交换指针本身不影响调用者的指针
> **注意**：要真正交换两个指针指向的值，需使用二级指针 `int **` 或直接交换 `*a` 和 `*b`

下面程序的输出结果是（  ）

```c
void swap(int *a, int *b) {
    int *t;
    t = a;
    a = b;
    b = t;
}

int main() {
    int x = 1, y = 2;
    int *p = &x, *q = &y;
    swap(p, q);
    printf("%d %d\n", *p, *q);
    return 0;
}
```

- **A.** 1 2
- **B.** 2 1
- **C.** 编译错误
- **D.** 运行时崩溃

<details><summary>💡 答案提示</summary>
<p><b>答案：A</b></p>
<p><code>swap</code> 函数内交换的只是<b>形参（指针的副本）</b>，不影响实参 <code>p</code> 和 <code>q</code>。函数返回后 <code>p</code> 仍指向 <code>x</code>，<code>q</code> 仍指向 <code>y</code>。要真正交换需用二级指针 <code>int **</code> 或交换 <code>*a</code> 和 <code>*b</code> 的值。</p>
</details>


---

**⚠️ 核心原则：C语言所有参数传递都是值传递**

传指针时，传的是"指针变量本身的值（地址值）"的副本。栈上会为形参开辟副本，函数内对形参的修改不影响实参。

- 对于指针来说就是栈上开辟跟外部指针指向相同的副本指针！那么修改指针指向是无效的，根据指向修改值是有效的（一级指针来说）
- 要修改一级指针指向的话，就要把他存到二级指针中，与上同理去修改二级指针指向的值即可完成修改。

**⚠️ 注意点一：两种操作效果完全不同**

| 操作                                             | 是否影响外部 |
| ------------------------------------------------ | ------------ |
| 传值，修改副本                                   | ❌            |
| 传一级指针，解引用修改内容（`*p = ...`）         | ✅            |
| 传一级指针，修改指针指向（`p = ...`）            | ❌            |
| 传二级指针，解引用修改一级指针指向（`*p = ...`） | ✅            |

本题 `swap` 函数内执行的是 `a = b`，属于**修改形参指针的指向**，是对副本的操作，函数返回后 `p` 仍指向 `x`，`q` 仍指向 `y`，输出 `1 2`。

**⚠️ 注意点二：三种"交换"写法的本质区别**

**写法一：交换形参指针指向（原题，无效）**

```c
void swap(int *a, int *b) {
    int *t = a; a = b; b = t;  // 只改了副本，外部p/q不变
}
// *p=1, *q=2，输出 1 2
```

**写法二：解引用交换内容（有效，但指向不变）**

```c
void swap(int *a, int *b) {
    int t = *a; *a = *b; *b = t;  // 修改了x和y的值
}
// p仍指向x，q仍指向y，但x=2,y=1，输出 2 1
```

**写法三：二级指针交换指向（有效，指向真正互换）**

```c
void swap(int **a, int **b) {
    int *t = *a; *a = *b; *b = t;  // p和q的指向互换
}
swap(&p, &q);
// p指向y，q指向x，输出 2 1
```

------

**⚠️ 注意点三：写法二和写法三输出相同但原理不同**

写法二和写法三输出都是 `2 1`，但本质完全不同：

- 写法二：`p` 仍指向 `x`，`q` 仍指向 `y`，只是 `x` 和 `y` 里存的值互换了
- 写法三：`p` 改为指向 `y`，`q` 改为指向 `x`，值没动，是指针指向本身发生了互换

这是最容易混淆的陷阱，考试中若题目问的是"指针指向是否改变"，两者答案截然相反。

------

**⚠️ 注意点四：三种写法对比总结**

| 函数写法                   | `*p` `*q` 输出 | `p`/`q` 指向是否改变 | `x`/`y` 的值是否改变 |
| -------------------------- | -------------- | -------------------- | -------------------- |
| 交换形参指针指向（写法一） | 1  2           | ❌                    | ❌                    |
| 解引用交换内容（写法二）   | 2  1           | ❌                    | ✅                    |
| 二级指针交换指向（写法三） | 2  1           | ✅                    | ❌                    |

### 1.2.8 空指针与 malloc 返回值 【问答题】

> **考点**：空指针常量的定义与宏本质；空指针的语义与内部实现；`malloc` 分配失败返回 `NULL` 而非整数 `0`；解引用空指针是未定义行为
> **注意**：
>
> `NULL` 是宏定义，通常展开为 `(void*)0`，但空指针的内部bit表示不一定是全0，取决于平台实现
>
> `NULL`、`0`、`'\0'`、`false` 底层值可能相同，但语义不同，指针判空应使用 `NULL`
>
> 未初始化指针是野指针，与空指针是两回事，定义指针时若暂无指向应初始化为 `NULL`
>
> 解引用空指针是未定义行为，`malloc` 后必须先判断返回值是否为 `NULL` 再使用
>
> `free` 后指针变成悬空指针，应立即置 `NULL` 防止误用

1. 什么是空指针常量（null pointer constant）？
2. 什么是空指针（null pointer）？
3. 空指针指向了内存的什么地方（空指针的内部实现）？
4. `malloc` 函数在分配内存失败时返回 0 还是 `NULL`？

💡 **答案提示**

**Q1：空指针常量** 是C语言标准定义的一个特殊常量，表示"不指向任何对象"的指针值。在代码中写作 `NULL` 或整数常量 `0`。`NULL` 本质是一个宏，通常定义为 `(void*)0`。

**Q2：空指针** 是一个指针变量，其值为**空指针常量**。表示该指针当前不指向任何有效的内存地址。

**Q3：空指针的内部实现** C标准只规定空指针不等于任何有效对象的地址，并不规定其内部bit表示一定是全0。但是大多数现代平台（x86/ARM等）确实用全0地址表示空指针。

**Q4：** 返回 `NULL`。虽然 `NULL` 在大多数实现中就是 `(void*)0`，但语义上应使用 `NULL` 进行判断，体现"空指针"的含义。

**⚠️ 注意点一：`NULL`、`0`、`'\0'`、`false` 的区别**

这四个在底层值可能相同，但语义完全不同，混用虽然能编译通过，但是不规范：

| 常量    | 类型       | 语义         | 用途       |
| ------- | ---------- | ------------ | ---------- |
| `NULL`  | `(void*)0` | 空指针       | 指针判空   |
| `0`     | `int`      | 整数零       | 数值计算   |
| `'\0'`  | `char`     | 字符串终止符 | 字符串结尾 |
| `false` | `_Bool`    | 逻辑假       | 布尔判断   |

```c
int *p = NULL;   // ✅ 规范
int *p = 0;      // ⚠️ 能编译，但语义不清晰
if (p == NULL)   // ✅ 规范的指针判空
if (!p)          // ⚠️ 能用，但不够明确
```

------

**⚠️ 注意点二：未初始化指针 vs 空指针，是两回事**

```c
int *p;        // ❌ 野指针，指向随机地址，非常危险
int *p = NULL; // ✅ 空指针，明确表示"不指向任何地方"
```

定义指针时若暂时没有指向目标，一定要初始化为 `NULL`，否则 `p` 是野指针，解引用会导致未定义行为。

------

**⚠️ 注意点三：解引用空指针是未定义行为**

```c
int *p = NULL;
*p = 10;   // ❌ 未定义行为，通常导致段错误（Segmentation Fault）
```

使用 `malloc` 后必须检查返回值再使用：

```c
int *p = (int*)malloc(sizeof(int));
if (p == NULL) {   // ✅ 必须先判断
    // 处理分配失败
}
*p = 10;
```

------

**⚠️ 注意点四：`malloc` 返回 `NULL` 还是 `0` 的本质**

`malloc` 失败时返回的是 `NULL`（类型为 `void*`），而不是整数 `0`。虽然大多数平台两者的bit表示相同，但类型不同：

```c
void *p = malloc(size);
if (p == NULL) { ... }   // ✅ 与空指针比较，语义正确
if (p == 0)    { ... }   // ⚠️ 整数0会隐式转换为空指针，能用但不规范
```

------

**⚠️ 注意点五：`free` 之后指针应立即置 `NULL`**

```c
free(p);
p = NULL;  // ✅ 防止产生悬空指针（dangling pointer）
```

`free` 后指针变量本身仍存在，值还是原来的地址（即悬空指针），若不置 `NULL` 后续误用会导致未定义行为。这虽不是本题直接考点，但与空指针使用密切相关，容易一并考察。


---

### 1.2.9 空指针、野指针与悬空指针（指针安全）【问答题】

> **考点**：三类危险指针的定义与区别；野指针的三种产生方式；访问后果为未定义行为；防御规范：free 后立即置 NULL
> **注意**：
>
> 悬空指针是野指针的一种，野指针比空指针更危险（看似合法但指向非法内存）
>
> 未初始化指针、free后未置NULL、返回局部变量地址，是**野指针三种典型来源**
>
> `free(p); p = NULL;` 只能保护当前指针，若存在多个指针指向同一块内存（指针别名），其他副本仍是悬空指针

1. 什么是悬空指针？
2. 空指针和野指针的区别是什么？
3. 访问野指针会发生什么？访问空指针会发生什么？
4. 释放之后的指针再次调用会发生什么状况，如何避免？

💡 **答案提示**

**Q1 悬空指针（Dangling Pointer）：** 指向已释放或已失效内存的指针，是野指针的一种。常见场景：

1. `free(p)` 后未置 `NULL`，继续使用 `p`
2. 函数返回局部变量的地址
3. 指向的栈内存在函数返回后被回收

**Q2 区别：**

- 空指针（NULL Pointer）：明确赋值为 `NULL`，表示"不指向任何有效对象"，是安全的初始化状态，误用时在有MMU的系统上通常会立即崩溃报错，便于定位
- 野指针（Wild/Dangling Pointer）：指向不确定或非法内存区域的指针，看似合法但实际指向非法内存，误用时可能静默读写错误数据而不崩溃，危害更大

野指针三种典型产生方式：

1. 指针未初始化 —— 声明后未赋值，值为随机地址
2. `free` 后未置 `NULL` —— 内存已释放，指针仍保存原地址
3. 返回局部变量的地址 —— 函数返回后栈内存被回收，指针失效

~~~c
int* get_val() {
    int x = 10;  // x 是栈上的局部变量
    return &x;   // ❌ 返回 x 的地址
                 // 函数返回后，栈指针上移，x 所在栈帧被标记为"可覆盖"
                 // 但内存并未立即清零，数据仍暂时残留在原地址
}

int main() {
    int *p = get_val();  // p 接收到了 x 的地址，地址本身是合法的数值
                         // 但该地址已不属于我们，随时可能被覆盖

    // 情况一：紧接着就读，可能侥幸读到 10
    printf("%d\n", *p);  // ⚠️ 可能输出 10（栈帧尚未被覆盖）
                         // 也可能是垃圾值，取决于编译器和运行时状态
                         // 看似正常，实则是未定义行为，掩盖了真正的问题

    // 情况二：中间调用了其他函数，新栈帧覆盖了原来的内存
    printf("%d\n", *p);  // ❌ 极可能输出垃圾值
                         // printf 本身的调用会在栈上建立新栈帧
                         // 原来 x 所在的内存已被 printf 的栈帧覆盖
}
```

栈内存回收的本质是**栈指针上移**，而不是清零。可以用下图理解：
```
调用 get_val() 时：          get_val() 返回后：
┌─────────────┐              ┌─────────────┐
│  main栈帧   │              │  main栈帧   │
├─────────────┤              ├─────────────┤  ← 栈指针回到这里
│ get_val栈帧 │              │  数据残留   │  ← 标记为可覆盖，但值暂时还在
│   x = 10   │              │  x = 10 ?  │     下次函数调用会覆盖这里
└─────────────┘              └─────────────┘
      ↑ 栈指针                      p 指向这里，地址失效
~~~

**Q3 访问野指针：** 行为是未定义的（Undefined Behavior）——

- 可能读到垃圾数据，看似正常但数据错误（最危险，不会崩溃难以察觉）
- 可能破坏其他变量的数据，写操作踩了别人的内存
- 可能触发段错误/HardFault 导致程序崩溃
- 嵌入式中可能导致系统跑飞、看门狗复位

访问空指针：行为也是未定义的，但通常表现更确定——

- 有 MMU 的系统（Linux/Windows）→ 段错误（Segmentation Fault），便于发现和定位
- 无 MMU 的嵌入式系统（如 Cortex-M）→ 可能触发 HardFault，也可能访问到地址0处的实际内容（中断向量表），导致不可预测的行为

如何避免：

```c
free(p);
p = NULL;  // ✅ 释放后立即置空，后续误访问会触发空指针异常，易于定位
```

⚠️ 但若存在多个指针指向同一块内存，仅置当前指针为 `NULL` 是不够的：

```c
int *p = malloc(sizeof(int));
int *q = p;   // q 是 p 的别名，指向同一块内存
free(p);
p = NULL;     // ✅ p 已安全
*q = 10;      // ❌ q 仍是悬空指针，Use-After-Free
```

这种情况需要在架构层面明确内存的唯一所有权，避免多个指针共享同一块堆内存的所有权。


---

### 1.2.10 函数指针与指针函数的区别 【问答题】

> **考点**：函数指针本质是指针；指针函数本质是函数；通过 `*` 与函数名的结合方式来区分
> **注意**：
>
> `int *func(int)` 和 `int (*pfunc)(int)` 仅一对括号之差，含义完全不同
>
> 函数指针变量未初始化直接调用是野指针，使用前必须赋值或判空
>
> `typedef` 可以简化函数指针的声明，实际工程中大量使用
>
> 指针函数返回局部变量的地址是野指针（见1.2.9），应返回堆内存或静态变量地址
>
> 函数指针在嵌入式中大量使用，如回调函数注册、状态机跳转表、驱动接口抽象（HAL层的ops结构体）

1. 函数指针是什么，你用它来干什么？
2. 指针函数与函数指针分别是什么？给出程序语句示例。

💡 **答案提示**

**Q1：函数指针**是指向函数的指针变量，存储的是函数的入口地址。典型用途：回调函数、状态机跳转表、驱动接口抽象。

**Q2：**

**指针函数：** 返回值为指针的函数，本质是函数。

```c
int *func(int a, int b);   // 返回 int* 的函数
// ⚠️ 不能返回局部变量地址，可返回堆内存或静态变量地址
int *func(int a, int b) {
    int *p = malloc(sizeof(int));  // ✅ 返回堆内存，函数返回也不会收回
    *p = a + b;//修改一级指针指向的值
    return p;  // 调用方负责 free
}
```

**函数指针：** 指向函数的指针变量，本质是指针。

```c
int (*pfunc)(int, int);     // 声明函数指针，此时未初始化是野指针
pfunc = add;                // ✅ 赋值后才能使用，add 是已定义的函数
if (pfunc != NULL)          // ✅ 调用前判空，防止野指针调用
    int result = pfunc(1, 2);

// typedef 简化声明，实际工程常用写法
typedef int (*AddFunc)(int, int);
AddFunc pfunc = add;        // 更直观
```

**记忆技巧：** 看 `*` 和函数名的结合方式——

- `int *func(...)` → `*` 修饰返回值，`func` 是函数 → **指针函数**
- `int (*pfunc)(...)` → `*` 和 `pfunc` 被括号锁在一起，`pfunc` 是指针 → **函数指针**
- [这里的判断方式跟指针数组以及数组指针判断类似](###1.2.1 数组指针 vs 指针数组 【问答题】)


---

### 1.2.11 复杂声明解析——函数指针调用 【问答题】

> **考点**：C语言复杂声明的阅读能力；函数指针的理解；强制类型转换
> **注意**：
>
> 拆解复杂声明的口诀：**从标识符出发，右看左看，括号优先**
>
> `(void(*)())` 是函数指针的类型，不是函数指针变量，不能直接调用，需先强转再解引用
>
> 整数 `0` 强转为指针是实现定义行为（implementation-defined），在标准C中不可移植，嵌入式中需结合平台确认地址0的实际含义
>
> 在有MMU的系统（Linux/Windows）上，地址0通常不可访问，直接调用会触发段错误
>
> 嵌入式中跳转复位向量更推荐用 `typedef` 写法，可读性更高

请解析 `(*(void(*)())0)()` 的含义。

💡 **答案提示**

从内向外逐层拆解：

```c
(*(void(*)())0)()
```

**第一层：** `void(*)()` —— 函数指针类型，指向无参数、无返回值的函数

```c
void(*)(void)   // 完整写法
void(*)()       // 简写，等价
```

**第二层：** `(void(*)())0` —— 将整数 `0` 强制转换为该函数指针类型

```c
(void(*)())0    // 把地址 0x0 解释为一个函数的入口地址
```

**第三层：** `*(void(*)())0` —— 解引用该函数指针，得到函数本身

```c
*(void(*)())0   // 取地址 0 处的函数
```

**第四层：** `(*(void(*)())0)()` —— 加上 `()` 调用该函数

```c
(*(void(*)())0)()  // 调用位于地址 0x0 处的 void func(void) 类型函数
```

**等价的可读写法（推荐）：**

```c
// 用 typedef 简化，实际工程推荐写法
typedef void (*ResetFunc)(void);
ResetFunc reset = (ResetFunc)0;
if (reset != NULL)
    reset();   // 跳转到地址 0 执行，等价于 (*(void(*)())0)()
```

**使用场景对比：**

| 场景                         | 地址0的含义         | 调用结果       |
| ---------------------------- | ------------------- | -------------- |
| 有MMU的系统（Linux/Windows） | 不可访问页          | ❌ 段错误       |
| 无MMU的嵌入式（如Cortex-M）  | 复位向量/中断向量表 | ✅ 跳转复位执行 |


---

### 1.2.12 回调函数的定义与典型使用场景 【问答题】

> **考点**：回调函数通过函数指针实现；核心思想是控制反转——调用时机由框架/底层决定，而非调用方主动触发；嵌入式与FreeRTOS中大量使用
> **注意**：
>
> 回调函数本身不是新语法，本质就是函数指针的应用，重点在于理解"控制反转"的思想
>
> 回调函数通常由中断或底层框架在特定时机调用，注意**不能在回调中执行耗时操作**
>
> FreeRTOS的软件定时器回调运行在 `TimerTask` 中，不是在调用 `xTimerStart` 的任务中执行
>
> FreeRTOS回调中**不能调用会阻塞的API**（如 `vTaskDelay`、`xQueueReceive` 带超时），否则会阻塞定时器任务导致系统异常
>
> HAL库的中断回调（如 `HAL_UART_RxCpltCallback`）运行在中断上下文中，同样不能有阻塞操作，耗时处理应通过队列/信号量交给任务处理

请简述回调函数以及使用场合。

💡 **答案提示**

**什么是回调函数：** 将函数指针传递给框架或底层模块，由框架在特定事件发生时主动调用的函数。核心思想是**控制反转**——"你不调用我，我来调用你"，调用时机由底层决定。

**基本结构：**

```c
// 定义回调函数类型
typedef void (*CallbackFunc)(void);

// 底层模块：接收并保存回调
CallbackFunc g_callback = NULL;
void Timer_RegisterCallback(CallbackFunc cb) {
    g_callback = cb;
}
// 底层在合适时机触发回调
void Timer_IRQHandler(void) {
    if (g_callback != NULL)
        g_callback();   // 调用上层注册的函数
}

// 上层模块：定义并注册回调
void onTimeout(void) {
    // 处理超时事件
}
Timer_RegisterCallback(onTimeout);  // 注册，不是调用
```

**典型使用场景总结：**

| 场景               | 示例                      | 运行上下文     |
| ------------------ | ------------------------- | -------------- |
| HAL中断回调        | `HAL_UART_RxCpltCallback` | 中断上下文     |
| FreeRTOS定时器回调 | `xTimerCreate` 注册的函数 | TimerTask      |
| 驱动抽象ops结构体  | HAL层函数指针表           | 任务上下文     |
| 事件驱动           | 按键、通信完成通知        | 视注册位置而定 |



### 1.2.13 通过地址直接赋值 【问答题】

> **考点**：强制类型转换；指针解引用；嵌入式寄存器操作
> **注意**：在嵌入式中常用于直接操作硬件寄存器，普通程序中属于未定义行为

设置地址为 `0x13579` 的整型变量的值为 `0x97351`。

<details><summary>💡 答案提示</summary>
<pre><code>*(int *)0x13579 = 0x97351;</code></pre>
<p>拆解：</p>
<ol>
<li><code>(int *)0x13579</code> —— 将整数地址强制转换为 <code>int</code> 类型指针</li>
<li><code>*(int *)0x13579</code> —— 解引用该指针，访问该地址处的整型变量</li>
<li><code>= 0x97351</code> —— 赋值</li>
</ol>
</details>


---

## 1.3 宏定义与预处理

### 1.3.1 宏定义求数组元素个数 【编程题】

> **考点**：`sizeof(arr)/sizeof(arr[0])` 的经典用法
> **注意**：
>
> 仅在数组定义的作用域有效
>
> **数组退化为指针后失效**：将数组传入函数后，参数类型退化为指针，`sizeof` 得到的是指针大小（4或8字节）而非数组大小，此时宏的结果**错误**

已知一个数组 `table`，用一个宏定义，求出数据的元素个数。

💡 答案提示

```c
#define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]))
```

⚠️ 易错示例

```c
#define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]))

void foo(int arr[]) {
    // 错误！arr 已退化为 int*
    // sizeof(arr) = 4 或 8（指针大小），而非数组总大小
    int n = ARRAY_SIZE(arr); // 结果错误
}

int main() {
    int table[] = {1, 2, 3, 4, 5};
    int n = ARRAY_SIZE(table); // 正确，n = 5
    foo(table);
}
```

### 1.3.2 宏定义展开的陷阱（无括号保护）【选择题】

> **考点**：宏是简单文本替换，参数不加括号会导致运算优先级错误
> **注意**：
>
> `#define TEST(a,b) a*b` 展开 `TEST(1+2,3)` 为 `1+2*3=7` 而非 `9`
>
> 即使参数加了括号，**宏整体若不加括号，在复杂表达式中仍可能出错**

下面程序的运行结果为？（  ）

```c
#define TEST(a,b) a*b

int main() {
    int a = TEST(1 + 2, 3);
    printf("result= %d\n", a);
    return 0;
}
```

- **A.** result= 9
- **B.** result= 5
- **C.** result= 7
- **D.** result= 3

💡 答案提示

答案：**C**

展开过程：`TEST(1+2, 3)` → `1+2*3` → `1+6` = **7**

正确写法应为 `#define TEST(a,b) ((a)*(b))`

⚠️ 易错点：只加参数括号还不够

```c
// 仅保护参数——大多数情况正确，但仍有漏洞
#define TEST(a,b) (a)*(b)

// 考虑这种调用：
int x = 10 / TEST(2, 5);
// 展开为：10 / (2)*(5) → (10/2)*5 = 25，而非 10/(2*5) = 1
```

所以完整的防御写法是**参数和整体都加括号**：

```c
#define TEST(a,b) ((a)*(b))
// 展开为：10 / ((2)*(5)) = 10/10 = 1  ✓
```


---

### 1.3.3 宏展开与运算符优先级（综合）【选择题】

> **考点**：多重宏嵌套展开后的优先级计算
> **注意**：本题在 1.3.2 基础上增加了**宏嵌套、符号常量替换、多步展开**，需逐步还原，不可跳步

设 `#define N 3`，`#define Y(n) ((N+1)*n)`，则表达式 `2*(N+Y(5+1))` 的值是（  ）

- **A.** 42
- **B.** 48
- **C.** 54
- **D.** 出错

💡 答案提示

答案：**B**

关键：`Y(n)` 中 `n` 没有括号保护，`*n` 展开为 `*5+1` 而非 `*(5+1)`，这正是宏与函数调用的本质区别。

⚠️ 易错点：展开要**逐步进行**，不能先算参数

```c
// 错误思路（先算 5+1=6，再代入）：
Y(5+1) → ((3+1)*6) = 24   ← 误以为答案是 A：2*(3+24)=54 或 B

// 正确思路（先文本替换，再按优先级计算）：
Y(5+1) → ((N+1)*5+1)      ← n 直接替换为 5+1，无括号保护
       → ((3+1)*5+1)
       → (4*5+1)
       → 21

整体：2*(N+Y(5+1)) → 2*(3+21) = 2*24 = 48
```


---

### 1.3.4 宏定义取模运算展开 【选择题】

> **考点**：宏展开时参数被多次替换，含副作用的表达式（如 `a++`）会被执行多次；而函数调用参数只求值一次
> **注意**：`DOUBLE(a++)` 展开为 `a+++a++`，`a` 自增**两次**，结果与函数版本不同

已知如下代码，输出结果是（  ）

```c
#define DOUBLE(x) ((x)+(x))

int double_fn(int x) { return x + x; }

int main() {
    int a = 3, b = 3;
    printf("%d\n", DOUBLE(a++));
    printf("%d\n", double_fn(b++));
    return 0;
}
```

- **A.** 6 和 6
- **B.** 7 和 6
- **C.** 8 和 6
- **D.** 6 和 7

💡 答案提示

答案：**B**

关键：宏是文本替换，参数 `a++` 被展开了**两次**；函数是传值调用，`b++` 只求值**一次**。这也是宏相比内联函数的主要风险所在。

⚠️ 易错点 

```c
// 宏展开：DOUBLE(a++) → ((a++)+(a++)) 
// a 初始为 3，两次 a++ 分别取值 3 和 4（先用后加） 
// 结果：3+4 = 7，执行后 a = 5 
// 函数调用：b++ 作为参数只求值一次，传入 3 
// 结果：3+3 = 6，执行后 b = 4
```


---

### 1.3.5 预编译相关问题 【问答题】？？？

> **考点**：编译四阶段（预处理→编译→汇编→链接）；预编译的工作内容
> **注意**：
>
> 预编译处理 `#include`、`#define`、条件编译等指令，不做语法检查
>
> **预编译是纯文本替换**，不理解 C 语法，不分配内存，不做类型检查
>
> **四个阶段的产物容易混淆**，需要对应记忆

1. 什么是预编译（Preprocessing）？
2. C 语言编译过程分为哪几个阶段？
3. 预编译阶段主要完成哪些工作？
4. 在实际开发中，何时需要使用预编译？
5. 预编译与编译的本质区别是什么？

**1. 什么是预编译？**

预编译是编译前的文本处理阶段，由预处理器完成，将源文件 `.c` 处理为展开后的纯 C 文本（`.i` 文件），供编译器使用。

⚠️ 易混淆：预编译不是"提前编译"，它根本不做编译工作，只做**文本层面的替换与处理**。

------

**2. C 语言编译过程的四个阶段**

| 阶段   | 工具     | 输入 | 输出             |
| ------ | -------- | ---- | ---------------- |
| 预处理 | 预处理器 | `.c` | `.i`             |
| 编译   | 编译器   | `.i` | `.s`（汇编）     |
| 汇编   | 汇编器   | `.s` | `.o`（目标文件） |
| 链接   | 链接器   | `.o` | 可执行文件       |

⚠️ 易混淆：**链接阶段才解决函数跨文件调用问题**，不是编译阶段。声明了但未定义的函数，编译能通过，链接才会报错。

------

**3. 预编译阶段主要完成的工作**

- 展开 `#include`，将头文件内容插入源文件
- 展开 `#define` 宏，进行文本替换
- 处理条件编译指令（`#ifdef`、`#ifndef`、`#endif` 等）
- 删除注释
- 处理 `#pragma` 等编译器指令

⚠️ 易混淆：`#include` 是**完整复制粘贴**头文件内容，重复包含会导致重复定义，这正是需要头文件保护（`#ifndef`/`#pragma once`）的原因。

------

**4. 实际开发中何时使用预编译**

- 用 `#define` 定义常量或宏函数
- 用 `#ifdef DEBUG` 控制调试代码的开关
- 用头文件保护防止重复包含
- 用 `#pragma once` 或 `#ifndef` 保护头文件

⚠️ 易混淆：`#define` 定义的常量**没有类型、没有作用域**，现代 C 推荐用 `const` 或 `enum` 替代常量定义，用 `inline` 函数替代宏函数。

------

**5. 预编译与编译的本质区别**

|                | 预编译            | 编译                 |
| -------------- | ----------------- | -------------------- |
| 处理对象       | 以 `#` 开头的指令 | C 语言语句           |
| 是否理解语法   | 否，纯文本处理    | 是，做语法和类型检查 |
| 是否报语法错误 | 不报              | 报                   |
| 产物           | 展开的 `.i` 文件  | 汇编 `.s` 文件       |

⚠️ 易混淆：宏展开后如果产生语法错误，**报错位置指向展开后的代码**，不是宏定义那一行，初学者容易找不到错误来源。

#### 工作中的体现？？？

固件是怎么来的？在哪一步产生的？具体的原理？

---

### 1.3.6 gcc 编译参数 【问答题】

> **考点**：`-c` 只编译不链接、`-o` 指定输出文件名、`-shared` 生成动态库、`-static` 静态链接
> **注意**：区分编译和链接阶段各参数的作用

gcc 编译中 `-c`、`-o`、`-shared`、`-static` 等编译参数的用途。

**各参数用途与易混淆点**

**`-c`：只编译，不链接**

bash

```bash
gcc -c foo.c        # 生成 foo.o，不生成可执行文件
```

⚠️ 易混淆：`-c` 不是"只预处理"，它会走完预处理→编译→汇编三个阶段，只是**不进行链接**。未定义的函数在此阶段不会报错，链接时才会。

------

**`-o`：指定输出文件名**

```bash
gcc foo.c -o myapp      # 输出可执行文件 myapp
gcc -c foo.c -o foo.o   # 输出目标文件 foo.o
```

⚠️ 易混淆：`-o` 可以和任何阶段组合使用，**不单独决定编译阶段**，它只是给输出文件命名。不加 `-o` 时默认输出 `a.out`。

------

**`-shared`：生成动态库（.so 文件）**

```bash
gcc -shared -fPIC foo.c -o libfoo.so
```

⚠️ 易混淆：生成动态库时通常需要同时加 **`-fPIC`**（位置无关代码），缺少它在某些平台会报错或产生不可靠的动态库，两者经常需要配合使用。

------

**`-static`：静态链接**

```bash
gcc foo.c -static -o myapp     # 将所有库静态链接进可执行文件
```

⚠️ 易混淆：`-static` 与 `-shared` 是**对立的**，不能同时使用。另外静态链接生成的文件体积大但**不依赖运行环境的动态库**，动态链接体积小但目标机器必须有对应的 `.so` 文件。

------

**综合对比**

| 参数      | 作用阶段   | 典型用途          | 常见误区          |
| --------- | ---------- | ----------------- | ----------------- |
| `-c`      | 停在汇编后 | 分步编译多文件    | 以为只是预处理    |
| `-o`      | 任意阶段   | 指定输出文件名    | 以为只能用于链接  |
| `-shared` | 链接       | 生成 `.so` 动态库 | 忘记配合 `-fPIC`  |
| `-static` | 链接       | 全静态链接        | 与 `-shared` 混用 |

⚠️ 补充易混淆点：`-shared` 和 `-static` 针对的是**库文件的链接方式**，而 `-c` 和 `-o` 针对的是**编译产物的控制**，两组参数作用层面不同，不要混为一谈。

---

### 1.3.7 条件编译指令 #ifdef/#ifndef/#else/#endif 【问答题】

> **考点**：预处理指令 vs 关键字的区别；条件编译的实际应用场景
> **注意**：它们是**预处理指令**而非"预定义标识符"；`#ifndef` 用于头文件防重复包含（Include Guard）

简述 `#ifdef`、`#else`、`#endif`、`#ifndef` 的作用。

<details><summary>💡 答案提示</summary>
<p>这些是<b>预处理指令</b>，用于<b>条件编译</b>，在预处理阶段决定哪些代码参与编译：</p>
<ul>
<li><code>#ifdef</code>：如果宏已定义，则编译其后的代码</li>
<li><code>#ifndef</code>：如果宏<b>未</b>定义，则编译其后的代码</li>
<li><code>#else</code>：与 <code>#ifdef</code>/<code>#ifndef</code> 配合，提供否定分支</li>
<li><code>#endif</code>：结束条件编译块</li>
</ul>
<p><b>场景一：条件编译（跨平台/调试控制）</b></p>
<pre><code>#ifdef DEBUG
    printf("debug info\n");
#else
    // Release模式不编译调试代码
#endif</code></pre>
<p><b>场景二：头文件防重复包含（Include Guard）</b></p>
<pre><code>#ifndef _MODULE_H_
#define _MODULE_H_
// 头文件内容
#endif</code></pre>
</details>


---

### 1.3.8 宏定义 MIN（返回较小值）【编程题】

> **考点**：三目运算符语法；宏参数务必加括号保护
> **注意**：宏的**双重求值**问题——如 `MIN(i++, j++)` 会导致参数被求值两次产生副作用

写一个宏 `MIN`，返回两个数中较小的那一个。

<details><summary>💡 答案提示</summary>
<pre><code>#define MIN(a, b)  ((a) < (b) ? (a) : (b))</code></pre>
<p>每个参数都要加括号，防止宏展开时运算符优先级导致错误。例如 <code>MIN(x+1, y+2)</code> 如果不加括号会出错。</p>
</details>

### 1.3.9 内联（inline 函数）与宏定义（#define）的区别

它们表面上都能避免函数调用开销，但本质完全不同——宏是预处理器的文本替换，inline 是编译器层面的函数优化建议。

#### 类型安全（最重要区别）

```c
#define SQUARE(x) ((x)*(x))          // 宏

inline int square(int x) {           // 内联函数
    return x * x;
}

int a = 5;
double b = 5.5;

int r1 = SQUARE(a);    // 正确 → 25
int r2 = SQUARE(b);    // 危险！b 隐式转换为 int，得到 25（丢失小数）

int r3 = square(a);    // 正确 → 25
int r4 = square(b);    // 编译警告/错误，类型不匹配（更安全）
```

宏无任何类型检查，参数直接文本替换，隐式转换错误只能靠运行时才暴露。内联函数有完整类型检查，问题在编译期就能发现。

#### 参数副作用问题（最经典陷阱）

副作用指的是：表达式在计算值的同时，还改变了程序的状态（最典型的就是修改了变量的值）。

常见有副作用的操作：

- i++、++i、i--、--i
- i = 10
- i += 1
- 调用有修改全局/静态变量的函数，如 printf()（修改文件流）、rand()（修改内部状态）

无副作用的操作（纯表达式）：

- i + 5
- i * 2
- 调用不修改任何外部状态的函数（如 strlen(str) 如果 str 不变）

```c
#define MAX(a, b) ((a) > (b) ? (a) : (b))

inline int max(int a, int b) {
    return a > b ? a : b;
}

int i = 6;

int r1 = max(i++, 5);
// i++ 只求值一次：传入6，返回6，i 变为 7
// 最终：r1 = 6，i = 7

int r2 = MAX(i++, 5);
// 展开：((i++) > 5 ? (i++) : 5)
// 条件判断：i++ 返回6，i 变为 7，6 > 5 成立
// 取左值：再次 i++，返回7，i 变为 8
// 最终：r2 = 7，i = 8（i 被自增了两次！）
```

- 这是宏最经典的陷阱：参数有副作用时会被多次求值。
  - 函数形参 vs. 宏参数 的求值次数区别
  - **宏参数（#define）**：属于**纯文本替换**，在预处理阶段展开。 宏展开后，参数出现的每一个位置都会**独立求值一次**。

- 内联函数参数只求值一次，完全避免这个问题。

#### 运算符优先级问题

```c
#define BAD_ADD(x, y) x + y          // 危险：没有整体括号

int r = BAD_ADD(1, 2) * 3;
// 展开为：1 + 2 * 3 → 7（预期是 9！）
```

正确写法是每个参数和整体都加括号：`#define ADD(x, y) ((x) + (y))`，但这依赖编写者自律，稍有疏漏就出 bug。内联函数不存在这个问题。

#### 总结对比

| 对比维度       | 宏（#define）              | 内联函数（inline） |
| -------------- | -------------------------- | ------------------ |
| 处理阶段       | 预处理（文本替换）         | 编译期（类型安全） |
| 类型检查       | 无                         | 有                 |
| 参数求值       | 每处独立求值，有副作用风险 | 只求值一次         |
| 优先级问题     | 需手动加括号               | 无此问题           |
| 是否一定展开   | 是                         | 编译器决定         |
| 调试支持       | 不可调试                   | 可调试             |
| 能做语言元编程 | 能（#、##、条件编译）      | 不能               |

## 1.4 关键字与修饰符

### 1.4.1 static 关键字 【问答题】

> **考点**：修饰局部变量（延长生命周期）、修饰全局变量/函数（限制作用域到本文件）
> **注意**：
>
> static 局部变量只初始化一次，后续调用保留上次的值
>
> static 局部变量作用域**不变**，仍只在函数内可见——常见误区是以为生命周期延长了，作用域也跟着扩大
>
> static 全局变量与普通全局变量**生命周期相同**（都是程序结束销毁），区别仅在于**链接属性(作用域大小)**，不要把两者的区别误答成生命周期

1. `static` 关键字在 C 语言中有哪几种用法？各自效果是什么？

2. `static` 函数与普通函数的区别是什么？

3. 以下代码输出什么？为什么？

```c
void counter() {
    static int cnt = 0;
    cnt++;
    printf("%d\n", cnt);
}

int main() {
    counter();
    counter();
    counter();
}
```

4. static 全局变量和普通全局变量有什么区别？
5. "生命周期"和"作用域"有什么区别？static 局部变量的生命周期和作用域分别是什么？

💡 答案提示

**static 的三种用法：**

| 用法         | 生命周期           | 作用域/可见性                          |
| ------------ | ------------------ | -------------------------------------- |
| 修饰局部变量 | 延长到程序结束     | 不变，仍限于函数内                     |
| 修饰全局变量 | 不变，程序结束销毁 | 限制在本文件，其他文件 extern 不可访问 |
| 修饰函数     | —                  | 仅本文件可见，防止命名冲突             |

**第3题：** 输出 `1 2 3`，cnt 存储在静态区，只初始化一次，每次调用保留上次的值。

**第4题关键：** 区别不是生命周期，而是**链接属性**——普通全局变量其他文件可通过 `extern` 访问，static 全局变量不行。

**第五题：**作用域是变量**可被访问的代码范围**，生命周期是变量**在内存中存在的时间段**，两者相互独立。

static 局部变量的作用域不变，仍只在定义它的函数内可见；但生命周期延长到整个程序运行期间，存储在静态区，函数返回后不销毁，下次调用时保留上次的值。


---

### 1.4.2 const 关键字 【问答题】

> **考点**：修饰变量为只读、修饰指针（`const int*` vs `int* const`）、修饰函数参数
> **注意**：
>
> `const` 在 `*` 左边修饰指向的值，在 `*` 右边修饰指针本身
>
> `const` 变量不等于编译期常量，不能用来定义数组长度（C99之前），不能用于 `switch case`
>
> `const` 只是编译器层面的只读保护，通过强制类型转换或间接手段修改是**未定义行为**，不要以为 const 是真正的"常量"
>
> 修饰函数参数时，`const` 是对**函数内部**的约束，告知调用者该参数不会被修改，是一种接口语义声明

1. `const` 关键字的作用是什么？有哪些使用场景？
2. 区分以下三种写法的含义：

```c
const int *p;
int * const p;
const int * const p;
```

3. 以下代码会发生什么？

```c
const int x = 10;
int *p = (int *)&x;
*p = 20;
printf("%d\n", x);
```

4. 函数参数加 `const` 的意义是什么？

```c
void print(const char *str);
```

💡 答案提示

**指针与 const 的组合：**

| 声明                  | 指针本身 | 指向的值 |
| --------------------- | -------- | -------- |
| `const int *p`        | 可改     | 不可改   |
| `int * const p`       | 不可改   | 可改     |
| `const int * const p` | 不可改   | 不可改   |

**第3题：** 编译器不报错，但属于**未定义行为**，`x` 的实际输出取决于编译器是否做了常量折叠优化，不可依赖。

**第4题：** 约束函数内部不得修改该参数指向的内容，是接口语义声明，同时允许调用者传入 `const` 指针而不产生警告。

### 1.4.3 extern 关键字 【问答题】

> **考点**：声明外部变量/函数，用于跨文件访问
> **注意**：
>
> `extern` 只是声明不是定义，不分配内存
>
> 全局变量若直接定义在头文件中，多个 `.c` 文件包含该头文件会导致**重复定义链接错误**，应在头文件中用 `extern` 声明，在某一个 `.c` 文件中定义
>
> `extern` 声明函数时可以省略 `extern`（函数默认外部链接），但变量不行，容易混淆
>
> `extern` 与 `static` 冲突：static 全局变量具有内部链接，其他文件用 `extern` 声明也**无法访问**

1. `extern` 关键字的作用是什么？有哪些使用场景？

2. 如何在另一个 `.c` 文件中引用已定义的全局变量？写出示例。

3. 全局变量可以直接定义在被多个 `.c` 文件包含的头文件中吗？为什么？应该怎么做？

4. 以下代码有什么问题？

```c
// a.c
static int count = 0;

// b.c
extern int count;  // 试图访问 a.c 中的 count
```

5. `extern` 声明函数和声明变量有什么区别？以下两种写法有何不同？

```c
extern void foo();   // 声明函数
extern int x;        // 声明变量
```

💡 答案提示

**第1题：** `extern` 用于声明一个在其他文件（或当前文件后面）已定义的变量或函数，告诉编译器"这个符号存在，去别处找"，本身不分配内存。常见使用场景有两个：一是跨文件共享全局变量，二是跨文件调用函数（实际上函数声明默认带外部链接，通常写在头文件中）。

**第2题示例：**

```c
// a.c —— 定义
int count = 0;

// b.c —— 声明后使用
extern int count;
count++;
```

**第3题：** 不可以。头文件被多个 `.c` 包含后，每个编译单元都有一份定义，链接时会报**重复定义错误**。正确做法是头文件中用 `extern` 声明，只在一个 `.c` 文件中定义。

```c
// common.h
extern int count;   // 声明

// common.c
int count = 0;      // 定义（只此一处）
```

**第4题：** `count` 在 `a.c` 中是 `static` 全局变量，具有内部链接，其他文件的 `extern` 声明**无法访问**，链接时报未定义符号错误。

**第5题：** 函数默认具有外部链接，`extern void foo()` 和 `void foo()` 声明效果相同，`extern` 可省略；但变量声明必须写 `extern`，否则会被视为定义并分配内存。

- 函数如果没有在对应头文件中声明的话，要想在其他源文件中使用就要使用extern声明，否则会有警告。

---

### 1.4.4 volatile 关键字 【问答题】

> **考点**：告诉编译器该变量可能被意外修改，禁止优化——每次访问都从内存重新读取
> **注意**：
>
> `volatile` 禁止编译器优化，但**不保证原子性和线程安全**，多线程场景下还需要加锁或使用原子操作，不能用 `volatile` 替代互斥锁
>
> `volatile` 只影响编译器行为，不影响 CPU 缓存一致性，在多核场景下**不能保证可见性**，与 Java 中的 `volatile` 语义不同，注意区分
>
> `const volatile` 可以同时使用，表示该变量只读（程序不能写），但可能被外部修改（每次都要重新读），常见于只读硬件状态寄存器

1. `volatile` 关键字的含义是什么？为什么需要它？
2. 以下代码在开启编译器优化后可能出现什么问题？加上 `volatile` 后有何变化？

```c
int flag = 0;

void wait_for_flag() {
    while (flag == 0);  // 等待中断将 flag 置1
}
```

3. `volatile` 能保证线程安全吗？为什么？

4. `const volatile` 组合修饰有意义吗？什么场景下使用？

💡 答案提示

**三大应用场景：**

| 场景           | 原因                                   |
| -------------- | -------------------------------------- |
| 硬件寄存器     | 寄存器值可能被硬件随时改变             |
| 中断服务程序   | ISR 中修改的共享变量，主程序需感知变化 |
| 多线程共享变量 | 防止编译器将变量缓存在寄存器中         |

**第2题：** 编译器优化后可能判断 `flag` 在循环中从未被修改，将其缓存在寄存器中，导致循环永远无法退出（死循环）。加上 `volatile` 后，编译器每次都从内存重新读取 `flag`，能正确感知外部修改。

**第3题：** 不能。`volatile` 只禁止编译器优化，不提供原子性保证，多线程对共享变量的读改写仍可能出现竞态条件，需配合互斥锁或原子操作使用。

**第4题：** 有意义。`const` 表示程序内部不可写，`volatile` 表示值可能被外部改变需每次重新读取，两者不冲突。典型场景是获取只读的硬件状态寄存器，程序只读取其值但硬件可能随时更新它。

### 1.4.5 静态变量、全局变量与局部变量的异同 【问答题】

> **考点**：`static` 的双重语义——修饰局部变量（延长生命周期不改作用域）vs 修饰全局变量/函数（限制作用域到当前文件）；各类变量的存储位置
> **注意**：
>
> 静态局部变量只初始化一次，后续调用保留上一次的值，这是笔试常考点
>
> 静态全局变量与普通全局变量**生命周期相同**，区别只在链接属性（作用域），不要误答成生命周期不同
>
> 全局变量和静态变量若未显式初始化，自动初始化为 0；局部变量未初始化则是**未定义的垃圾值**，两者行为不同容易忽略
>
> `.bss` 段存放**未初始化或初始化为0**的全局/静态变量，`.data` 段存放**已初始化且非0**的，笔试有时会细问

1. 请简述静态变量、全局变量、局部变量的异同。
2. 以下代码输出什么？

```c
void foo() {
    static int a = 0;
    int b = 0;
    a++; b++;
    printf("a=%d b=%d\n", a, b);
}

int main() {
    foo();
    foo();
    foo();
}
```

3. 全局变量和静态局部变量的生命周期相同，那它们有什么区别？
4. 以下两个变量分别存放在 `.bss` 还是 `.data` 段？

```c
static int x = 0;
static int y = 10;
```

💡 答案提示

| 变量类型        | 存储位置      | 生命周期     | 作用域     | 默认初始值 |
| --------------- | ------------- | ------------ | ---------- | ---------- |
| 局部变量        | 栈            | 函数执行期间 | 函数/块内  | 垃圾值     |
| static 局部变量 | .bss/.data 段 | 整个程序     | 函数/块内  | 0          |
| 全局变量        | .bss/.data 段 | 整个程序     | 所有文件   | 0          |
| static 全局变量 | .bss/.data 段 | 整个程序     | 仅当前文件 | 0          |

**static 的两种用法：**

1. 修饰局部变量：延长生命周期，不改变作用域
2. 修饰全局变量/函数：限制作用域到当前文件，不改变生命周期

**第2题：** 输出：

```
a=1 b=1
a=2 b=1
a=3 b=1
```

`a` 是静态局部变量，保留上次的值；`b` 是普通局部变量，每次调用重新初始化为 0。

**第3题：** 生命周期相同，但作用域不同——全局变量整个程序可见，其他文件可通过 `extern` 访问；静态局部变量作用域仍限于函数内，外部无法访问。

**第4题：** `x` 初始化为 0 存放在 `.bss` 段；`y` 初始化为非0值存放在 `.data` 段。

## 1.5 运算符与表达式

### 1.5.1 运算符优先级 【选择题】

> **考点**：优先级从高到低大致为：括号/下标 > 单目 > 算术 > 移位 > 关系 > 位运算 > 逻辑 > 赋值
> **注意**：
>
> `==` 和 `!=` 优先级低于其他关系运算符（`> < >= <=`），常被误认为同级
>
> 位运算（`& ^ |`）优先级低于关系运算符，`a & b == 0` 实际上是 `a & (b == 0)`，是经典陷阱
>
> 逻辑与 `&&` 高于逻辑或 `||`，两者都低于关系运算符
>
> 单目 `++/--` 高于双目算术运算符，但前置和后置优先级不同：后置 `++` 优先级高于前置 `++`
>
> 赋值运算符 `=` 优先级几乎最低，仅高于逗号运算符

**(1)** 算术运算符、赋值运算符和关系运算符的运算优先级按从高到低依次为（  ）

- A. 算术运算、赋值运算、关系运算
- B. 算术运算、关系运算、赋值运算
- C. 关系运算、赋值运算、算术运算
- D. 关系运算、算术运算、赋值运算

💡 **答案：B**。算术 > 关系 > 赋值，赋值优先级几乎最低。


---

**(2)** C语言中，下列运算符优先级最高的是（  ）

- A. `!`（逻辑非，单目）
- B. `%`（取模，算术）
- C. `>>`（右移）
- D. `==`（等于，关系）

💡 **答案：A**。单目运算符优先级高于双目算术运算符，`!` 属于单目，优先级最高。


---

**(3)** 下列优先级判断**错误**的是（  ）

- A. `%` > `+`
- B. `&&` > `=`
- C. `[]` > 后置 `++`
- D. `<<` > `>`

💡 **答案：C**。`[]`（下标）和后置 `++` 优先级相同，同属第一级，从左到右结合，并非 `[]` 更高。A、B、D 均正确。

**(4)**以下表达式的结果是什么？

```c
int a = 1, b = 1;
int c = a & b == 0;
printf("%d\n", c);
```

💡 **答案：** 输出 `0`。

因为 `==` 优先级高于 `&`，实际计算顺序是：

```c
c = a & (b == 0)
c = 1 & (1 == 0)
c = 1 & 0
c = 0
```

而大多数人会误读为 `(a & b) == 0`，即 `(1 & 1) == 0 = 0`，结果虽然相同但逻辑完全不同，换个值就会出错。将 `b` 改为 `2` 可以更清晰暴露差异：

```c
int a = 1, b = 2;
// 误读：(a & b) == 0  →  (1 & 2) == 0  →  0 == 0  →  1
// 实际：a & (b == 0)  →  1 & 0          →  0
```

### 1.5.7 运算符优先级与结合性（乘法、取模、加法）【选择题】

> **考点**：`*`、`%` 优先级相同且左结合，均高于 `+`
> **注意**：
>
> `*` 和 `%` **优先级相同**，同级运算按**左结合**依次从左到右计算，不是 `%` 优先于 `*`
>
> `%` 是**取模（取余）**，结果是除法的余数，而非商
>
> `68 % 3` 的计算：68 = 3×22 + **2**，余数为2，初学者容易算错
>
> 整个表达式没有括号时，严格按照"先乘除取模，后加减"的顺序，且同级从左到右

在C语言程序中，下面程序运行后，`n` 的值是多少？（  ）

```c
int n = 0;
int f = 17;
n = 4 * f % 3 + 1;
```

- **A.** 1
- **B.** 2
- **C.** 3
- **D.** 4

💡 **答案提示** 

**答案：C** 

```c
n = 4 * f % 3 + 1
  = 4 * 17 % 3 + 1     // 代入 f=17
  = (4 * 17) % 3 + 1   // *和%同级，左结合，先算4*17
  = 68 % 3 + 1         // 68÷3=22余2，取余得2
  = 2 + 1              // 最后加法
  = 3
```

💡 **记忆口诀**：同级运算看左右，不同级别高者先；`*`、`/`、`%` 是一家，`+`、`-` 靠边站。

### 1.5.2 整型专用运算符 【选择题】

> **考点**：取模运算 `%` 要求操作数必须是整型
> **注意**：
>
> `/` 既可用于整型也可用于浮点型，但整型相除会**截断小数部分**，`5/2=2` 而非 `2.5`，容易忽略
>
> `!` 可用于任意标量（整型、浮点、指针），结果为 0 或 1
>
> `**` 在 C 语言中**不是合法运算符**，是干扰项，C 中求幂需用 `pow()` 函数
>
> 取模结果的符号与**被除数**一致（C99规定），如 `-7 % 3 = -1` 而非 `2`，这是笔试常考陷阱

**(1)**C 语言中运算对象必须是整型的运算符是（  ）

- A. `%`

  B. `/`

  C. `!`

  D. `*`（乘法）

💡 **答案：A**。`%` 只能用于整型；`/` 可用于浮点；`!` 可用于任意标量；`*` 乘法同样可以用于浮点数（如 `1.5 * 2.0`），所以四个选项中只有 `%` 要求操作数必须是整型，答案不变。改成 `*` 只是让选项更合法、更具迷惑性

**(2)**以下代码输出什么？

```c
printf("%d\n", -7 % 3);
printf("%d\n", 7 % -3);
```

C99 规定取模结果符号与**被除数**一致，`-7 % 3` 被除数为 `-7` 故结果为 `-1`；`7 % -3` 被除数为 `7` 故结果为 `1`。

**(3)**以下代码输出什么？

```c
printf("%d\n", 5 / 2);
printf("%f\n", 5.0 / 2);

2
2.500000
```

整型相除截断小数，`5/2=2`；只要有一个操作数为浮点型，结果就是浮点数。


---

### 1.5.3 逗号表达式 【选择题】

> **考点**：逗号表达式从左到右依次求值，整个表达式的值为最后一个表达式的值
> **注意**：
>
> `j++`（后缀自增）：表达式的值是自增**前**的值，自增**后**才生效
>
> `++j`（前缀自增）：表达式的值是自增**后**的值
>
> 逗号表达式取**最后一项**的值，而不是所有项的累加或最大值
>
> 逗号运算符优先级是所有运算符中**最低**的，注意括号的作用——`(j=3, j++)` 外层括号保证整体作为一个表达式被求值

若变量已正确定义，表达式 `(j=3, j++)` 的值是（  ）

- **A.** 3
- **B.** 4
- **C.** 5
- **D.** 0

💡 **答案提示**

**答案：A**

1. `j=3` → j 赋值为 3，该子表达式值为 3
2. `j++` → 后缀自增，**表达式的值为自增前的 3**，语句结束后 j 变为 4
3. 逗号表达式取最后一项 `j++` 的值 → **3**

**延伸对比：**

| 表达式       | 值    | 执行后 j   |
| ------------ | ----- | ---------- |
| `(j=3, j++)` | **3** | 4          |
| `(j=3, ++j)` | **4** | 4          |
| `(j=3, j+1)` | **4** | 3（j不变） |


---

### 1.5.4 位运算——右移 【选择题】

> **考点**：右移 `>>` 将二进制位向右移动，低位丢弃，高位补位
> **注意**：
>
> 右移1位 ≈ 整除2，右移n位 ≈ 整除2ⁿ（**向下取整**，负数时与普通除法结果不同）
>
> **无符号数**右移：高位补 **0**（逻辑右移）
>
> **有符号正数**右移：高位补 **0**
>
> **有符号负数**右移：高位补 **1**（算术右移，保持负数符号）
>
> 左移 `<<` 是乘以2的幂，左移n位 = 乘以2ⁿ，所有二进制位整体向左移动n位，右边补0
>
> 左移和右移都是针对**二进制**操作

执行语句 `k = 7 >> 1;` 后，变量 `k` 的当前值是（  ）

- **A.** 15
- **B.** 31
- **C.** 3
- **D.** 1

干扰项说明：

- 选 **A（15）** 或 **B（31）**：可能误以为是**左移**（`7<<1`=14，`15<<1`=30，数值变大）
- 选 **D（1）**：可能误以为右移2位，或只取了最低位

💡 **答案提示**

**答案：C**

```
7  的二进制：0000 0111
右移1位后：  0000 0011  = 3
             ↑补0        ↓低位1丢弃
```

**延伸对比：**

| 表达式    | 运算    | 结果                     |
| --------- | ------- | ------------------------ |
| `7 >> 1`  | 7 ÷ 2¹  | **3**                    |
| `7 >> 2`  | 7 ÷ 2²  | **1**                    |
| `7 << 1`  | 7 × 2¹  | **14**                   |
| `-8 >> 1` | 高位补1 | **-4**（有符号算术右移） |

**负数右移示例**（补充理解，防止混淆）：

```
-8 的补码：1111 1000
右移1位：  1111 1100  = -4（高位补1，保持负号）
```


---

### 1.5.5 位运算——特定位清零 【选择题】

> **考点**：使用位掩码（mask）对特定位进行操作
> **注意**：
>
> `4` = `0000 0100`，即 bit[2]（位编号从0开始，**bit[0]是最低位**）
>
> `~4` 是按位取反，结果是 `1111 1011`，**只有 bit[2] 是0**，其余全是1
>
> `&` 运算：与0相与→清零，与1相与→保持原值；所以 `&= ~mask` 只改变mask对应的位
>
> `|` 运算：与1相或→置1，与0相或→保持原值
>
> `^` 运算：与1异或→翻转，与0异或→保持原值
>
> **bit编号从0开始**，bit[2] 对应数值 2² = **4**，这是选4作为掩码的原因，初学者容易搞错对应关系

下面哪个操作可以将 `flag` 的 bit[2] 置 0？（  ）

- **A.** `flag |= 4` — 置1
- **B.** `flag ^= 4` — 翻转（不确定结果）
- **C.** `flag &= ~4` — **清零** ✓
- **D.** `flag |= ~4` — 几乎全部置1

💡 **答案提示**

**答案：C**

假设 `flag = 0xFF`（全1），逐项分析：

```
flag       = 1111 1111
4          = 0000 0100
~4         = 1111 1011
```

| 选项            | 运算过程                | 结果        | 效果                             |
| --------------- | ----------------------- | ----------- | -------------------------------- |
| A. `flag |= 4`  | `1111 1111 | 0000 0100` | `1111 1111` | bit[2]置**1**（错）              |
| B. `flag ^= 4`  | `1111 1111 ^ 0000 0100` | `1111 1011` | bit[2]**翻转**，结果不确定（错） |
| C. `flag &= ~4` | `1111 1111 & 1111 1011` | `1111 1011` | bit[2]清**0**，其余不变 ✓        |
| D. `flag |= ~4` | `1111 1111 | 1111 1011` | `1111 1111` | 几乎全部置1（错）                |

**掩码与位编号对应关系：**

| 目标位 | bit[0] | bit[1] | bit[2] | bit[3] | bit[n] |
| ------ | ------ | ------ | ------ | ------ | ------ |
| 掩码值 | 1      | 2      | **4**  | 8      | 2ⁿ     |

**三种位操作口诀：**

- 清零用 `&= ~mask`
- 置一用 `|= mask`
- 翻转用 `^= mask`


---

### 1.5.6 位运算——判断2的幂 【编程题】

> **考点**：利用位运算的数学性质判断2的幂，比循环除2更高效
> **注意**：
>
> **必须单独排除 `x=0`**：`0 & (0-1)` = `0 & (-1)` = `0`，若不加 `x>0` 判断，0会被误判为2的幂
>
> **负数问题**：若 `x` 为有符号数，负数也需排除，`x>0` 已同时处理
>
> **运算符优先级陷阱**：`&` 的优先级低于 `==`，**必须加括号**
>
> - 错误写法：`x & x-1 == 0`（实际等价于 `x & (x-1==0)`，结果完全错误）
> - 正确写法：`(x & (x-1)) == 0`
>
> `x-1` 当 `x=0` 时会发生**无符号数下溢**（若x为unsigned），这也是要先判断 `x>0` 的原因之一

写一语句实现 `x` 是否为2的若干次幂的判断。

```c
(x > 0) && ((x & (x - 1)) == 0)
```

**原理图解：**

```
x   = 2³ = 8 → 0000 1000
x-1 =      7 → 0000 0111
x & (x-1)  → 0000 0000 = 0 ✓ 是2的幂

x   =      6 → 0000 0110
x-1 =      5 → 0000 0101
x & (x-1)  → 0000 0100 ≠ 0 ✗ 不是2的幂
```

**边界情况验证：**

| x    | x>0  | x & (x-1)    | 结论                    |
| ---- | ---- | ------------ | ----------------------- |
| 0    | ✗    | 短路，不计算 | 假（正确排除）          |
| 1    | ✓    | 1&0 = 0      | **真**（2⁰=1，是2的幂） |
| 2    | ✓    | 2&1 = 0      | 真                      |
| 3    | ✓    | 3&2 = 2 ≠ 0  | 假                      |
| 8    | ✓    | 8&7 = 0      | 真                      |
| -8   | ✗    | 短路，不计算 | 假（正确排除负数）      |

**优先级陷阱对比：**

| 写法               | 实际解析           | 是否正确                                             |
| ------------------ | ------------------ | ---------------------------------------------------- |
| `x & x-1 == 0`     | `x & (x-1==0)`     | ✗ 错误                                               |
| `(x & x-1) == 0`   | `(x & (x-1)) == 0` | ✗ 仍错（`x-1`先算但`&`右侧缺括号在某些编译器有歧义） |
| `(x & (x-1)) == 0` | 完全正确解析       | ✓ 正确                                               |

### 1.5.8 字符运算与 ASCII 【选择题】

> **考点**：字符本质是ASCII整数，可直接参与算术运算，`%c` 输出对应字符
> **注意**：
>
> `'f'` 赋值给 `int x`，x存储的是 `'f'` 的**ASCII码值102**，不是字母本身
>
> `x - 'a'` 计算的是字母 `f` 距离 `a` 的**偏移量**（=5），这是一种常见的"字母位置"计算技巧
>
> `+1` 表示往后移一个字母，`'a' + 6` = 第7个字母 = `'g'`
>
> `printf("%c", ...)` 会将整数**转回对应字符**输出，而 `%d` 则输出数字——注意格式符的区别
>
> 常用ASCII码需记忆：`'a'=97, 'A'=65, '0'=48`，相互之间**不连续**，不可混用。小写大，大写小。

下述程序执行后的输出结果是（  ）

```c
#include <stdio.h>
int main() {
    int x = 'f';
    printf("%c\n", 'a' + (x - 'a' + 1));
}
```

- **A.** g
- **B.** h
- **C.** i
- **D.** j

💡 **答案提示** 

**答案：A**

```c
x = 'f' = 102（ASCII）

x - 'a' = 102 - 97 = 5    // f是字母表中第5个偏移（从0起）
x - 'a' + 1 = 6           // 往后移一位
'a' + 6 = 97 + 6 = 103    // ASCII 103
103 对应字符 → 'g'
```

**常见字母运算模板：**

| 目的                | 写法                     |
| ------------------- | ------------------------ |
| 数字转字符          | `'0' + n`                |
| 字符转数字          | `ch - '0'`               |
| 大小写转换（小→大） | `ch - 'a' + 'A'`         |
| 大小写转换（大→小） | `ch - 'A' + 'a'`         |
| 判断是否小写字母    | `ch >= 'a' && ch <= 'z'` |
| 判断是否数字字符    | `ch >= '0' && ch <= '9'` |

> 💡 **记忆技巧**：把字母表想象成数组，`'a'` 是下标0，`ch - 'a'` 就是取下标，`'a' + n` 就是按下标找字母。


---

### 1.5.9 整数除法精度丢失 【选择题】

> **考点**：整数除法在C中直接截断小数，与浮点除法结果不同
> **注意**：
>
> `1/2` 中两个操作数都是**整型常量**，结果为整型 `0`，与变量类型无关——即使后面有float变量，`1/2` 已经先算完了
>
> C语言除法规则：**只要两个操作数都是整数，结果就是整数**（截断，不是四舍五入）
>
> `*` 和 `/` 同优先级**左结合**，所以 `(a+b) * c * 1 / 2` 中 `/2` 作用于前面已经是浮点数的中间结果
>
> `c / 2` 中 `c` 是 `float`，`2` 是整型，**混合运算会自动提升为浮点除法**，结果为 `1.5`，不会截断
>
> 关键判断依据：**除号两侧是否有浮点数参与**，有则浮点除法，全整数则整数除法

设 `float a=2, b=4, c=3;`，以下表达式中与代数式 `(a+b)*c/2` 计算结果（**9.0**）不一致的是（  ）

- A. `(a + b) * c / 2`
- B. `(1/2) * (a + b) * c`
- C. `(a + b) * c * 1 / 2`
- D. `c / 2 * (a + b)`

💡 **答案提示**

**答案：B**

逐项计算（`a=2, b=4, c=3`，目标值 **9.0**）：

| 选项 | 计算过程                                        | 结果         |
| ---- | ----------------------------------------------- | ------------ |
| A    | `(2+4)*3/2` = `6.0*3/2` = `18.0/2` = **9.0**    | ✓ 一致       |
| B    | `(1/2)*(a+b)*c` = `0*(2+4)*3` = **0.0**         | ✗ **不一致** |
| C    | `(2+4)*3*1/2` = `18.0*1/2` = `18.0/2` = **9.0** | ✓ 一致       |
| D    | `3/2*(2+4)` = `1.5*6.0` = **9.0**               | ✓ 一致       |

**整数除法 vs 浮点除法判断：**

| 表达式                    | 除号两侧类型 | 结果          |
| ------------------------- | ------------ | ------------- |
| `1 / 2`                   | int ÷ int    | **0**（截断） |
| `1.0 / 2`                 | double ÷ int | **0.5**       |
| `c / 2`（c为float）       | float ÷ int  | **1.5**       |
| `(a+b) / 2`（a,b为float） | float ÷ int  | **浮点结果**  |

> 💡 **记忆技巧**：看除号 `/` 的**左右两侧**，只要有一个是浮点数，结果就是浮点；`1/2` 两侧都是整数常量，无论写在哪里都已经等于0了。


---

### 1.5.10 strcmp 返回值 【选择题】

> **考点**：`strcmp` 逐字符比较ASCII值，返回整数
> **注意**：
>
> `strcmp` 比较的是**字符串**，不是数值——`"3.14"` 和 `"3.278"` 是字符序列，不是小数
>
> 逐字符比较：`'3'=='3'` → `'.'=='.'` → `'1'` vs `'2'`，`'1'`的ASCII=49，`'2'`的ASCII=50，49<50，所以返回**负整数**
>
> 返回值只保证：相等→0，前小后大→负整数，前大后小→正整数；**具体数值因编译器而异**，不能假设返回-1或1
>
> 容易误认为比较的是数值大小：数值上 3.14 < 3.278，字符串比较结论相同，但**原因不同**——是因为 `'1'<'2'`，而不是因为数值更小
>
> 需要 `#include <string.h>` 才能使用
>
> `strcmp` 返回值常用于条件判断，应写 `strcmp(s1,s2) == 0` 而非 `strcmp(s1,s2)` 直接当bool用（虽然能跑，但语义不清晰）

表达式 `strcmp("3.14", "3.278")` 的值是一个（  ）

- **A.** 非零整数
- **B.** 浮点数
- **C.** 0
- **D.** 字符

💡 **答案提示**

**答案：A**

```
"3.14"  逐字符：'3'  '.'  '1'  '4'  '\0'
"3.278" 逐字符：'3'  '.'  '2'  '7'  '8'  '\0'
                 ↓    ↓    ↓
                相等  相等  不等！
               '1'(49) < '2'(50) → 返回负整数
```

**strcmp 返回值总结：**

| 情况               | 返回值     |
| ------------------ | ---------- |
| 两字符串完全相等   | **0**      |
| 前者字典序小于后者 | **负整数** |
| 前者字典序大于后者 | **正整数** |

**常见错误用法对比：**

| 写法                        | 问题                               |
| --------------------------- | ---------------------------------- |
| `if (strcmp(s1, s2))`       | 非零为真，能判断不相等，但语义不清 |
| `if (strcmp(s1, s2) == 0)`  | ✓ 推荐，明确判断相等               |
| `if (strcmp(s1, s2) == -1)` | ✗ 错误，返回值不保证是-1           |

> 💡 **记忆技巧**：`strcmp` 返回值可以理解为"前减后"的方向——前者小则负，前者大则正，相等则零。但只是方向参考，不代表具体差值。

---

### 1.5.11 int/bool/float/指针与零值比较 【问答题】

> **考点**：浮点数**不能用 `==` 和 `0` 比较**，必须用精度范围判断；布尔值用 `if(!b)` 更规范
> **注意**：
>
> `int` 与零比较直接用 `== 0` 即可，但 `0 == a` 的**防御性写法**可避免误写成 `a = 0`（赋值），推荐养成习惯
>
> `bool` 变量本身就代表真假，直接用 `if (b)` / `if (!b)`，写 `if (b == true)` 或 `if (b == 1)` 虽然能跑但不规范
>
> `float` 不能用 `==` 与任何值比较——因为浮点数在内存中是近似表示，`0.1 + 0.2 != 0.3`，必须用误差范围判断
>
> `EPSILON` 的大小需根据场景选择：`float` 用 `1e-6`，`double` 用 `1e-9`，不是固定的
>
> 指针写 `if (!p)` 和 `if (p == NULL)` 均正确，但 `if (p == NULL)` **语义更清晰**，推荐在指针判断中使用
>
> `NULL` 必须大写，`null` 在C中不存在（C++/Java才有小写）

写出 `int`、`bool`、`float`、指针变量与"零值"比较的 `if` 语句。

💡 **答案提示**

```c
// int 与零值比较
int a = 0;
if (a == 0)       // 标准写法
if (0 == a)       // 防御性写法，防止误写成 a = 0

// bool 与零值比较
bool b = true;
if (!b)           // ✓ 推荐

// float 与零值比较
#include <math.h>
#define EPSILON 1e-6
float f = 0.1f;
if (fabs(f) < EPSILON)    // ✓ 正确，用误差范围判断
if (f == 0.0f)            // ✗ 错误！浮点数不能用==比较

// 指针与零值比较
int *p = NULL;
if (p == NULL)    // ✓ 推荐，语义清晰
```

**浮点精度问题示例（为什么不能用==）：**

```c
float x = 0.1f + 0.2f;
if (x == 0.3f)           // 结果为假！x实际为0.30000001...
if (fabs(x - 0.3f) < 1e-6)  // ✓ 正确判断方式
```

> 💡 **记忆技巧**：四种类型记忆口诀——整数直接比，布尔用逻辑非，浮点用误差，指针判NULL。

## 1.6 流程控制

### 1.6.1 switch 语句的 fall-through 【分析题】

> **考点**：`switch` 中没有 `break` 会贯穿执行到下一个 `case`
> **注意**：
>
> `switch` 匹配后从对应 `case` 开始执行，**没有 `break` 就继续向下贯穿**，不会再判断下面的 `case` 条件
>
> `default` 不一定在最后，但本题在最后，贯穿时同样会执行
>
> `case 0:` 后面没有任何语句直接接 `case 1:`，这是**有意的 fall-through**，两个case共享同一段代码，是合法且常见的写法
>
> 第(2)题核心是字符运算：`c` 是字符，`c - '2'` 得到的是**相对偏移**，用于匹配case；输出时 `c + 4` 是在原字符ASCII值上加4
>
> `getchar()` 每次读一个字符，`while` 循环对输入串 `2473` 逐字符处理，`'\n'` 作为终止条件

**(1)** 分析以下程序的输出结果：

````c
#include <stdio.h>
int main() {
    int i = 10;
    switch (i) {
        case 9:  i++;
        case 10: i++;
        case 11: i++;
        default: i++;
    }
    printf("result= %d\n", i);
    return 0;
}
```
💡 **答案提示**
```
i = 10，匹配 case 10，从此处开始执行：
case 10: i++ → i = 11
case 11: i++ → i = 12   // 无break，继续贯穿
default: i++ → i = 13   // 无break，继续贯穿
输出：result= 13
````


---

**(2)** 下述程序运行时，如果输入为 `2473`，则输出结果是（  ）

```c
#include <stdio.h>
void main() {
    int c;
    while ((c = getchar()) != '\n')
        switch (c - '2') {
            case 0:
            case 1: putchar(c + 4); break;
            case 2: putchar(c + 4); break;
            case 3: putchar(c + 3); break;
            default: putchar(c + 2); break;
        }
    printf("\n");
}
```

- **A.** 6897
- **B.** 6885
- **C.** 6877
- **D.** 6997

**逐字符推算：**

| 输入字符 c | c的ASCII | c-'2' | 匹配case                       | 操作  | 输出ASCII | 输出字符 |
| ---------- | -------- | ----- | ------------------------------ | ----- | --------- | -------- |
| `'2'`      | 50       | 0     | case 0 → fall-through → case 1 | `c+4` | 54        | `'6'`    |
| `'4'`      | 52       | 2     | case 2                         | `c+4` | 56        | `'8'`    |
| `'7'`      | 55       | 5     | default                        | `c+2` | 57        | `'9'`    |
| `'3'`      | 51       | 1     | case 1                         | `c+4` | 55        | `'7'`    |

根据上述计算，正确输出应为`6897`，因此选项A正确。

------

💡 **答案提示**

**答案：A（6897）**

**解题步骤模板：** ① 确定 `c` 的ASCII值 → ② 算 `c-'2'` 匹配哪个case → ③ 注意 case 0 无语句直接fall-through到 case 1 → ④ 用对应操作算输出ASCII → ⑤ 转回字符


---

### 1.6.2 条件判断执行流程 【选择题】

> **考点**：`!`运算符、前缀自减 `--a`、`if-else` 分支执行
> **注意**：
>
> `--a` 是**前缀自减**，先将 `a` 减 1，再将减后的值用于判断，而非先判断再减；
>
> `!0` 为**真**（非零取反为假，零取反为真）；
>
> `if-else` 中 `else` 始终与**最近的未配对 `if`** 结合，本题两个 `if` 各自独立，互不影响；
>
> `x--` 是**后缀自减**，此处直接对 `x` 减 1，结果立即生效（容易与前缀混淆）；
>
> 两个 `if` 是**顺序执行**的独立语句，第一个 `if` 的结果会影响第二个 `if` 的初始值。

下列程序段运行后，`x` 的值是（  ）

```c
a = 1; b = 2; x = 0;
if (!(--a)) x--;
if (!b) x = 7; else ++x;
```

- **A.** 0
- **B.** 3
- **C.** 6
- **D.** 7

**解析：**

第一步：`--a` → `a` 变为 `0`，`!(0)` 为真，执行 `x--`，`x = -1`

第二步：`!b` → `!(2)` 为假，走 `else` 分支，执行 `++x`，`x = 0`

- A. **0** ✓
- B. 3
- C. 6
- D. 7

**答案：A**


---

### 1.6.3 for 循环特殊写法 【问答题】

> **考点**：`for` 语句三部分的省略写法、永真条件、无限循环
> **注意**：
>
> `for` 的三个部分（初始化、条件、迭代）**都可以省略**，但两个分号 `;` **不能省略**；
>
> 条件部分省略时，C语言默认视为**永真**，与显式写 `1` 效果相同；
>
> `for(;1;)` 与 `for(;;)` 与 `while(1)` **三者完全等价**，都是无限循环；
>
> 无限循环本身**不是语法错误**，编译器不会报错，是逻辑层面的问题；
>
> 无限循环并非一定有害，嵌入式/操作系统中主循环常用此写法，但需要内部有 `break` 或 `return` 等退出机制，否则程序永远无法终止。

语句 `for(;1;)` 有什么问题？它是什么意思？

**参考答案：**

`for(;1;)` 是一个**无限循环**语句。

结构分析上，`for` 的初始化部分和迭代部分均被省略，条件部分写的是常量 `1`，在C语言中非零值恒为真，因此循环条件永远成立，循环体会被**无限次执行**，程序无法自然退出该循环。

它等价于以下几种写法：

```c
for(;;)      // 条件省略，默认永真
while(1)     // 最常见的无限循环写法
while(true)  // C99/C++中可用
```

**存在的问题：**

- 这条语句本身**没有语法错误**，可以正常编译；
- 问题在于**逻辑层面**：若循环体内没有 `break`、`return` 或 `exit()` 等退出手段，程序将陷入死循环，无法终止，导致程序"假死"或资源耗尽；
- 在一般应用程序中，这通常是一个**逻辑设计缺陷**。

**补充易错点：**

- 容易误认为省略条件就是"条件为假"从而不执行——实际上恰恰相反，省略条件默认为**真**；
- 容易误认为这是语法错误而认为编译不通过——实际上编译器只检查语法，逻辑问题需要人工判断。

---

### 1.6.4 do...while 与 while的区别 【问答题】

> **考点**：`do...while` 的执行特性、与 `while` 的区别
> **注意**：
>
> `do...while` 是**先执行循环体，再判断条件**，因此至少执行**一次**；
>
> `while` 是**先判断条件，再执行循环体**，条件一开始为假则**一次都不执行**；
>
> `do...while` 末尾的 **分号 `;` 不能省略**，这是语法要求，容易遗漏；
>
> ⚠️ **最重要的陷阱：`while...do` 在C语言中根本不存在！** 这是一个**非法语法**，C语言只有 `do...while`，没有 `while...do`；
>
> 题目中出现 `while...do` 是一个**干扰性的错误概念**，考查学生是否会被表面相似的写法混淆；
>
> `while...do` 是部分伪代码或其他语言（如Pascal）中的写法，不能套用到C语言中。

`do...while` 和 `while...do` 有什么区别？

**对比示例：**

```c
int a = 0;

// while：条件为假，一次不执行
while (a > 0) {
    printf("while执行\n");   // 不会输出
}

// do...while：先执行一次再判断
do {
    printf("do执行\n");      // 输出一次
} while (a > 0);
```

**补充易错点总结：**

- 误以为 `while...do` 是合法的C语法——它**不存在**，不要被题目表述带偏；
- 忘记 `do...while` 末尾的分号，导致编译错误；
- 两种循环条件**相同**时，`do...while` 比 `while` 多执行一次循环体（仅在初始条件为假时体现差异）。

---

## 1.7 函数

### 1.7.1 函数参数传递方式 【选择题】

> **考点**：值传递、指针传递、数组传递（退化为指针）
> **注意**：
>
> 数组名作为参数传递时退化为指针，函数内 `sizeof(a)` 得到的是指针本身大小（32位系统为4字节，64位系统为8字节），而非原数组大小
>
> `void fun(int a[])` 与 `void fun(int *a)` 对编译器完全等价，写成数组形式仅是语义提示，不改变退化为指针的本质；从调用形式看是"数组传递"，从机制本质看是"指针传递"，两者描述同一件事，并不互斥
>
> 指针传递可以在函数内通过解引用修改原变量的值，值传递只修改副本，不影响原变量
>
> 数组传递后可以在函数内修改原数组的元素值，因为本质上操作的是原数组的地址
>
> 要在函数内获取传入数组的长度，必须通过额外手段，不能依赖 `sizeof`

**(1)** 参数传递方式判断：

```c
int fun(int a[], short *ptr, int c) {
    /* ... */
}

int main() {
    int arr[10];
    short val = 100;
    int x = 200;
    fun(arr, &val, x);
    return 0;
}
```

- 请选择所有正确的传递方式描述：（  ）

  - A. `a` 是数组传递（语义形式）
  - B. `a` 的本质是指针传递
  - C. `ptr` 是指针传递
  - D. `c` 是值传递

  **答案：ABCD**

**解析：**

- A和B同时成立且不互斥，`int a[]` 写法在语义上表达"传入数组"，但编译器将其等价处理为 `int *a`，本质是指针传递
- `ptr` 接收 `&val`，直接传入地址，是典型的指针传递
- `c` 接收 `x` 的值的副本，函数内修改 `c` 不影响 `x`，是值传递


---

**(2)** 数组作为函数参数以地址形式传入函数，要在函数内部计算出传入数组的大小；数组作为函数参数怎样传入，有几种方法？ 【问答题】

1. 额外传递长度参数（最常用）

```c
void fun(int a[], int len) { /* 用 len 表示元素个数 */ }
```

2. 传入首尾指针

```c
void fun(int *begin, int *end) { int len = end - begin; }
```

调用时：`fun(arr, arr + 10);`

3. **哨兵值** 约定数组以某个特殊值结尾（如字符串以 `\0` 结尾），函数内遍历直到遇到哨兵值为止。适用于元素值域有限、可划出特殊值的场景。

#### 总结

**① 本质：所有参数传递都是值传递（栈上复制）**

函数调用时所有参数都在栈上创建副本，区别只在于复制的是什么：

| 传递方式 | 栈上复制的内容           | 能否影响外部变量                                 |
| -------- | ------------------------ | ------------------------------------------------ |
| 值传递   | 变量的值本身             | ❌ 只修改副本，不影响外部                         |
| 指针传递 | 指针的值（地址）         | ⚠️ 改指针指向不影响外部，解引用 `*ptr` 可影响外部 |
| 数组传递 | 首元素地址（退化为指针） | ⚠️ 同指针传递，见③                                |

**② 数组传递退化为指针**

- `void fun(int a[])` 与 `void fun(int *a)` 对编译器完全等价，数组形式仅是语义提示
- 从调用形式看是"数组传递"，从机制本质看是"指针传递"，两者描述同一件事，并不互斥
- 退化后 `sizeof(a)` 得到的是**指针本身的大小**（32位系统4字节，64位系统8字节），而非原数组大小，因此不能在函数内用 `sizeof` 获取数组长度

**③ 数组下标是解引用的语法糖**

函数内能通过 `a[i]` 修改原数组元素，原因链条是：

> 数组名退化为指针 → 复制的是首元素地址 → `a[i]` 等价于 `*(a+i)`，本质是解引用 → 操作的是原内存

同理，函数内让 `a` 指向别处不影响外部数组，只有通过下标或解引用操作元素才影响外部。

**④ 函数内获取数组长度必须依赖额外手段**

由于退化后 `sizeof` 失效，常用方法有：额外传递长度参数、传首尾指针、约定哨兵值。`sizeof(a)/sizeof(a[0])` 这类宏只能在数组名**尚未退化前**（与数组定义同作用域处）使用。[跳转使用宏获取数组元素个数](###1.3.1 宏定义求数组元素个数 【编程题】)。

---

### 1.7.2 main 函数参数 【选择题】

> **考点**：`main(int argc, char *argv[])` 的参数含义与规范
> **注意**：
>
> `argc` 统计的是**包含程序名在内**的参数总个数，执行 `./program hello world` 时 `argc = 3`，`argv[0]` 是程序名，`argv[1]` 起才是用户传入的参数
>
> `argv[argc]` 固定为 `NULL`，是参数数组的哨兵值
>
> `char *argv[]` 作为函数参数同样退化为 `char **argv`，与数组传递退化规则一致

**(1)** 若 `main()` 函数带参数，参数个数最多是（  ）

- **A.** 0
- **B.** 1
- **C.** 2
- **D.** 3

**解析：** C标准规定 `main` 函数的带参形式为 `int main(int argc, char *argv[])`，最多两个形参。部分编译器扩展支持第三个参数 `char *envp[]` 用于接收环境变量，但这不属于C标准，考试按标准答C。

**(2) 执行以下命令时，`argc` 的值是（  ）**

```
./program foo bar baz
```

- A. 3
- B. 4
- C. 2
- D. 1

**答案：B**

**解析：** `argc` 统计包含程序名在内的所有参数，`argv[0] = "./program"`，`argv[1] = "foo"`，`argv[2] = "bar"`，`argv[3] = "baz"`，共4个，所以 `argc = 4`。`argv[4] = NULL` 为哨兵值。

**(3) 以下关于 `argv` 的说法正确的是（  ）**

- A. `argv` 是一个字符串
- B. `argv[0]` 是用户传入的第一个参数
- C. `argv[argc]` 的值为 `NULL`
- D. `char *argv[]` 与 `char argv[][]` 等价

**答案：C**

**解析：**

- A错，`argv` 是字符串数组（指针数组）
- B错，`argv[0]` 是程序名本身，用户参数从 `argv[1]` 开始
- C对，`argv[argc]` 固定为 `NULL`，是标准规定的哨兵值
- D错，`char *argv[]` 作为参数退化为 `char **argv`，而 `char argv[][]` 是二维字符数组，两者类型不同


---

### 1.7.3 函数缺省返回类型 【选择题】

> **考点**：C89中未声明返回类型的函数默认返回 `int`
> **注意**：
>
> 本规则属于**C89/C90标准**，C99及之后的标准已取消隐式 `int`，不写返回类型会报错，现代编译器下可能看到警告或错误
>
> 隐式 `int` 规则同样适用于**函数调用前未声明**的情况：C89中调用一个未提前声明的函数，编译器隐式假设其返回 `int`
>
> 缺省返回类型是 `int` 不等于可以省略 `return`，函数体内若没有返回语句或返回了不兼容的类型，行为是未定义的

**(1) 在C89标准中，定义函数时缺省返回类型声明，则函数默认返回类型是（  ）**

- A. void
- B. char
- C. float
- D. int

**答案：D**

**解析：** C89标准规定，函数定义或声明时若省略返回类型，编译器默认其返回类型为 `int`，即 `fun(){}` 等价于 `int fun(){}`。C99之后此规则被取消，省略返回类型会导致编译错误。

------

**(2) 在C89标准中，以下代码的输出结果是（  ）**

c

```c
fun() {
    return 100;
}

int main() {
    printf("%d\n", fun());
    return 0;
}
```

- A. 编译错误
- B. 运行时错误
- C. 100
- D. 0

**答案：C**

**解析：** C89中 `fun()` 缺省返回类型默认为 `int`，`return 100` 合法，输出100。若在C99/C11编译器下编译则会报错。

------

**(3) 在C89标准中，以下关于隐式 `int` 规则说法正确的是（  ）**

- A. 缺省返回类型的函数默认返回 `void`
- B. 调用未声明的函数，编译器隐式假设其返回 `int`
- C. 缺省返回类型的函数可以不写 `return` 语句
- D. C99标准保留了隐式 `int` 规则

**答案：B**

**解析：**

- A错，默认是 `int` 不是 `void`
- B对，C89中调用未声明函数时编译器同样隐式假设返回 `int`，这是隐式int规则的另一个体现
- C错，缺省返回类型是int不代表可以省略return，省略return或返回不兼容类型属于未定义行为
- D错，C99已明确废除隐式int规则


---

## 1.8 字符串与内存操作

### 1.8.1 转义字符 【选择题】

> **考点**：八进制转义 `\ddd`（1-3位，每位只能是0-7）、十六进制转义 `\xhh`（`\x` 后跟1位以上十六进制数字，但值不能溢出char范围）
> **注意**：
>
> 八进制转义每一位只能是 `0-7`，出现 `8` 或 `9` 则非法，如 `'\9'` 是错误的转义字符
>
> 八进制转义最多3位，如 `'\0000'` 四位是错误的
>
> `\x` 后的十六进制位数C标准无硬性上限，但值超出 `char` 可表示范围时行为未定义，考试通常以"超出范围"作为出错依据
>
> `'\000'` 与 `'\0'` 等价，均表示空字符NUL，值为0，是合法的
>
> `'\14'` 是合法的八进制转义，值为十进制12，即换行符 `'\n'`

**(1) 下列转义字符中错误的是（  ）**

- A. `'\000'`
- B. `'\14'`
- C. `'\x1F'`
- D. `'\89'`

**答案：D**

**解析：** `'\89'` 中 `8` 和 `9` 不是合法的八进制数字（八进制只有0-7），因此是非法转义。A是合法八进制，值为0；B是合法八进制，值为12；C是合法十六进制，值为31。

------

**(2) 下列关于转义字符的说法正确的是（  ）**

- A. `'\0000'` 是合法的八进制转义字符
- B. `'\000'` 与 `'\0'` 表示不同的字符
- C. 八进制转义字符每一位可以是 `0-9` 中的任意数字
- D. `'\14'` 的十进制值为12

**答案：D**

**解析：**

- A错，八进制转义最多3位，`'\0000'` 四位非法
- B错，两者均表示空字符NUL，值都是0
- C错，八进制只能用 `0-7`，出现8或9即非法
- D对，`\14` 是八进制14，转十进制为 1×8+4=12

**二进制 / 八进制 / 十六进制转十进制快速方法**

[位运算的对照](###1.5.4 位运算——右移 【选择题】)

**核心公式：从右往左，每一位乘以对应进制的次幂后求和（权值展开法）**

**二进制转十进制：** 每位乘以2的对应次幂

```
1101 → 1×2³ + 1×2² + 0×2¹ + 1×2⁰
     = 8 + 4 + 0 + 1 = 13
```

**八进制转十进制：** 每位乘以8的对应次幂

```
\14 → 1×8¹ + 4×8⁰ = 8 + 4 = 12
```

**十六进制转十进制：** 每位乘以16的对应次幂，A-F对应10-15

```
\x1F → 1×16¹ + 15×16⁰ = 16 + 15 = 31
```


---

### 1.8.2 字符指针与偏移 【选择题】

> **考点**：运算符优先级、`*p+4` 与 `*(p+4)` 的区别、ASCII偏移计算
> **注意**：
>
> 解引用 `*` 的优先级高于加法 `+`，所以 `*p+4` 等价于 `(*p)+4`，是先取值再加4，而非 `*(p+4)`（先偏移指针再取值）
>
> `'a'` 的ASCII值为97，字母 `a-z` 在ASCII表中连续排列，`'a'+n` 就是字母表中第n个之后的字母，如 `'a'+4='e'`
>
> 字符数组 `{"abc\0def"}` 中 `\0` 后面的 `def` 依然存在于内存中，`\0` 只是字符串函数（如 `strlen`、`printf("%s")`）的终止标志，不影响直接下标或指针访问
>
> `printf("%c")` 只输出单个字符，不受 `\0` 影响

**两种读法对比：**

| 表达式   | 含义                    | 计算过程                      | 结果  |
| -------- | ----------------------- | ----------------------------- | ----- |
| `*p+4`   | 先取 `*p` 的值，再加4   | `'a'+4=101`                   | `'e'` |
| `*(p+4)` | 先将指针偏移4位，再取值 | 跳过`a` `b` `c` `\0`，取到`d` | `'d'` |

**(1) 若定义了 `char ch[] = {"abc\0def"}, \*p = ch;`，则执行 `printf("%c", \*p+4);` 的输出结果是（  ）**

- A. def
- B. d
- C. e
- D. 0

**答案：C**

**解析：** `*p` 解引用得到 `ch[0]` 即 `'a'`（ASCII 97），加4得101，对应字符 `'e'`。A错，`%c` 只输出单个字符；B是 `*(p+4)` 的结果，混淆了运算符优先级；D是误以为 `p+4` 指向 `\0`（实际 `\0` 在下标3处）。

------

**(2) 同样条件下，`printf("%c", \*(p+4));` 的输出结果是（  ）**

- A. e
- B. d
- C. \0
- D. 0

**答案：B**

**解析：** `p+4` 将指针偏移4位，`ch` 的内存布局为 `a(0) b(1) c(2) \0(3) d(4) e(5) f(6)`，下标4处是 `'d'`，所以输出 `'d'`。C和D是误以为 `\0` 在下标4处。

------

**(3) 以下关于 `"abc\0def"` 的说法正确的是（  ）**

- A. 该字符串长度为7，`strlen` 返回7
- B. `\0` 后面的 `def` 不存在于内存中
- C. `strlen(ch)` 返回3
- D. `sizeof(ch)` 返回3

**答案：C**

**解析：** `strlen` 遇到 `\0` 停止计数，所以返回3；`\0` 后的 `def` 依然存在于内存中，B错；`sizeof(ch)` 返回数组总字节数，包含所有字符和结尾的 `\0`，共8字节，D错。


---

### 1.8.3 字符串遍历与步长 【分析题】

> **考点**：指针步长、`%s` 打印子串、循环终止条件
> **注意**：
>
> `*bp` 作为循环条件等价于 `*bp != '\0'`，是判断当前字符是否为空字符，而非判断指针是否为NULL
>
> `printf("%s", bp)` 从 `bp` 当前位置打印**直到遇到 `\0`**，是打印子串而非单个字符，与 `printf("%c", *bp)` 完全不同
>
> `bp+=2` 每次跳过2个字符，不是逐字符遍历，可能跳过某些字符但不影响 `%s` 的打印终点
>
> 遇到此类题目，务必手动画出内存布局逐步追踪指针位置

执行下述程序的输出结果：

```c
#include <stdio.h>
char b[] = "ABCDEF";
main() {
    char *bp;
    for (bp = b; *bp; bp += 2)
        printf("%s", bp);
    printf("\n");
}
```

**内存布局：**

```
下标:  0    1    2    3    4    5    6
内容:  A    B    C    D    E    F    \0
```

**逐步追踪：**

| 循环次数 | bp指向下标 | `*bp`                      | 打印内容 |
| -------- | ---------- | -------------------------- | -------- |
| 第1次    | 0          | `'A'`，非`\0`，进入循环    | `ABCDEF` |
| 第2次    | 2          | `'C'`，非`\0`，进入循环    | `CDEF`   |
| 第3次    | 4          | `'E'`，非`\0`，进入循环    | `EF`     |
| 第4次    | 6          | `'\0'`，条件为假，退出循环 | —        |

**最终输出：**

```
ABCDEFCDEFE F
```

注意三次输出之间没有空格或换行，连续拼接在同一行，最后 `printf("\n")` 换行。

------

**(1) 执行上述程序的输出结果是（  ）**

- A. `ABCDEF`
- B. `ACE`
- C. `ABCDEFCDEF EF`
- D. `ABCDEFCDEFEF`

**答案：D**

**解析：** 每次 `printf("%s", bp)` 从当前位置打印到 `\0`，三次分别输出 `ABCDEF`、`CDEF`、`EF`，连续拼接无间隔，共输出 `ABCDEFCDEFEF`。B是误用 `%c` 的结果，C多了空格。

------

**(2) 若将 `bp+=2` 改为 `bp+=3`，输出结果是（  ）**

- A. `ABCDEFDEF`
- B. `ABCDEDEF`
- C. `ABCDEFDEF F`
- D. `ACF`

**答案：A**

**解析：** 步长改为3，逐步追踪：

| 循环次数 | bp指向下标 | `*bp`            | 打印内容 |
| -------- | ---------- | ---------------- | -------- |
| 第1次    | 0          | `'A'`，进入循环  | `ABCDEF` |
| 第2次    | 3          | `'D'`，进入循环  | `DEF`    |
| 第3次    | 6          | `'\0'`，退出循环 | —        |

最终输出 `ABCDEFDEF`。

------

**(3) 若将 `printf("%s", bp)` 改为 `printf("%c", *bp)`，输出结果是（  ）**

- A. `ABCDEF`
- B. `ACE`
- C. `ABCDEFCDEFEF`
- D. `ACD`

**答案：B**

**解析：** `%c` 只打印当前指针指向的单个字符，步长2依次指向下标0、2、4，对应字符 `A`、`C`、`E`，输出 `ACE`。这与 `%s` 打印子串形成鲜明对比。


---

### 1.8.4 memcpy 重叠拷贝行为分析 【分析题】

> **考点**：`memcpy` 重叠行为、逐字节拷贝过程追踪、`memmove` 对比
> **注意**：源和目标重叠时，`memcpy` 的行为是未定义的；实际结果取决于实现

请分析下列程序执行后，数组 `data` 的最终内容是什么：

```c
#include <stdio.h>
#include <string.h>

#define MAX_DATA_SIZE (10)

int main() {
    unsigned int i = 0;
    unsigned char data[MAX_DATA_SIZE] = {1,2,3,4,5,6,7,8,9,0};
    memcpy(&data[2], data, MAX_DATA_SIZE / 2);
    return 0;
}
```

- `memcpy` 源与目标内存区域重叠时行为是**未定义的**，C标准不保证结果正确，实际结果取决于编译器实现
- 本题在**从低地址向高地址逐字节拷贝**的典型实现下分析，这是考试中的约定前提
- 判断是否重叠：源范围 `[src, src+n)`，目标范围 `[dst, dst+n)`，两者有交集即为重叠
- 目标在源**右边**时，从低到高拷贝会先覆盖重叠区域，导致后续读到已被污染的值
  - 有重叠的话，原来的值会被新拷贝的值覆盖了，导致后面从源拷贝的值已经不是原来的值了。
- 目标在源**左边**时，从低到高拷贝不会产生覆盖问题，结果与预期一致
  - 只要读取不被污染，就不会产生问题。
- `memmove` 会检测重叠方向，目标在源右边时改为从高地址向低地址拷贝，结果始终正确
  - 怎么确定高地址的边界呢？通过字节个数和源地址去算高地址，然后从最后一个字节开始往前拷贝

**重叠区域判断：**

```
下标:   0  1  2  3  4  5  6  7  8  9
初始:   1  2  3  4  5  6  7  8  9  0
源:     [---- 5字节 ----]
             src[0..4]
目标:         [---- 5字节 ----]
                  dst[2..6]
重叠:         [--]
               [2..4]
```

**逐字节拷贝过程追踪（低到高）：**

| 步骤  | 操作              | 读取值            | 写入位置  | 数组状态              |
| ----- | ----------------- | ----------------- | --------- | --------------------- |
| 初始  | —                 | —                 | —         | `1 2 3 4 5 6 7 8 9 0` |
| 第1步 | `data[2]=data[0]` | 1                 | `data[2]` | `1 2 1 4 5 6 7 8 9 0` |
| 第2步 | `data[3]=data[1]` | 2                 | `data[3]` | `1 2 1 2 5 6 7 8 9 0` |
| 第3步 | `data[4]=data[2]` | **1（已被污染）** | `data[4]` | `1 2 1 2 1 6 7 8 9 0` |
| 第4步 | `data[5]=data[3]` | **2（已被污染）** | `data[5]` | `1 2 1 2 1 2 7 8 9 0` |
| 第5步 | `data[6]=data[4]` | **1（已被污染）** | `data[6]` | `1 2 1 2 1 2 1 8 9 0` |

**最终结果（典型实现）：** `{1, 2, 1, 2, 1, 2, 1, 8, 9, 0}`

**若改用 `memmove`（从高地址向低地址拷贝）：**

| 步骤  | 操作              | 读取值 | 写入位置  | 数组状态              |
| ----- | ----------------- | ------ | --------- | --------------------- |
| 初始  | —                 | —      | —         | `1 2 3 4 5 6 7 8 9 0` |
| 第1步 | `data[6]=data[4]` | 5      | `data[6]` | `1 2 3 4 5 6 5 8 9 0` |
| 第2步 | `data[5]=data[3]` | 4      | `data[5]` | `1 2 3 4 5 4 5 8 9 0` |
| 第3步 | `data[4]=data[2]` | 3      | `data[4]` | `1 2 3 4 3 4 5 8 9 0` |
| 第4步 | `data[3]=data[1]` | 2      | `data[3]` | `1 2 3 2 3 4 5 8 9 0` |
| 第5步 | `data[2]=data[0]` | 1      | `data[2]` | `1 2 1 2 3 4 5 8 9 0` |

**最终结果（memmove）：** `{1, 2, 1, 2, 3, 4, 5, 8, 9, 0}`

------

**(1) 在从低地址向高地址逐字节拷贝的典型实现下，程序执行后 `data` 的内容是（  ）**

- A. `{1, 2, 1, 2, 3, 4, 5, 8, 9, 0}`
- B. `{1, 2, 1, 2, 1, 2, 1, 8, 9, 0}`
- C. `{1, 2, 3, 4, 5, 6, 7, 8, 9, 0}`
- D. `{1, 2, 1, 2, 1, 8, 9, 0}`

**答案：B**

**解析：** 源和目标重叠，从低到高拷贝时重叠区域的值被提前覆盖，后续步骤读到的是已被污染的值，导致出现循环重复的 `1 2 1 2 1 2 1` 模式。A是使用 `memmove` 的正确结果。

------

**(2) 若将 `memcpy` 改为 `memmove`，`data` 的最终内容是（  ）**

- A. `{1, 2, 1, 2, 1, 2, 1, 8, 9, 0}`
- B. `{1, 2, 1, 2, 3, 4, 5, 8, 9, 0}`
- C. `{1, 2, 3, 4, 5, 4, 5, 8, 9, 0}`
- D. `{1, 2, 3, 4, 5, 6, 7, 8, 9, 0}`

**答案：B**

**解析：** `memmove` 检测到目标在源右边，改为从高地址向低地址拷贝，避免了覆盖问题，结果是预期的 `{1, 2, 1, 2, 3, 4, 5, 8, 9, 0}`。

------

**(3) 以下关于 `memcpy` 和 `memmove` 的说法正确的是（  ）**

- A. `memcpy` 和 `memmove` 在任何情况下结果都相同
- B. 源和目标不重叠时，`memcpy` 和 `memmove` 结果相同
- C. `memcpy` 在重叠时会自动检测方向，保证正确性
- D. `memmove` 比 `memcpy` 慢，任何情况下都应优先使用 `memcpy`

**答案：B**

**解析：** 不重叠时两者行为一致，结果相同；A错，重叠时结果可能不同；C错，自动检测方向的是 `memmove` 而非 `memcpy`；D的说法方向正确（`memmove` 因需判断方向略慢）但结论错误，重叠场景必须用 `memmove`。

#### 总结

**① 数组元素的存储方向与大小端无关**

数组元素**始终从低地址向高地址连续存储**，这是C标准规定的，与大小端无关。

大小端影响的是**单个多字节数据内部的字节排列顺序**：

| 概念         | 影响对象                     | 示例                                      |
| ------------ | ---------------------------- | ----------------------------------------- |
| 数组存储方向 | 元素与元素之间的地址顺序     | `data[0]` 地址 < `data[1]` 地址，永远成立 |
| 大小端       | 单个多字节元素内部的字节顺序 | `int x = 0x12345678`，占4字节，见下表     |

```
内存地址:      低地址 → 高地址
大端存储:      12  34  56  78   （高位字节在低地址）
小端存储:      78  56  34  12   （低位字节在低地址）
```

本题 `data` 是 `unsigned char` 数组，每个元素只占1字节，**不存在多字节内部排列问题**，大小端对本题完全没有影响。`data[0]` 一定在最低地址，`data[9]` 一定在最高地址。

------

**② `memcpy` 与 `memmove` 的参数含义**

两者函数签名完全相同：

```c
void *memcpy (void *dst, const void *src, size_t n);
void *memmove(void *dst, const void *src, size_t n);
```

| 参数   | 含义                   |
| ------ | ---------------------- |
| `dst`  | 目标地址，拷贝到哪里   |
| `src`  | 源地址，从哪里读数据   |
| `n`    | 拷贝的**字节数**       |
| 返回值 | 返回 `dst`，一般不使用 |

注意点：

- 参数顺序是**dst在前，src在后**，与赋值语句 `dst = src` 的书写习惯一致，但容易和 `strcpy(dst, src)` 混淆记反
- 第三个参数是**字节数**而非元素个数，拷贝 `int` 数组时需要乘以 `sizeof(int)`，如 `memcpy(dst, src, 5 * sizeof(int))`
- 本题 `memcpy(&data[2], data, MAX_DATA_SIZE / 2)` 中，`dst=&data[2]`，`src=data`（即`&data[0]`），`n=5`字节

## 1.9 内存管理

### 1.9.1 栈与堆的区别 【问答题】

> **考点**：栈与堆的管理方式、生命周期、典型用法及堆上分配的注意事项
> **注意**：
>
> 栈由系统自动管理，但空间有限（通常几MB），局部数组过大或递归过深会导致**栈溢出**（stack overflow），并非无限安全
>
> `free(p)` 释放内存后 `p` 变为**悬空指针**（dangling pointer），仍指向原地址，再次访问是未定义行为；习惯上应在 `free` 后立即执行 `p = NULL`
>
> `malloc` 返回 `void*`，C语言中会自动隐式转换为任意指针类型，**不需要强制类型转换**；
>
> 内存模型中的"堆"与数据结构中的"堆（二叉堆/优先队列）"**名字相同但概念无关**

"栈 stack"和"堆 heap"有什么区别？写两个函数分别在栈上和堆上分配内存，在堆上分配内存应注意哪些问题？

**栈与堆对比：**

| 对比项   | 栈（Stack）       | 堆（Heap）                   |
| -------- | ----------------- | ---------------------------- |
| 管理方式 | 系统自动分配/回收 | 程序员手动 `malloc/free`     |
| 空间大小 | 较小（通常几MB）  | 较大（取决于系统内存）       |
| 分配速度 | 快（移动栈指针）  | 慢（查找空闲块）             |
| 碎片     | 无                | 有                           |
| 生命周期 | 函数结束自动释放  | 手动释放前一直存在           |
| 风险     | 栈溢出            | 内存泄漏、悬空指针、重复释放 |

**栈上分配示例：**

```c
void stack_alloc() {
    int a = 10;              /* 基本类型，栈上 */
    int arr[100];            /* 数组，栈上，函数返回后自动释放 */
    /* 注意：不能返回局部变量的地址，函数结束后栈帧销毁 */
}
```

**堆上分配示例：**

```c
void heap_alloc() {
    int *p = malloc(sizeof(int) * 100);  /* 堆上分配100个int */
    if (p == NULL) {                      /* ① 必须检查返回值 */
        /* 处理分配失败 */
        return;
    }
    /* 使用内存 */
    p[0] = 1;
    free(p);       /* ② 用完必须释放，否则内存泄漏 */
    p = NULL;      /* ③ free后置NULL，避免悬空指针 */
    /* free(p);    ④ 重复释放是未定义行为，置NULL后再free是安全的 */
}
```

**堆上分配的注意事项：**

① **检查返回值：** `malloc` 分配失败时返回 `NULL`，不检查直接使用会导致空指针解引用崩溃

② **用完必须释放：** 不调用 `free` 会导致内存泄漏，长期运行的程序会耗尽内存

③ **free后置NULL：** 避免悬空指针，置NULL后即使误操作也会触发可排查的空指针错误而非未定义行为

④ **避免重复释放：** 对同一指针调用两次 `free` 是未定义行为，可能导致程序崩溃；`free(NULL)` 是安全的无操作

⑤ **分配与释放配对：** `malloc` 和 `free` 必须成对出现，在同一层级管理，避免所有权混乱


---

### 1.9.2 结构体的使用场景 【问答题】

> **考点**：结构体的封装思想、与全局变量的对比、使用注意事项
> **注意**：
>
> 结构体作为函数参数时是**整体值拷贝**，结构体较大时应传指针 `struct Point *p` 而非直接传值，避免拷贝开销
>
> 全局变量的核心问题不只是风格，而是**任何地方都可以修改**，数据流向难以追踪，多线程下还存在竞态条件风险
>
> 结构体可以**嵌套**其他结构体，也可以包含指向自身的**指针**（用于链表、树等），但不能包含自身类型的**值**（大小无限递归，编译报错）
>
> 结构体存在**内存对齐**，实际大小不等于各成员大小之和，编译器会插入填充字节（padding），`sizeof(struct)` 结果可能超出预期

结构体的使用场景，为啥不用全局变量？

**结构体的使用场景：**

结构体将描述同一事物的相关数据封装在一起，适用于以下场景：

**描述一个实体的多个相关属性**

```c
struct Student {
    int id;
    char name[32];
    float score;
};
```

**函数间传递多个相关数据**

```c
/* 不用结构体：参数列表冗长，容易传错顺序 */
void print_student(int id, char *name, float score);

/* 用结构体：清晰，扩展方便 */
void print_student(struct Student *s);
```

**函数返回多个值**

```c
struct MinMax {
    int min;
    int max;
};

struct MinMax find_minmax(int arr[], int len) {
    struct MinMax result;
    /* ... */
    return result;
}
```

------

**为什么不用全局变量：**

全局变量谁都能改、难追踪、难维护；结构体把数据封装起来跟着调用走，可控、清晰、安全。

**传参方式选择：**

```c
/* 小结构体（几个基本类型成员）：直接传值 */
void move(struct Point p, int dx, int dy);

/* 大结构体：传指针，避免拷贝开销 */
void process(struct BigData *data);

/* 只读时加 const，明确语义 */
void print_student(const struct Student *s);
```


---

## 1.10 编译与链接

### 1.11.1 编译错误 vs 运行时错误 【选择题】

> **考点**：三类错误的区分——编译错误、运行时错误、逻辑错误
> **注意**：
>
> - 三类错误的本质区别：
>
> | 错误类型   | 发现时机   | 典型表现                                     |
> | ---------- | ---------- | -------------------------------------------- |
> | 编译错误   | 编译阶段   | 语法违规，编译器报错，无法生成可执行文件     |
> | 运行时错误 | 程序运行中 | 程序崩溃，如**除零、空指针解引用、栈溢出**   |
> | 逻辑错误   | 程序运行后 | 程序正常运行但结果不符合预期，编译器无法检测 |
>
> - `x==5;` 语法合法，是比较表达式作为语句，编译通过；但本意是赋值却写成比较，属于**逻辑错误**，不要误认为是运行时错误
> - 现代编译器对 `x==5;` 加 `-Wall` 会产生**警告**，但警告不是错误，不影响编译通过，不要把警告误认为编译错误
> - C语言每条语句都必须以分号结尾，**没有例外**，复合语句最后一条语句同样需要分号

**(1) 下列各个错误中，哪一个不属于编译错误（  ）**

- A. 改变 `x` 原值为5，写作 `x==5;`
- B. 花括号不配对
- C. 复合语句中的最后一条语句后未加分号
- D. 变量有引用、无定义

**答案：A**

**解析：** `x==5;` 语法上合法，编译器不会报错，属于逻辑错误。B是典型语法错误；C中每条语句都必须有分号，缺少分号是编译错误；D中使用未定义的变量编译器会报"未声明的标识符"错误。

------

**(2) 以下哪种错误属于运行时错误（  ）**

- A. 缺少头文件
- B. 变量未声明就使用
- C. 对空指针进行解引用
- D. 将 `==` 误写成 `=` 导致判断逻辑错误

**答案：C**

**解析：** 空指针解引用在运行时触发段错误（Segmentation Fault），是典型的运行时错误。A和B是编译错误；D是逻辑错误，程序能正常运行但结果不符合预期。

------

**(3) 以下关于 `x==5;` 的说法正确的是（  ）**

- A. 是编译错误，因为比较结果没有被使用
- B. 是运行时错误，程序会崩溃
- C. 语法合法，编译通过，但属于逻辑错误
- D. 加 `-Wall` 编译后会报编译错误

**答案：C**

**解析：** `x==5;` 是合法的表达式语句，编译通过；加 `-Wall` 只会产生警告而非错误，D错；程序不会崩溃，B错；属于逻辑错误而非编译错误，A错。


---

### 1.11.2 静态库和动态库的区别 【问答题】

> **考点**：静态库与动态库的链接方式、优缺点及适用场景
> **注意**：
>
> 动态库分两种加载方式：**隐式链接**（程序启动时由OS自动加载）和**显式链接**（运行中手动调用 `dlopen`/`LoadLibrary`），不只是笼统的"运行时加载"
>
> 动态库"更新无需重新编译"的前提是**接口不变**，若函数签名改变仍需重新编译调用方
>
> 静态库无外部库依赖，但其内部若调用了系统函数，这些系统依赖仍然存在，只是被打包进了可执行文件
>
> 多个静态库中若有同名函数会产生**符号冲突**，动态库有独立命名空间，冲突风险更低

静态库和动态库的区别。

**核心区别对比：**

| 对比项         | 静态库（`.a`/`.lib`）            | 动态库（`.so`/`.dll`）                    |
| -------------- | -------------------------------- | ----------------------------------------- |
| 链接时机       | 编译时链接，代码打包进可执行文件 | 运行时加载（启动自动或手动 `dlopen`）     |
| 可执行文件体积 | 大（库代码被复制进去）           | 小（只保存引用）                          |
| 内存占用       | 多个进程各自持有一份             | 多个进程共享同一份                        |
| 依赖关系       | 无外部库依赖，独立运行           | 需要运行环境中存在对应的库文件            |
| 更新方式       | 需重新编译链接                   | 接口不变时替换库文件即可，无需重新编译    |
| 符号冲突       | 多库同名函数易冲突               | 独立命名空间，冲突风险低                  |
| 适用场景       | 嵌入式、对依赖敏感的发布环境     | 桌面/服务器应用、插件系统、频繁更新的模块 |

**动态库两种加载方式：**

```c
/* 隐式链接：编译时指定，程序启动时OS自动加载 */
/* gcc main.c -lmylib -o main */
#include "mylib.h"
mylib_func();   /* 直接调用，OS负责加载 */
```

**静态库：**

```makefile
# Makefile 中链接静态库
gcc main.c -L./lib -lmylib -o main
# -L 指定库文件搜索路径
# -l 指定库名（libmylib.a 去掉 lib 前缀和 .a 后缀）
```

**动态库：**

```makefile
# 编译时指定（隐式链接），和静态库写法一样
gcc main.c -L./lib -lmylib -o main

# 但运行时还需要能找到 .so 文件，有三种方式：
# ① 设置环境变量（临时，常用于开发调试）
export LD_LIBRARY_PATH=./lib:$LD_LIBRARY_PATH

# ② 把库拷贝到系统目录（全局生效）
cp libmylib.so /usr/lib/

# ③ 在 /etc/ld.so.conf 中添加路径后执行 ldconfig（全局生效）
ldconfig
```

**Makefile 完整示例：**

```makefile
CC = gcc
CFLAGS = -Wall
LDFLAGS = -L./lib        # 库搜索路径
LIBS = -lmylib           # 链接的库

main: main.c
    $(CC) $(CFLAGS) main.c $(LDFLAGS) $(LIBS) -o main
```

**编译时如何决定链接静态还是动态：**

```makefile
# 强制静态链接
gcc main.c -L./lib -static -lmylib -o main

# 默认优先动态库，没有 .so 才用 .a
gcc main.c -L./lib -lmylib -o main
```

**一句话总结（适合面试）：**

> 静态库编译时把代码直接打包进可执行文件，独立性强但体积大、每次改库都要重新编译；动态库运行时才加载，多个进程可以共享同一份，体积小，只要接口不变替换库文件就能热更新，但部署时要确保运行环境里有对应的库文件

## 1.12 位域

- 位域(bit-field)确实常用于寄存器操作，但它提供了比位运算更直观的方式。
- 位域是结构体中的一种特殊成员，可以指定成员占用的**位(bit)数**，而不是字节数。

```c
struct 结构体名 {
    类型 成员名 : 位数;
};
```

```c
假设我们要操作一个8位的状态寄存器，各位含义如下：

bit 0: 使能位
bit 1-3: 模式选择(3位，0-7)
bit 4-6: 优先级(3位，0-7)
bit 7: 中断标志
```

**传统位运算方式**

```c
uint8_t status_reg = 0;

// 设置使能位
status_reg |= (1 << 0);

// 设置模式为5
status_reg &= ~(0x07 << 1);  // 先清零
status_reg |= (5 << 1);       // 再设置

// 读取优先级
uint8_t priority = (status_reg >> 4) & 0x07;
```

使用位域方式

```c
struct StatusReg {
    uint8_t enable    : 1;  // 占1位
    uint8_t mode      : 3;  // 占3位
    uint8_t priority  : 3;  // 占3位
    uint8_t int_flag  : 1;  // 占1位
};

//实例化一个结构体变量
struct StatusReg status = {0};

// 操作变得非常直观
status.enable = 1;
status.mode = 5;
uint8_t priority = status.priority;
```

### 位域的优缺点

**优点：**

- 代码可读性强，一目了然
- 自动处理位移和掩码
- 节省内存（多个小数据打包存储）

**缺点：**

- 可能影响性能（某些平台）

## 1.13 C语言中有关内存布局的概念

C语言的内存布局（`Memory Layout`）是指C程序在**运行时**，其**进程在内存中的组织结构和分配方式**。这是一个经典的编程概念，主要用于理解程序如何使用内存资源、避免内存错误（如溢出、泄漏），并优化性能。

内存布局指的是：程序被OS加载并执行时，作为进程在内存中的动态结构。可执行文件被加载到内存，OS初始化段，程序运行时堆和栈动态变化。

C语言的内存布局本质上是操作系统中的内存概念：

- 它基于**操作系统的进程内存模型**。OS（如Linux的内核）**为每个进程提供一个独立的虚拟内存空间**（通常从0x00000000到高地址，如64位系统的2^64-1）。
- OS负责内存的分配、保护和分页（paging）。例如，文本段被标记为只读，栈和堆有增长限制。C语言通过标准库（如stdlib.h的malloc）与OS交互，**但底层是OS的系统调用（如brk()或mmap()）**。
- 这不是C语言独有的，而是通用于许多语言（如C++），但C强调手动管理，因此布局概念更突出。如果没有OS（如裸机嵌入式系统），内存布局可能简化，由程序员直接定义。

### 整体布局

- **Linux下32位环境的用户空间内存分布情况**

对于32位环境，理论上程序可以拥有4GB的虚拟地址空间，我们在C语言中使用到的变量、函数、字符串等都会对应内存中的一块区域。

- 但是，在这 4GB 的地址空间中，要拿出一部分给操作系统内核使用，应用程序无法直接访问这一段内存，这一部分内存地址被称为内核空间（Kernel Space）。
- Windows 在默认情况下会将高地址的 2GB 空间分配给内核（也可以配置为1GB），而 Linux默认情况下会将高地址的1GB 空间分配给内核。也就是说，应用程序只能使用剩下的 2GB 或 3GB 的地址空间，称为用户空间（User Space）。

**那如果两个C语言程序正在运行的话。那么他们的内存模型应该是共享内核空间。用户空间再分为具体的独立空间。关于用户空间中的分布可以参考C语言的内存布局。**

![img](./C语言相关.assets/1852906-20220430161404050-235745048.jpg)

### 通用分区与ELF段的对应关系

面试中有两种问法：问"在哪个区域"（通用分区），或问"在哪个段"（ELF段）。两者的对应关系如下：

| 通用分区               | ELF段     | 权限          | 说明                                                         |
| ---------------------- | --------- | ------------- | ------------------------------------------------------------ |
| 程序代码区             | `.text`   | 只读 + 可执行 | 函数机器码                                                   |
| 常量区                 | `.rodata` | 只读          | 字符串字面量、全局const变量                                  |
| 全局数据区（已初始化） | `.data`   | 读写          | 已初始化的全局/静态变量，初始值存于二进制文件                |
| 全局数据区（未初始化） | `.bss`    | 读写          | 未初始化或初始化为0的全局/静态变量，**不占二进制文件体积**，加载时由OS清零 |
| 堆区                   | heap      | 读写          | 运行时动态分配，向上增长                                     |
| 动态链接库映射         | mmap区域  | 读写/只读     | 位于堆和栈之间，`dlopen` 加载的 `.so`，以及大块 `malloc`（>128KB）也走此区域 |
| 栈区                   | stack     | 读写          | 函数调用帧、局部变量，向下增长                               |

### 程序代码区（`.text` 段）

**存放函数体的二进制代码。一个C语言程序由多个函数构成，C语言程序的执行就是函数之间的相互调用**。该区域对应ELF的 `.text` 段，权限为只读+可执行（R-X），运行期间不可修改。

### 常量区（`.rodata` 段）

**存放一般的常量、字符串常量等。这块内存只有读取权限，没有写入权限，因此它们的值在程序运行期间不能改变。**

对应ELF的 `.rodata`（read-only data）段，包括：

- 字符串字面量：`"hello"`、`"www.baidu.com"` 等
- 全局/文件作用域的 `const` 变量：`const int MAX = 100;`

> **注意**：函数内部的 `const` 局部变量（如 `const int x = 5;`）**通常仍在栈上**，编译器会阻止对它赋值，但存储位置不变。只有全局/静态的 `const` 才进 `.rodata`。

### 全局数据区

**存放全局变量、静态变量等。**这块内存有读写权限，因此它们的值在程序运行期间可以任意改变。

面试中经常进一步问"在哪个段"，此处细分为两个ELF段：

- **`.data` 段**：存放**已初始化且初始值非零**的全局变量和静态变量。初始值保存在二进制文件中，加载时从文件读入内存。
- **`.bss` 段**（Block Started by Symbol）：存放**未初始化**或**初始化为0**的全局变量和静态变量。`.bss` **不占二进制文件的实际体积**，只记录所需大小，加载时由OS/loader自动清零。

```c
int g1 = 5;        // .data（已初始化，非零）
int g2 = 0;        // .bss（初始化为0，不占文件体积）
int g3;            // .bss（未初始化，加载时清零）
static int s1 = 1; // .data（文件作用域静态变量）
static int s2;     // .bss
```

> **高频陷阱：`static` 局部变量不在栈上！**
> 函数内的 `static` 变量生命周期贯穿整个程序，存放在 `.data`（非零初始化）或 `.bss`（未初始化/零初始化），**不随函数结束而销毁**。
>
> ```c
> void foo() {
>  static int count = 0;  // .bss，不是栈！每次调用foo()，count依然保留上次的值
>  count++;
> }
> ```

### **堆区**

一般由程序员分配和释放，若程序员不释放，程序运行结束时由操作系统回收。**malloc()、calloc()、free() 等函数操作的就是这块内存**，这也是本章要讲解的重点。

**注意：这里所说的堆区与数据结构中的堆不是一个概念，堆区的分配方式倒是类似于链表。**

(**个人**：这里的堆区上面的未被分配的内存，当我们动态分配内存时，堆区会向上增长，使用它上面的未分配的内存拿来作为堆内存，)

### **动态链接库映射区（mmap区域）**

**用于在程序运行期间加载和卸载动态链接库**，位于堆区和栈区之间。(**个人**：静态链接库已经在运行之前的链接阶段链接到可执行程序里面了，所以静态链接库里面的函数此时放置在**程序代码区**)

- **静态链接库**类似makefile中构建时加载的.a库函数文件（构建时（编译链接阶段））。程序中可以直接调用.a库中的库函数。
  - 更新库需重新编译整个程序，代码区指令不可更改。
- **动态链接库**可在程序运行期间动态加载/卸载，多个进程可共享同一份库代码（节省内存）。
  - 更新库只需替换 .so/.dll 文件（.so 在 Linux，.dll 在 Windows），无需重编程序。

> **补充**：`mmap` 区域不只用于动态库。`malloc` 申请**较大内存块（通常 >128KB，即 MMAP_THRESHOLD）**时，glibc 不再从堆顶扩展（`brk()`），而是直接用 `mmap()` 在此区域映射匿名内存，`free()` 后立即归还给OS（而非留在堆中）。

### **栈区**

**存放函数的参数值、局部变量的值等**，其操作方式类似于数据结构中的栈**。(个人：**这里的栈区向下增长，使用它下面未被分配的内存**)**。

### 实例

```c
#include <stdio.h>
const char* str1 = "www.baidu.com";  //字符串在.rodata（常量区），str1指针本身在.data（全局数据区）
int n;  //全局数据区，未初始化 → .bss段（不占二进制文件体积，加载时清零）
const char* func() {
    const char* str = "岳麓书院";  //字符串在常量区，str在栈区
    return str;
}
int main() {
    int a;  //栈区
    const char* str2 = "01234";  //字符串在常量区，str2在栈区
    char  arr[20] = "56789";  //字符串和arr都在栈区
    const char* pstr = func();  //栈区
    int b;  //栈区
    printf("str1: %p\npstr: %p\nstr2: %p\n", str1, pstr, str2);
    puts("--------------");
    printf("&str1: %p\n   &n: %p\n", &str1, &n);
    puts("--------------");
    printf("  &a: %p\n arr: %p\n  &b: %p\n", &a, arr, &b);
    puts("--------------");
    printf("n: %d\na :%d\nb: %d\n", n, a, b);
    puts("--------------");
    printf("%s\n", pstr);
    return 0;
}
```

- **全局变量的大小和地址在编译/链接阶段就确定了**。`.data` 中已初始化的全局变量，其初始值存于二进制文件，加载时从文件读入；`.bss` 中未初始化的全局变量，不占二进制文件体积，加载时由OS清零（默认值为 0）。局部变量的内存在函数调用时于栈上分配，默认初始值不确定，一般是垃圾值。
- **函数 func() 中的局部字符串常量"岳麓书院"也被存储到常量区，不会随着 func() 的运行结束而销毁，所以最后依然能够输出**。
- **字符数组 arr[20] 在栈区分配内存，字符串"56789"就保存在这块内存中，而不是在常量区，大家要注意区分**。
  - (**个人**：这里char arr[20] = "56789"是对一个局部数组定义的同时进行初始化，是char arr[20] = {'5','6','7','8','9'\0'}的一种简写形式，而const char* arr = "56789"则是单纯的指针变量定义并初始化，这两者还是有区别的)

### 总结

- **程序代码区用来保存指令**，
- **常量区、全局数据区、堆、栈都用来保存数据**。

- **程序代码区、常量区、全局数据区在程序加载到内存后就分配好了，并且在程序运行期间一直存在，不能销毁也不能增加（大小已被固定），只能等到程序运行结束后由操作系统收回，所以全局变量、字符串常量等在程序的任何地方都能访问，因为它们的内存一直都在**。
- **函数被调用时，会将参数、局部变量、返回地址等与函数相关的信息压入栈中，函数执行结束后，这些信息都将被销毁。**所以局部变量、参数只在当前函数中有效，不能传递到函数外部，因为它们的内存不在了。
- **常量区、全局数据区、栈上的内存由系统自动分配和释放，不能由程序员控制**。
- **程序员唯一能控制的内存区域就是堆（Heap）：它是一块巨大的内存空间，常常占据整个虚拟空间的绝大部分**，在这片空间中，程序可以申请一块内存，并自由地使用（放入任何数据）。堆内存在程序主动释放之前会一直存在，不随函数的结束而失效。在函数内部产生的数据只要放到堆中，就可以在函数外部使用。

### 结合嵌入式

#### 在嵌入式系统中（如微控制器），C语言的内存布局

在嵌入式C语言开发中（尤其是基于微控制器MCU的系统中），全局const变量通常会被放置在Flash（只读存储器）中。

大多数微控制器采用**改进的Harvard架构**：

- **Flash**：大容量、非易失性、只读（编程后不可随意修改），用于存储程序代码和常量数据。
- **RAM**：小容量、易失性、读写快速，用于运行时变量（全局非const、栈、堆）。

典型容量对比（常见MCU）：

- Flash：64KB ~ 2MB（甚至更大）
- SRAM（RAM）：几KB ~ 几百KB（如STM32F103：20KB RAM，64KB Flash）

**RAM非常宝贵**，不能随便浪费。因此，任何“运行时不需要修改”的数据，都应该尽量放在Flash中。

#### 嵌入式C内存分布典型示意图（以STM32为例）

```c
Flash 区域（只读，非易失性，掉电保留）
0x08000000 ┌────────────────────────────┐
           │ 代码区 (.text)              │  ← 函数机器码，直接执行
           ├────────────────────────────┤
           │ 常量区 (.rodata)            │  ← const 全局变量、字符串、查找表
           ├────────────────────────────┤
           │ .data 初始值（镜像）        │  ← 上电时复制到RAM
           └────────────────────────────┘

RAM 区域（读写，易失性，上电清空）
0x20000000 ┌────────────────────────────┐
           │ .data（已初始化全局变量）   │
           ├────────────────────────────┤
           │ .bss（未初始化全局变量，清0）│
           ├────────────────────────────┤
           │ 堆（Heap，如果启用malloc）   │  ← 向上增长（很少用）
           ├────────────────────────────┤
           │ ... 空闲RAM ...             │
           ├────────────────────────────┤
           │ 栈（Stack）                 │  ← 向下增长（函数调用、局部变量）
           └────────────────────────────┘ 高地址
```

- 如果是 RTOS（最常见的轻量级 SoC + OS）： 是的，内存分布基本和裸机嵌入式一样 —— 代码 + const 放 Flash，全局/堆/栈放 RAM，极大程度节省 RAM。
- 如果是轻量级 Linux： 不再如此，更接近桌面系统，代码和常量加载到 RAM，有虚拟内存。