# 综合

## 单位换算

某相机内置256MB存储空间，拍摄照片的分辨率为1600x1200像素，颜色深度为24位，若不采用压缩存储技术，使用内部储存最多可以拍多少张照片？

先将MB转换成KB，KB转成B。然后除以1600x1200x24得到一张照片所需要的二进制位数。但是转换单位我给忘记了

> **✅ 思路正确，补全计算过程：**
> 256MB = 256 × 1024 × 1024 = 268,435,456 字节(Byte)
> 一张照片大小 = 1600 × 1200 × 24 / 8 = 5,760,000 字节（注意24位是bit，要除以8换算成Byte）
> 268,435,456 ÷ 5,760,000 ≈ 46.6 → **最多拍46张**
>
> **考点：** 存储单位换算（1MB = 1024KB = 1024×1024B），位(bit)与字节(Byte)的关系（1Byte = 8bit）
> **注意：** 颜色深度24位表示每个像素占24bit，计算时别忘了除以8转字节

## 命令行基础

### 在 Shell 中，用于表示**传入参数个数**的特殊变量是？

```c
A. $#
B. $*
C. $?
D. 0
```

C选项？

> **❌ 错误，正确答案是A `$#`**
>
> - `$#` —— 传入参数的**个数**
> - `$*` —— 所有参数作为一个整体字符串
> - `$?` —— 上一条命令的**退出状态码**（0成功，非0失败）
> - `$0` —— 脚本自身的名称
>
> **考点：** Shell特殊变量。`$?`是返回值/退出码，不是参数个数，不要混淆

### 下面哪种写法表示：如果 `cmd1` 成功执行，则执行 `cmd2` 命令？

A. `cmd1 cmd2`
B. `cmd1; cmd2`
C. `cmd1 && cmd2`
D. `cmd1 || cmd2`

不知道。

> **正确答案是C `cmd1 && cmd2`**
> - `cmd1 cmd2` —— 语法错误/cmd2被当成cmd1的参数
> - `cmd1; cmd2` —— 无论cmd1成功与否，都执行cmd2
> - `cmd1 && cmd2` —— cmd1**成功（返回0）** 才执行cmd2
> - `cmd1 || cmd2` —— cmd1**失败（返回非0）** 才执行cmd2
>
> **考点：** Shell逻辑运算符。`&&`短路与，`||`短路或，`;`顺序执行。这是必须掌握的基础

## 下面哪种不是linux的设备类型?

```c
A: 块设备
B: 字符设备
C: 网络设备
D: 虚拟设备
```

根据我的了解选C跟D。

> **❌ 错误，正确答案是D（虚拟设备）**
> Linux三大设备类型：
> 1. **块设备(Block Device)** —— 按数据块访问，如硬盘、SD卡
> 2. **字符设备(Char Device)** —— 按字节流顺序访问，如串口、键盘
> 3. **网络设备(Network Device)** —— 网络通信，如网卡eth0
>
> **"虚拟设备"不是Linux标准设备分类。** 网络设备是Linux三大设备类型之一，必须记住
>
> **考点：** Linux设备模型三大分类（块/字符/网络）

# C语言

##  对于以下stTest结构体赋值，正确的说法是？

```c
typedef struct
{
 u8 Bass;
 u8 Treble;
 u16 eq[3];
 u8 *pPEQTable;   
}stSoundModeSeting;

stSoundModeSeting stTest;
stSoundModeSeting stDefault={50,50,{10,10,10},NULL};
```

- A：所有逐一成员赋值
- B：可使用如下赋值mencpy(&stTest,&stDefault,sizeof(stTest));
- C：可使用如下赋值stTest = stDefault;

stTest结构体变量并没有赋值，赋值的是另外一个结构体变量stDefault。关于结构体赋值，没见过C选项这种形式。B选项是通过地址去赋值，我觉得没有问题。所以我选B答案。

> **❌ 不完整，正确答案是ABC全部正确**
> - A：逐一成员赋值 —— 当然可以，`stTest.Bass = 50;` 逐个赋值
> - B：memcpy整体拷贝 —— 正确，按内存逐字节复制（注意题目写的是mencpy，应该是memcpy的笔误）
> - C：**C语言支持同类型结构体之间直接用`=`赋值！** 这是合法操作，编译器会自动进行成员逐一拷贝
>
> **考点：** C语言结构体赋值的三种方式。`stTest = stDefault;` 是完全合法的，这是一个非常常见的考点和易错点，务必记住

## 如下哪个表示一个指向整数型的常指针?

```c
A: int *const a;
B: int const *a;
C: 以上都不对
D: const int *a;
```

根据题目表述，指针的指向是不能变更的，指针指向的值是可以变更的。所以const应该在*的右边也就是A答案。

> **✅ 正确，答案A**
> 口诀：**const在`*`左修饰指向的值，const在`*`右修饰指针本身**
> - `int *const a` —— 指针本身不可变（常指针），指向的值可变 ✓
> - `const int *a` 与 `int const *a` 等价 —— 指向的值不可变（常量指针），指针本身可变
>
> **考点：** const与指针的组合，从右往左读（右左法则）

## 当需要从文本文件的每一行中截取指定内容的数据时，下面那个命令可以提供帮助？

```c
A: cp
B: dd
C: fmt
D: cut    
```

根据字面意思，应该选D

> **✅ 正确，答案D `cut`**
> - `cp` —— 复制文件
> - `dd` —— 低级数据复制/转换
> - `fmt` —— 文本格式化（调整行宽）
> - `cut` —— 按列/字段**截取**每行指定内容，如 `cut -d':' -f1 /etc/passwd`
>
> **考点：** Linux文本处理命令。cut按列截取，awk按字段处理，sed按行编辑

## 下面各语句中，能正确进行赋字符串操作的语句是

```c
A: char s[5]={'a','b','c','d','e','\0'};
B: char *s; s = "abcde";
C: char *s; scanf("%s",&s);
D: char s[5]={"abcde"};
```

A选项有结束符，应该是对的。B选项将指针指向了字符串字面量的首地址也是对的。C选项看起来不像赋值。D选项跟A选项是两种不同的写法，也是对的。所以我选择ABD。

> **❌ 错误，正确答案是B**
> - A：`char s[5]` 数组大小为5，但初始化列表有6个元素（`'a','b','c','d','e','\0'`），**数组越界**，编译器会报错
> - B：`char *s; s = "abcde";` —— 正确，指针指向字符串字面量首地址 ✓
> - C：`char *s; scanf("%s", &s);` —— 错误，`s`是指针变量，`&s`是指针的地址（`char**`类型），scanf会往指针变量本身的内存写入，导致**未定义行为**。且指针未指向有效缓冲区
> - D：`char s[5]={"abcde"};` —— `"abcde"`含隐含的`\0`共6字节，数组只有5字节，**`\0`被截断**，结果不是合法的C字符串
>
> **考点：** 字符数组初始化。数组大小必须能容纳所有元素（含`\0`）；`scanf`的`%s`需要传入`char*`类型的有效缓冲区地址
> **注意：** A选项的陷阱在于数数——5个字符+1个`\0`=6个元素，放不进`s[5]`

## C语言中，malloc函数申请到的空间储存在哪个位置？

```c
A: BSS段
B: 栈区
C: 堆区
D: data段
```

根据我了解的C语言程序运行时的OS中的内存布局按照区来划分，地址从高到地依次是：

1. 堆区
   1. 一般是程序员手动申请的内存空间从这里开辟，也是唯一可以自主操控的内存空间
2. 栈区
   1. 一般像函数中的临时变量，返回值都是用栈区存储
3. 静态常量区
   1. 包括像常量，字符串字面量都是存储在静态常量区
4. 全局数据区
   1. 一般像是全局变量存储这里
5. 代码区
   1. 一般都是存储编译后的二进制机器指令码

所以我选堆区。

> **✅ 正确，答案C（堆区）**
> - BSS段 —— 存放**未初始化**的全局变量和静态变量
> - 栈区 —— 局部变量、函数参数、返回地址（自动管理，LIFO）
> - **堆区** —— `malloc/calloc/realloc`动态分配的内存，需手动`free`释放
> - data段 —— 存放**已初始化**的全局变量和静态变量
>
> **考点：** C语言内存布局五大区域。malloc = 堆区，这是铁律
> **注意：** 你的内存布局排序有误，正确的地址从高到低应为：**栈区 → 堆区 → BSS段 → data段 → 代码区**（栈从高地址向下增长，堆从低地址向上增长）

## 在Linux系统中，用来存放系统所需要的配置文件和子目录是

```c
A: /var
B: /root
C: /etc
D: /home
```

根据我的了解，home一般是用户目录，存放用户的配置等等。root目录就应该是放系统配置和子目录的。选B

> **❌ 错误，正确答案是C `/etc`**
> - `/var` —— 可变数据文件（日志、缓存、邮件等）
> - `/root` —— **root用户的家目录**，不是存放系统配置的地方
> - `/etc` —— **系统配置文件目录**（如`/etc/passwd`、`/etc/fstab`、`/etc/nginx/`等）
> - `/home` —— 普通用户的家目录
>
> **考点：** Linux目录结构。`/etc`（Editable Text Configuration）是系统配置文件的标准存放位置，这是必背知识点
> **注意：** `/root`是root用户的"家"，不要和"系统配置"混淆。系统配置 = `/etc`

## 嵌入式系统中，一个任务被唤醒就意味着

```c
A: 该任务重新占有了CPU
B: 他的优先级变为最高
C: 任务变为就绪态
D: 其任务移至等待队列的队首   
```

一个任务从阻塞态被唤醒，应该是进入就绪态等待CPU使用权。直接选C

> **✅ 正确，答案C（任务变为就绪态）**
> - 唤醒 ≠ 立刻执行，唤醒只是从**阻塞态→就绪态**，等待调度器分配CPU
> - A错：占有CPU需要调度器调度，唤醒不等于立刻获得CPU
> - B错：优先级不会因唤醒而改变
> - D错：是移至**就绪队列**，不是等待队列
>
> **考点：** RTOS任务状态机（运行态、就绪态、阻塞态）。唤醒 = 阻塞→就绪，调度 = 就绪→运行

## 属于线程之间共享资源的是？

```c
A: 全局变量
B: 线程栈
C: 地址空间
D: 堆
```

以我的了解来看，各进程是独立的，有独立的内存空间地址。而进程中的各线程是共享父进程的资源的，但是也有独立的部分，就是线程栈。选择B

> **❌ 错误，题目问的是"属于共享资源"，B线程栈恰恰是线程私有的！正确答案是ACD**
>
> **线程共享的资源：**
> - 全局变量 ✓（A）
> - 地址空间 ✓（C）
> - 堆 ✓（D）
> - 还有：代码段、打开的文件描述符、信号处理函数等
>
> **线程私有的资源：**
> - **线程栈**（B）—— 每个线程有自己独立的栈
> - 寄存器组、程序计数器(PC)、线程ID、errno
>
> **考点：** 线程共享 vs 私有资源。你的知识点是对的（"线程栈是独立的"），但审题出了问题——题目问的是"共享"资源，你却选了"私有"资源
> **注意：** 审题！"属于共享的是"和"属于私有的是"意思完全相反

## 在单循环的嵌入式系统中，使用一个全局变量在中断函数和main函数之间传递数据，为了避免数据错误，可以采用如下做法

```c
A: 可以用const修饰此全局变量
B: 可以用volatile修饰此全局变量
C: 可以用static修饰此全局变
D: 可以用static const修饰此全局变量
```

使用const修饰，代表不可以被程序修改。不符合传递数据的要求。使用static修饰的话作用变成此源文件，也不符合要求。使用volatile修饰，告知编译器此变量可能会被外部因素更改（比如只可读的状态寄存器），此变量每次都要从内存中获取值，而不是缓存。所以选B

> **✅ 正确，答案B（volatile）**
> - `const` —— 变量不可修改，无法用于传递数据 ✗
> - `volatile` —— 告诉编译器**不要优化**此变量的读取，每次都从内存取值 ✓
> - `static` —— 限制作用域，与防止数据错误无关 ✗
> - `static const` —— 既不可修改又限制作用域，更不行 ✗
>
> **考点：** volatile的核心作用——**防止编译器优化**。中断中修改的变量如果没有volatile修饰，编译器可能将其缓存到寄存器中，main函数读到的是旧值
> **注意：** 你的理解基本正确，但volatile不仅用于"只读寄存器"，更典型的场景就是**中断与主程序之间共享变量**

## 以下不正确的说法是

```c
A: 如果函数值的类型与返回值类型不一致，以函数值类型为准
B: return后边的值不能为表达式
C: 如果形参与实参类型不一致，以实参类型为准
D: 定义函数时，形参的类型说明可以放在函数体内
```

函数值类型就代表要求的返回值类型。return当然可以返回表达式。形参是声明时就已经确定了需要的实参类型了。定义函数时，形参类型不能写在函数内。选择BCD.

> **✅ 正确，答案BCD**
> - A（正确说法）：函数声明的返回类型与实际return值类型不一致时，以**函数声明的返回类型为准**（隐式类型转换）
> - B（**不正确**）：return后面当然可以接表达式，如`return a + b;`、`return x > 0 ? x : -x;`
> - C（**不正确**）：形参与实参类型不一致时，以**形参类型为准**（实参被隐式转换为形参类型），不是以实参类型为准
> - D（**不正确**）：形参类型说明应写在函数头部的参数列表中，不能放在函数体内
>
> **考点：** C语言函数的类型转换规则——无论是返回值还是参数传递，都是**被调用方的声明类型为准**（函数返回类型、形参类型）
> **注意：** C选项容易犯迷糊，记住口诀：**"形参说了算"**

# 算法

## 实现大整数乘法是利用什么算法？

```c
A: 动态规划算法
B: 贪心算法
C: 分治算法
D: 回溯算法
```

没有了解过。

> **正确答案是C（分治算法）**
> 经典的**Karatsuba算法**就是用分治思想实现大整数乘法：
> - 将大整数拆分为高位和低位两部分
> - 递归地对较小的部分做乘法
> - 合并结果
> - 时间复杂度从朴素的O(n²)降到O(n^1.585)
>
> **考点：** 分治算法的经典应用——大整数乘法(Karatsuba)、归并排序、快速排序、Strassen矩阵乘法
> **注意：** 分治 = **分解子问题 + 递归求解 + 合并结果**，符合大整数乘法"拆分→分别乘→合并"的思路

## 链表

以下代码实现了从表中删除重复项的功能，请选择其中空白行应填入的正确代码。

```c
template <class T>
void removeDuplicates(list<T> &aList)
{
    T curValue;
    list<T>::iterator cur, p;

    cur = aList.begin();
    while (cur != aList.end())
    {
        curValue = *cur;

        // 空白行①

        while (p != aList.end())
        {
            if (*p == curValue)
            {
                // 空白行②
            }
            else
            {
                p++;
            }
        }

        cur++;
    }
}

A:
p = ++cur;
aList.erase(p++);

B:
p = cur + 1;
aList.erase(p);

C:
p = cur + 1;
aList.erase(p++);

D:
p = ++cur;
aList.erase(p);
```

看代码，基本的逻辑就是，链表中每一个节点逐一跟后面节点比较，删除所有重复节点。

也就意味着空行1，需要拿到cur当前节点的下一个节点，只有B和C符合要求。那么空行2，当前节点与后一个节点重复时，删除后一个节点。继续往后比较，排查是否有重复节点，所以只能选择C选项。

> **❌ 错误，正确答案是A**
>
> **关键错误：`std::list`的迭代器不支持`+`运算符！**
> - `list`是双向链表，迭代器是**BidirectionalIterator**，只支持`++`和`--`
> - `cur + 1`无法通过编译，**B和C直接排除**
> - 只有`++cur`（自增）才是合法的迭代器操作
>
> **分析A选项：**
> - 空白行①：`p = ++cur;` —— cur先自增指向下一个元素，p也指向该位置（注意：这里cur已经前进了一步，后面外层`cur++`会再前进，但逻辑上是对的，因为我们要从cur的下一个开始检查）
> - 空白行②：`aList.erase(p++);` —— **先保存p当前位置用于erase，再将p自增指向下一个元素**。这是STL中删除元素的标准写法，避免迭代器失效
>
> **分析D选项：**
> - `aList.erase(p);` —— erase后p迭代器**失效**，后续while循环中`p != aList.end()`是未定义行为
>
> **考点：** ①`std::list`迭代器只支持`++/--`，不支持随机访问(+n)；②STL容器删除元素时的迭代器失效问题，`erase(p++)`是经典安全写法
> **注意：** 这道题的核心陷阱就是`list`迭代器 vs `vector`迭代器的区别。`vector`支持`+n`，`list`不支持

## 给定一个整数，将其转化为7进制，并以字符串形式输出。

```c
示例1:
输入:100
输出:"202"
示例2:
输入:-7
输出:"-10"
注意:输入范围是[-1e7,1e7]。
```

没有思路。

> **最优解：短除法（辗转取余）**
>
> 思路：不断对7取余得到每一位，再对7整除缩小数值，最后将结果反转。负数先转正数处理，最后加负号。
>
> ```c
> #include <stdio.h>
> #include <string.h>
>
> void convertToBase7(int num, char *result) {
>     if (num == 0) { strcpy(result, "0"); return; }
>
>     int negative = num < 0;
>     if (negative) num = -num;
>
>     char buf[32];
>     int i = 0;
>     while (num > 0) {
>         buf[i++] = '0' + (num % 7);  // 取余得到当前最低位
>         num /= 7;                     // 整除去掉最低位
>     }
>
>     int j = 0;
>     if (negative) result[j++] = '-';
>     while (i > 0) result[j++] = buf[--i];  // 反转
>     result[j] = '\0';
> }
>
> // 示例: 100 → 100%7=6,100/7=14 → 14%7=0,14/7=2 → 2%7=2,2/7=0 → 逆序"202"
> ```
>
> **考点：** 进制转换的通用方法——**短除法**（对目标进制取余，逆序排列）
> **注意：** 边界情况：输入为0时直接返回"0"；负数需要单独处理符号

## 对括号的合法性判断是一个常见且实用的问题。例如，在代码编辑器或编译器中都会检查括号是否正确闭合。

输入一个字符串，其中包含 ()、[]、{} 六种括号，请判断该字符串中的括号是否合法。

| 输入       | 输出    |
| ---------- | ------- |
| `"()[]{}"` | `true`  |
| `"(]"`     | `false` |
| `"(["`     | `false` |

**判定规则**

1. 左括号必须由相同类型的右括号闭合。
2. 左括号必须按正确的顺序闭合（后开先闭）。
3. 每个右括号都必须有对应的左括号。
4. 所有括号最终都必须完全匹配。

不会写。。。

> **最优解：栈（后进先出，天然匹配"后开先闭"规则）**
>
> 思路：遇到左括号入栈，遇到右括号弹栈检查是否匹配。最终栈为空则合法。
>
> ```c
> #include <stdbool.h>
> #include <string.h>
>
> bool isValid(const char *s) {
>     int len = strlen(s);
>     char stack[len];
>     int top = -1;
>
>     for (int i = 0; s[i]; i++) {
>         if (s[i] == '(' || s[i] == '[' || s[i] == '{') {
>             stack[++top] = s[i];          // 左括号入栈
>         } else {
>             if (top == -1) return false;   // 栈空，没有匹配的左括号
>             char c = stack[top--];         // 弹栈
>             if (s[i] == ')' && c != '(') return false;
>             if (s[i] == ']' && c != '[') return false;
>             if (s[i] == '}' && c != '{') return false;
>         }
>     }
>     return top == -1;  // 栈空=全部匹配
> }
> ```
>
> **考点：** 栈的经典应用——括号匹配。这是数据结构面试的高频题（LeetCode第20题）
> **注意：** 三个容易遗漏的边界：①右括号多余（栈空时遇到右括号）②左括号多余（遍历结束栈不空）③类型不匹配（`(`遇到`]`）

# 通信总线

## 下列关于UART通信描述正确的是

A: 收发两端可以不工作在同一个速率上
B: 异步通讯方式
C: 传输速度固定不可变
D: 不可以实现全双工模式

串口是双线全双工异步的通讯方式直接选B。

> **✅ 正确，答案B（异步通讯方式）**
> - A错：收发两端**必须**工作在相同波特率上，否则无法正确解码
> - B对：UART = Universal **Asynchronous** Receiver/Transmitter，无时钟线，靠波特率约定同步
> - C错：波特率是**可配置**的（9600、115200等），不是固定的
> - D错：UART有TX和RX两根线，**可以实现全双工**
>
> **考点：** UART特性——异步、全双工、波特率可配置、收发必须同一波特率
> **注意：** 你的分析完全正确，继续保持

## 关于SP和IIC总线的描述，正确的是

```c
A: IIC可以实现全双工，SPI不能实现全双工
B: IIC的数据输入输出用的是一根线，SPI则分为数据输入和数据输出两根线
C: IIC的抗干扰能力比SPI强
D: SPI适合长距离传播
```

根据我的了解，IIC是双线，半双工的同步通讯方式。一根时钟线，一根数据线。其他就不知道了，不知道选啥。

> **正确答案是B**
> - A错：恰好说反了。**IIC是半双工**（SDA一根数据线），**SPI才能实现全双工**（MOSI+MISO两根数据线）
> - B对：**IIC用SDA一根线**收发数据（半双工）；**SPI用MOSI（主→从）和MISO（从→主）两根线**分别负责输入输出 ✓
> - C错：SPI的抗干扰能力比IIC强（SPI速度更快、信号更稳定）
> - D错：SPI适合**短距离、高速**板级通信，不适合长距离
>
> | 特性 | IIC | SPI |
> |------|-----|-----|
> | 线数 | 2根（SCL+SDA） | 4根（SCLK+MOSI+MISO+CS） |
> | 双工 | 半双工 | 全双工 |
> | 速度 | 较慢（100K/400K/3.4M） | 较快（可达几十MHz） |
> | 寻址 | 地址寻址，支持多从机 | CS片选，每个从机需一根CS线 |
>
> **考点：** IIC vs SPI对比。你对IIC的理解是正确的，由此可以直接推导出B选项正确
> **注意：** 看到IIC就想到"两线、半双工、一根数据线"，自然就能选出B