# 综合

## 单位换算

某相机内置256MB存储空间，拍摄照片的分辨率为1600x1200像素，颜色深度为24位，若不采用压缩存储技术，使用内部储存最多可以拍多少张照片？

先将MB转换成KB，KB转成B。然后除以1600x1200x24得到一张照片所需要的二进制位数。但是转换单位我给忘记了

> **✅ 思路正确，补全计算过程：**
> 256MB = 256 × 1024 × 1024 = 268,435,456 字节(Byte)
> 一张照片大小 = 1600 × 1200 × 24 / 8 = 5,760,000 字节（注意24位是bit，要除以8换算成Byte）
> 268,435,456 ÷ 5,760,000 ≈ 46.6 → **最多拍46张**
>
> **考点：** 存储单位换算（1MB = 1024KB = 1024×1024B），位(bit)与字节(Byte)的关系（1Byte = 8bit）
> **注意：** 颜色深度24位表示每个像素占24bit，计算时别忘了除以8转字节

## 命令行基础

### 在 Shell 中，用于表示传入参数个数的特殊变量是？

```c
A. $#
B. $*
C. $?
D. 0
```

C选项？

> **❌ 错误，正确答案是A `$#`**
>
> - `$#` —— 传入参数的**个数**
> - `$*` —— 所有参数作为一个整体字符串
> - `$?` —— 上一条命令的**退出状态码**（0成功，非0失败）
> - `$0` —— 脚本自身的名称
>
> **考点：** Shell特殊变量。`$?`是返回值/退出码，不是参数个数，不要混淆

### 下面哪种写法表示：如果 `cmd1` 成功执行，则执行 `cmd2` 命令？

A. `cmd1 cmd2`
B. `cmd1; cmd2`
C. `cmd1 && cmd2`
D. `cmd1 || cmd2`

不知道。

> **正确答案是C `cmd1 && cmd2`**
> - `cmd1 cmd2` —— 语法错误/cmd2被当成cmd1的参数
> - `cmd1; cmd2` —— 无论cmd1成功与否，都执行cmd2  这相当于两个独立语句
> - `cmd1 && cmd2` —— cmd1**成功（返回0）** 才执行cmd2
> - `cmd1 || cmd2` —— cmd1**失败（返回非0）** 才执行cmd2
>
> **考点：** Shell逻辑运算符。`&&`短路与，`||`短路或，`;`顺序执行。这是必须掌握的基础

## 下面哪种不是linux的设备类型?

```c
A: 块设备
B: 字符设备
C: 网络设备
D: 虚拟设备
```

根据我的了解选C跟D。

> **❌ 错误，正确答案是D（虚拟设备）**
> Linux三大设备类型：
> 1. **块设备(Block Device)** —— 按数据块访问，如硬盘、SD卡
> 2. **字符设备(Char Device)** —— 按字节流顺序访问，如串口、键盘
> 3. **网络设备(Network Device)** —— 网络通信，如网卡eth0
>
> **"虚拟设备"不是Linux标准设备分类。** 网络设备是Linux三大设备类型之一，必须记住
>
> **考点：** Linux设备模型三大分类（块/字符/网络）

# C语言

## 有关内存的思考题

### 1

```c
void GetMemory(char *p)
{
    p = (char *)malloc(100);
}

void Test(void)
{
    char *str = NULL;
    GetMemory(str);
    strcpy(str, "hello world");
    printf(str);
}
```

请问运行 `Test` 函数会有什么样的结果？

程序最后没有把分配的内存free掉导致内存有泄漏风险。

---

### ❌ 批改：答案不完整，漏掉了最致命的问题

> **最优解答：**
>
> 1. **崩溃（段错误）。** `GetMemory(str)` 传的是指针的**值拷贝**（值传递），函数内 `p = malloc(100)` 只修改了局部变量 `p`，**str 仍然是 NULL**
> 2. `strcpy(str, "hello world")` 向 NULL 指针写入 → **程序崩溃**
> 3. 同时确实存在内存泄漏：`malloc` 分配的内存无法被外部访问，也没有 `free`
>
> **⚠️ 你的问题：**
>
> - 你只答了内存泄漏，漏掉了**最关键的问题：str 依然是 NULL，strcpy 会崩溃**
> - **考点核心：** C语言函数参数是**值传递**。要修改外部指针，必须传**指针的指针**（`char **p`）

### 2

```c
char *GetMemory(void)
{
    char p[] = "hello world";
    return p;
}

void Test(void)
{
    char *str = NULL;
    str = GetMemory();
    printf(str);
}
```

请问运行 `Test` 函数会有什么样的结果？

p指针是临时变量。返回的是一个不正确的地址，根本拿不到正确的字符串

---

### ✅ 批改：方向正确，但表述需更精准

> **最优解答：**
>
> - `p[]` 是**局部数组**，存储在**栈**上。函数返回后栈帧被销毁，`p` 的内存被回收
> - `return p` 返回的是一个**悬空指针（dangling pointer）**，指向已被释放的栈内存
> - `printf(str)` 读取该地址 → **输出乱码（未定义行为）**
>
> **⚠️ 注意点：**
>
> - `p` 不是"指针"，`p` 是**局部数组**（`char p[]`），只是退化为指针返回了
> - 如果改为 `char *p = "hello world"`（字符串字面量存储在常量区），则返回是合法的
> - **考点核心：** 不要返回指向栈内存（局部变量）的指针

### 3

```c
void GetMemory2(char **p, int num)
{
    *p = (char *)malloc(num);
}

void Test(void)
{
    char *str = NULL;
    GetMemory2(&str, 100);
    strcpy(str, "hello");
    printf(str);
}
```

请问运行 `Test` 函数会有什么样的结果？

没看出来，跟第一个一样的问题

---

### ❌ 批改：答错了，这题和第1题不同

> **最优解答：**
>
> - **能正确输出 "hello"，但存在内存泄漏。**
> - 这里用了**二级指针** `char **p`，传入 `&str`，通过 `*p = malloc(num)` **成功修改了外部的 str**
> - `strcpy` 和 `printf` 都能正常执行
> - 问题：最后没有 `free(str)`，造成**内存泄漏**
>
> **⚠️ 关键区别（对比第1题）：**
>
> - 第1题：`GetMemory(char *p)` — 值传递，修改的是局部拷贝，**外部 str 不变**
> - 第3题：`GetMemory2(char **p)` — 传指针的地址，`*p = malloc()` **真正修改了外部 str**
> - **考点核心：** 二级指针修改一级指针的经典用法。这是第1题的**正确写法**

### 4

```c
void Test(void)
{
    char *str = (char *)malloc(100);
    strcpy(str, "hello");
    free(str);

    if (str != NULL)
    {
        strcpy(str, "world");
        printf(str);
    }
}
```

请问运行 `Test` 函数会有什么样的结果？

都free掉了，正常执行吧！

---

### ❌ 批改：答错了，这题有严重问题

> **最优解答：**
>
> - `free(str)` 释放了内存，但 **str 指针的值没有被置为 NULL**
> - `free` 不会自动将指针设为 NULL，所以 `str != NULL` 判断为 **true**
> - `strcpy(str, "world")` 向**已释放的内存**写入 → **未定义行为（野指针/悬空指针操作）**
> - 可能表面上"正常输出"，但这是**踩已释放内存**，随时可能崩溃或破坏其他数据
>
> **正确写法：**
>
> ```c
> free(str);
> str = NULL;  // 关键！释放后立即置空
> ```
>
> **⚠️ 注意点：**
>
> - `free` 只是告诉系统"这块内存我不用了"，**不会修改指针本身的值**
> - **考点核心：** free 后必须置 NULL，防止产生**野指针（dangling pointer）**
> - 这是 C 语言内存管理的经典陷阱，笔试高频考点

---

### 📊 总评

| 题目           | 结果       | 说明                                     |
| -------------- | ---------- | ---------------------------------------- |
| sizeof 5题     | ✅ 全对     | 答案正确，第3题表述有笔误                |
| #include 区别  | ⚠️ 不完整   | 缺少 `""` 会回退到标准库搜索的说明       |
| const 用途     | ⚠️ 不完整   | 缺少 const 与指针组合的经典考点          |
| for 循环优缺点 | ❌ 未作答   | —                                        |
| 内存题1        | ❌ 不完整   | 只答了内存泄漏，漏掉了最致命的 NULL 崩溃 |
| 内存题2        | ✅ 方向正确 | 需更精准区分"局部数组"和"指针"           |
| 内存题3        | ❌ 答错     | 与第1题不同，这是正确的二级指针写法      |
| 内存题4        | ❌ 答错     | free 不会置 NULL，产生野指针操作         |

**薄弱点：** C 语言指针与内存管理（值传递 vs 地址传递、free 后置 NULL、栈/堆区别）。建议重点复习。

## 请简述以下两个for循环的优缺点

```c
for (i = 0; i < N; i++)
{
    if (condition)
        DoSomething();
    else
        DoOtherThing();
}

if (condition)
{
    for (i = 0; i < N; i++)
        DoSomething();
}
else
{
    for (i = 0; i < N; i++)
        DoOtherThing();
}
```

---

### ✅ 批改：此题你未作答

> **最优解答：**
>
> **第一种（循环内判断）：**
>
> - 优点：代码简洁，逻辑清晰，容易理解
> - 缺点：每次循环都要做一次 `condition` 判断，**多了 N 次判断开销**
>
> **第二种（循环外判断）：**
>
> - 优点：`condition` 只判断一次，循环体内无分支，**运行效率高**
> - 缺点：代码冗余，两个 for 循环重复，不易维护；如果 N 很大时优势明显
>
> **⚠️ 考点：**
>
> - 程序的 **效率** 与 **可读性/可维护性** 之间的权衡
> - 如果 N 较小，优先选第一种（可读性优先）
> - 如果 N 很大且 condition 与循环无关（循环不变量），优先选第二种（性能优先）
> - 现代编译器优化可能会自动将第一种优化为第二种（循环不变量外提）

## const 有什么用途？

- 定义常量
- const可以修饰函数的参数、返回值，甚至函数的定义体。被const修饰的东西都受到强制保护，可以预防意外的变动，能提高程序的健壮性。
  - 调用函数传递指针时，可以防止指针指向的值被修改。传递数组名时，也可以起到相同的效果

---

### ✅ 批改：正确但不够全面，笔试需要更有条理

> **最优解答（分点作答）：**
>
> 1. **定义常量：** `const int MAX = 100;` 代替 `#define`，有类型检查更安全
> 2. **修饰函数参数：** 防止函数内部意外修改传入的值，如 `void func(const char *p)`
> 3. **修饰函数返回值：** 返回值不可被修改，如 `const char* getName()`
> 4. **修饰指针：**
>    - `const int *p` — 指向的值不可变，指针可变（常量指针）
>    - `int * const p` — 指针不可变，指向的值可变（指针常量）
>    - `const int * const p` — 都不可变
>
> **⚠️ 注意点：**
>
> - 你漏了 **const 修饰指针** 这个经典考点（`const int *p` vs `int * const p`）
> - "const修饰函数的定义体"这个说法不准确，C语言中 const 不修饰函数体；C++ 中 const 成员函数是修饰 `this` 指针
> - **考点核心：** const 与指针的组合（左定值、右定向）

## \#include  <filename.h>  和  #include  “filename.h” 有什么区别？

对于#include  <filename.h> ，编译器从标准库路径开始搜索 filename.h

对于#include  "filename.h" ，编译器从用户的工作路径开始搜索 filename.h

---

### ✅ 批改：基本正确，但需补充完整

> **最优解答：**
>
> - `<filename.h>`：编译器**只在**标准库/系统头文件目录中搜索（如 `/usr/include`、编译器自带的 `include` 目录）
> - `"filename.h"`：编译器**先在**当前源文件所在目录（或项目目录）搜索，**找不到再去**标准库路径搜索
>
> **⚠️ 你的回答缺失的关键点：**
>
> - `"filename.h"` 的搜索是**两步走**的：先当前目录 → 再标准库路径。你只说了第一步
> - 你问"举一个路径例子"——答卷中不应出现自问，笔试中要直接给出答案
>
> **路径示例：**
>
> - `<stdio.h>` → 搜索 `/usr/include/stdio.h`（系统路径）
> - `"myheader.h"` → 先搜索 `./myheader.h`（当前目录），找不到再去系统路径
>
> **考点：** 搜索顺序的差异，`""` 是 `<>` 的超集

## 以下为Windows NT下的32位C++程序，请计算sizeof的值

```c
char str[] = “Hello” ;
char *p = str ;
int n = 10;

1. sizeof (str ) =  
    
2. sizeof ( p ) =   
    
3. sizeof ( n ) =  
    
4. void Func ( char str[100])
{
sizeof( str ) = 
}

5. void *p = malloc( 100 );
sizeof ( p ) =
```

1. 对于sizeof来说，如果给的是数组名臣，那么就是计算整个数组大小，所以答案为6
2. 如果给的是指针变量，那么就算的就是指针的类型大小所以答案是4
3. 如果给的是整型变量，那么就算的就是指针的类型大小所以答案是4
4. 在C语言中，参数传递的法则。此时str是一个指针。所以答案是4
5. 计算的是指针的类型大小，所以答案是4.

---

### ✅ 批改：全部正确（5/5），答案均无误

> **最优解答：**
>
> 1. `sizeof(str) = 6` — 字符串 `"Hello"` 有5个字符 + 1个 `'\0'` 结尾符 = 6字节
> 2. `sizeof(p) = 4` — 32位系统下，任何类型的指针大小都是4字节
> 3. `sizeof(n) = 4` — 32位系统下 `int` 为4字节
> 4. `sizeof(str) = 4` — 数组作为函数参数时**退化为指针**，不再保留数组长度信息
> 5. `sizeof(p) = 4` — `void*` 也是指针，32位下为4字节
>
> **⚠️ 注意点：**
>
> - 第3题你写的"指针的类型大小"应为"整型的大小"，笔误，表述不严谨
> - **考点核心：** 数组名 vs 指针 vs 函数参数退化。牢记：`sizeof` 作用于数组名 = 整个数组大小；作用于指针 = 指针本身大小（32位→4，64位→8）
> - **易错点：** 如果是64位系统，第2、4、5题答案变为 **8**

##  对于以下stTest结构体赋值，正确的说法是？

```c
typedef struct
{
 u8 Bass;
 u8 Treble;
 u16 eq[3];
 u8 *pPEQTable;   
}stSoundModeSeting;

stSoundModeSeting stTest;
stSoundModeSeting stDefault={50,50,{10,10,10},NULL};
```

- A：所有逐一成员赋值
- B：可使用如下赋值mencpy(&stTest,&stDefault,sizeof(stTest));
- C：可使用如下赋值stTest = stDefault;

stTest结构体变量并没有赋值，赋值的是另外一个结构体变量stDefault。关于结构体赋值，没见过C选项这种形式。B选项是通过地址去赋值，我觉得没有问题。所以我选BC答案。

> - B：memcpy整体拷贝 —— 正确，按内存逐字节复制（注意题目写的是mencpy，应该是memcpy的笔误）
> - C：**C语言支持同类型结构体之间直接用`=`赋值！** 这是合法操作，编译器会自动进行成员逐一拷贝
> 
> **考点：** C语言结构体赋值的三种方式。`stTest = stDefault;` 是完全合法的，这是一个非常常见的考点和易错点，务必记住

## 如下哪个表示一个指向整数型的常指针?

```c
A: int *const a;
B: int const *a;
C: 以上都不对
D: const int *a;
```

根据题目表述，指针的指向是不能变更的，指针指向的值是可以变更的。所以const应该在*的右边也就是A答案。

> **✅ 正确，答案A**
> 口诀：**const在`*`左修饰指向的值，const在`*`右修饰指针本身**
>
> - `int *const a` —— 指针本身不可变（常指针），指向的值可变 ✓
> - `const int *a` 与 `int const *a` 等价 —— 指向的值不可变（常量指针），指针本身可变
>
> **考点：** const与指针的组合，从右往左读（右左法则）

## 当需要从文本文件的每一行中截取指定内容的数据时，下面那个命令可以提供帮助？

```c
A: cp
B: dd
C: fmt
D: cut    
```

根据字面意思，应该选D

> **✅ 正确，答案D `cut`**
> - `cp` —— 复制文件
> - `dd` —— 低级数据复制/转换 很容易记成”删除“
> - `fmt` —— 文本格式化（调整行宽）
> - `cut` —— 按列/字段**截取**每行指定内容，如 `cut -d':' -f1 /etc/passwd`
>
> **考点：** Linux文本处理命令。cut按列截取，awk按字段处理，sed按行编辑

## 下面各语句中，能正确进行赋字符串操作的语句是

```c
A: char s[5]={'a','b','c','d','e','\0'};
B: char *s; s = "abcde";
C: char *s; scanf("%s",&s);
D: char s[5]={"abcde"};
```

A选项有结束符，应该是对的。B选项将指针指向了字符串字面量的首地址也是对的。C选项看起来不像赋值。D选项跟A选项是两种不同的写法，也是对的。所以我选择ABD。

> **❌ 错误，正确答案是B**
> - A：`char s[5]` 数组大小为5，但初始化列表有6个元素（`'a','b','c','d','e','\0'`），**数组越界**，编译器会报错
> - B：`char *s; s = "abcde";` —— 正确，指针指向字符串字面量首地址 ✓
> - C：试图通过一个未初始化的指针来接收输入数据。指针没有指向合法缓冲区。
> - D：`char s[5]={"abcde"};` —— `"abcde"`含隐含的`\0`共6字节，数组只有5字节，**`\0`被截断**，结果不是合法的C字符串
>
> **考点：** 字符数组初始化。数组大小必须能容纳所有元素（含`\0`）；`scanf`的`%s`需要传入`char*`类型的有效缓冲区地址
> **注意：** A选项的陷阱在于数数——5个字符+1个`\0`=6个元素，放不进`s[5]`

## C语言中，malloc函数申请到的空间储存在哪个位置？

```c
A: BSS段
B: 栈区
C: 堆区
D: data段
```

查看`0-C语言中的内存布局.md`

## 在Linux系统中，用来存放系统所需要的配置文件和子目录是

```c
A: /var
B: /root
C: /etc
D: /home
```

根据我的了解，home一般是用户目录，存放用户的配置等等。root目录就应该是放系统配置和子目录的。选B

> **❌ 错误，正确答案是C `/etc`**
> - `/var` —— 可变数据文件（日志、缓存、邮件等）
> - `/root` —— **root用户的家目录**，不是存放系统配置的地方
> - `/etc` —— **系统配置文件目录**（如`/etc/passwd`、`/etc/fstab`、`/etc/nginx/`等）
> - `/home` —— 普通用户的家目录
>
> **考点：** Linux目录结构。`/etc`（Editable Text Configuration）是系统配置文件的标准存放位置，这是必背知识点
> **注意：** `/root`是root用户的"家"，不要和"系统配置"混淆。系统配置 = `/etc`

## 嵌入式系统中，一个任务被唤醒就意味着

```c
A: 该任务重新占有了CPU
B: 他的优先级变为最高
C: 任务变为就绪态
D: 其任务移至等待队列的队首   
```

一个任务从阻塞态被唤醒，应该是进入就绪态等待CPU使用权。直接选C

> **✅ 正确，答案C（任务变为就绪态）**
> - 唤醒 ≠ 立刻执行，唤醒只是从**阻塞态→就绪态**，等待调度器分配CPU
> - A错：占有CPU需要调度器调度，唤醒不等于立刻获得CPU
> - B错：优先级不会因唤醒而改变
> - D错：是移至**就绪队列**，不是等待队列
>
> **考点：** RTOS任务状态机（运行态、就绪态、阻塞态）。唤醒 = 阻塞→就绪，调度 = 就绪→运行

## 属于线程之间共享资源的是？

```c
A: 全局变量
B: 线程栈
C: 地址空间
D: 堆
```

以我的了解来看，各进程是独立的，有独立的内存空间地址。而进程中的各线程是共享父进程的资源的，但是也有独立的部分，就是线程栈。选择B

> **❌ 错误，题目问的是"属于共享资源"，B线程栈恰恰是线程私有的！正确答案是ACD**
>
> **线程共享的资源：**
>
> - 全局变量 ✓（A）
> - 地址空间 ✓（C）
> - 堆 ✓（D）
> - 还有：代码段、打开的文件描述符、信号处理函数等
>
> **线程私有的资源：**
> - **线程栈**（B）—— 每个线程有自己独立的栈
> - 寄存器组、程序计数器(PC)、线程ID、errno
>
> **考点：** 线程共享 vs 私有资源。你的知识点是对的（"线程栈是独立的"），但审题出了问题——题目问的是"共享"资源，你却选了"私有"资源
> **注意：** 审题！"属于共享的是"和"属于私有的是"意思完全相反

## 在单循环的嵌入式系统中，使用一个全局变量在中断函数和main函数之间传递数据，为了避免数据错误，可以采用如下做法

```c
A: 可以用const修饰此全局变量
B: 可以用volatile修饰此全局变量
C: 可以用static修饰此全局变
D: 可以用static const修饰此全局变量
```

使用const修饰，代表不可以被程序修改。不符合传递数据的要求。使用static修饰的话作用变成此源文件，也不符合要求。使用volatile修饰，告知编译器此变量可能会被外部因素更改（比如只可读的状态寄存器），此变量每次都要从内存中获取值，而不是缓存。所以选B

> **✅ 正确，答案B（volatile）**
> - `const` —— 变量不可修改，无法用于传递数据 ✗
> - `volatile` —— 告诉编译器**不要优化**此变量的读取，每次都从内存取值 ✓
> - `static` —— 限制作用域，与防止数据错误无关 ✗
> - `static const` —— 既不可修改又限制作用域，更不行 ✗
>
> **考点：** volatile的核心作用——**防止编译器优化**。中断中修改的变量如果没有volatile修饰，编译器可能将其缓存到寄存器中，main函数读到的是旧值
> **注意：** 你的理解基本正确，但volatile不仅用于"只读寄存器"，更典型的场景就是**中断与主程序之间共享变量**

## 以下不正确的说法是

```c
A: 如果函数值的类型与返回值类型不一致，以函数值类型为准
B: return后边的值不能为表达式
C: 如果形参与实参类型不一致，以实参类型为准
D: 定义函数时，形参的类型说明可以放在函数体内
```

函数值类型就代表要求的返回值类型。return当然可以返回表达式。形参是声明时就已经确定了需要的实参类型了。定义函数时，形参类型不能写在函数内。选择BCD.

> **✅ 正确，答案BCD**
> - A（正确说法）：函数声明的返回类型与实际return值类型不一致时，以**函数声明的返回类型为准**（隐式类型转换）
> - B（**不正确**）：return后面当然可以接表达式，如`return a + b;`、`return x > 0 ? x : -x;`
> - C（**不正确**）：形参与实参类型不一致时，以**形参类型为准**（实参被隐式转换为形参类型），不是以实参类型为准
> - D（**不正确**）：形参类型说明应写在函数头部的参数列表中，不能放在函数体内
>
> **考点：** C语言函数的类型转换规则——无论是返回值还是参数传递，都是**被调用方的声明类型为准**（函数返回类型、形参类型）
> **注意：** C选项容易犯迷糊，记住口诀：**"形参说了算"**

# 算法

## 实现大整数乘法是利用什么算法？

```c
A: 动态规划算法
B: 贪心算法
C: 分治算法
D: 回溯算法
```

没有了解过。

> **正确答案是C（分治算法）**
> 经典的**Karatsuba算法**就是用分治思想实现大整数乘法：
>
> - 将大整数拆分为高位和低位两部分
> - 递归地对较小的部分做乘法
> - 合并结果
> - 时间复杂度从朴素的O(n²)降到O(n^1.585)
>
> **考点：** 分治算法的经典应用——大整数乘法(Karatsuba)、归并排序、快速排序、Strassen矩阵乘法
> **注意：** 分治 = **分解子问题 + 递归求解 + 合并结果**，符合大整数乘法"拆分→分别乘→合并"的思路

## 链表

以下代码实现了从表中删除重复项的功能，请选择其中空白行应填入的正确代码。

```c
template <class T>
void removeDuplicates(list<T> &aList)
{
    T curValue;
    list<T>::iterator cur, p;

    cur = aList.begin();
    while (cur != aList.end())
    {
        curValue = *cur;

        // 空白行①

        while (p != aList.end())
        {
            if (*p == curValue)
            {
                // 空白行②
            }
            else
            {
                p++;
            }
        }

        cur++;
    }
}

A:
p = ++cur;
aList.erase(p++);

B:
p = cur + 1;
aList.erase(p);

C:
p = cur + 1;
aList.erase(p++);

D:
p = ++cur;
aList.erase(p);
```

看代码，基本的逻辑就是，链表中每一个节点逐一跟后面节点比较，删除所有重复节点。

也就意味着空行1，需要拿到cur当前节点的下一个节点，只有B和C符合要求。那么空行2，当前节点与后一个节点重复时，删除后一个节点。继续往后比较，排查是否有重复节点，所以只能选择C选项。

> **❌ 错误，正确答案是A**
>
> **关键错误：`std::list`的迭代器不支持`+`运算符！**
>
> - `list`是双向链表，迭代器是**BidirectionalIterator**，只支持`++`和`--`
> - `cur + 1`无法通过编译，**B和C直接排除**
> - 只有`++cur`（自增）才是合法的迭代器操作
>
> **分析A选项：**
> - 空白行①：`p = ++cur;` —— cur先自增指向下一个元素，p也指向该位置（注意：这里cur已经前进了一步，后面外层`cur++`会再前进，但逻辑上是对的，因为我们要从cur的下一个开始检查）
> - 空白行②：`aList.erase(p++);` —— **先保存p当前位置用于erase，再将p自增指向下一个元素**。这是STL中删除元素的标准写法，避免迭代器失效
>
> **分析D选项：**
> - `aList.erase(p);` —— erase后p迭代器**失效**，后续while循环中`p != aList.end()`是未定义行为
>
> **考点：** ①`std::list`迭代器只支持`++/--`，不支持随机访问(+n)；②STL容器删除元素时的迭代器失效问题，`erase(p++)`是经典安全写法
> **注意：** 这道题的核心陷阱就是`list`迭代器 vs `vector`迭代器的区别。`vector`支持`+n`，`list`不支持

## 给定一个整数，将其转化为7进制，并以字符串形式输出。

```c
示例1:
输入:100
输出:"202"
示例2:
输入:-7
输出:"-10"
注意:输入范围是[-1e7,1e7]。
```

没有思路。

> **最优解：短除法（辗转取余）**
>
> 思路：不断对7取余得到每一位，再对7整除缩小数值，最后将结果反转。负数先转正数处理，最后加负号。
>
> ```c
> #include <stdio.h>
> 
> char* toBase7(int num)
> {
>     // 静态缓冲区足够容纳范围 [-1e7, 1e7]
>     // 7^9 = 40353607 > 1e7
>     // 最多 9 位 + 负号 + '\0'
>     static char buf[12];
>     
>     if (num == 0) {
>         buf[0] = '0';
>         buf[1] = '\0';
>         return buf;
>     }
> 
>     int isNegative = 0;
>     if (num < 0) {
>         isNegative = 1;
>         num = -num;
>     }
> 
>     int i = 0;
> 
>     while (num > 0) {
>         int digit = num % 7;
>         buf[i++] = digit + '0';//数字转字符：加上'0'即可
>         num /= 7;
>     }
> 
>     if (isNegative) {
>         buf[i++] = '-';
>     }
> 
>     buf[i] = '\0';
> 
>     // 反转字符串
>     int left = 0, right = i - 1;
>     while (left < right) {
>         char temp = buf[left];
>         buf[left] = buf[right];
>         buf[right] = temp;
>         left++;
>         right--;
>     }
> 
>     return buf;
> }
> 
> 
> // 示例: 100 → 100%7=6,100/7=14 → 14%7=0,14/7=2 → 2%7=2,2/7=0 → 逆序"202"
> ```
>
> **考点：** 进制转换的通用方法——**短除法**（对目标进制取余，逆序排列）
> **注意：** 边界情况：输入为0时直接返回"0"；负数需要单独处理符号
>
> 每次取余得到最低位
> 每次整除去掉最低位，不断重复即可。
>
> 这个算法适用于：
>
> - 二进制
> - 八进制
> - 十进制
> - 十六进制
> - 任意 2 ~ 36 进制
> - 任意正整数进制

## 对括号的合法性判断是一个常见且实用的问题。例如，在代码编辑器或编译器中都会检查括号是否正确闭合。

输入一个字符串，其中包含 ()、[]、{} 六种括号，请判断该字符串中的括号是否合法。

| 输入       | 输出    |
| ---------- | ------- |
| `"()[]{}"` | `true`  |
| `"(]"`     | `false` |
| `"(["`     | `false` |

**判定规则**

1. 左括号必须由相同类型的右括号闭合。
2. 左括号必须按正确的顺序闭合（后开先闭）。
3. 每个右括号都必须有对应的左括号。
4. 所有括号最终都必须完全匹配。

不会写。。。

> **最优解：栈（后进先出，天然匹配"后开先闭"规则）**
>
> 遍历字符串
>
> 遇到左括号 → 入栈
>
> 遇到右括号 → 检查：
>
> - 栈是否为空
> - 栈顶是否匹配
>
> 最终栈必须为空
>
> ```c
> #include <stdbool.h>
> #include <string.h>
> 
> bool isValid(const char* s)
> {
>     int len = strlen(s);
> 
>     // 最大栈深度不超过字符串长度
>     char stack[len];
>     int top = -1;
> 
>     for (int i = 0; i < len; i++)
>     {
>         char c = s[i];//指针可以直接使用数组下标语法糖访问元素。
> 
>         // 左括号入栈
>         if (c == '(' || c == '[' || c == '{')
>         {
>             stack[++top] = c;//先操作栈顶下标再入栈
>         }
>         else
>         {
>             // 右括号或者其他字符时，栈必须非空，如果是合法的，左括号一定先入栈了。
>             if (top < 0)
>                 return false;
> 
>             char t = stack[top--];//先操作栈顶再出栈，检测最后入栈的左括号是否匹配。因为最后入栈一定是最先闭合的！
> 
>             // 检查是否匹配
>             if ((c == ')' && t != '(') ||
>                 (c == ']' && t != '[') ||
>                 (c == '}' && t != '{'))
>             {
>                 return false;
>             }
>         }
>     }
> 
>     // 所有括号必须匹配完成，遍历完后，所有的括号都是一对。
>     return top == -1;
> }
> 
> ```
>
> **考点：** 栈的经典应用——括号匹配。这是数据结构面试的高频题（LeetCode第20题）
> **注意：** 三个容易遗漏的边界：①右括号多余（栈空时遇到右括号）②左括号多余（遍历结束栈不空）③类型不匹配（`(`遇到`]`）
>
> 遍历整个字符串，只针对目标括号字符进行入栈与检测。
>
> 出现右括号时，栈空则不合法。出栈不匹配也不合法。如果合法，出现右括号时，出栈的一定是对应的左括号。因为后开先闭。

# 通信总线

## 下列关于UART通信描述正确的是

A: 收发两端可以不工作在同一个速率上
B: 异步通讯方式
C: 传输速度固定不可变
D: 不可以实现全双工模式

串口是双线全双工异步的通讯方式直接选B。

> **✅ 正确，答案B（异步通讯方式）**
> - A错：收发两端**必须**工作在相同波特率上，否则无法正确解码
> - B对：UART = Universal **Asynchronous** Receiver/Transmitter，无时钟线，靠波特率约定同步
> - C错：波特率是**可配置**的（9600、115200等），不是固定的
> - D错：UART有TX和RX两根线，**可以实现全双工**
>
> **考点：** UART特性——异步、全双工、波特率可配置、收发必须同一波特率
> **注意：** 你的分析完全正确，继续保持

## 关于SPI和IIC总线的描述，正确的是

```c
A: IIC可以实现全双工，SPI不能实现全双工
B: IIC的数据输入输出用的是一根线，SPI则分为数据输入和数据输出两根线
C: IIC的抗干扰能力比SPI强
D: SPI适合长距离传播
```

根据我的了解，IIC是双线，半双工的同步通讯方式。一根时钟线，一根数据线。其他就不知道了，不知道选啥。

> **正确答案是B**
> - A错：恰好说反了。**IIC是半双工**（SDA一根数据线），**SPI才能实现全双工**（MOSI+MISO两根数据线）
> - B对：**IIC用SDA一根线**收发数据（半双工）；**SPI用MOSI（主→从）和MISO（从→主）两根线**分别负责输入输出 ✓
> - C错：SPI的抗干扰能力比IIC强（SPI速度更快、信号更稳定）
> - D错：SPI适合**短距离、高速**板级通信，不适合长距离
>
> | 特性 | IIC | SPI |
> |------|-----|-----|
> | 线数 | 2根（SCL+SDA） | 4根（SCLK+MOSI+MISO+CS） |
> | 双工 | 半双工 | 全双工 |
> | 速度 | 较慢（100K/400K/3.4M） | 较快（可达几十MHz） |
> | 寻址 | 地址寻址，支持多从机 | CS片选，每个从机需一根CS线 |
>
> **考点：** IIC vs SPI对比。你对IIC的理解是正确的，由此可以直接推导出B选项正确
> **注意：** 看到IIC就想到"两线、半双工、一根数据线"，自然就能选出B