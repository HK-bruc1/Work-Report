# C语言

## 简述`#ifdef,#else,#endif,#ifndef`的作用

**【我的原答案】**

这几个预定义标识符，通常用于条件编译。以节省ROM。比如：

```c
#ifdef 宏C
代码A
#else
代码B
#endif
```

- 如果定义了宏C那么则编译代码A而不编译代码B。

还用于头文件中的反包含机制，避免同一个头文件被重复包含，导致编译报重复声明错误。比如

```c
#ifndef 宏A
#define 宏A
#endif
```

**【批改】✅ 基本正确，但有两个问题需要纠正：**

1. 它们不叫"预定义标识符"，叫**预处理指令**（Preprocessor Directives）。
2. 头文件保护的示例不完整，`#ifndef` 和 `#endif` 之间应包含头文件的实际内容。

**【最优解】**

这些是**预处理指令**，用于**条件编译**，在预处理阶段决定哪些代码参与编译。

- `#ifdef`：如果宏已定义，则编译其后的代码
- `#ifndef`：如果宏**未**定义，则编译其后的代码
- `#else`：与`#ifdef`/`#ifndef`配合，提供否定分支
- `#endif`：结束条件编译块

两个典型场景：

**场景一：条件编译（跨平台/调试控制）**
```c
#ifdef DEBUG
    printf("debug info\n");
#else
    // Release模式不编译调试代码
#endif
```

**场景二：头文件防重复包含（Include Guard）**

```c
#ifndef _MODULE_H_
#define _MODULE_H_
// 头文件内容
#endif
```

> **考点**：预处理指令 vs 关键字的区别；条件编译的实际应用场景。

---

## `sizeof`和`strlen`的区别？

**【我的原答案】**

前者计算的大小是不包含"\0"的，后者计算的大小是包含的。

**【批改】❌ 完全说反了，且遗漏了核心区别。**

**【最优解】**

| 区别 | `sizeof` | `strlen` |
|------|----------|----------|
| 性质 | **运算符**，编译期求值 | **库函数**（`<string.h>`），运行期求值 |
| `\0` | **包含** `\0` | **不包含** `\0` |
| 计算对象 | 任意类型占用的**内存字节数** | 字符串的**有效字符个数** |
| 参数 | 类型或变量 | 必须是 `char*`（以`\0`结尾） |

```c
char str[] = "hello";
sizeof(str);  // 6（含'\0'）
strlen(str);  // 5（不含'\0'）
```

> **注意**：`sizeof` 对数组名返回整个数组大小，对指针返回指针本身大小（4/8字节），这是常见陷阱。
> **考点**：编译期 vs 运行期；`\0` 的计算差异；数组名退化为指针时的行为。

## 一个参数可以既是`const`又是`volatile`吗？

**【我的原答案】**

首先使用volatile修饰就意味着告诉编译器值随时可能被改变需要每次从寄存器中获取，而const修饰的变量都是不可能更改的，一般都是常量储存在静态常量区。这两者相互矛盾了，不能同时一起修饰。

**【批改】❌ 答案错误。可以同时使用，且 volatile 是从内存（而非寄存器）中获取。**

- `volatile` 的含义不是"值会被代码改变"，而是"值可能被**外部因素**（硬件、中断、其他线程）改变"。
- `const` 的含义是"**本代码不能修改**该变量"，不代表值不会变。
- 两者并不矛盾。

**【最优解】**

**可以。** 典型场景：只读的硬件状态寄存器。

```c
const volatile uint32_t *status_reg = (const volatile uint32_t *)0x40001000;
```

- `const`：告诉编译器**程序自身不应修改**这个值
- `volatile`：告诉编译器**每次访问必须从内存重新读取**，不要做缓存优化（因为硬件可能随时改变该值）

经典例子：嵌入式中的**只读状态寄存器**——程序不能写它（const），但硬件会更新它（volatile）。

> **注意**：volatile 是"从内存读"不是"从寄存器读"，恰恰是**禁止**编译器将值缓存到CPU寄存器中。
> **考点**：const 和 volatile 的精确语义；嵌入式硬件寄存器的应用；编译器优化行为。

---

## 请解析`(* (void (*) ()) 0) ()`的含义吗？

**【我的原答案】**

（未作答）

**【最优解】**

**从内向外拆解**：

1. `void (*)()` —— 一个**函数指针类型**，指向无参数、无返回值的函数
2. `(void (*)()) 0` —— 将整数 `0` **强制转换**为该函数指针类型，即地址0处的函数
3. `(* (void (*)()) 0)` —— **解引用**该函数指针，得到函数本身
4. `(* (void (*)()) 0)()` —— **调用**该函数

**含义：调用位于内存地址 `0x0` 处的一个 `void func(void)` 类型的函数。**

在嵌入式中常用于跳转到复位向量（地址0）执行。

> **考点**：C语言复杂声明的阅读能力；函数指针的理解；强制类型转换。

## 什么是右值引用？跟左值又有什么区别？

**【我的原答案】**

一般右值代表临时变量，没有存储空间的。而左值都有存储空间的。最常出现在赋值运算符的两侧。通过是计算后的结果值作为右值被引用赋值给左值。比如 int a = (10+6)

**【批改】⚠️ 对左值/右值的基本理解大致正确，但未回答核心问题"什么是右值引用"，也未提到 `&&` 语法和移动语义。**

**【最优解】**

**左值（lvalue）**：有持久身份的表达式，可取地址。如变量名 `a`、`arr[0]`、`*ptr`。

**右值（rvalue）**：临时的、即将销毁的表达式，不可取地址。如字面量 `42`、表达式 `a+b`、函数返回的临时对象。

## 链表和数组有什么区别？

**【我的原答案】**

（未作答）

**【最优解】**

| 区别 | 数组 | 链表 |
|------|------|------|
| 内存分配 | **连续**内存 | **离散**内存，通过指针连接 |
| 随机访问 | O(1)，支持下标直接访问 | O(n)，必须从头遍历 |
| 插入/删除 | O(n)，需要移动元素 | O(1)，修改指针即可（已知位置时） |
| 大小 | 固定（静态数组）或需重新分配 | 动态增长，按需分配 |
| 缓存友好 | **好**（连续内存，局部性强） | **差**（节点分散，缓存命中率低） |
| 额外开销 | 无 | 每个节点需存储指针 |

> **考点**：时间复杂度对比；内存布局与缓存局部性；实际场景的选型依据。

---

## 简述队列和栈的异同？

**【我的原答案】**

（未作答）

**【最优解】**

**相同点：**
- 都是**线性数据结构**，操作受限（不允许随机访问中间元素）
- 都可以用数组或链表实现

**不同点：**

| 区别 | 栈（Stack） | 队列（Queue） |
|------|------------|---------------|
| 原则 | **LIFO**（后进先出） | **FIFO**（先进先出） |
| 操作 | `push`（入栈）/ `pop`（出栈），同一端 | `enqueue`（入队尾）/ `dequeue`（出队头） |
| 典型应用 | 函数调用栈、DFS | 消息队列、BFS |

> **考点**：LIFO vs FIFO；典型应用场景；变体（循环队列、双端队列、优先队列）。

---

## 写一个宏MIN，返回两个数小的哪一个？

**【我的原答案】**

```c
#define MIN(a,b)  (a>b:a)
```

**【批改】❌ 语法完全错误。三目运算符格式是 `条件 ? 值1 : 值2`，不是 `条件:值`。且逻辑也反了。还缺少括号保护。**

**【最优解】**

```c
#define MIN(a, b)  ((a) < (b) ? (a) : (b))
```

每个参数都要加括号，防止宏展开时运算符优先级导致错误。例如 `MIN(x+1, y+2)` 如果不加括号会出错。

进阶（GCC扩展，避免参数被求值两次的副作用）：
```c
#define MIN(a, b) ({        \
    typeof(a) _a = (a);     \
    typeof(b) _b = (b);     \
    _a < _b ? _a : _b;     \
})
```

> **注意**：宏参数务必加括号；注意宏的**双重求值**问题（如 `MIN(i++, j++)`）。
> **考点**：三目运算符语法；宏的括号保护；宏的副作用陷阱。

---

## 写出`int`,`bool`,`float`,指针变量与"零值"比较的if语句？

**【我的原答案】**

```c
int a = 1;
if(a == 0);
bool a = ture;
if(a==false);
int *p = null;
if(p==null);
```

**【批改】⚠️ 存在以下问题：**

1. `ture` 拼写错误，应为 `true`
2. `null` 大小写错误，C语言中是 `NULL`（大写）
3. **缺少 `float` 的比较**（题目要求了）
4. `bool` 的比较建议直接用 `if(!a)` 更规范
5. float 不能用 `==` 直接比较，这是本题最关键的考点

**【最优解】**

```c
// int 与零值比较
int a = 1;
if (a == 0)        // 或 if (0 == a) 防止误写成赋值

// bool 与零值比较
bool b = true;
if (!b)            // 不要写 if(b == false)，直接用逻辑非

// float 与零值比较（核心考点！）
float f = 0.1f;
if (f > -1e-6 && f < 1e-6)   // 浮点数不能用 == 比较，必须用精度范围判断
// 或写为：
#define EPSILON 1e-6 //相当于1 × 10⁻⁶
if (fabs(f) < EPSILON)
“这个数的绝对值是不是已经非常非常小了，
小到我们可以把它当成零来处理？”
fabs(f) → 取绝对值（不管正负都看大小）
< 1e-6 → 小于百万分之一 → 已经很小了
于是就认为“≈ 0”

    
// 指针与零值比较
int *p = NULL;
if (p == NULL)     // 或 if (!p)
```

> **注意**：本题最核心的考点就是 **float 不能用 `==` 和 `0` 比较**，因为浮点数存在精度误差。
> **考点**：浮点数精度问题；布尔值的规范写法；NULL 的大小写；防御性编程（`0 == a`）。

---

## 设置地址为`0x13579`的整型变量的值为`0x97351`？

**【我的原答案】**

（未作答）

**【最优解】**

```c
*(int *)0x13579 = 0x97351;
```

拆解：
1. `(int *)0x13579` —— 将整数地址强制转换为 `int` 类型指针
2. `*(int *)0x13579` —— 解引用该指针，访问该地址处的整型变量
3. `= 0x97351` —— 赋值

> **注意**：在嵌入式中常用于直接操作硬件寄存器。普通程序中这样做属于未定义行为。
> **考点**：强制类型转换；指针解引用；嵌入式寄存器操作。

---

## 编码实现数字字符串转化为数字？

**【我的原答案】**

（未作答）

**【最优解】**

目标：把字符串 "   -12345" 变成数字 -12345

```c
int my_atoi(const char *str) {
    int sign = 1;     // 默认正数
    int result = 0;   // 最终要返回的数字，从 0 开始累加

    // 1. 跳过前面的空格
    while (*str == ' ') {
        str++;        // 指针向后移动
    }
    // 假设输入是 "   -12345"
    // 跳过 3 个空格后，str 指向 '-'

    // 2. 判断是否有符号
    if (*str == '-' || *str == '+') {
        if (*str == '-') sign = -1;   // 如果是负号，sign 变成 -1
        str++;                        // 符号处理完，指针后移
    }
    // 现在 str 指向 '1'，sign = -1

    // 3. 核心：一位一位地把字符转成数字并累加
    while (*str >= '0' && *str <= '9') {   // 只要还是数字字符
        // ------------------ 这一行最关键 ------------------
        result = result * 10 + (*str - '0');
        // ----------------------------------------------------
        str++;
    }

    return sign * result;
}
```

核心原理：`字符 - '0'` 得到对应数字，逐位累乘10相加。

> **注意**：完整实现还需考虑溢出检测（超出 `INT_MAX`/`INT_MIN`），面试中提一嘴加分。
> **考点**：字符与数字的ASCII转换（`- '0'`）；边界处理（空格、正负号、溢出）。

---

# 总评

| 题目 | 评分 | 说明 |
|------|------|------|
| `#ifdef` 系列 | ✅ 80分 | 理解正确，术语和示例不够严谨 |
| `sizeof` vs `strlen` | ❌ 0分 | **说反了**，这是致命错误 |
| `malloc` vs `new` | ❌ 20分 | `new`不是自动管理内存 |
| `const volatile` | ❌ 0分 | 结论错误，可以共存 |
| 复杂声明解析 | ❌ 未答 | — |
| 类内引用成员 | ⚠️ 30分 | 结论对但理由错，缺关键约束 |
| 右值引用 | ⚠️ 40分 | 缺核心内容（`&&`、移动语义） |
| 链表 vs 数组 | ❌ 未答 | — |
| 队列 vs 栈 | ❌ 未答 | — |
| 宏 MIN | ❌ 0分 | 三目运算符语法错误 |
| 零值比较 | ⚠️ 30分 | 拼写错误、缺float、缺核心考点 |
| 地址赋值 | ❌ 未答 | — |
| 字符串转数字 | ❌ 未答 | — |

**薄弱点总结：**
1. **基础语法**：三目运算符、NULL大小写等基本功需要加强
2. **关键概念搞反**：`sizeof`/`strlen` 包不包含 `\0` 记反了，这类高频考点务必记牢
3. **深度不足**：多道题只答了表面，缺少关键限制条件和底层原理
4. **未答题过多**：13题未答5题，需要补齐知识盲区
