# UART 串口通信

## 基本概念

UART（Universal Asynchronous Receiver-Transmitter）是一种**异步串行通信协议**，数据一位一位按顺序传输，收发双方不共享时钟信号，靠约定好的波特率来同步。

- **异步通信**：没有时钟线，这是它与 SPI、I2C 的重要区别
- **波特率**：每秒传输的符号数，单位 bps。波特率 9600 代表每秒传输 9600 位，每位持续约 104 μs。接收方检测到起始位下降沿后，按波特率定时依次采样后续每一位。**双方波特率必须一致**，否则采样错位导致数据错误。常用波特率：9600、115200
- **三根线**：TX（发送）、RX（接收）、GND（共地），两设备之间交叉连接（A 的 TX 接 B 的 RX，A 的 RX 接 B 的 TX）
- **全双工**：TX 专门发送，RX 专门接收，两线互不干扰，可同时收发

## 数据帧结构

UART 以**帧**为单位传输，一帧是一次完整的通信单元：

```
空闲状态  起始位    数据位           校验位    停止位     空闲状态
高电平    1bit低   5~9bit（常8）    可选1bit  1~2bit高   高电平
```

| 字段     | 内容              | 说明                                                   |
| -------- | ----------------- | ------------------------------------------------------ |
| 空闲状态 | 高电平            | 无数据时总线保持高，接收方等待                         |
| 起始位   | 1 bit 低电平      | 一帧开始标志，接收方检测到下降沿后开始按波特率定时采样 |
| 数据位   | 5~9 bit（通常 8） | 低位（LSB）先发，逐位串行传输，合在一起才是要传的字节  |
| 校验位   | 可选 1 bit        | 奇校验或偶校验，也可不用                               |
| 停止位   | 1~2 bit 高电平    | 一帧结束标志，总线回到空闲状态，准备下一帧             |

发送方把字节按帧格式打包逐位发出；接收方从起始位开始逐位采样，采完停止位后将数据位重新拼成一个字节。连续传输多个字节就是连续发送多帧。

## 奇偶校验

### 计算方式

以数据位 `01101001` 为例（含 4 个 1）：

- **奇校验**：要求数据位 + 校验位中 1 的总个数为**奇数**，4 个 1 是偶数，所以校验位填 `1`，凑成 5 个（奇数）
- **偶校验**：要求总个数为**偶数**，4 个 1 已是偶数，校验位填 `0`，保持 4 个（偶数）
- 在数据帧里额外加一位，使得"数据位 + 校验位"里1的总个数满足奇/偶的约定。

### 接收方验证

接收方收到数据位和校验位后，自己数一遍 1 的个数，看是否符合约定规则。不符合则说明传输中某一位发生了翻转。

### 局限性

校验位只能检测**奇数个位**出错的情况。若同时有两位翻转，奇偶性不变，校验位无法发现错误。可靠性要求高的场合需配合上层 CRC 校验。

## 电平标准与物理层扩展

RS232 和 RS485 本质上都是基于 UART 的串口通信：数据层面（帧格式、波特率、起始/停止位）完全不变，唯一不同的是**物理层电平标准**。单片机只需在 IO 口外加一颗转换芯片，内部照常操作普通 UART，不需要改任何代码逻辑。

### TTL 电平

UART 本身使用 TTL 电平（0V/3.3V 或 0V/5V）：

| -            | 发送方输出         | 接收方判定       |
| ------------ | ------------------ | ---------------- |
| **高电平**   | > 2.4 V            | > 2.0 V 为逻辑 1 |
| **低电平**   | < 0.4 V            | < 0.8 V 为逻辑 0 |
| **噪声容限** | 中间区域不确定     | 不确定           |

与 PC 通信通常通过 CH340、CP2102 等 USB 转 UART 桥接芯片完成协议和电平转换。

### RS232

RS232 将电压幅度提高到 **±12V** 以增强抗干扰能力，但逻辑定义与 TTL **完全相反**：

| 逻辑   | TTL 电平 | RS232 电平       |
| ------ | -------- | ---------------- |
| 逻辑 1 | 高电平   | **-3V \~ -15V**  |
| 逻辑 0 | 低电平   | **+3V \~ +15V**  |

MAX232 做了两件事：**升降压 + 逻辑取反**（TTL 高电平 → -12V，TTL 低电平 → +12V）。通信距离约 15m，点对点。

### RS485

RS485 改用**差分信号**，靠 A/B 两线的电压差表示逻辑，与绝对电位无关：

- A - B > +200 mV → 逻辑 1
- A - B < -200 mV → 逻辑 0

"差分±7V"是总线共模电压的**容忍范围**（A、B 绝对电位可在 -7V \~ +12V 之间浮动，不是逻辑定义本身），这保证了长线上两端接地电位不同时差分信号仍能正确识别。MAX485 完成单端转差分 + 电平转换。通信距离约 1200m，支持一主多从（最多 32 个节点）。

### 三种接口对比

| 协议        | 电平           | 逻辑极性    | 通信距离      | 拓扑              |
| ----------- | -------------- | ----------- | ------------- | ----------------- |
| UART（TTL） | 0V / 3.3V 或 5V | 正逻辑     | 几十厘米～几米 | 点对点           |
| RS232       | ±12V           | **反逻辑**  | 约 15 m       | 点对点            |
| RS485       | 差分（共模±7V）| 差分正逻辑  | 约 1200 m     | 一主多从（32节点）|

## 硬件 UART vs 软件 UART

实现 UART 通信有两种方式：使用 MCU 内置的 UART 外设（硬件 UART），或用普通 GPIO 手动模拟时序（软件 UART / Bit-bang）。

### 硬件 UART

MCU 内部集成了专用的 UART 硬件外设，TX/RX 引脚由外设自动控制，CPU 只需把数据写入**发送寄存器**或从**接收寄存器**读出，其余全部由硬件完成。

**工作机制：**

- **发送**：CPU 把字节写入 TDR（发送数据寄存器），硬件自动加起始位、逐位移出、加停止位
- **接收**：硬件检测起始位下降沿，按配置的波特率自动采样，拼好后存入 RDR（接收数据寄存器），触发中断或 DMA 通知 CPU 来取
- **波特率**：由波特率发生器（BRG）分频系统时钟产生，精度高，与 CPU 负载无关
- **中断 / DMA**：接收完成、发送缓冲空等事件均可触发中断，也可配 DMA 实现零 CPU 占用的数据搬运

**GPIO 配置（以 STM32 为例）：**

| 引脚 | GPIO 模式                 | 原因                                       |
| ---- | ------------------------- | ------------------------------------------ |
| TX   | **复用**推挽输出（AF_PP） | 由 UART 外设接管驱动，推挽保证输出驱动能力 |
| RX   | 浮空输入 或 上拉输入      | 接收外部信号，上拉防止引脚悬空引入噪声     |

### 软件 UART（Bit-bang）

用普通 GPIO 口，在软件中按 UART 时序手动翻转电平，完全由 CPU 执行。硬件 UART 外设不够用时的备选方案。

**GPIO 配置：**

| 引脚 | GPIO 模式      | 原因                                         |
| ---- | -------------- | -------------------------------------------- |
| TX   | 推挽输出（PP） | 初始化为高电平（空闲状态），按帧格式逐位翻转 |
| RX   | 上拉输入       | UART 空闲为高，上拉防悬空，软件定时采样      |

**发送端核心逻辑（以 8N1 为例）：**

```c
gpio_write(TX, 0);                    // 起始位，拉低
delay_us(bit_time);
for (int i = 0; i < 8; i++) {
    gpio_write(TX, (data >> i) & 1);  // LSB 先发，每位保持 1 个 bit 时间
    delay_us(bit_time);
}
gpio_write(TX, 1);                    // 停止位，拉高
delay_us(bit_time);
```

**接收端核心逻辑：**

```c
wait_falling_edge(RX);       // 检测起始位下降沿
delay_us(bit_time * 1.5);    // 延迟 1.5 个 bit，跳到第 1 数据位中间采样
for (int i = 0; i < 8; i++) {
    data |= gpio_read(RX) << i;
    delay_us(bit_time);      // 每隔 1 个 bit 采样一次
}
```

接收端延迟 **1.5 个 bit 时间**而不是 1 个，目的是在每个数据位的**中间位置**采样，避开边沿跳变的不稳定区域；之后每隔 1 个 bit 时间采样后续位。

### 硬件 UART vs 软件 UART 对比

| 对比项       | 硬件 UART                      | 软件 UART（Bit-bang）              |
| ------------ | ------------------------------ | ---------------------------------- |
| 实现方式     | MCU 内置外设自动处理时序       | CPU 手动控制 GPIO 翻转             |
| CPU 占用     | 低（中断/DMA，发送期间 CPU 空闲）| 高（发送期间 CPU 忙等，无法响应其他任务）|
| 波特率精度   | 高（硬件分频，与 CPU 负载无关）| 受系统时钟精度和中断延迟影响       |
| 最高波特率   | 可达数 Mbps                    | 通常 ≤ 115200，越高越不可靠        |
| 引脚限制     | 只能用固定的 UART 复用引脚     | 任意 GPIO 均可                     |
| 抗中断干扰   | 强（硬件不受中断影响）         | 弱（中断打断可导致时序错乱）       |
| 适用场景     | 正式产品、高波特率、多路串口   | 硬件资源不足时的临时补充、低速低要求场合 |

# I2C通信

## 基本概念

I2C（Inter-Integrated Circuit）是一种**同步、半双工**的串行通信协议，由飞利浦公司（现 NXP）发明，广泛用于连接低速外设（传感器、EEPROM、显示屏控制器等）。

- **两根线**：SDA（Serial Data，数据线）和 SCL（Serial Clock，时钟线），比 SPI 省线
- **多主多从**：总线上可以挂多个主机和多个从机，靠 7 位或 10 位地址区分从机
- **半双工**：SDA 是双向数据线，收发共用同一根线，不能同时收发
- **同步通信**：**主机**提供 SCL 时钟，**从机**跟随时钟采样数据
- **需要上拉电阻**：SDA 和 SCL 都是开漏输出，必须接上拉电阻到 VCC（常用 4.7kΩ）

## 速率等级

| 模式     | 速率      |
| -------- | --------- |
| 标准模式 | 100 kbps  |
| 快速模式 | 400 kbps  |
| 高速模式 | 3.4 Mbps  |

## 时序与信号定义

I2C 所有信号都基于 SCL 和 SDA 两根线的状态变化。**空闲状态**：SDA 和 SCL 都保持高电平（由上拉电阻拉高）。

### 起始信号（START）

**SCL 为高时，SDA 从高变低。**

这是每次通信的开始标志。**总线上所有从机**检测到这个变化就知道通信要开始了，**进入监听状态**。

### 停止信号（STOP）

**SCL 为高时，SDA 从低变高。**

这是每次通信的结束标志，总线释放回空闲状态。

> 关键：START 和 STOP 是 I2C 中唯一允许在 SCL 高时改变 SDA 的情况，其他时候 SCL 高时 SDA 必须稳定。

### 数据传输规则

**SCL 低时才能改变 SDA；SCL 高时 SDA 必须稳定，此时接收方采样数据。**

- 因为在SCL为高时，SDA的变化会被识别为起始信号或者结束信号导致通信不完整。

每次传输 **8 位数据**，高位（MSB）先发。发完 8 位后，**发送方**释放 SDA（置高），等待**接收方**在第 9 个时钟周期给出应答。

### ACK / NACK 应答机制

每传输完 8 位数据，接收方必须给出一个应答位（第 9 个时钟周期）：

- **ACK（应答，低电平）**：**接收方主动拉低 SDA** → 表示"收到了，继续"
- **NACK（非应答，高电平）**：SDA 保持高电平（发送方释放，无人拉低）→ 表示"没收到 / 不接受 / 传完了"

**写操作**时从机给 ACK；**读操作**时每字节由主机给 ACK（最后一字节给 NACK 告知从机停止）。

## 数据帧格式

### 写操作（主机→从机）

- 先会有一个寻地址（找目标从机），从机回复ACK之后，就建立起通信实现点对点通信。
- 从机只有对寻址回复ACK之后才能对具体数据进行回复ACK

**寻址操作详细说明**：主机发送起始信号（START）后，紧接着发送7位从机地址和1位读写方向位（0表示写，1表示读），共8位。**所有从机都会接收这个地址，并与自身地址比较。**只有地址匹配的从机在第9个时钟周期拉低SDA（发送ACK），表示应答。如果地址不匹配，从机不会拉低SDA，主机将检测到NACK（高电平）。收到ACK后，主机与从机之间建立起点对点连接，随后可以传输数据字节。每个数据字节后都有ACK/NACK应答。如果主机收到NACK，可以发送停止信号（STOP）结束通信或重新尝试。

```
START → [7位地址 + W(0)] → ACK(从机)
      → [数据字节1]       → ACK(从机)
      → [数据字节2]       → ACK(从机)
      → ...
      → STOP
```

### 读操作（从机→主机）

```
START → [7位地址 + R(1)] → ACK(从机)
      ← [数据字节1]       → ACK(主机，继续读)
      ← [数据字节2]       → NACK(主机，最后一字节)
      → STOP
```

### 复合读操作（先写寄存器地址，再读数据）

大多数传感器需要先指定寄存器地址，再读取数据，需要用到**重复起始（Repeated START）**：

```
START → [地址 + W] → ACK → [寄存器地址] → ACK
      → Repeated START → [地址 + R] → ACK
      ← [数据字节]    → NACK → STOP
```

中间的 Repeated START 不需要先发 STOP，可以直接切换读写方向，避免总线被其他主机抢占。

## 地址机制

I2C 通过 **7 位地址**区分从机，理论上支持 128 个地址，但其中保留了部分特殊地址（如 0x00 广播地址、0x78\~0x7F 用于 10 位地址扩展），实际可用 **112 个从机地址**。

从机地址由芯片型号决定，部分芯片提供 ADDR 引脚，通过接高/低可改变地址低位，允许同一总线挂多颗相同型号的芯片（例如 ADDR 引脚接 GND 是 0x48，接 VCC 是 0x49）。

## 开漏输出与上拉电阻（重要）

I2C 的 SDA 和 SCL 都使用**开漏（Open-Drain）输出**：设备只能主动拉低总线，不能主动拉高，上拉电阻负责将总线恢复到高电平。

**为什么用开漏而不用推挽？**

1. **线与（Wired-AND）逻辑**：任何一个设备拉低总线，总线就是低电平。ACK 机制和多主仲裁都依赖这个特性。
2. **避免短路**：多个设备同时操作总线时，不会出现一个输出高、另一个输出低导致的电流对冲短路。
3. **电压兼容**：只要上拉电阻接到合适电压，3.3V 和 5V 设备可以共用同一总线（需注意电平兼容性）。

**上拉电阻选取：** 阻值过小功耗大但上升沿快；阻值过大上升沿慢影响速率。标准模式常用 4.7kΩ，高速模式需要更小的上拉电阻（1\~2kΩ）。

## 多主仲裁机制

当多个主机同时发起通信时，I2C 通过**总线仲裁**自动决定谁继续通信：

- 每个主机在发送数据的同时，监测总线实际电平
- 若主机发高电平，但总线实际是低电平（说明另一主机拉低了），该主机**立即停止发送**，退出仲裁
  
- 继续发低电平的主机感知不到任何异常，正常继续通信
- **结果：低电平优先，不会产生数据冲突，且通信不会中断**

**仲裁机制详细说明**：I2C总线采用“线与”逻辑，任何设备都可以拉低总线，但只能释放总线（靠上拉电阻拉高）。主机在发起起始信号前应检测总线空闲状态（SCL和SDA都为高），确保符合起始信号条件。当多个主机同时发起通信时，它们首先都会发送起始信号（START），起始信号时序相同，不会冲突。**仲裁发生在地址和数据传输阶段**。每个主机在发送每一位时都会检测SDA线的实际电平。如果主机尝试发送高电平（释放SDA），但检测到SDA为低电平（说明另一个主机正在发送低电平），则该主机立即知道自己失去仲裁，停止驱动SDA并切换为从机模式，监听获胜主机发送的后续数据。发送低电平的主机不受影响，继续通信。仲裁按位进行，直到只剩一个主机。**如果两个主机发送的地址和数据完全相同，则它们会继续同步传输，直到出现不同位**。低电平优先的仲裁机制确保不会产生数据冲突，且通信不会中断。注意：仲裁只发生在SCL为高电平时，因为此时SDA必须稳定；SCL为低时允许改变SDA，不会触发仲裁。

**总线含义**：I2C总线是共享的通信线路，所有设备的SCL引脚都连接到同一根SCL线上，所有SDA引脚连接到同一根SDA线上，形成公共通信通道。

**仲裁细节澄清**：

1. **多个主机同时发出起始信号**：起始信号完全相同（SCL高时SDA从高变低），不会发生仲裁，所有主机会同步开始。
2. **寻址阶段的仲裁**：在SCL为高时，如果不同主机发送的SDA电平不同（一个发高，一个发低），则发高电平的主机检测到总线实际为低，失去仲裁。
3. **已有主机通信时新主机介入**：起始信号要求SCL为高、SDA从高变低。规范要求主机在发起起始信号前检测总线空闲状态（SCL和SDA都为高）。在旧主机传输过程中，当传输数据位为1（SDA为高）且SCL为高时，新主机可能检测到SCL和SDA都为高并发起起始信号。此时两主机的SCL通过"线与"逻辑同步，仲裁从寻址阶段开始：若地址不同，寻址阶段即决出胜负；若地址相同，仲裁延续到数据阶段，按位比较直到出现不同位（发高电平的主机退出）。

## I2C 优缺点

**优点：**
- 只需两根线，硬件成本低，PCB 走线简单
- 支持多主多从，寻址灵活，一条总线可挂多个设备
- 有 ACK/NACK 应答机制，具备基本的通信确认能力

**缺点：**
- 半双工，速率低于 SPI
- 总线电容限制了挂载设备数量和通信距离（总线电容通常不超过 400pF）
- 软件模拟时序相对 UART 复杂，需要精确控制时序




# 3.1 常见通信协议对比

### 3.1.1 五种通信协议的工作原理与特点 【问答题】

> **考点**：各总线的线数、速率、拓扑结构、全/半双工、同步/异步等特性对比
> **注意**：串口可以是全双工也可以是半双工或单工，**不要一律说全双工**

请简述以下通信协议的工作原理以及特点：

| 协议       | 线数                    | 同步/异步 | 双工模式           | 关键特性                            |
| ---------- | ----------------------- | --------- | ------------------ | ----------------------------------- |
| **RS-485** | 2线（A/B差分）          | 异步      | 半双工             | 差分信号、多点通信、长距离（1200m） |
| **UART**   | 2线（TX/RX）            | 异步      | **全/半/单工均可** | 起始位/停止位、波特率匹配           |
| **CAN**    | 2线（CANH/CANL）        | 异步      | 半双工             | 差分信号、多主仲裁、错误检测完善    |
| **I2C**    | 2线（SDA+SCL）          | 同步      | 半双工             | 多主多从、7/10位地址寻址            |
| **SPI**    | 4线（MOSI/MISO/SCK/CS） | 同步      | 全双工             | 高速、无地址寻址、主从架构          |

---

### 3.1.2 串口、IIC、SPI 深入理解 【问答题】

> **考点**：三种协议的时序图、数据格式、应用场景选择
> **注意**：串口是异步通信（无时钟线），I2C和SPI是同步通信（有时钟线）

<details><summary>💡 答案提示</summary>
<p>选型参考：</p>
<ul>
<li><b>低速、少量设备、省引脚</b> → I2C</li>
<li><b>高速、实时数据传输</b> → SPI</li>
<li><b>长距离、调试打印</b> → UART</li>
</ul>
</details>


---

## 3.2 GPIO 与 I2C 设备驱动 【问答题】

> **考点**：GPIO的输入/输出/复用模式；I2C设备驱动流程（起始→地址→读写→停止）
> **注意**：I2C需要注意从机地址（7位/10位）、ACK/NACK应答机制

GPIO 功能，驱动一个 I2C 设备的流程。

<details><summary>💡 答案提示</summary>
<p>I2C 通信流程：</p>
<pre><code>主机发送起始信号(START)
    → 发送从机地址 + 读/写位
    → 等待从机 ACK
    → 发送/接收数据字节
    → 每字节后等待 ACK/NACK
    → 发送停止信号(STOP)</code></pre>
</details>