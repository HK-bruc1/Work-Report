# UART 串口通信

## 基本概念

UART（Universal Asynchronous Receiver-Transmitter）是一种**异步串行通信协议**，数据一位一位按顺序传输，收发双方不共享时钟信号，靠约定好的波特率来同步。

- **异步通信**：没有时钟线，这是它与 SPI、I2C 的重要区别
- **波特率**：每秒传输的符号数，单位 bps。波特率 9600 代表每秒传输 9600 位，每位持续约 104 μs。接收方检测到起始位下降沿后，按波特率定时依次采样后续每一位。**双方波特率必须一致**，否则采样错位导致数据错误。常用波特率：9600、115200
- **三根线**：TX（发送）、RX（接收）、GND（共地），两设备之间交叉连接（A 的 TX 接 B 的 RX，A 的 RX 接 B 的 TX）
- **全双工**：TX 专门发送，RX 专门接收，两线互不干扰，可同时收发

## 数据帧结构

UART 以**帧**为单位传输，一帧是一次完整的通信单元：

```
空闲状态  起始位    数据位           校验位    停止位     空闲状态
高电平    1bit低   5~9bit（常8）    可选1bit  1~2bit高   高电平
```

| 字段     | 内容              | 说明                                                   |
| -------- | ----------------- | ------------------------------------------------------ |
| 空闲状态 | 高电平            | 无数据时总线保持高，接收方等待                         |
| 起始位   | 1 bit 低电平      | 一帧开始标志，接收方检测到下降沿后开始按波特率定时采样 |
| 数据位   | 5~9 bit（通常 8） | 低位（LSB）先发，逐位串行传输，合在一起才是要传的字节  |
| 校验位   | 可选 1 bit        | 奇校验或偶校验，也可不用                               |
| 停止位   | 1~2 bit 高电平    | 一帧结束标志，总线回到空闲状态，准备下一帧             |

发送方把字节按帧格式打包逐位发出；接收方从起始位开始逐位采样，采完停止位后将数据位重新拼成一个字节。连续传输多个字节就是连续发送多帧。

## 奇偶校验

### 计算方式

以数据位 `01101001` 为例（含 4 个 1）：

- **奇校验**：要求数据位 + 校验位中 1 的总个数为**奇数**，4 个 1 是偶数，所以校验位填 `1`，凑成 5 个（奇数）
- **偶校验**：要求总个数为**偶数**，4 个 1 已是偶数，校验位填 `0`，保持 4 个（偶数）
- 在数据帧里额外加一位，使得"数据位 + 校验位"里1的总个数满足奇/偶的约定。

### 接收方验证

接收方收到数据位和校验位后，自己数一遍 1 的个数，看是否符合约定规则。不符合则说明传输中某一位发生了翻转。

### 局限性

校验位只能检测**奇数个位**出错的情况。若同时有两位翻转，奇偶性不变，校验位无法发现错误。可靠性要求高的场合需配合上层 CRC 校验。

## 电平标准与物理层扩展

RS232 和 RS485 本质上都是基于 UART 的串口通信：数据层面（帧格式、波特率、起始/停止位）完全不变，唯一不同的是**物理层电平标准**。单片机只需在 IO 口外加一颗转换芯片，内部照常操作普通 UART，不需要改任何代码逻辑。

### TTL 电平

UART 本身使用 TTL 电平（0V/3.3V 或 0V/5V）：

| -            | 发送方输出         | 接收方判定       |
| ------------ | ------------------ | ---------------- |
| **高电平**   | > 2.4 V            | > 2.0 V 为逻辑 1 |
| **低电平**   | < 0.4 V            | < 0.8 V 为逻辑 0 |
| **噪声容限** | 中间区域不确定     | 不确定           |

与 PC 通信通常通过 CH340、CP2102 等 USB 转 UART 桥接芯片完成协议和电平转换。

### RS232

RS232 将电压幅度提高到 **±12V** 以增强抗干扰能力，但逻辑定义与 TTL **完全相反**：

| 逻辑   | TTL 电平 | RS232 电平       |
| ------ | -------- | ---------------- |
| 逻辑 1 | 高电平   | **-3V \~ -15V**  |
| 逻辑 0 | 低电平   | **+3V \~ +15V**  |

MAX232 做了两件事：**升降压 + 逻辑取反**（TTL 高电平 → -12V，TTL 低电平 → +12V）。通信距离约 15m，点对点。

### RS485

RS485 改用**差分信号**，靠 A/B 两线的电压差表示逻辑，与绝对电位无关：

- A - B > +200 mV → 逻辑 1
- A - B < -200 mV → 逻辑 0

"差分±7V"是总线共模电压的**容忍范围**（A、B 绝对电位可在 -7V \~ +12V 之间浮动，不是逻辑定义本身），这保证了长线上两端接地电位不同时差分信号仍能正确识别。MAX485 完成单端转差分 + 电平转换。通信距离约 1200m，支持一主多从（最多 32 个节点）。

### 三种接口对比

| 协议        | 电平           | 逻辑极性    | 通信距离      | 拓扑              |
| ----------- | -------------- | ----------- | ------------- | ----------------- |
| UART（TTL） | 0V / 3.3V 或 5V | 正逻辑     | 几十厘米～几米 | 点对点           |
| RS232       | ±12V           | **反逻辑**  | 约 15 m       | 点对点            |
| RS485       | 差分（共模±7V）| 差分正逻辑  | 约 1200 m     | 一主多从（32节点）|

## 硬件 UART vs 软件 UART

实现 UART 通信有两种方式：使用 MCU 内置的 UART 外设（硬件 UART），或用普通 GPIO 手动模拟时序（软件 UART / Bit-bang）。

### 硬件 UART

MCU 内部集成了专用的 UART 硬件外设，TX/RX 引脚由外设自动控制，CPU 只需把数据写入**发送寄存器**或从**接收寄存器**读出，其余全部由硬件完成。

**工作机制：**

- **发送**：CPU 把字节写入 TDR（发送数据寄存器），硬件自动加起始位、逐位移出、加停止位
- **接收**：硬件检测起始位下降沿，按配置的波特率自动采样，拼好后存入 RDR（接收数据寄存器），触发中断或 DMA 通知 CPU 来取
- **波特率**：由波特率发生器（BRG）分频系统时钟产生，精度高，与 CPU 负载无关
- **中断 / DMA**：接收完成、发送缓冲空等事件均可触发中断，也可配 DMA 实现零 CPU 占用的数据搬运

**GPIO 配置（以 STM32 为例）：**

| 引脚 | GPIO 模式                 | 原因                                       |
| ---- | ------------------------- | ------------------------------------------ |
| TX   | **复用**推挽输出（AF_PP） | 由 UART 外设接管驱动，推挽保证输出驱动能力 |
| RX   | 浮空输入 或 上拉输入      | 接收外部信号，上拉防止引脚悬空引入噪声     |

### 软件 UART（Bit-bang）

用普通 GPIO 口，在软件中按 UART 时序手动翻转电平，完全由 CPU 执行。硬件 UART 外设不够用时的备选方案。

**GPIO 配置：**

| 引脚 | GPIO 模式      | 原因                                         |
| ---- | -------------- | -------------------------------------------- |
| TX   | 推挽输出（PP） | 初始化为高电平（空闲状态），按帧格式逐位翻转 |
| RX   | 上拉输入       | UART 空闲为高，上拉防悬空，软件定时采样      |

**发送端核心逻辑（以 8N1 为例）：**

```c
gpio_write(TX, 0);                    // 起始位，拉低
delay_us(bit_time);
for (int i = 0; i < 8; i++) {
    gpio_write(TX, (data >> i) & 1);  // LSB 先发，每位保持 1 个 bit 时间
    delay_us(bit_time);
}
gpio_write(TX, 1);                    // 停止位，拉高
delay_us(bit_time);
```

**接收端核心逻辑：**

```c
wait_falling_edge(RX);       // 检测起始位下降沿
delay_us(bit_time * 1.5);    // 延迟 1.5 个 bit，跳到第 1 数据位中间采样
for (int i = 0; i < 8; i++) {
    data |= gpio_read(RX) << i;
    delay_us(bit_time);      // 每隔 1 个 bit 采样一次
}
```

接收端延迟 **1.5 个 bit 时间**而不是 1 个，目的是在每个数据位的**中间位置**采样，避开边沿跳变的不稳定区域；之后每隔 1 个 bit 时间采样后续位。

### 硬件 UART vs 软件 UART 对比

| 对比项       | 硬件 UART                      | 软件 UART（Bit-bang）              |
| ------------ | ------------------------------ | ---------------------------------- |
| 实现方式     | MCU 内置外设自动处理时序       | CPU 手动控制 GPIO 翻转             |
| CPU 占用     | 低（中断/DMA，发送期间 CPU 空闲）| 高（发送期间 CPU 忙等，无法响应其他任务）|
| 波特率精度   | 高（硬件分频，与 CPU 负载无关）| 受系统时钟精度和中断延迟影响       |
| 最高波特率   | 可达数 Mbps                    | 通常 ≤ 115200，越高越不可靠        |
| 引脚限制     | 只能用固定的 UART 复用引脚     | 任意 GPIO 均可                     |
| 抗中断干扰   | 强（硬件不受中断影响）         | 弱（中断打断可导致时序错乱）       |
| 适用场景     | 正式产品、高波特率、多路串口   | 硬件资源不足时的临时补充、低速低要求场合 |

# I2C通信

## 基本概念

I2C（Inter-Integrated Circuit）是一种**同步、半双工**的串行通信协议，由飞利浦公司（现 NXP）发明，广泛用于连接低速外设（传感器、EEPROM、显示屏控制器等）。

- **两根线**：SDA（Serial Data，数据线）和 SCL（Serial Clock，时钟线），比 SPI 省线
- **多主多从**：总线上可以挂多个主机和多个从机，靠 7 位或 10 位地址区分从机
- **半双工**：SDA 是双向数据线，收发共用同一根线，不能同时收发
- **同步通信**：**主机**提供 SCL 时钟，**从机**跟随时钟采样数据
- **需要上拉电阻**：SDA 和 SCL 都是开漏输出，必须接上拉电阻到 VCC（常用 4.7kΩ）

## 速率等级

| 模式     | 速率      |
| -------- | --------- |
| 标准模式 | 100 kbps  |
| 快速模式 | 400 kbps  |
| 高速模式 | 3.4 Mbps  |

**SCL 时钟由谁产生？**

SCL 始终由**主机**产生，从机没有时钟输出能力，只负责跟随 SCL 采样数据。SCL 并不是 MCU 的系统时钟（晶振频率，如 72MHz），而是由 MCU 内部的 I2C 外设对系统时钟（APB 总线时钟）**分频**后得到的较低频率，即上表中 100kHz / 400kHz 这些配置的目标值。从机完全不需要知道主机的系统时钟是多少，只需跟随 SCL 脉冲工作即可。软件模拟 I2C 时，SCL 的高低电平由 CPU 手动翻转 GPIO 产生，频率由延时决定。

## 时序与信号定义

I2C 所有信号都基于 SCL 和 SDA 两根线的状态变化。**空闲状态**：SDA 和 SCL 都保持高电平（由上拉电阻拉高）。

### 起始信号（START）

**SCL 为高时，SDA 从高变低。**

这是每次通信的开始标志。**总线上所有从机**检测到这个变化就知道通信要开始了，**进入监听状态**。

### 停止信号（STOP）

**SCL 为高时，SDA 从低变高。**

这是每次通信的结束标志，总线释放回空闲状态。

> 关键：START 和 STOP 是 I2C 中唯一允许在 SCL 高时改变 SDA 的情况，其他时候 SCL 高时 SDA 必须稳定。

### 数据传输规则

**SCL 低时才能改变 SDA；SCL 高时 SDA 必须稳定，此时接收方采样数据。**

- 因为在SCL为高时，SDA的变化会被识别为起始信号或者结束信号导致通信不完整。

每次传输 **8 位数据**，高位（MSB）先发。发完 8 位后，**发送方**释放 SDA（置高），等待**接收方**在第 9 个时钟周期给出应答。

### ACK / NACK 应答机制

每传输完 8 位数据，接收方必须给出一个应答位（第 9 个时钟周期）：

- **ACK（应答，低电平）**：**接收方主动拉低 SDA** → 表示"收到了，继续"
- **NACK（非应答，高电平）**：SDA 保持高电平（发送方释放，无人拉低）→ 表示"没收到 / 不接受 / 传完了"

**写操作**时从机给 ACK；**读操作**时每字节由主机给 ACK（最后一字节给 NACK 告知从机停止）。

## 数据帧格式

### 写操作（主机→从机）

- 先会有一个寻地址（找目标从机），从机回复ACK之后，就建立起通信实现点对点通信。
- 从机只有对寻址回复ACK之后才能对具体数据进行回复ACK

**寻址操作详细说明**：主机发送起始信号（START）后，紧接着发送7位从机地址和1位读写方向位（0表示写，1表示读），共8位。**所有从机都会接收这个地址，并与自身地址比较。**只有地址匹配的从机在第9个时钟周期拉低SDA（发送ACK），表示应答。如果地址不匹配，从机不会拉低SDA，主机将检测到NACK（高电平）。收到ACK后，主机与从机之间建立起点对点连接，随后可以传输数据字节。每个数据字节后都有ACK/NACK应答。如果主机收到NACK，可以发送停止信号（STOP）结束通信或重新尝试。

```
START → [7位地址 + W(0)] → ACK(从机)
      → [数据字节1]       → ACK(从机)
      → [数据字节2]       → ACK(从机)
      → ...
      → STOP
```

### 读操作（从机→主机）

```
START → [7位地址 + R(1)] → ACK(从机)
      ← [数据字节1]       → ACK(主机，继续读)
      ← [数据字节2]       → NACK(主机，最后一字节)
      → STOP
```

### 复合读操作（先写寄存器地址，再读数据）

大多数传感器需要先指定寄存器地址，再读取数据，需要用到**重复起始（Repeated START）**：

```
START → [地址 + W] → ACK → [寄存器地址] → ACK
      → Repeated START → [地址 + R] → ACK
      ← [数据字节]    → NACK → STOP
```

中间的 Repeated START 不需要先发 STOP，可以直接切换读写方向，避免总线被其他主机抢占。

## 地址机制

I2C 通过 **7 位地址**区分从机，理论上支持 128 个地址，但其中保留了部分特殊地址（如 0x00 广播地址、0x78\~0x7F 用于 10 位地址扩展），实际可用 **112 个从机地址**。

从机地址由芯片型号决定，部分芯片提供 ADDR 引脚，通过接高/低可改变地址低位，允许同一总线挂多颗相同型号的芯片（例如 ADDR 引脚接 GND 是 0x48，接 VCC 是 0x49）。

## 开漏输出与上拉电阻（重要）

I2C 的 SDA 和 SCL 都使用**开漏（Open-Drain）输出**：设备只能主动拉低总线，不能主动拉高，上拉电阻负责将总线恢复到高电平。

**为什么用开漏而不用推挽？**

1. **线与（Wired-AND）逻辑**：任何一个设备拉低总线，总线就是低电平。ACK 机制和多主仲裁都依赖这个特性。
2. **避免短路**：多个设备同时操作总线时，不会出现一个输出高、另一个输出低导致的电流对冲短路。
3. **电压兼容**：只要上拉电阻接到合适电压，3.3V 和 5V 设备可以共用同一总线（需注意电平兼容性）。

**上拉电阻选取：** 阻值过小功耗大但上升沿快；阻值过大上升沿慢影响速率。标准模式常用 4.7kΩ，高速模式需要更小的上拉电阻（1\~2kΩ）。

## 多主仲裁机制

当多个主机同时发起通信时，I2C 通过**总线仲裁**自动决定谁继续通信：

- 每个主机在发送数据的同时，监测总线实际电平
- 若主机发高电平，但总线实际是低电平（说明另一主机拉低了），该主机**立即停止发送**，退出仲裁
  
- 继续发低电平的主机感知不到任何异常，正常继续通信
- **结果：低电平优先，不会产生数据冲突，且通信不会中断**

**仲裁机制详细说明**：I2C总线采用“线与”逻辑，任何设备都可以拉低总线，但只能释放总线（靠上拉电阻拉高）。主机在发起起始信号前应检测总线空闲状态（SCL和SDA都为高），确保符合起始信号条件。当多个主机同时发起通信时，它们首先都会发送起始信号（START），起始信号时序相同，不会冲突。**仲裁发生在地址和数据传输阶段**。每个主机在发送每一位时都会检测SDA线的实际电平。如果主机尝试发送高电平（释放SDA），但检测到SDA为低电平（说明另一个主机正在发送低电平），则该主机立即知道自己失去仲裁，停止驱动SDA并切换为从机模式，监听获胜主机发送的后续数据。发送低电平的主机不受影响，继续通信。仲裁按位进行，直到只剩一个主机。**如果两个主机发送的地址和数据完全相同，则它们会继续同步传输，直到出现不同位**。低电平优先的仲裁机制确保不会产生数据冲突，且通信不会中断。注意：仲裁只发生在SCL为高电平时，因为此时SDA必须稳定；SCL为低时允许改变SDA，不会触发仲裁。

**总线含义**：I2C总线是共享的通信线路，所有设备的SCL引脚都连接到同一根SCL线上，所有SDA引脚连接到同一根SDA线上，形成公共通信通道。

**仲裁细节澄清**：

1. **多个主机同时发出起始信号**：起始信号完全相同（SCL高时SDA从高变低），不会发生仲裁，所有主机会同步开始。
2. **寻址阶段的仲裁**：在SCL为高时，如果不同主机发送的SDA电平不同（一个发高，一个发低），则发高电平的主机检测到总线实际为低，失去仲裁。
3. **已有主机通信时新主机介入**：起始信号要求SCL为高、SDA从高变低。规范要求主机在发起起始信号前检测总线空闲状态（SCL和SDA都为高）。在旧主机传输过程中，当传输数据位为1（SDA为高）且SCL为高时，新主机可能检测到SCL和SDA都为高并发起起始信号。此时两主机的SCL通过"线与"逻辑同步，仲裁从寻址阶段开始：若地址不同，寻址阶段即决出胜负；若地址相同，仲裁延续到数据阶段，按位比较直到出现不同位（发高电平的主机退出）。

## I2C 优缺点

**优点：**
- 只需两根线，硬件成本低，PCB 走线简单
- 支持多主多从，寻址灵活，一条总线可挂多个设备
- 有 ACK/NACK 应答机制，具备基本的通信确认能力

**缺点：**
- 半双工，速率低于 SPI
- 总线电容限制了挂载设备数量和通信距离（总线电容通常不超过 400pF）
- 软件模拟时序相对 UART 复杂，需要精确控制时序




# SPI 通信

## 基本概念

SPI（Serial Peripheral Interface）是一种**同步、全双工**的串行通信协议，由摩托罗拉公司发明，广泛用于高速外设（Flash、ADC/DAC、显示屏驱动、无线模块等）。

- **四根线**：MOSI（主发从收）、MISO（主收从发）、SCK（时钟）、CS/SS（片选），比 I2C 多线但速率更高
- **主从架构**：只有一个主机，可以有多个从机，主机提供时钟、控制通信节奏
- **全双工**：MOSI 和 MISO 各自独立，可以同时发送和接收数据
- **同步通信**：主机提供 SCK 时钟，收发双方按时钟边沿同步采样
- **无地址机制**：靠 CS（片选）引脚选中目标从机，每个从机需要独立一根 CS 线
- **无应答机制**：主机发完数据不会收到从机确认，与 I2C 的 ACK/NACK 不同

## 信号线说明

| 信号线 | 全称                       | 方向  | 说明                                               |
| ------ | -------------------------- | ----- | -------------------------------------------------- |
| MOSI   | Master Out Slave In        | 主→从 | 主机发送数据，从机接收                             |
| MISO   | Master In Slave Out        | 从→主 | 从机发送数据，主机接收                             |
| SCK    | Serial Clock               | 主→从 | 主机提供时钟，驱动收发双方在同一时钟边沿采样       |
| CS/SS  | Chip Select / Slave Select | 主→从 | 低电平有效，主机拉低选中目标从机；高电平时从机忽略总线 |

**SCK 时钟由谁产生？**

SCK 始终由**主机**产生，方向永远是主→从，从机没有时钟输出能力。SCK 并不是 MCU 的系统时钟，而是由 MCU 内部的 SPI 外设对系统时钟（APB 总线时钟）**分频**后输出的。从机自身即使有晶振，也与 SPI 通信时钟无关——从机只是被动地跟随主机送来的 SCK 边沿采样数据，完全听从主机的节奏。软件模拟 SPI 时，SCK 靠 CPU 手动翻转 GPIO 产生，速率由软件延时决定。

## 工作原理

SPI 通信的核心是**移位寄存器**机制：主机和从机各有一个移位寄存器，两者通过 MOSI 和 MISO 首尾相连，构成一个**环形**结构。

- 主机拉低 CS，选中目标从机
- 主机产生 SCK 时钟，每个时钟周期：MOSI 将主机移位寄存器最高位移出送入从机，同时 MISO 将从机移位寄存器最高位移出送入主机
- 经过 8 个时钟周期后，主机发出了一字节数据，同时也收到了从机的一字节数据——**收发同时完成**
- 传完一帧后，主机拉高 CS 释放从机

**全双工的含义**：每个时钟沿，主从双方各发一位、各收一位，是真正意义上的同时收发。即使主机只想**读数据**，也必须发送（通常发 0x00 或 0xFF 作为"哑字节"）来驱动时钟，从机才能把数据送出来。

**为什么 SPI 必须全双工，而 UART 可以单线单向？**

根本原因在于**时钟的归属不同**。SPI 的 SCK 由主机产生，从机要发数据，必须靠主机的 SCK 来驱动它的移位寄存器移位——没有 SCK 从机根本无法输出数据。而 SCK 一旦产生，就同时推动了主从两侧的移位寄存器，MOSI 和 MISO 上的数据必然同步流动，**收和发在物理上不可分离**，这是 SPI 全双工的硬性约束。

UART 则完全不同：TX 和 RX 两根线**互相独立、没有任何关联**，各自靠自己这一侧的波特率发生器计时，发送方按波特率移出数据，接收方按波特率采样，两者只靠"约定好相同的波特率"来对齐，不存在共享信号。因此 UART 可以只用 TX 单向发送，或只用 RX 单向接收，不需要另一根线的配合。

## 四种工作模式（CPOL 与 CPHA）

SPI 的时序由两个参数决定：

理解这两个参数之前，先明确每个时钟周期内的两个动作：

- 因为是同一个时钟周期内会发出与接收到一个二进制。
- **采样（Latch）**：在某个时钟边沿读取数据线上的电平，锁存为当前位的值

- **移位（Shift）**：在另一个时钟边沿将移位寄存器移位，同时在数据线上**准备好下一位**数据

每个时钟周期有两个跳变沿，一个用来**采样**，另一个用来**移位**，交替进行。

- **CPOL（时钟极性）**：定义 SCK 空闲时的电平，决定了哪个沿是"第一个沿"
  - CPOL = 0：SCK 空闲为**低电平** → 第一个有效边沿是**上升沿**
  - CPOL = 1：SCK 空闲为**高电平** → 第一个有效边沿是**下降沿**

- **CPHA（时钟相位）**：定义采样在哪个边沿发生
  - CPHA = 0：在**第一个**边沿**采样**，在**第二个**边沿**移位**（第一位数据在 CS 拉低时就已准备好）
  - CPHA = 1：在**第一个**边沿**移位**，在**第二个**边沿**采样**（第一位数据在第一个边沿才推出）
  - 同一个周期内一个用来采样，另一个肯定用来移位。不能在同一个边沿进行两种操作，CPU干不过来！

### 以 Mode 0（CPOL=0, CPHA=0）为例

Mode 0 最为常见，以此说明一次完整的通信流程：SCK 空闲低电平，**上升沿采样，下降沿移位**。

```
CS  :  ‾‾‾|___________________________|‾‾‾

SCK :  ____|‾|_|‾|_|‾|_|‾|_|‾|_|‾|_|‾|_|____
            ↑ ↓ ↑ ↓ ↑ ↓ ↑ ↓ ↑ ↓ ↑ ↓ ↑ ↓ ↑ ↓
           采 移 采 移 采 移 采 移 ...（采=采样，移=移位换下一位）

MOSI:  ____[b7  |b6  |b5  |b4  |b3  |b2  |b1  |b0]____
            ↑CS↓时准备好b7，每个↓沿换下一位

MISO:  ____[b7  |b6  |b5  |b4  |b3  |b2  |b1  |b0]____
            ↑从机CS↓时准备好b7，主机在每个↑沿采样
```

完整流程：
1. **CS 拉低** → 从机被选中，主机与从机立即将各自要发的字节最高位（b7）放到 MOSI / MISO 上，等待第一个时钟沿
2. **SCK 第一个上升沿** → 双方同时**采样**：主机读 MISO 上的 b7，从机读 MOSI 上的 b7
3. **SCK 下降沿** → 双方同时**移位**：各自将下一位（b6）放到数据线上
4. 重复步骤 2~3，经过 **8 个上升沿**，1 字节收发同时完成
5. **CS 拉高** → 通信结束，从机释放 MISO（回到高阻态）

### 四种模式对照

| 模式   | CPOL | CPHA | SCK 空闲 | 采样边沿        | 移位边沿        | 常见应用                 |
| ------ | ---- | ---- | -------- | --------------- | --------------- | ------------------------ |
| Mode 0 | 0    | 0    | 低       | 上升沿（第1沿） | 下降沿（第2沿） | **最常用**，Flash、SD 卡 |
| Mode 1 | 0    | 1    | 低       | 下降沿（第2沿） | 上升沿（第1沿） | 部分 ADC                 |
| Mode 2 | 1    | 0    | 高       | 下降沿（第1沿） | 上升沿（第2沿） | -                        |
| Mode 3 | 1    | 1    | 高       | 上升沿（第2沿） | 下降沿（第1沿） | 部分 ADC                 |

> Mode 0 和 Mode 3 的采样边沿都是上升沿，Mode 1 和 Mode 2 的采样边沿都是下降沿。两对模式是"镜像"关系，区别只是 SCK 空闲极性相反。

**主从双方必须使用相同的模式**，否则采样错位导致数据错误。实际使用时查从机芯片手册确认它支持哪种模式，主机配置成一致即可。

## 多从机管理

SPI 没有地址机制，多从机时靠 **CS 引脚**区分。

### 独立片选（最常用）

**每个从机占用主机一根独立 GPIO 作为 CS**，主机同一时刻只拉低一根 CS，其余从机 CS 保持高电平、忽略总线：

```
主机 CS0 ──→ 从机1
主机 CS1 ──→ 从机2
主机 CS2 ──→ 从机3
（MOSI / MISO / SCK 三根总线所有从机共享）
```

**代价**：每增加一个从机就需要一根额外的 CS 引脚，从机数量多时主机引脚压力大。这是 SPI 相比 I2C 的主要缺点之一。

## CS 片选时序

- **CS 拉低（选中）**：从机进入工作状态，MISO 引脚从高阻态（三态）切换为输出，开始响应 SCK 和 MOSI
- **CS 拉高（释放）**：从机忽略总线，MISO 重新进入**高阻态**，不影响其他从机使用总线
- 部分从机要求 CS 拉低后需等待一段建立时间才能开始 SCK；每次片选结束后也需要保持 CS 高电平一段时间才能发起下一次通信——具体时序参考芯片手册

**高阻态的意义**：多个从机共用 MISO 线，未被选中的从机 MISO 必须处于高阻（相当于断开连接），否则多个输出同时驱动同一根线会产生冲突。

### 为什么只有MISO需要高阻态？

| 维度 | MOSI（主→从） | MISO（从→主） | 理论依据 |
|------|---------------|---------------|----------|
| **信号方向** | 主机→从机（单向） | 从机→主机（单向） | SPI全双工但方向固定 |
| **驱动源** | **唯一主机**驱动 | **多个从机**可能驱动 | 一主多从架构 |
| **多从机竞争** | ❌ 无竞争（主机独占） | ✅ 有竞争（多从机共享） | 总线共享拓扑 |
| **CS释放后** | 从机MOSI保持输入态 | 未选中从机MISO**必须高阻** | 避免总线冲突 |

**核心理论要点：**
1. **MOSI无竞争**：主机是MOSI线的**唯一驱动源**，所有从机MOSI引脚仅为输入，不存在多个驱动源竞争。
2. **MISO有竞争**：多个从机共享同一根MISO线，若未被选中的从机不进入高阻态，会导致：
   - 多个输出同时驱动同一根线
   - 逻辑电平冲突（一个拉高、一个拉低 → 短路风险）
   - 主机无法正确识别数据来源
3. **高阻态 = 电气隔离**：相当于从物理上"断开"未被选中从机与MISO总线的连接，确保**点对点**通信。

**面试回答要点：**
"SPI一主多从时，MISO需要高阻态而MOSI不需要，因为MOSI由主机单向驱动，无竞争；而MISO被多个从机共享，为避免多个输出同时驱动同一根线导致总线冲突，未被选中的从机必须将MISO置为高阻态。"

## 硬件 SPI vs 软件 SPI

| 对比项     | 硬件 SPI                           | 软件 SPI（Bit-bang）              |
| ---------- | ---------------------------------- | --------------------------------- |
| 实现方式   | MCU 内置 SPI 外设，自动处理时序    | CPU 手动控制 4 根 GPIO 翻转       |
| CPU 占用   | 低（中断 / DMA，传输期间 CPU 空闲）| 高（传输期间 CPU 忙等）           |
| 速率       | 高（可达主频的 1/2）               | 低，受 CPU 速度和中断延迟限制     |
| 引脚灵活性 | 只能用固定的复用引脚               | 任意 GPIO 均可                    |
| 适用场景   | 正式产品、高速传输（Flash、屏幕）  | 硬件 SPI 不足时的临时补充、低速场合 |

## SPI 优缺点

**优点：**
- 全双工，速率高，可达数十甚至数百 Mbps
- 时序简单，无起始/停止位，没有地址开销
- 数据帧长度灵活，不限于 8 位，支持连续数据流
- 从机硬件实现极简，只需移位寄存器

**缺点：**
- 需要 4 根线，多从机时每个从机额外占用一根 CS，引脚消耗大
- 无应答机制，主机无法确认从机是否正确接收
- 只支持一主多从，不支持多主（与 I2C 不同）
- 传输距离短，通常只用于板级通信

## SPI vs I2C 选型参考

| 对比项     | SPI                              | I2C                                |
| ---------- | -------------------------------- | ---------------------------------- |
| 线数       | 4 线（+每从机 1 根 CS）          | 2 线                               |
| 速率       | 高（可达数十 / 百 Mbps）         | 较低（标准 100k，快速 400k，高速 3.4M）|
| 双工模式   | **全双工**                       | 半双工                             |
| 从机选择   | CS 片选引脚（硬件选择）          | 7 / 10 位地址（软件寻址）          |
| 应答机制   | 无                               | 有 ACK / NACK                      |
| 多主支持   | 不支持                           | 支持                               |
| 适用场景   | 高速外设（Flash、屏幕、无线模块）| 低速传感器、EEPROM、配置总线       |

> **选型口诀**：要速度选 SPI，要省线选 I2C，要长距离选 RS485。

# CAN通信

## 基本概念

CAN（Controller Area Network）是一种**多主、差分串行通信协议**，最初由博世公司为汽车电子系统设计，现已广泛应用于工业控制、医疗设备等领域。

- **多主架构**：任何节点都可以主动发起通信，通过仲裁机制避免冲突
- **差分信号**：使用 CAN_H 和 CAN_L 两根线，抗干扰能力强，适合电磁环境恶劣的场合
- **非破坏性仲裁**：优先级高的报文自动胜出，失败节点稍后重试，无数据损坏
- **强大的错误检测**：内置 CRC、ACK、位填充等多种校验机制，可靠性极高
- **广播通信**：所有节点都能收到同一报文，靠标识符（ID）区分报文含义

## 物理层

CAN 物理层采用 **ISO 11898** 标准，使用双绞线传输差分信号：

| 逻辑 | CAN_H 电压 | CAN_L 电压 | 差分电压（CAN_H - CAN_L） |
|------|------------|------------|---------------------------|
| 显性（0） | 3.5 V      | 1.5 V      | +2 V                     |
| 隐性（1） | 2.5 V      | 2.5 V      | 0 V                      |

**显性电平（0）** 优先级高于**隐性电平（1）**，这是仲裁机制的基础。

**终端电阻**：总线两端需各接一个 **120 Ω** 电阻，消除信号反射，保证信号完整性。

## 帧类型

CAN 定义了四种帧类型：

| 帧类型 | 用途 |
|--------|------|
| **数据帧** | 携带实际数据，最常见 |
| **远程帧** | 请求其他节点发送指定 ID 的数据帧 |
| **错误帧** | 节点检测到错误时主动发出，通知全网 |
| **过载帧** | 节点处理不过来时请求延迟下一帧 |

## 数据帧结构（标准帧，11 位 ID）

标准帧共 **108 位**，包含以下域：

```
帧起始 → 仲裁域 → 控制域 → 数据域 → CRC域 → ACK域 → 帧结束
```

| 域 | 位宽 | 说明 |
|----|------|------|
| **帧起始（SOF）** | 1 | 显性电平（0），同步所有节点 |
| **仲裁域** | 12 | 11 位 ID + 1 位 RTR（远程传输请求，数据帧为 0） |
| **控制域** | 6 | IDE（标准帧为 0）、保留位 r0、4 位数据长度码（DLC，0~8） |
| **数据域** | 0~64 | 实际数据，长度由 DLC 指定 |
| **CRC域** | 16 | 15 位 CRC + 1 位 CRC 界定符（隐性 1） |
| **ACK域** | 2 | ACK 槽（发送方发隐性 1，接收方正确接收后改为显性 0） + ACK 界定符（隐性 1） |
| **帧结束（EOF）** | 7 | 连续 7 个隐性 1 |

**扩展帧（29 位 ID）** 在标准帧基础上增加 18 位扩展 ID，仲裁域和控制域结构略有不同。

## 非破坏性仲裁

CAN 的仲裁发生在**仲裁域**，所有节点同时发送 ID，并监控总线实际电平：

- 节点发送 **隐性（1）** 但读到 **显性（0）** 时，立即知道自己优先级较低，**停止发送**，转为接收模式
- 发送 **显性（0）** 的节点不受影响，继续完成报文传输
- **结果**：ID 值越小（二进制），优先级越高；仲裁失败的节点待总线空闲后自动重试

这种机制保证了高优先级报文及时发送，且无数据冲突或丢失。

## 错误检测与处理

CAN 设计了五层错误检测机制：

1. **CRC 校验**：15 位 CRC，覆盖帧起始到数据域
2. **ACK 应答**：至少一个正确接收的节点在 ACK 槽回显显性电平
3. **位填充**：连续 5 个相同极性位后插入一个反向位，防止同步丢失；接收方检查填充规则
4. **帧格式检查**：固定域（CRC 界定符、ACK 界定符、帧结束等）必须为预期值
5. **总线监控**：节点发送时同时读回总线电平，比对是否一致

每个节点维护两个错误计数器：**发送错误计数器（TEC）** 和 **接收错误计数器（REC）**。根据计数值，节点处于三种状态：

| 状态 | TEC/REC 范围 | 行为 |
|------|--------------|------|
| **主动错误** | 0~127 | 正常收发，检测到错误时发送主动错误帧 |
| **被动错误** | 128~255 | 仍可收发，但错误帧改为被动错误帧（连续 6 个隐性 1） |
| **离线** | TEC > 255 | 脱离总线，需重启恢复 |

## CAN FD（Flexible Data‑rate）

CAN FD 在经典 CAN 基础上改进：

- **更高的速率**：仲裁阶段仍用原波特率，数据阶段可切换到更高波特率（最高 8 Mbps）
- **更大的数据域**：DLC 支持 0~64 字节（经典 CAN 仅 0~8 字节）
- **保持与经典 CAN 的兼容性**：CAN FD 帧使用保留位标识，经典 CAN 节点会将其视为错误帧

## CAN 与其他串行协议对比

| 对比项 | CAN | UART | I2C | SPI |
|--------|-----|------|-----|-----|
| 线数 | 2（差分） | 2（TX/RX） | 2（SDA/SCL） | 4（MOSI/MISO/SCK/CS） |
| 拓扑 | 多主，总线型 | 点对点 | 多主多从，总线型 | 一主多从，总线型 |
| 最大速率 | 1 Mbps（经典 CAN）<br>8 Mbps（CAN FD） | 数 Mbps | 3.4 Mbps | 数十 Mbps |
| 错误检测 | CRC、ACK、位填充 | 可选奇偶校验 | ACK/NACK | 无 |
| 仲裁机制 | 非破坏性（ID 优先级） | 无（靠波特率同步） | 线与（低电平优先） | 无（靠 CS 片选） |
| 典型应用 | 汽车网络、工业控制 | 调试、设备间通信 | 传感器、EEPROM | Flash、显示屏 |

# 在SDK中的体现
