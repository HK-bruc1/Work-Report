# 嵌入式C语言笔试真题分类整理

# 一、C语言基础

## 1.1 数据类型与变量

### 1.1.1 结构体内存对齐 【选择题】

> **考点**：结构体大小计算、内存对齐规则（对齐到最大成员大小的整数倍）
> **注意**：`short` 2字节、`char` 1字节、`float` 4字节，对齐后可能有填充字节

设 `struct{ short a; char b; float c; } cs;` 则 `sizeof(cs)` 的值是（  ）

- **A.** 4
- **B.** 5
- **C.** 6
- **D.** 7

------

无论32位还是64位，大小固定：

| 类型        | 大小   |
| ----------- | ------ |
| `char`      | 1 字节 |
| `short`     | 2 字节 |
| `int`       | 4 字节 |
| `long long` | 8 字节 |
| `float`     | 4 字节 |
| `double`    | 8 字节 |

32位 vs 64位 有区别的：

| 类型   | 32位   | 64位                   |
| ------ | ------ | ---------------------- |
| `long` | 4 字节 | 8 字节（Windows仍为4） |
| 指针   | 4 字节 | 8 字节                 |

简单记：**只有 `long` 和指针会变**，其余都固定。

#### 内存大小对齐口诀

结构体不是简单地将成员大小相加，编译器会进行**内存对齐（alignment）**：

1. **成员对齐**：每个成员的起始地址必须是其自身大小的整数倍
2. **结构体总大小**：必须是最大成员大小的整数倍（用于数组时保证每个元素对齐）

```c
最大成员：int = 4字节

char a;  // size=1，offset=0，offnext=0+1=1
int  b;  // size=4，offset=4（填充3字节，4-1=3），offnext=4+4=8
char c;  // size=1，offset=8，offnext=8+1=9

原始大小=9，向上取整到4的倍数，填充3字节 → 总大小=12
```

- 实在忘记了就画内存占用格子示意图


---

### 1.1.2 左值和右值的区别 【问答题】

> **考点**：左值（可被赋值、有明确内存地址的表达式）与右值（临时值、不可取地址）的概念
> **注意**：赋值号左边必须是左值；常量、表达式结果通常是右值

请解释左值和右值的区别。

<details><summary>💡 答案提示</summary>
<ul>
<li><b>左值（lvalue）</b>：有确定内存地址、可出现在赋值运算符左边的表达式。如变量 <code>x</code>、数组元素 <code>a[0]</code>、解引用 <code>*p</code></li>
<li><b>右值（rvalue）</b>：没有持久地址的临时值，只能出现在赋值运算符右边。如字面量 <code>10</code>、表达式 <code>a+b</code>、函数返回值</li>
</ul>
</details>


---

### 1.1.3 浅拷贝与深拷贝的区别 【问答题】

> **考点**：值拷贝 vs 内容拷贝，指针成员的处理方式
> **注意**：浅拷贝仅复制指针值，两个对象共享同一块内存；深拷贝会重新分配内存空间并复制内容

请解释浅拷贝与深拷贝的区别。

<details><summary>💡 答案提示</summary>
<ul>
<li><b>浅拷贝</b>：逐字节复制，指针成员只复制地址值 → 两个对象指向<b>同一块内存</b>，一方修改内容会影响另一方</li>
<li><b>深拷贝</b>：为指针成员<b>重新分配内存</b>并复制内容 → 两个对象完全独立</li>
</ul>
</details>


---

### 1.1.4 字符串赋值方式判断 【选择题】

> **考点**：字符数组初始化与赋值的合法方式
> **注意**：数组名是常量地址，不能用 `=` 直接赋值字符串；`strcpy` 和逐字符初始化是合法的；字符串是末尾带 `\0` 的字符数组，指定长度的初始化会自动补 `\0`，不指定长度则不会

以下对字符数组 `test` 赋值方式**错误**的是（  ）

- **A.** `char test[10]; strcpy(test, "test");`
- **B.** `char test[10]; test = "test";`
- **C.** `char test[] = {'t','e','s','t'};`
- **D.** `char test[10] = {'t','e','s','t'};`

------

```c
数组名 test 是常量地址，不可用 = 赋值。只有在声明时才能用 = 初始化，声明后赋值必须用 strcpy。
另外注意 C 选项 char test[] = {'t','e','s','t'} 长度由内容决定为4，没有 \0，是字符数组而非字符串；D 选项 char test[10] 剩余位置自动补 \0，是合法字符串。
    
字符数组不一定是字符串（没有 \0 就不是）
字符串一定是字符数组
    
声明时可以用 = 初始化：
char test[10] = "test";   // 合法，声明时初始化
char test[] = "test";     // 合法，声明时初始化
声明后不能用 = 赋值，只能用 strcpy
char test[10];
test = "test";            // 非法，数组名是常量地址
strcpy(test, "test");     // 合法    
```


---

### 1.1.5 二维数组的初始化方式判断 【选择题】

> **考点**：二维数组初始化语法——花括号嵌套 vs 逗号表达式、行列匹配
> **注意**：`(0,1,2)` 是逗号表达式而非花括号初始化；行数不能超过声明；元素不足自动补0；行数可以省略由编译器推导，但列数必须显式指定；元素总数不能超过声明大小

以下二维数组初始化方式正确的是（  ）

- **A.** `int a[2][3] = ((0,1,2),(3,4,5));` — 圆括号是逗号表达式，非法
- **B.** `int a[2][3] = {{0,1,2},{3,4,5}};` — 标准写法
- **C.** `int a[2][3] = {{0,1},{2,3},{4,5}};` — 3行但只声明了2行，非法
- **D.** `int a[2][3] = {0,1,2,3,4};` — 线性初始化，合法（不足补0）
- **E**. `int a[][3] = {{0,1,2},{3,4,5}};` — 行数省略，由编译器推导为2，合法
- **F**. `int a[2][] = {{0,1,2},{3,4,5}};` — 列数省略，非法
- **G**. `int a[2][3] = {{0,1}};` — 部分初始化，不足补0，合法
- **H**. `int a[2][3] = {0,1,2,3,4,5,6};` — 元素超出总大小6，非法

<details><summary>💡 答案提示</summary>
<p><b>答案：B、D、E、G</b></p>
<ul>
<li>A 错在用了圆括号 <code>()</code>，逗号表达式 <code>(0,1,2)</code> 的值只是 <code>2</code></li>
<li>C 错在花括号内有3组，但行数声明为2</li>
<li>F 错在列数省略，列数必须显式指定</li>
<li>H 错在元素总数7超出声明大小2×3=6</li>
<li>E 合法，行数由编译器自动推导为2</li>
<li>G 合法，不足的元素自动补0</li>
</ul>
</details>


---

### 1.1.6 sizeof 与 strlen 的区别 【问答题】

> **考点**：`sizeof` 是运算符（编译期）、`strlen` 是库函数（运行期）；`sizeof` 包含 `\0`，`strlen` 不包含
> **注意**：`sizeof` 对数组名返回整个数组的总字节大小，对指针返回指针本身大小（4/8字节），这是常见陷阱

简述 `sizeof` 和 `strlen` 的区别。

<details><summary>💡 答案提示</summary>
<table>
<tr><th>区别</th><th><code>sizeof</code></th><th><code>strlen</code></th></tr>
<tr><td>性质</td><td><b>运算符</b>，编译期求值</td><td><b>库函数</b>（<code>&lt;string.h&gt;</code>），运行期求值</td></tr>
<tr><td><code>\0</code></td><td><b>包含</b> <code>\0</code></td><td><b>不包含</b> <code>\0</code></td></tr>
<tr><td>计算对象</td><td>任意类型占用的<b>内存字节数</b></td><td>字符串的<b>有效字符个数</b></td></tr>
<tr><td>参数</td><td>类型或变量</td><td>必须是 <code>char*</code>（以<code>\0</code>结尾）</td></tr>
</table>
<pre><code>char str[] = "hello";
sizeof(str);  // 6（含'\0'）
strlen(str);  // 5（不含'\0'）</code></pre>
<p><b>注意点：</b></p>
<ul>
<li><b>指针 vs 数组</b>：<code>sizeof(p)</code> 得到的是指针本身大小（4或8），不是字符串长度；<code>strlen(p)</code> 正常工作</li>
<li><b>数组退化</b>：数组作为参数传入函数后退化为指针，函数内 <code>sizeof(arr)</code> 只能得到指针大小，不是数组大小</li>
<li><b>没有 <code>\0</code> 时</b>：<code>strlen</code> 会一直往后找直到遇到 <code>\0</code>，造成越界，未定义行为</li>
<li><b><code>strlen</code> 返回值是 <code>size_t</code>（无符号）</b>：做减法时需谨慎。无符号整数遵循<b>环形模运算</b>：
  <ul>
    <li>32位下，无符号数范围是 <code>0 ~ 2^32-1</code>，结果超出范围就对 <code>2^32</code> 取模</li>
    <li>可以理解为一个<b>环形数轴</b>，从0减到头不会变负，而是从最大值那端绕回来，如 <code>0 - 1 = 4294967295</code></li>
    <li>因此 <code>strlen(str) - 10</code> 在结果"应为负"时会变成很大的正数（如 <code>2 - 10 = 4294967288</code>），导致条件判断出错</li>
    <li>这种现象叫<b>整数下溢（underflow）</b>，与之对应的超出最大值叫<b>整数上溢（overflow）</b></li>
    <li>建议改用 <code>></code> 直接比较或强制转换为 <code>int</code>：
      <pre><code>if (strlen(str) > 10) { }         // 推荐
if ((int)strlen(str) - 10 > 0) { } // 或强制转换</code></pre>
    </li>
  </ul>
</li>
</ul>
</details>


---

## 1.2 指针

### 1.2.1 数组指针 vs 指针数组 【问答题】

> **考点**：`int (*p)[5]` 是指向数组的指针，`int *p[5]` 是指针数组——括号位置决定含义
> **注意**：看 `*` 先和谁结合：`(*p)` 先和括号结合，p是指针；`*p[]` 先和 `[]` 结合，p是数组；数组指针必须用 `&数组名` 赋值；解引用要加括号 `(*p)[i]`；可用于指向二维数组的行；两者 `sizeof` 结果完全不同

```c
int a[5];
int (*p)[5] = &a;   // 指向数组的指针
int *q[5];           // 指针数组（5个int指针组成的数组）
```

写出自己定义的数组指针和指针数组。

💡 **答案提示**

| 区别     | 数组指针 `int (*p)[5]`              | 指针数组 `int *p[5]`         |
| -------- | ----------------------------------- | ---------------------------- |
| 本质     | 一个**指针**，指向长度为5的int数组  | 一个**数组**，含5个int指针   |
| 赋值     | 必须用 `&a`，不能用 `a`（一维数组） | 每个元素单独赋值             |
| 解引用   | `(*p)[i]`，括号不能省               | `*p[i]`，取第i个指针指向的值 |
| sizeof   | 4或8（只是一个指针）                | 20或40（5个指针的数组）      |
| 使用场景 | 指向二维数组的行                    | 存储多个指针，如字符串数组   |

**注意点：**

- **赋值方式**：数组指针必须用 `&a`，`a` 是 `int*`，`&a` 才是 `int(*)[5]`
- **解引用**：`(*p)[0]` 才正确，`*p[0]` 因优先级问题等价于 `*(p[0])`，含义完全不同
- **指向二维数组**：`int (*p)[5] = a` 可指向二维数组第一行，`p++` 会跨越一整行（5个int）
- **口诀**：看 `*` 先和谁结合——`(*p)` 先和括号结合，p是指针；`*p[]` 先和 `[]` 结合，p是数组

**示例：**

`int a[3][5];` 声明二维数组，`int (*p)[5] = a;` 指向第一行，`(*p)[0]` 正确解引用，`p++` 跨越一整行。

`int *q[5];` 声明指针数组，`int x = 10; q[0] = &x;` 每个元素单独赋值，`*q[0]` 取第0个指针指向的值即10。

---

### 1.2.2 使用代码声明各类指针与数组 【编程题】

> **考点**：综合考察指针、数组、函数指针等声明语法
> **注意**：熟练区分变量、变量指针、数组、指针数组、数组指针、函数指针

使用代码声明以下各类型（每种至少一个示例，并用注释标注类型名称）：

1. 普通变量
2. 指针变量（变量指针）
3. 数组
4. 指针数组（元素为指针的数组）
5. 数组指针（指向数组的指针）
6. 函数指针

```c
// 用于演示函数指针的函数
int add(int a, int b) {
    return a + b;
}

int main() {

    // 1. 普通变量
    int var = 42;

    // 2. 指针变量（变量指针）—— 存储变量的地址 声明的同时初始化
    int *ptr = &var;

    // 3. 数组 —— 连续存储同类型元素
    int arr[5] = {1, 2, 3, 4, 5};

    // 4. 指针数组 —— 数组的每个元素都是指针
    int *ptr_arr[5] = {&arr[0], &arr[1], &arr[2], &arr[3], &arr[4]};

    // 5. 数组指针 —— 指向整个数组的指针（步长为数组长度）
    int (*arr_ptr)[5] = &arr;

    // 6. 函数指针 —— 指向函数的指针
    int (*func_ptr)(int, int) = &add;
```

**核心记忆口诀**

| 类型     | 声明形式         | 记忆方式                           |
| -------- | ---------------- | ---------------------------------- |
| 指针变量 | `int *p`         | `*`靠近变量名                      |
| 指针数组 | `int *p[n]`      | `[]`优先级高，先是数组，元素是指针 |
| 数组指针 | `int (*p)[n]`    | `()`强制先结合，先是指针，指向数组 |
| 函数指针 | `int (*p)(参数)` | `()`强制先结合，先是指针，指向函数 |

区分指针数组和数组指针的关键就是**括号优先级**：有括号包住 `*p` 就先看指针，没有就先看右边的 `[]`。

#### 注意事项

##### **指针数组 vs 数组指针 —— 解引用方式不同**

```c
int arr[5] = {1, 2, 3, 4, 5};

int *ptr_arr[5];       // 指针数组
ptr_arr[2];            // 得到一个 int*
*ptr_arr[2];           // 才得到 int 值

int (*arr_ptr)[5] = &arr;  // 数组指针
arr_ptr;               // 得到一个 (*)[5]
(*arr_ptr)[2];         // 才得到 int 值，必须先解引用
arr_ptr[0][2];         // 等价写法
```

##### `&arr` vs `arr` —— 值相同但类型不同

```c
int arr[5] = {1, 2, 3, 4, 5};

printf("%p\n", arr);       // 数组首元素地址，类型 int*
printf("%p\n", &arr);      // 整个数组的地址，类型 int(*)[5]

// 值打印出来一样，但步长不同！
printf("%p\n", arr + 1);   // +4字节（跳一个int）
printf("%p\n", &arr + 1);  // +20字节（跳整个数组）
```

##### 函数指针赋值 —— 取地址符可省略但建议统一

```c
int (*func_ptr)(int, int) = &add;  // 显式取地址（推荐，意图清晰）
int (*func_ptr)(int, int) = add;   // 也合法，函数名自动退化为指针

// 调用时同理
func_ptr(3, 4);     // 推荐
(*func_ptr)(3, 4);  // 也合法
```

##### 指针数组指针 —— 指向指针数组的指针

- 后面为主，那就是指向指针数组的指针简单来看就是数组指针！
- [数组指针赋值方式](###1.2.1 数组指针 vs 指针数组 【问答题】)

```c
int *ptr_arr[5];          // 指针数组
int *(*p)[5] = &ptr_arr;  // 指向该指针数组的指针

// 读法：去掉变量名 p，剩下 int*(*)[5]
// 先看 (*) → 是指针，指向 int*[5] → 元素为int*的数组
```

##### const 位置不同含义完全不同

```c
int a = 1, b = 2;

const int *p = &a;   // 指向常量的指针：不能改 *p，但能改 p 的指向
int * const p = &a;  // 常量指针：    能改 *p，但不能改 p 的指向
const int * const p = &a; // 两者都不能改
```

- 记忆技巧：`const` 在 `*` **左边**，保护**值**；在 `*` **右边**，保护**地址**。

##### 数组名作函数参数会退化为指针

```c
void func(int arr[5])  { }  // 实际等价于 👇
void func(int *arr)    { }  // 编译器自动退化，sizeof(arr) = 8（指针大小）

// 若想传数组指针保留维度信息：
void func(int (*arr)[5]) { }  // sizeof(*arr) = 20（数组实际大小）
```



### 1.2.3 指针步长与地址计算 【选择题】

> **考点**：指针类型决定步长——`int*` 步长为4字节，`char*` 步长为1字节
> **注意**：`char` 数组强转为 `int*` 后，`p[1]` 偏移4字节而非1字节

假如 `test` 数组的起始地址为 `0x12345678`，则表达式 `test_p[1]` 的指针地址值是多少？（  ）

```c
char test[8] = { 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08 };
int *test_p = (int *)test;
```

- **A.** 0x12345678
- **B.** 0x1234567C
- **C.** 0x12345679
- **D.** 0x1234567A

------

💡 **答案提示**

**答案：B**

`test_p` 是 `int*`，步长为 `sizeof(int)` = 4 字节。`test_p[1]` = `test_p + 1` = `0x12345678 + 4` = **`0x1234567C`**

---

**⚠️ 注意点一：步长由指针类型决定，与数组原始类型无关**

```c
char  *cp = test;         cp[1];  // 偏移 1字节 → 0x12345679  （选项C的陷阱）
int   *ip = (int*)test;   ip[1];  // 偏移 4字节 → 0x1234567C  ✅
short *sp = (short*)test; sp[1];  // 偏移 2字节 → 0x1234567A  （选项D的陷阱）
```

**⚠️ 注意点二：题目问的是地址，不是值**

```c
test_p[1] 的地址 = 0x1234567C          ← 题目问这个
*(test_p + 1)    = 0x08070605（小端）   ← 这是值，不是题目问的
```

**⚠️ 注意点三：大小端影响值，不影响地址**

```
内存布局：01 02 03 04 | 05 06 07 08
       test_p[0]  | test_p[1]

小端(x86)：test_p[1] 的值 = 0x08070605
大端：     test_p[1] 的值 = 0x05060708
但 test_p[1] 的地址永远是 0x1234567C，与大小端无关
```

**⚠️ 注意点四：强转后越界风险**

```c
test_p[0];  // 访问字节[0~3] ✅
test_p[1];  // 访问字节[4~7] ✅
test_p[2];  // 访问字节[8~11] ❌ 越界！未定义行为
```

`char[8]` 强转为 `int*` 后，只能合法访问下标 `[0]` 和 `[1]`。

---

**选项陷阱对照**

| 选项                  | 地址值             | 陷阱原因               |
| --------------------- | ------------------ | ---------------------- |
| A. `0x12345678`       | `test_p[0]` 的地址 | 误以为下标不偏移       |
| **B. `0x1234567C` ✅** | 正确答案           | +1 × 4字节             |
| C. `0x12345679`       | `char*` 步长偏移1  | 忘记强转改变了步长     |
| D. `0x1234567A`       | `short*` 步长偏移2 | 混淆成 `short*` 的步长 |

### 1.2.4 数组名与指针运算 【选择题】

> **考点**：数组名作为地址常量不可自增；`*a` 等价于 `a[0]`
> **注意**：`a++` 非法，因为数组名不是可修改的左值

数组定义为 `int a[4];`，表达式（  ）是错误的。

- **A.** `*a`
- **B.** `a[0]`
- **C.** `a`
- **D.** `a++`


---

💡 答案提示 

答案：D 数组名 `a` 是地址常量（不可修改的左值），不能执行 `++` 运算。

**⚠️ 注意点一：数组名是常量，但指针变量可以自增**

```c
int a[4] = {1, 2, 3, 4};
int *p = a;

a++;  // ❌ 非法，a 是地址常量
p++;  // ✅ 合法，p 是指针变量，可修改
```

> 两者都能用 `*` 解引用，但只有指针变量能自增，这是最常见的混淆点。

------

**⚠️ 注意点二：`*a`、`a[0]`、`*(a+0)` 三者完全等价**

```c
*a        // 解引用首地址 → a[0] 的值
a[0]      // 下标访问    → 同上
*(a + 0)  // 指针偏移    → 同上

// 同理：
*(a + 1) == a[1]
*(a + 2) == a[2]
```

------

**⚠️ 注意点三：`a` 与 `&a` 值相同但类型不同（同上一题）**

```c
int a[4];

a     // 类型 int*，指向首元素
&a    // 类型 int(*)[4]，指向整个数组

a + 1    // 偏移 4字节（跳一个int）
&a + 1   // 偏移 16字节（跳整个数组）
```

------

**⚠️ 注意点四：`sizeof(a)` 与 `sizeof(p)` 不同**

```c
int a[4];
int *p = a;

sizeof(a);  // 16字节（整个数组大小）
sizeof(p);  // 8字节（指针本身大小，64位系统）
```

> 数组名传入函数后会退化为指针，此时 `sizeof` 就只返回指针大小了，这是另一个高频陷阱。

### 1.2.5 指针偏移与数组元素访问 【分析题】

> **考点**：指针 `p` 指向 `a[5]`，`p[7]` 等价于 `*(p+7)` 即 `a[12]`
> **注意**：指针下标运算基于指针当前位置，而非数组起始位置

下面程序中 `b` 的值是（  ）

```c
int a[15] = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};
int *p = &a[5];
int b = p[7];
```


---

💡 答案提示 

答案：13 `p` 指向 `a[5]`，`p[7]` = `*(p+7)` = `a[5+7]` = `a[12]` = 13

**⚠️ 注意点一：`p = &a[5]` 与 `p = a+5` 完全等价**

```c
int *p = &a[5];  // 两种写法
int *p = a + 5;  // 完全等价

// 同理：
&a[i] == a + i
 a[i] == *(a + i)
```

------

**⚠️ 注意点二：负下标合法，只要不越界**

```c
int *p = &a[5];

p[-1];  // = *(p-1) = a[4] = 5  ✅ 合法
p[-5];  // = *(p-5) = a[0] = 1  ✅ 合法
p[-6];  // ❌ 越界！未定义行为
```

> `p[7]` 让人直觉上以为从数组头开始数第7个，实际是**从p当前位置**偏移7，负下标同理。

------

**⚠️ 注意点三：容易数错下标**

```c
// a 数组下标与值的对应关系：
// 下标： 0  1  2  3  4  5  6  7  8  9  10 11 12 13 14
// 值：   1  2  3  4  5  6  7  8  9  10 11 12 13 14 15

int *p = &a[5];  // p 指向值为 6 的元素，不是值为 5！
```

> `a[5]` 是第6个元素（值为6），下标从0开始，这是最常见的数错原因。

------

**⚠️ 注意点四：越界访问不报错但是未定义行为**

```c
int *p = &a[5];

p[9];   // = a[14] = 15  ✅ 刚好在边界内
p[10];  // = a[15] ❌ 越界！编译不报错，但结果不可预期
```

> C语言不做边界检查，越界访问能编译通过，结果取决于那块内存存了什么。

### 1.2.6 指向整个数组的指针运算 【分析题】

> **考点**：`&数组名` 的类型是 `T (*)[N]`（指向整个数组的指针），+1 跳过整个数组（N×sizeof(T) 字节）；而 `数组名` 类型是 `T*`，+1 仅跳过一个元素
> **注意**：这类题的核心是搞清楚指针 +1 到底移动多少字节——取决于指针所指类型的大小

```c
int32_t var[7] = {2, 4, 6, 8, 10, 12, 14};
int32_t *var_ptr = (int32_t *)(&var + 1);
*(var_ptr - 1) = *(var + 1);
```

上述代码执行后，`var` 数组的值是什么？

<details><summary>💡 答案提示</summary>
<ul>
<li><code>&var + 1</code> 跳过整个数组（7 × 4 = 28字节），指向数组末尾之后</li>
<li><code>var_ptr - 1</code> 回退一个 <code>int32_t</code>（4字节），即指向 <code>var[6]</code></li>
<li><code>*(var + 1)</code> = <code>var[1]</code> = 4</li>
<li>最终 <code>var[6]</code> 从 14 变为 4</li>
</ul>
<p><b>结果：</b><code>{2, 4, 6, 8, 10, 12, 4}</code></p>
</details>
**⚠️ 注意点一：`&var + 1` 指向数组末尾之后，不是最后一个元素**

```c
int32_t var[7] = {2, 4, 6, 8, 10, 12, 14};

// 内存示意：
// [0] [1] [2] [3] [4] [5] [6] | 越界区域
//  2   4   6   8  10  12  14  ↑
//                           &var+1 指向这里（合法指针，但不可解引用）

&var + 1   // 指向 var[7]，越过整个数组
var + 1    // 指向 var[1]，仅越过一个元素
```

> `&var + 1` 作为地址值是合法的（C标准允许指向数组末尾后一位），但对其解引用是未定义行为。

------

**⚠️ 注意点二：强转是关键，没有强转就无法做指针算术**

```c
int32_t *var_ptr = (int32_t *)(&var + 1);
//                 ↑ 必须强转！
// &var + 1 的类型是 int32_t(*)[7]，不能直接赋给 int32_t*
// 强转后 var_ptr 的步长变回 4字节，才能用 -1 回退一个元素
//&var 的类型是 int32_t (*)[7]，所以它的步长是整个数组的大小,不强转的话步长就是28字节
```

------

**⚠️ 注意点三：`*(var + 1)` 与 `*var + 1` 含义完全不同**

```c
*(var + 1)  // 先偏移再解引用 → var[1] = 4   ← 题目用的是这个
*var + 1    // 先解引用再加1 → var[0] + 1 = 3
```

> 运算符优先级：`*` 和 `+` 同级时从右往左，但 `*(var+1)` 有括号强制先算偏移。

------

**⚠️ 注意点四：`int32_t` 与 `int` 的关系**

~~~c
// int32_t 是固定4字节的类型，定义在 <stdint.h>
// 在大多数32/64位平台上 int32_t == int，但不能依赖这一点
// 本题步长计算依赖 sizeof(int32_t) = 4，而非 sizeof(int)
```

> 如果题目改成 `int64_t`，整个数组大小变为 56字节，步长计算结果完全不同，要特别注意类型。

---

**⚠️ 注意点五：画图是解这类题最可靠的方法**
```
地址：  1000  1004  1008  1012  1016  1020  1024  1028
值：    [0]   [1]   [2]   [3]   [4]   [5]   [6]   (越界)
         2     4     6     8    10    12    14
         ↑                                   ↑
        var                              &var+1 → 强转 → var_ptr
                                              var_ptr-1 ↑
                                         指向 var[6]，将其改为 4
~~~

> 遇到多步指针运算，逐步标注每个指针指向哪里，比心算可靠得多。

### 1.2.7 指针交换函数（值传递 vs 地址修改）【选择题】

> **考点**：C语言函数参数是值传递——交换指针本身不影响调用者的指针
> **注意**：要真正交换两个指针指向的值，需使用二级指针 `int **` 或直接交换 `*a` 和 `*b`

下面程序的输出结果是（  ）

```c
void swap(int *a, int *b) {
    int *t;
    t = a;
    a = b;
    b = t;
}

int main() {
    int x = 1, y = 2;
    int *p = &x, *q = &y;
    swap(p, q);
    printf("%d %d\n", *p, *q);
    return 0;
}
```

- **A.** 1 2
- **B.** 2 1
- **C.** 编译错误
- **D.** 运行时崩溃

<details><summary>💡 答案提示</summary>
<p><b>答案：A</b></p>
<p><code>swap</code> 函数内交换的只是<b>形参（指针的副本）</b>，不影响实参 <code>p</code> 和 <code>q</code>。函数返回后 <code>p</code> 仍指向 <code>x</code>，<code>q</code> 仍指向 <code>y</code>。要真正交换需用二级指针 <code>int **</code> 或交换 <code>*a</code> 和 <code>*b</code> 的值。</p>
</details>

---

**⚠️ 核心原则：C语言所有参数传递都是值传递**

传指针时，传的是"指针变量本身的值（地址值）"的副本。栈上会为形参开辟副本，函数内对形参的修改不影响实参。

- 对于指针来说就是栈上开辟跟外部指针指向相同的副本指针！那么修改指针指向是无效的，根据指向修改值是有效的（一级指针来说）
- 要修改一级指针指向的话，就要把他存到二级指针中，与上同理去修改二级指针指向的值即可完成修改。

**⚠️ 注意点一：两种操作效果完全不同**

| 操作                                             | 是否影响外部 |
| ------------------------------------------------ | ------------ |
| 传值，修改副本                                   | ❌            |
| 传一级指针，解引用修改内容（`*p = ...`）         | ✅            |
| 传一级指针，修改指针指向（`p = ...`）            | ❌            |
| 传二级指针，解引用修改一级指针指向（`*p = ...`） | ✅            |

本题 `swap` 函数内执行的是 `a = b`，属于**修改形参指针的指向**，是对副本的操作，函数返回后 `p` 仍指向 `x`，`q` 仍指向 `y`，输出 `1 2`。

**⚠️ 注意点二：三种"交换"写法的本质区别**

**写法一：交换形参指针指向（原题，无效）**

```c
void swap(int *a, int *b) {
    int *t = a; a = b; b = t;  // 只改了副本，外部p/q不变
}
// *p=1, *q=2，输出 1 2
```

**写法二：解引用交换内容（有效，但指向不变）**

```c
void swap(int *a, int *b) {
    int t = *a; *a = *b; *b = t;  // 修改了x和y的值
}
// p仍指向x，q仍指向y，但x=2,y=1，输出 2 1
```

**写法三：二级指针交换指向（有效，指向真正互换）**

```c
void swap(int **a, int **b) {
    int *t = *a; *a = *b; *b = t;  // p和q的指向互换
}
swap(&p, &q);
// p指向y，q指向x，输出 2 1
```

------

**⚠️ 注意点三：写法二和写法三输出相同但原理不同**

写法二和写法三输出都是 `2 1`，但本质完全不同：

- 写法二：`p` 仍指向 `x`，`q` 仍指向 `y`，只是 `x` 和 `y` 里存的值互换了
- 写法三：`p` 改为指向 `y`，`q` 改为指向 `x`，值没动，是指针指向本身发生了互换

这是最容易混淆的陷阱，考试中若题目问的是"指针指向是否改变"，两者答案截然相反。

------

**⚠️ 注意点四：三种写法对比总结**

| 函数写法                   | `*p` `*q` 输出 | `p`/`q` 指向是否改变 | `x`/`y` 的值是否改变 |
| -------------------------- | -------------- | -------------------- | -------------------- |
| 交换形参指针指向（写法一） | 1  2           | ❌                    | ❌                    |
| 解引用交换内容（写法二）   | 2  1           | ❌                    | ✅                    |
| 二级指针交换指向（写法三） | 2  1           | ✅                    | ❌                    |

### 1.2.8 空指针与 malloc 返回值 【问答题】

> **考点**：空指针常量的定义与宏本质；空指针的语义与内部实现；`malloc` 分配失败返回 `NULL` 而非整数 `0`；解引用空指针是未定义行为
> **注意**：
>
> `NULL` 是宏定义，通常展开为 `(void*)0`，但空指针的内部bit表示不一定是全0，取决于平台实现
>
> `NULL`、`0`、`'\0'`、`false` 底层值可能相同，但语义不同，指针判空应使用 `NULL`
>
> 未初始化指针是野指针，与空指针是两回事，定义指针时若暂无指向应初始化为 `NULL`
>
> 解引用空指针是未定义行为，`malloc` 后必须先判断返回值是否为 `NULL` 再使用
>
> `free` 后指针变成悬空指针，应立即置 `NULL` 防止误用

1. 什么是空指针常量（null pointer constant）？
2. 什么是空指针（null pointer）？
3. 空指针指向了内存的什么地方（空指针的内部实现）？
4. `malloc` 函数在分配内存失败时返回 0 还是 `NULL`？

💡 **答案提示**

**Q1：空指针常量** 是C语言标准定义的一个特殊常量，表示"不指向任何对象"的指针值。在代码中写作 `NULL` 或整数常量 `0`。`NULL` 本质是一个宏，通常定义为 `(void*)0`。

**Q2：空指针** 是一个指针变量，其值为**空指针常量**。表示该指针当前不指向任何有效的内存地址。

**Q3：空指针的内部实现** C标准只规定空指针不等于任何有效对象的地址，并不规定其内部bit表示一定是全0。但是大多数现代平台（x86/ARM等）确实用全0地址表示空指针。

**Q4：** 返回 `NULL`。虽然 `NULL` 在大多数实现中就是 `(void*)0`，但语义上应使用 `NULL` 进行判断，体现"空指针"的含义。

**⚠️ 注意点一：`NULL`、`0`、`'\0'`、`false` 的区别**

这四个在底层值可能相同，但语义完全不同，混用虽然能编译通过，但是不规范：

| 常量    | 类型       | 语义         | 用途       |
| ------- | ---------- | ------------ | ---------- |
| `NULL`  | `(void*)0` | 空指针       | 指针判空   |
| `0`     | `int`      | 整数零       | 数值计算   |
| `'\0'`  | `char`     | 字符串终止符 | 字符串结尾 |
| `false` | `_Bool`    | 逻辑假       | 布尔判断   |

```c
int *p = NULL;   // ✅ 规范
int *p = 0;      // ⚠️ 能编译，但语义不清晰
if (p == NULL)   // ✅ 规范的指针判空
if (!p)          // ⚠️ 能用，但不够明确
```

------

**⚠️ 注意点二：未初始化指针 vs 空指针，是两回事**

```c
int *p;        // ❌ 野指针，指向随机地址，非常危险
int *p = NULL; // ✅ 空指针，明确表示"不指向任何地方"
```

定义指针时若暂时没有指向目标，一定要初始化为 `NULL`，否则 `p` 是野指针，解引用会导致未定义行为。

------

**⚠️ 注意点三：解引用空指针是未定义行为**

```c
int *p = NULL;
*p = 10;   // ❌ 未定义行为，通常导致段错误（Segmentation Fault）
```

使用 `malloc` 后必须检查返回值再使用：

```c
int *p = (int*)malloc(sizeof(int));
if (p == NULL) {   // ✅ 必须先判断
    // 处理分配失败
}
*p = 10;
```

------

**⚠️ 注意点四：`malloc` 返回 `NULL` 还是 `0` 的本质**

`malloc` 失败时返回的是 `NULL`（类型为 `void*`），而不是整数 `0`。虽然大多数平台两者的bit表示相同，但类型不同：

```c
void *p = malloc(size);
if (p == NULL) { ... }   // ✅ 与空指针比较，语义正确
if (p == 0)    { ... }   // ⚠️ 整数0会隐式转换为空指针，能用但不规范
```

------

**⚠️ 注意点五：`free` 之后指针应立即置 `NULL`**

```c
free(p);
p = NULL;  // ✅ 防止产生悬空指针（dangling pointer）
```

`free` 后指针变量本身仍存在，值还是原来的地址（即悬空指针），若不置 `NULL` 后续误用会导致未定义行为。这虽不是本题直接考点，但与空指针使用密切相关，容易一并考察。


---

### 1.2.9 空指针、野指针与悬空指针（指针安全）【问答题】

> **考点**：三类危险指针的定义与区别；野指针的三种产生方式；访问后果为未定义行为；防御规范：free 后立即置 NULL
> **注意**：
>
> 悬空指针是野指针的一种，野指针比空指针更危险（看似合法但指向非法内存）
>
> 未初始化指针、free后未置NULL、返回局部变量地址，是**野指针三种典型来源**
>
> `free(p); p = NULL;` 只能保护当前指针，若存在多个指针指向同一块内存（指针别名），其他副本仍是悬空指针

1. 什么是悬空指针？
2. 空指针和野指针的区别是什么？
3. 访问野指针会发生什么？访问空指针会发生什么？
4. 释放之后的指针再次调用会发生什么状况，如何避免？

💡 **答案提示**

**Q1 悬空指针（Dangling Pointer）：** 指向已释放或已失效内存的指针，是野指针的一种。常见场景：

1. `free(p)` 后未置 `NULL`，继续使用 `p`
2. 函数返回局部变量的地址
3. 指向的栈内存在函数返回后被回收

**Q2 区别：**

- 空指针（NULL Pointer）：明确赋值为 `NULL`，表示"不指向任何有效对象"，是安全的初始化状态，误用时在有MMU的系统上通常会立即崩溃报错，便于定位
- 野指针（Wild/Dangling Pointer）：指向不确定或非法内存区域的指针，看似合法但实际指向非法内存，误用时可能静默读写错误数据而不崩溃，危害更大

野指针三种典型产生方式：

1. 指针未初始化 —— 声明后未赋值，值为随机地址
2. `free` 后未置 `NULL` —— 内存已释放，指针仍保存原地址
3. 返回局部变量的地址 —— 函数返回后栈内存被回收，指针失效

~~~c
int* get_val() {
    int x = 10;  // x 是栈上的局部变量
    return &x;   // ❌ 返回 x 的地址
                 // 函数返回后，栈指针上移，x 所在栈帧被标记为"可覆盖"
                 // 但内存并未立即清零，数据仍暂时残留在原地址
}

int main() {
    int *p = get_val();  // p 接收到了 x 的地址，地址本身是合法的数值
                         // 但该地址已不属于我们，随时可能被覆盖

    // 情况一：紧接着就读，可能侥幸读到 10
    printf("%d\n", *p);  // ⚠️ 可能输出 10（栈帧尚未被覆盖）
                         // 也可能是垃圾值，取决于编译器和运行时状态
                         // 看似正常，实则是未定义行为，掩盖了真正的问题

    // 情况二：中间调用了其他函数，新栈帧覆盖了原来的内存
    printf("%d\n", *p);  // ❌ 极可能输出垃圾值
                         // printf 本身的调用会在栈上建立新栈帧
                         // 原来 x 所在的内存已被 printf 的栈帧覆盖
}
```

栈内存回收的本质是**栈指针上移**，而不是清零。可以用下图理解：
```
调用 get_val() 时：          get_val() 返回后：
┌─────────────┐              ┌─────────────┐
│  main栈帧   │              │  main栈帧   │
├─────────────┤              ├─────────────┤  ← 栈指针回到这里
│ get_val栈帧 │              │  数据残留   │  ← 标记为可覆盖，但值暂时还在
│   x = 10   │              │  x = 10 ?  │     下次函数调用会覆盖这里
└─────────────┘              └─────────────┘
      ↑ 栈指针                      p 指向这里，地址失效
~~~

**Q3 访问野指针：** 行为是未定义的（Undefined Behavior）——

- 可能读到垃圾数据，看似正常但数据错误（最危险，不会崩溃难以察觉）
- 可能破坏其他变量的数据，写操作踩了别人的内存
- 可能触发段错误/HardFault 导致程序崩溃
- 嵌入式中可能导致系统跑飞、看门狗复位

访问空指针：行为也是未定义的，但通常表现更确定——

- 有 MMU 的系统（Linux/Windows）→ 段错误（Segmentation Fault），便于发现和定位
- 无 MMU 的嵌入式系统（如 Cortex-M）→ 可能触发 HardFault，也可能访问到地址0处的实际内容（中断向量表），导致不可预测的行为

如何避免：

```c
free(p);
p = NULL;  // ✅ 释放后立即置空，后续误访问会触发空指针异常，易于定位
```

⚠️ 但若存在多个指针指向同一块内存，仅置当前指针为 `NULL` 是不够的：

```c
int *p = malloc(sizeof(int));
int *q = p;   // q 是 p 的别名，指向同一块内存
free(p);
p = NULL;     // ✅ p 已安全
*q = 10;      // ❌ q 仍是悬空指针，Use-After-Free
```

这种情况需要在架构层面明确内存的唯一所有权，避免多个指针共享同一块堆内存的所有权。


---

### 1.2.10 函数指针与指针函数的区别 【问答题】

> **考点**：函数指针本质是指针；指针函数本质是函数；通过 `*` 与函数名的结合方式来区分
> **注意**：
>
> `int *func(int)` 和 `int (*pfunc)(int)` 仅一对括号之差，含义完全不同
>
> 函数指针变量未初始化直接调用是野指针，使用前必须赋值或判空
>
> `typedef` 可以简化函数指针的声明，实际工程中大量使用
>
> 指针函数返回局部变量的地址是野指针（见1.2.9），应返回堆内存或静态变量地址
>
> 函数指针在嵌入式中大量使用，如回调函数注册、状态机跳转表、驱动接口抽象（HAL层的ops结构体）

1. 函数指针是什么，你用它来干什么？
2. 指针函数与函数指针分别是什么？给出程序语句示例。

💡 **答案提示**

**Q1：函数指针**是指向函数的指针变量，存储的是函数的入口地址。典型用途：回调函数、状态机跳转表、驱动接口抽象。

**Q2：**

**指针函数：** 返回值为指针的函数，本质是函数。

```c
int *func(int a, int b);   // 返回 int* 的函数
// ⚠️ 不能返回局部变量地址，可返回堆内存或静态变量地址
int *func(int a, int b) {
    int *p = malloc(sizeof(int));  // ✅ 返回堆内存，函数返回也不会收回
    *p = a + b;//修改一级指针指向的值
    return p;  // 调用方负责 free
}
```

**函数指针：** 指向函数的指针变量，本质是指针。

```c
int (*pfunc)(int, int);     // 声明函数指针，此时未初始化是野指针
pfunc = add;                // ✅ 赋值后才能使用，add 是已定义的函数
if (pfunc != NULL)          // ✅ 调用前判空，防止野指针调用
    int result = pfunc(1, 2);

// typedef 简化声明，实际工程常用写法
typedef int (*AddFunc)(int, int);
AddFunc pfunc = add;        // 更直观
```

**记忆技巧：** 看 `*` 和函数名的结合方式——

- `int *func(...)` → `*` 修饰返回值，`func` 是函数 → **指针函数**
- `int (*pfunc)(...)` → `*` 和 `pfunc` 被括号锁在一起，`pfunc` 是指针 → **函数指针**
- [这里的判断方式跟指针数组以及数组指针判断类似](###1.2.1 数组指针 vs 指针数组 【问答题】)


---

### 1.2.11 复杂声明解析——函数指针调用 【问答题】

> **考点**：C语言复杂声明的阅读能力；函数指针的理解；强制类型转换
> **注意**：
>
> 拆解复杂声明的口诀：**从标识符出发，右看左看，括号优先**
>
> `(void(*)())` 是函数指针的类型，不是函数指针变量，不能直接调用，需先强转再解引用
>
> 整数 `0` 强转为指针是实现定义行为（implementation-defined），在标准C中不可移植，嵌入式中需结合平台确认地址0的实际含义
>
> 在有MMU的系统（Linux/Windows）上，地址0通常不可访问，直接调用会触发段错误
>
> 嵌入式中跳转复位向量更推荐用 `typedef` 写法，可读性更高

请解析 `(*(void(*)())0)()` 的含义。

💡 **答案提示**

从内向外逐层拆解：

```c
(*(void(*)())0)()
```

**第一层：** `void(*)()` —— 函数指针类型，指向无参数、无返回值的函数

```c
void(*)(void)   // 完整写法
void(*)()       // 简写，等价
```

**第二层：** `(void(*)())0` —— 将整数 `0` 强制转换为该函数指针类型

```c
(void(*)())0    // 把地址 0x0 解释为一个函数的入口地址
```

**第三层：** `*(void(*)())0` —— 解引用该函数指针，得到函数本身

```c
*(void(*)())0   // 取地址 0 处的函数
```

**第四层：** `(*(void(*)())0)()` —— 加上 `()` 调用该函数

```c
(*(void(*)())0)()  // 调用位于地址 0x0 处的 void func(void) 类型函数
```

**等价的可读写法（推荐）：**

```c
// 用 typedef 简化，实际工程推荐写法
typedef void (*ResetFunc)(void);
ResetFunc reset = (ResetFunc)0;
if (reset != NULL)
    reset();   // 跳转到地址 0 执行，等价于 (*(void(*)())0)()
```

**使用场景对比：**

| 场景                         | 地址0的含义         | 调用结果       |
| ---------------------------- | ------------------- | -------------- |
| 有MMU的系统（Linux/Windows） | 不可访问页          | ❌ 段错误       |
| 无MMU的嵌入式（如Cortex-M）  | 复位向量/中断向量表 | ✅ 跳转复位执行 |


---

### 1.2.12 回调函数的定义与典型使用场景 【问答题】

> **考点**：回调函数通过函数指针实现；核心思想是控制反转——调用时机由框架/底层决定，而非调用方主动触发；嵌入式与FreeRTOS中大量使用
> **注意**：
>
> 回调函数本身不是新语法，本质就是函数指针的应用，重点在于理解"控制反转"的思想
>
> 回调函数通常由中断或底层框架在特定时机调用，注意**不能在回调中执行耗时操作**
>
> FreeRTOS的软件定时器回调运行在 `TimerTask` 中，不是在调用 `xTimerStart` 的任务中执行
>
> FreeRTOS回调中**不能调用会阻塞的API**（如 `vTaskDelay`、`xQueueReceive` 带超时），否则会阻塞定时器任务导致系统异常
>
> HAL库的中断回调（如 `HAL_UART_RxCpltCallback`）运行在中断上下文中，同样不能有阻塞操作，耗时处理应通过队列/信号量交给任务处理

请简述回调函数以及使用场合。

💡 **答案提示**

**什么是回调函数：** 将函数指针传递给框架或底层模块，由框架在特定事件发生时主动调用的函数。核心思想是**控制反转**——"你不调用我，我来调用你"，调用时机由底层决定。

**基本结构：**

```c
// 定义回调函数类型
typedef void (*CallbackFunc)(void);

// 底层模块：接收并保存回调
CallbackFunc g_callback = NULL;
void Timer_RegisterCallback(CallbackFunc cb) {
    g_callback = cb;
}
// 底层在合适时机触发回调
void Timer_IRQHandler(void) {
    if (g_callback != NULL)
        g_callback();   // 调用上层注册的函数
}

// 上层模块：定义并注册回调
void onTimeout(void) {
    // 处理超时事件
}
Timer_RegisterCallback(onTimeout);  // 注册，不是调用
```

**典型使用场景总结：**

| 场景               | 示例                      | 运行上下文     |
| ------------------ | ------------------------- | -------------- |
| HAL中断回调        | `HAL_UART_RxCpltCallback` | 中断上下文     |
| FreeRTOS定时器回调 | `xTimerCreate` 注册的函数 | TimerTask      |
| 驱动抽象ops结构体  | HAL层函数指针表           | 任务上下文     |
| 事件驱动           | 按键、通信完成通知        | 视注册位置而定 |



### 1.2.13 通过地址直接赋值 【问答题】

> **考点**：强制类型转换；指针解引用；嵌入式寄存器操作
> **注意**：在嵌入式中常用于直接操作硬件寄存器，普通程序中属于未定义行为

设置地址为 `0x13579` 的整型变量的值为 `0x97351`。

<details><summary>💡 答案提示</summary>
<pre><code>*(int *)0x13579 = 0x97351;</code></pre>
<p>拆解：</p>
<ol>
<li><code>(int *)0x13579</code> —— 将整数地址强制转换为 <code>int</code> 类型指针</li>
<li><code>*(int *)0x13579</code> —— 解引用该指针，访问该地址处的整型变量</li>
<li><code>= 0x97351</code> —— 赋值</li>
</ol>
</details>

---

## 1.3 宏定义与预处理

### 1.3.1 宏定义求数组元素个数 【编程题】

> **考点**：`sizeof(arr)/sizeof(arr[0])` 的经典用法
> **注意**：
>
> 仅在数组定义的作用域有效
>
> **数组退化为指针后失效**：将数组传入函数后，参数类型退化为指针，`sizeof` 得到的是指针大小（4或8字节）而非数组大小，此时宏的结果**错误**

已知一个数组 `table`，用一个宏定义，求出数据的元素个数。

💡 答案提示

```c
#define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]))
```

⚠️ 易错示例

```c
#define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]))

void foo(int arr[]) {
    // 错误！arr 已退化为 int*
    // sizeof(arr) = 4 或 8（指针大小），而非数组总大小
    int n = ARRAY_SIZE(arr); // 结果错误
}

int main() {
    int table[] = {1, 2, 3, 4, 5};
    int n = ARRAY_SIZE(table); // 正确，n = 5
    foo(table);
}
```

### 1.3.2 宏定义展开的陷阱（无括号保护）【选择题】

> **考点**：宏是简单文本替换，参数不加括号会导致运算优先级错误
> **注意**：
>
> `#define TEST(a,b) a*b` 展开 `TEST(1+2,3)` 为 `1+2*3=7` 而非 `9`
>
> 即使参数加了括号，**宏整体若不加括号，在复杂表达式中仍可能出错**

下面程序的运行结果为？（  ）

```c
#define TEST(a,b) a*b

int main() {
    int a = TEST(1 + 2, 3);
    printf("result= %d\n", a);
    return 0;
}
```

- **A.** result= 9
- **B.** result= 5
- **C.** result= 7
- **D.** result= 3

💡 答案提示

答案：**C**

展开过程：`TEST(1+2, 3)` → `1+2*3` → `1+6` = **7**

正确写法应为 `#define TEST(a,b) ((a)*(b))`

⚠️ 易错点：只加参数括号还不够

```c
// 仅保护参数——大多数情况正确，但仍有漏洞
#define TEST(a,b) (a)*(b)

// 考虑这种调用：
int x = 10 / TEST(2, 5);
// 展开为：10 / (2)*(5) → (10/2)*5 = 25，而非 10/(2*5) = 1
```

所以完整的防御写法是**参数和整体都加括号**：

```c
#define TEST(a,b) ((a)*(b))
// 展开为：10 / ((2)*(5)) = 10/10 = 1  ✓
```


---

### 1.3.3 宏展开与运算符优先级（综合）【选择题】

> **考点**：多重宏嵌套展开后的优先级计算
> **注意**：本题在 1.3.2 基础上增加了**宏嵌套、符号常量替换、多步展开**，需逐步还原，不可跳步

设 `#define N 3`，`#define Y(n) ((N+1)*n)`，则表达式 `2*(N+Y(5+1))` 的值是（  ）

- **A.** 42
- **B.** 48
- **C.** 54
- **D.** 出错

💡 答案提示

答案：**B**

关键：`Y(n)` 中 `n` 没有括号保护，`*n` 展开为 `*5+1` 而非 `*(5+1)`，这正是宏与函数调用的本质区别。

⚠️ 易错点：展开要**逐步进行**，不能先算参数

```c
// 错误思路（先算 5+1=6，再代入）：
Y(5+1) → ((3+1)*6) = 24   ← 误以为答案是 A：2*(3+24)=54 或 B

// 正确思路（先文本替换，再按优先级计算）：
Y(5+1) → ((N+1)*5+1)      ← n 直接替换为 5+1，无括号保护
       → ((3+1)*5+1)
       → (4*5+1)
       → 21

整体：2*(N+Y(5+1)) → 2*(3+21) = 2*24 = 48
```


---

### 1.3.4 宏定义取模运算展开 【选择题】

> **考点**：宏展开时参数被多次替换，含副作用的表达式（如 `a++`）会被执行多次；而函数调用参数只求值一次
> **注意**：`DOUBLE(a++)` 展开为 `a+++a++`，`a` 自增**两次**，结果与函数版本不同

已知如下代码，输出结果是（  ）

```c
#define DOUBLE(x) ((x)+(x))

int double_fn(int x) { return x + x; }

int main() {
    int a = 3, b = 3;
    printf("%d\n", DOUBLE(a++));
    printf("%d\n", double_fn(b++));
    return 0;
}
```

- **A.** 6 和 6
- **B.** 7 和 6
- **C.** 8 和 6
- **D.** 6 和 7

💡 答案提示

答案：**B**

关键：宏是文本替换，参数 `a++` 被展开了**两次**；函数是传值调用，`b++` 只求值**一次**。这也是宏相比内联函数的主要风险所在。

⚠️ 易错点 

```c
// 宏展开：DOUBLE(a++) → ((a++)+(a++)) 
// a 初始为 3，两次 a++ 分别取值 3 和 4（先用后加） 
// 结果：3+4 = 7，执行后 a = 5 
// 函数调用：b++ 作为参数只求值一次，传入 3 
// 结果：3+3 = 6，执行后 b = 4
```


---

### 1.3.5 预编译相关问题 【问答题】？？？

> **考点**：编译四阶段（预处理→编译→汇编→链接）；预编译的工作内容
> **注意**：
>
> 预编译处理 `#include`、`#define`、条件编译等指令，不做语法检查
>
> **预编译是纯文本替换**，不理解 C 语法，不分配内存，不做类型检查
>
> **四个阶段的产物容易混淆**，需要对应记忆

1. 什么是预编译（Preprocessing）？
2. C 语言编译过程分为哪几个阶段？
3. 预编译阶段主要完成哪些工作？
4. 在实际开发中，何时需要使用预编译？
5. 预编译与编译的本质区别是什么？

**1. 什么是预编译？**

预编译是编译前的文本处理阶段，由预处理器完成，将源文件 `.c` 处理为展开后的纯 C 文本（`.i` 文件），供编译器使用。

⚠️ 易混淆：预编译不是"提前编译"，它根本不做编译工作，只做**文本层面的替换与处理**。

------

**2. C 语言编译过程的四个阶段**

| 阶段   | 工具     | 输入 | 输出             |
| ------ | -------- | ---- | ---------------- |
| 预处理 | 预处理器 | `.c` | `.i`             |
| 编译   | 编译器   | `.i` | `.s`（汇编）     |
| 汇编   | 汇编器   | `.s` | `.o`（目标文件） |
| 链接   | 链接器   | `.o` | 可执行文件       |

⚠️ 易混淆：**链接阶段才解决函数跨文件调用问题**，不是编译阶段。声明了但未定义的函数，编译能通过，链接才会报错。

------

**3. 预编译阶段主要完成的工作**

- 展开 `#include`，将头文件内容插入源文件
- 展开 `#define` 宏，进行文本替换
- 处理条件编译指令（`#ifdef`、`#ifndef`、`#endif` 等）
- 删除注释
- 处理 `#pragma` 等编译器指令

⚠️ 易混淆：`#include` 是**完整复制粘贴**头文件内容，重复包含会导致重复定义，这正是需要头文件保护（`#ifndef`/`#pragma once`）的原因。

------

**4. 实际开发中何时使用预编译**

- 用 `#define` 定义常量或宏函数
- 用 `#ifdef DEBUG` 控制调试代码的开关
- 用头文件保护防止重复包含
- 用 `#pragma once` 或 `#ifndef` 保护头文件

⚠️ 易混淆：`#define` 定义的常量**没有类型、没有作用域**，现代 C 推荐用 `const` 或 `enum` 替代常量定义，用 `inline` 函数替代宏函数。

------

**5. 预编译与编译的本质区别**

|                | 预编译            | 编译                 |
| -------------- | ----------------- | -------------------- |
| 处理对象       | 以 `#` 开头的指令 | C 语言语句           |
| 是否理解语法   | 否，纯文本处理    | 是，做语法和类型检查 |
| 是否报语法错误 | 不报              | 报                   |
| 产物           | 展开的 `.i` 文件  | 汇编 `.s` 文件       |

⚠️ 易混淆：宏展开后如果产生语法错误，**报错位置指向展开后的代码**，不是宏定义那一行，初学者容易找不到错误来源。

#### 工作中的体现？？？

固件是怎么来的？在哪一步产生的？具体的原理？

---

### 1.3.6 gcc 编译参数 【问答题】

> **考点**：`-c` 只编译不链接、`-o` 指定输出文件名、`-shared` 生成动态库、`-static` 静态链接
> **注意**：区分编译和链接阶段各参数的作用

gcc 编译中 `-c`、`-o`、`-shared`、`-static` 等编译参数的用途。

**各参数用途与易混淆点**

**`-c`：只编译，不链接**

bash

```bash
gcc -c foo.c        # 生成 foo.o，不生成可执行文件
```

⚠️ 易混淆：`-c` 不是"只预处理"，它会走完预处理→编译→汇编三个阶段，只是**不进行链接**。未定义的函数在此阶段不会报错，链接时才会。

------

**`-o`：指定输出文件名**

```bash
gcc foo.c -o myapp      # 输出可执行文件 myapp
gcc -c foo.c -o foo.o   # 输出目标文件 foo.o
```

⚠️ 易混淆：`-o` 可以和任何阶段组合使用，**不单独决定编译阶段**，它只是给输出文件命名。不加 `-o` 时默认输出 `a.out`。

------

**`-shared`：生成动态库（.so 文件）**

```bash
gcc -shared -fPIC foo.c -o libfoo.so
```

⚠️ 易混淆：生成动态库时通常需要同时加 **`-fPIC`**（位置无关代码），缺少它在某些平台会报错或产生不可靠的动态库，两者经常需要配合使用。

------

**`-static`：静态链接**

```bash
gcc foo.c -static -o myapp     # 将所有库静态链接进可执行文件
```

⚠️ 易混淆：`-static` 与 `-shared` 是**对立的**，不能同时使用。另外静态链接生成的文件体积大但**不依赖运行环境的动态库**，动态链接体积小但目标机器必须有对应的 `.so` 文件。

------

**综合对比**

| 参数      | 作用阶段   | 典型用途          | 常见误区          |
| --------- | ---------- | ----------------- | ----------------- |
| `-c`      | 停在汇编后 | 分步编译多文件    | 以为只是预处理    |
| `-o`      | 任意阶段   | 指定输出文件名    | 以为只能用于链接  |
| `-shared` | 链接       | 生成 `.so` 动态库 | 忘记配合 `-fPIC`  |
| `-static` | 链接       | 全静态链接        | 与 `-shared` 混用 |

⚠️ 补充易混淆点：`-shared` 和 `-static` 针对的是**库文件的链接方式**，而 `-c` 和 `-o` 针对的是**编译产物的控制**，两组参数作用层面不同，不要混为一谈。

---

### 1.3.7 条件编译指令 #ifdef/#ifndef/#else/#endif 【问答题】

> **考点**：预处理指令 vs 关键字的区别；条件编译的实际应用场景
> **注意**：它们是**预处理指令**而非"预定义标识符"；`#ifndef` 用于头文件防重复包含（Include Guard）

简述 `#ifdef`、`#else`、`#endif`、`#ifndef` 的作用。

<details><summary>💡 答案提示</summary>
<p>这些是<b>预处理指令</b>，用于<b>条件编译</b>，在预处理阶段决定哪些代码参与编译：</p>
<ul>
<li><code>#ifdef</code>：如果宏已定义，则编译其后的代码</li>
<li><code>#ifndef</code>：如果宏<b>未</b>定义，则编译其后的代码</li>
<li><code>#else</code>：与 <code>#ifdef</code>/<code>#ifndef</code> 配合，提供否定分支</li>
<li><code>#endif</code>：结束条件编译块</li>
</ul>
<p><b>场景一：条件编译（跨平台/调试控制）</b></p>
<pre><code>#ifdef DEBUG
    printf("debug info\n");
#else
    // Release模式不编译调试代码
#endif</code></pre>
<p><b>场景二：头文件防重复包含（Include Guard）</b></p>
<pre><code>#ifndef _MODULE_H_
#define _MODULE_H_
// 头文件内容
#endif</code></pre>
</details>

---

### 1.3.8 宏定义 MIN（返回较小值）【编程题】

> **考点**：三目运算符语法；宏参数务必加括号保护
> **注意**：宏的**双重求值**问题——如 `MIN(i++, j++)` 会导致参数被求值两次产生副作用

写一个宏 `MIN`，返回两个数中较小的那一个。

<details><summary>💡 答案提示</summary>
<pre><code>#define MIN(a, b)  ((a) < (b) ? (a) : (b))</code></pre>
<p>每个参数都要加括号，防止宏展开时运算符优先级导致错误。例如 <code>MIN(x+1, y+2)</code> 如果不加括号会出错。</p>
</details>
---

## 1.4 关键字与修饰符

### 1.4.1 static 关键字 【问答题】

> **考点**：修饰局部变量（延长生命周期）、修饰全局变量/函数（限制作用域到本文件）
> **注意**：
>
> static 局部变量只初始化一次，后续调用保留上次的值
>
> static 局部变量作用域**不变**，仍只在函数内可见——常见误区是以为生命周期延长了，作用域也跟着扩大
>
> static 全局变量与普通全局变量**生命周期相同**（都是程序结束销毁），区别仅在于**链接属性(作用域大小)**，不要把两者的区别误答成生命周期

1. `static` 关键字在 C 语言中有哪几种用法？各自效果是什么？

2. `static` 函数与普通函数的区别是什么？

3. 以下代码输出什么？为什么？

```c
void counter() {
    static int cnt = 0;
    cnt++;
    printf("%d\n", cnt);
}

int main() {
    counter();
    counter();
    counter();
}
```

4. static 全局变量和普通全局变量有什么区别？
5. "生命周期"和"作用域"有什么区别？static 局部变量的生命周期和作用域分别是什么？

💡 答案提示

**static 的三种用法：**

| 用法         | 生命周期           | 作用域/可见性                          |
| ------------ | ------------------ | -------------------------------------- |
| 修饰局部变量 | 延长到程序结束     | 不变，仍限于函数内                     |
| 修饰全局变量 | 不变，程序结束销毁 | 限制在本文件，其他文件 extern 不可访问 |
| 修饰函数     | —                  | 仅本文件可见，防止命名冲突             |

**第3题：** 输出 `1 2 3`，cnt 存储在静态区，只初始化一次，每次调用保留上次的值。

**第4题关键：** 区别不是生命周期，而是**链接属性**——普通全局变量其他文件可通过 `extern` 访问，static 全局变量不行。

**第五题：**作用域是变量**可被访问的代码范围**，生命周期是变量**在内存中存在的时间段**，两者相互独立。

static 局部变量的作用域不变，仍只在定义它的函数内可见；但生命周期延长到整个程序运行期间，存储在静态区，函数返回后不销毁，下次调用时保留上次的值。


---

### 1.4.2 const 关键字 【问答题】

> **考点**：修饰变量为只读、修饰指针（`const int*` vs `int* const`）、修饰函数参数
> **注意**：
>
> `const` 在 `*` 左边修饰指向的值，在 `*` 右边修饰指针本身
>
> `const` 变量不等于编译期常量，不能用来定义数组长度（C99之前），不能用于 `switch case`
>
> `const` 只是编译器层面的只读保护，通过强制类型转换或间接手段修改是**未定义行为**，不要以为 const 是真正的"常量"
>
> 修饰函数参数时，`const` 是对**函数内部**的约束，告知调用者该参数不会被修改，是一种接口语义声明

1. `const` 关键字的作用是什么？有哪些使用场景？
2. 区分以下三种写法的含义：

```c
const int *p;
int * const p;
const int * const p;
```

3. 以下代码会发生什么？

```c
const int x = 10;
int *p = (int *)&x;
*p = 20;
printf("%d\n", x);
```

4. 函数参数加 `const` 的意义是什么？

```c
void print(const char *str);
```

💡 答案提示

**指针与 const 的组合：**

| 声明                  | 指针本身 | 指向的值 |
| --------------------- | -------- | -------- |
| `const int *p`        | 可改     | 不可改   |
| `int * const p`       | 不可改   | 可改     |
| `const int * const p` | 不可改   | 不可改   |

**第3题：** 编译器不报错，但属于**未定义行为**，`x` 的实际输出取决于编译器是否做了常量折叠优化，不可依赖。

**第4题：** 约束函数内部不得修改该参数指向的内容，是接口语义声明，同时允许调用者传入 `const` 指针而不产生警告。

### 1.4.3 extern 关键字 【问答题】

> **考点**：声明外部变量/函数，用于跨文件访问
> **注意**：
>
> `extern` 只是声明不是定义，不分配内存
>
> 全局变量若直接定义在头文件中，多个 `.c` 文件包含该头文件会导致**重复定义链接错误**，应在头文件中用 `extern` 声明，在某一个 `.c` 文件中定义
>
> `extern` 声明函数时可以省略 `extern`（函数默认外部链接），但变量不行，容易混淆
>
> `extern` 与 `static` 冲突：static 全局变量具有内部链接，其他文件用 `extern` 声明也**无法访问**

1. `extern` 关键字的作用是什么？有哪些使用场景？

2. 如何在另一个 `.c` 文件中引用已定义的全局变量？写出示例。

3. 全局变量可以直接定义在被多个 `.c` 文件包含的头文件中吗？为什么？应该怎么做？

4. 以下代码有什么问题？

```c
// a.c
static int count = 0;

// b.c
extern int count;  // 试图访问 a.c 中的 count
```

5. `extern` 声明函数和声明变量有什么区别？以下两种写法有何不同？

```c
extern void foo();   // 声明函数
extern int x;        // 声明变量
```

💡 答案提示

**第1题：** `extern` 用于声明一个在其他文件（或当前文件后面）已定义的变量或函数，告诉编译器"这个符号存在，去别处找"，本身不分配内存。常见使用场景有两个：一是跨文件共享全局变量，二是跨文件调用函数（实际上函数声明默认带外部链接，通常写在头文件中）。

**第2题示例：**

```c
// a.c —— 定义
int count = 0;

// b.c —— 声明后使用
extern int count;
count++;
```

**第3题：** 不可以。头文件被多个 `.c` 包含后，每个编译单元都有一份定义，链接时会报**重复定义错误**。正确做法是头文件中用 `extern` 声明，只在一个 `.c` 文件中定义。

```c
// common.h
extern int count;   // 声明

// common.c
int count = 0;      // 定义（只此一处）
```

**第4题：** `count` 在 `a.c` 中是 `static` 全局变量，具有内部链接，其他文件的 `extern` 声明**无法访问**，链接时报未定义符号错误。

**第5题：** 函数默认具有外部链接，`extern void foo()` 和 `void foo()` 声明效果相同，`extern` 可省略；但变量声明必须写 `extern`，否则会被视为定义并分配内存。

- 函数如果没有在对应头文件中声明的话，要想在其他源文件中使用就要使用extern声明，否则会有警告。

---

### 1.4.4 volatile 关键字 【问答题】

> **考点**：告诉编译器该变量可能被意外修改，禁止优化——每次访问都从内存重新读取
> **注意**：
>
> `volatile` 禁止编译器优化，但**不保证原子性和线程安全**，多线程场景下还需要加锁或使用原子操作，不能用 `volatile` 替代互斥锁
>
> `volatile` 只影响编译器行为，不影响 CPU 缓存一致性，在多核场景下**不能保证可见性**，与 Java 中的 `volatile` 语义不同，注意区分
>
> `const volatile` 可以同时使用，表示该变量只读（程序不能写），但可能被外部修改（每次都要重新读），常见于只读硬件状态寄存器

1. `volatile` 关键字的含义是什么？为什么需要它？
2. 以下代码在开启编译器优化后可能出现什么问题？加上 `volatile` 后有何变化？

```c
int flag = 0;

void wait_for_flag() {
    while (flag == 0);  // 等待中断将 flag 置1
}
```

3. `volatile` 能保证线程安全吗？为什么？

4. `const volatile` 组合修饰有意义吗？什么场景下使用？

💡 答案提示

**三大应用场景：**

| 场景           | 原因                                   |
| -------------- | -------------------------------------- |
| 硬件寄存器     | 寄存器值可能被硬件随时改变             |
| 中断服务程序   | ISR 中修改的共享变量，主程序需感知变化 |
| 多线程共享变量 | 防止编译器将变量缓存在寄存器中         |

**第2题：** 编译器优化后可能判断 `flag` 在循环中从未被修改，将其缓存在寄存器中，导致循环永远无法退出（死循环）。加上 `volatile` 后，编译器每次都从内存重新读取 `flag`，能正确感知外部修改。

**第3题：** 不能。`volatile` 只禁止编译器优化，不提供原子性保证，多线程对共享变量的读改写仍可能出现竞态条件，需配合互斥锁或原子操作使用。

**第4题：** 有意义。`const` 表示程序内部不可写，`volatile` 表示值可能被外部改变需每次重新读取，两者不冲突。典型场景是获取只读的硬件状态寄存器，程序只读取其值但硬件可能随时更新它。

### 1.4.7 静态变量、全局变量与局部变量的异同 【问答题】

> **考点**：`static` 的双重语义——修饰局部变量（延长生命周期不改作用域）vs 修饰全局变量/函数（限制作用域到当前文件）；各类变量的存储位置
> **注意**：
>
> 静态局部变量只初始化一次，后续调用保留上一次的值，这是笔试常考点
>
> 静态全局变量与普通全局变量**生命周期相同**，区别只在链接属性（作用域），不要误答成生命周期不同
>
> 全局变量和静态变量若未显式初始化，自动初始化为 0；局部变量未初始化则是**未定义的垃圾值**，两者行为不同容易忽略
>
> `.bss` 段存放**未初始化或初始化为0**的全局/静态变量，`.data` 段存放**已初始化且非0**的，笔试有时会细问

1. 请简述静态变量、全局变量、局部变量的异同。
2. 以下代码输出什么？

```c
void foo() {
    static int a = 0;
    int b = 0;
    a++; b++;
    printf("a=%d b=%d\n", a, b);
}

int main() {
    foo();
    foo();
    foo();
}
```

3. 全局变量和静态局部变量的生命周期相同，那它们有什么区别？
4. 以下两个变量分别存放在 `.bss` 还是 `.data` 段？

```c
static int x = 0;
static int y = 10;
```

💡 答案提示

| 变量类型        | 存储位置      | 生命周期     | 作用域     | 默认初始值 |
| --------------- | ------------- | ------------ | ---------- | ---------- |
| 局部变量        | 栈            | 函数执行期间 | 函数/块内  | 垃圾值     |
| static 局部变量 | .bss/.data 段 | 整个程序     | 函数/块内  | 0          |
| 全局变量        | .bss/.data 段 | 整个程序     | 所有文件   | 0          |
| static 全局变量 | .bss/.data 段 | 整个程序     | 仅当前文件 | 0          |

**static 的两种用法：**

1. 修饰局部变量：延长生命周期，不改变作用域
2. 修饰全局变量/函数：限制作用域到当前文件，不改变生命周期

**第2题：** 输出：
```
a=1 b=1
a=2 b=1
a=3 b=1
```

`a` 是静态局部变量，保留上次的值；`b` 是普通局部变量，每次调用重新初始化为 0。

**第3题：** 生命周期相同，但作用域不同——全局变量整个程序可见，其他文件可通过 `extern` 访问；静态局部变量作用域仍限于函数内，外部无法访问。

**第4题：** `x` 初始化为 0 存放在 `.bss` 段；`y` 初始化为非0值存放在 `.data` 段。

## 1.5 运算符与表达式

### 1.5.1 运算符优先级 【选择题】

> **考点**：优先级从高到低大致为：括号/下标 > 单目 > 算术 > 移位 > 关系 > 位运算 > 逻辑 > 赋值
> **注意**：
>
> `==` 和 `!=` 优先级低于其他关系运算符（`> < >= <=`），常被误认为同级
>
> 位运算（`& ^ |`）优先级低于关系运算符，`a & b == 0` 实际上是 `a & (b == 0)`，是经典陷阱
>
> 逻辑与 `&&` 高于逻辑或 `||`，两者都低于关系运算符
>
> 单目 `++/--` 高于双目算术运算符，但前置和后置优先级不同：后置 `++` 优先级高于前置 `++`
>
> 赋值运算符 `=` 优先级几乎最低，仅高于逗号运算符

**(1)** 算术运算符、赋值运算符和关系运算符的运算优先级按从高到低依次为（  ）

- A. 算术运算、赋值运算、关系运算
- B. 算术运算、关系运算、赋值运算
- C. 关系运算、赋值运算、算术运算
- D. 关系运算、算术运算、赋值运算

💡 **答案：B**。算术 > 关系 > 赋值，赋值优先级几乎最低。


---

**(2)** C语言中，下列运算符优先级最高的是（  ）

- A. `!`（逻辑非，单目）
- B. `%`（取模，算术）
- C. `>>`（右移）
- D. `==`（等于，关系）

💡 **答案：A**。单目运算符优先级高于双目算术运算符，`!` 属于单目，优先级最高。


---

**(3)** 下列优先级判断**错误**的是（  ）

- A. `%` > `+`
- B. `&&` > `=`
- C. `[]` > 后置 `++`
- D. `<<` > `>`

💡 **答案：C**。`[]`（下标）和后置 `++` 优先级相同，同属第一级，从左到右结合，并非 `[]` 更高。A、B、D 均正确。

**(4)**以下表达式的结果是什么？

```c
int a = 1, b = 1;
int c = a & b == 0;
printf("%d\n", c);
```

💡 **答案：** 输出 `0`。

因为 `==` 优先级高于 `&`，实际计算顺序是：

```c
c = a & (b == 0)
c = 1 & (1 == 0)
c = 1 & 0
c = 0
```

而大多数人会误读为 `(a & b) == 0`，即 `(1 & 1) == 0 = 0`，结果虽然相同但逻辑完全不同，换个值就会出错。将 `b` 改为 `2` 可以更清晰暴露差异：

```c
int a = 1, b = 2;
// 误读：(a & b) == 0  →  (1 & 2) == 0  →  0 == 0  →  1
// 实际：a & (b == 0)  →  1 & 0          →  0
```

### 1.5.7 运算符优先级与结合性（乘法、取模、加法）【选择题】

> **考点**：`*`、`%` 优先级相同且左结合，均高于 `+`
> **注意**：
>
> `*` 和 `%` **优先级相同**，同级运算按**左结合**依次从左到右计算，不是 `%` 优先于 `*`
>
> `%` 是**取模（取余）**，结果是除法的余数，而非商
>
> `68 % 3` 的计算：68 = 3×22 + **2**，余数为2，初学者容易算错
>
> 整个表达式没有括号时，严格按照"先乘除取模，后加减"的顺序，且同级从左到右

在C语言程序中，下面程序运行后，`n` 的值是多少？（  ）

```c
int n = 0;
int f = 17;
n = 4 * f % 3 + 1;
```

- **A.** 1
- **B.** 2
- **C.** 3
- **D.** 4

💡 **答案提示** 

**答案：C** 

```c
n = 4 * f % 3 + 1
  = 4 * 17 % 3 + 1     // 代入 f=17
  = (4 * 17) % 3 + 1   // *和%同级，左结合，先算4*17
  = 68 % 3 + 1         // 68÷3=22余2，取余得2
  = 2 + 1              // 最后加法
  = 3
```

💡 **记忆口诀**：同级运算看左右，不同级别高者先；`*`、`/`、`%` 是一家，`+`、`-` 靠边站。

### 1.5.2 整型专用运算符 【选择题】

> **考点**：取模运算 `%` 要求操作数必须是整型
> **注意**：
>
> `/` 既可用于整型也可用于浮点型，但整型相除会**截断小数部分**，`5/2=2` 而非 `2.5`，容易忽略
>
> `!` 可用于任意标量（整型、浮点、指针），结果为 0 或 1
>
> `**` 在 C 语言中**不是合法运算符**，是干扰项，C 中求幂需用 `pow()` 函数
>
> 取模结果的符号与**被除数**一致（C99规定），如 `-7 % 3 = -1` 而非 `2`，这是笔试常考陷阱

**(1)**C 语言中运算对象必须是整型的运算符是（  ）

- A. `%`

  B. `/`

  C. `!`

  D. `*`（乘法）

💡 **答案：A**。`%` 只能用于整型；`/` 可用于浮点；`!` 可用于任意标量；`*` 乘法同样可以用于浮点数（如 `1.5 * 2.0`），所以四个选项中只有 `%` 要求操作数必须是整型，答案不变。改成 `*` 只是让选项更合法、更具迷惑性

**(2)**以下代码输出什么？

```c
printf("%d\n", -7 % 3);
printf("%d\n", 7 % -3);
```

C99 规定取模结果符号与**被除数**一致，`-7 % 3` 被除数为 `-7` 故结果为 `-1`；`7 % -3` 被除数为 `7` 故结果为 `1`。

**(3)**以下代码输出什么？

```c
printf("%d\n", 5 / 2);
printf("%f\n", 5.0 / 2);

2
2.500000
```

整型相除截断小数，`5/2=2`；只要有一个操作数为浮点型，结果就是浮点数。


---

### 1.5.3 逗号表达式 【选择题】

> **考点**：逗号表达式从左到右依次求值，整个表达式的值为最后一个表达式的值
> **注意**：
>
> `j++`（后缀自增）：表达式的值是自增**前**的值，自增**后**才生效
>
> `++j`（前缀自增）：表达式的值是自增**后**的值
>
> 逗号表达式取**最后一项**的值，而不是所有项的累加或最大值
>
> 逗号运算符优先级是所有运算符中**最低**的，注意括号的作用——`(j=3, j++)` 外层括号保证整体作为一个表达式被求值

若变量已正确定义，表达式 `(j=3, j++)` 的值是（  ）

- **A.** 3
- **B.** 4
- **C.** 5
- **D.** 0

💡 **答案提示**

**答案：A**

1. `j=3` → j 赋值为 3，该子表达式值为 3
2. `j++` → 后缀自增，**表达式的值为自增前的 3**，语句结束后 j 变为 4
3. 逗号表达式取最后一项 `j++` 的值 → **3**

**延伸对比：**

| 表达式       | 值    | 执行后 j   |
| ------------ | ----- | ---------- |
| `(j=3, j++)` | **3** | 4          |
| `(j=3, ++j)` | **4** | 4          |
| `(j=3, j+1)` | **4** | 3（j不变） |


---

### 1.5.4 位运算——右移 【选择题】

> **考点**：右移 `>>` 将二进制位向右移动，低位丢弃，高位补位
> **注意**：
>
> 右移1位 ≈ 整除2，右移n位 ≈ 整除2ⁿ（**向下取整**，负数时与普通除法结果不同）
>
> **无符号数**右移：高位补 **0**（逻辑右移）
>
> **有符号正数**右移：高位补 **0**
>
> **有符号负数**右移：高位补 **1**（算术右移，保持负数符号）
>
> 左移 `<<` 是乘以2的幂，左移n位 = 乘以2ⁿ，所有二进制位整体向左移动n位，右边补0
>
> 左移和右移都是针对**二进制**操作

执行语句 `k = 7 >> 1;` 后，变量 `k` 的当前值是（  ）

- **A.** 15
- **B.** 31
- **C.** 3
- **D.** 1

干扰项说明：

- 选 **A（15）** 或 **B（31）**：可能误以为是**左移**（`7<<1`=14，`15<<1`=30，数值变大）
- 选 **D（1）**：可能误以为右移2位，或只取了最低位

💡 **答案提示**

**答案：C**

```
7  的二进制：0000 0111
右移1位后：  0000 0011  = 3
             ↑补0        ↓低位1丢弃
```

**延伸对比：**

| 表达式    | 运算    | 结果                     |
| --------- | ------- | ------------------------ |
| `7 >> 1`  | 7 ÷ 2¹  | **3**                    |
| `7 >> 2`  | 7 ÷ 2²  | **1**                    |
| `7 << 1`  | 7 × 2¹  | **14**                   |
| `-8 >> 1` | 高位补1 | **-4**（有符号算术右移） |

**负数右移示例**（补充理解，防止混淆）：

```
-8 的补码：1111 1000
右移1位：  1111 1100  = -4（高位补1，保持负号）
```


---

### 1.5.5 位运算——特定位清零 【选择题】

> **考点**：使用位掩码（mask）对特定位进行操作
> **注意**：
>
> `4` = `0000 0100`，即 bit[2]（位编号从0开始，**bit[0]是最低位**）
>
> `~4` 是按位取反，结果是 `1111 1011`，**只有 bit[2] 是0**，其余全是1
>
> `&` 运算：与0相与→清零，与1相与→保持原值；所以 `&= ~mask` 只改变mask对应的位
>
> `|` 运算：与1相或→置1，与0相或→保持原值
>
> `^` 运算：与1异或→翻转，与0异或→保持原值
>
> **bit编号从0开始**，bit[2] 对应数值 2² = **4**，这是选4作为掩码的原因，初学者容易搞错对应关系

下面哪个操作可以将 `flag` 的 bit[2] 置 0？（  ）

- **A.** `flag |= 4` — 置1
- **B.** `flag ^= 4` — 翻转（不确定结果）
- **C.** `flag &= ~4` — **清零** ✓
- **D.** `flag |= ~4` — 几乎全部置1

💡 **答案提示**

**答案：C**

假设 `flag = 0xFF`（全1），逐项分析：

```
flag       = 1111 1111
4          = 0000 0100
~4         = 1111 1011
```

| 选项            | 运算过程                | 结果        | 效果                             |
| --------------- | ----------------------- | ----------- | -------------------------------- |
| A. `flag |= 4`  | `1111 1111 | 0000 0100` | `1111 1111` | bit[2]置**1**（错）              |
| B. `flag ^= 4`  | `1111 1111 ^ 0000 0100` | `1111 1011` | bit[2]**翻转**，结果不确定（错） |
| C. `flag &= ~4` | `1111 1111 & 1111 1011` | `1111 1011` | bit[2]清**0**，其余不变 ✓        |
| D. `flag |= ~4` | `1111 1111 | 1111 1011` | `1111 1111` | 几乎全部置1（错）                |

**掩码与位编号对应关系：**

| 目标位 | bit[0] | bit[1] | bit[2] | bit[3] | bit[n] |
| ------ | ------ | ------ | ------ | ------ | ------ |
| 掩码值 | 1      | 2      | **4**  | 8      | 2ⁿ     |

**三种位操作口诀：**

- 清零用 `&= ~mask`
- 置一用 `|= mask`
- 翻转用 `^= mask`


---

### 1.5.6 位运算——判断2的幂 【编程题】

> **考点**：利用位运算的数学性质判断2的幂，比循环除2更高效
> **注意**：
>
> **必须单独排除 `x=0`**：`0 & (0-1)` = `0 & (-1)` = `0`，若不加 `x>0` 判断，0会被误判为2的幂
>
> **负数问题**：若 `x` 为有符号数，负数也需排除，`x>0` 已同时处理
>
> **运算符优先级陷阱**：`&` 的优先级低于 `==`，**必须加括号**
>
> - 错误写法：`x & x-1 == 0`（实际等价于 `x & (x-1==0)`，结果完全错误）
> - 正确写法：`(x & (x-1)) == 0`
>
> `x-1` 当 `x=0` 时会发生**无符号数下溢**（若x为unsigned），这也是要先判断 `x>0` 的原因之一

写一语句实现 `x` 是否为2的若干次幂的判断。

~~~c
(x > 0) && ((x & (x - 1)) == 0)
```

**原理图解：**
```
x   = 2³ = 8 → 0000 1000
x-1 =      7 → 0000 0111
x & (x-1)  → 0000 0000 = 0 ✓ 是2的幂

x   =      6 → 0000 0110
x-1 =      5 → 0000 0101
x & (x-1)  → 0000 0100 ≠ 0 ✗ 不是2的幂
~~~

**边界情况验证：**

| x    | x>0  | x & (x-1)    | 结论                    |
| ---- | ---- | ------------ | ----------------------- |
| 0    | ✗    | 短路，不计算 | 假（正确排除）          |
| 1    | ✓    | 1&0 = 0      | **真**（2⁰=1，是2的幂） |
| 2    | ✓    | 2&1 = 0      | 真                      |
| 3    | ✓    | 3&2 = 2 ≠ 0  | 假                      |
| 8    | ✓    | 8&7 = 0      | 真                      |
| -8   | ✗    | 短路，不计算 | 假（正确排除负数）      |

**优先级陷阱对比：**

| 写法               | 实际解析           | 是否正确                                             |
| ------------------ | ------------------ | ---------------------------------------------------- |
| `x & x-1 == 0`     | `x & (x-1==0)`     | ✗ 错误                                               |
| `(x & x-1) == 0`   | `(x & (x-1)) == 0` | ✗ 仍错（`x-1`先算但`&`右侧缺括号在某些编译器有歧义） |
| `(x & (x-1)) == 0` | 完全正确解析       | ✓ 正确                                               |

### 1.5.8 字符运算与 ASCII 【选择题】

> **考点**：字符本质是ASCII整数，可直接参与算术运算，`%c` 输出对应字符
> **注意**：
>
> `'f'` 赋值给 `int x`，x存储的是 `'f'` 的**ASCII码值102**，不是字母本身
>
> `x - 'a'` 计算的是字母 `f` 距离 `a` 的**偏移量**（=5），这是一种常见的"字母位置"计算技巧
>
> `+1` 表示往后移一个字母，`'a' + 6` = 第7个字母 = `'g'`
>
> `printf("%c", ...)` 会将整数**转回对应字符**输出，而 `%d` 则输出数字——注意格式符的区别
>
> 常用ASCII码需记忆：`'a'=97, 'A'=65, '0'=48`，相互之间**不连续**，不可混用。小写大，大写小。

下述程序执行后的输出结果是（  ）

```c
#include <stdio.h>
int main() {
    int x = 'f';
    printf("%c\n", 'a' + (x - 'a' + 1));
}
```

- **A.** g
- **B.** h
- **C.** i
- **D.** j

💡 **答案提示** 

**答案：A**

```c
x = 'f' = 102（ASCII）

x - 'a' = 102 - 97 = 5    // f是字母表中第5个偏移（从0起）
x - 'a' + 1 = 6           // 往后移一位
'a' + 6 = 97 + 6 = 103    // ASCII 103
103 对应字符 → 'g'
```

**常见字母运算模板：**

| 目的                | 写法                     |
| ------------------- | ------------------------ |
| 数字转字符          | `'0' + n`                |
| 字符转数字          | `ch - '0'`               |
| 大小写转换（小→大） | `ch - 'a' + 'A'`         |
| 大小写转换（大→小） | `ch - 'A' + 'a'`         |
| 判断是否小写字母    | `ch >= 'a' && ch <= 'z'` |
| 判断是否数字字符    | `ch >= '0' && ch <= '9'` |

> 💡 **记忆技巧**：把字母表想象成数组，`'a'` 是下标0，`ch - 'a'` 就是取下标，`'a' + n` 就是按下标找字母。


---

### 1.5.9 整数除法精度丢失 【选择题】

> **考点**：整数除法在C中直接截断小数，与浮点除法结果不同
> **注意**：
>
> `1/2` 中两个操作数都是**整型常量**，结果为整型 `0`，与变量类型无关——即使后面有float变量，`1/2` 已经先算完了
>
> C语言除法规则：**只要两个操作数都是整数，结果就是整数**（截断，不是四舍五入）
>
> `*` 和 `/` 同优先级**左结合**，所以 `(a+b) * c * 1 / 2` 中 `/2` 作用于前面已经是浮点数的中间结果
>
> `c / 2` 中 `c` 是 `float`，`2` 是整型，**混合运算会自动提升为浮点除法**，结果为 `1.5`，不会截断
>
> 关键判断依据：**除号两侧是否有浮点数参与**，有则浮点除法，全整数则整数除法

设 `float a=2, b=4, c=3;`，以下表达式中与代数式 `(a+b)*c/2` 计算结果（**9.0**）不一致的是（  ）

- A. `(a + b) * c / 2`
- B. `(1/2) * (a + b) * c`
- C. `(a + b) * c * 1 / 2`
- D. `c / 2 * (a + b)`

💡 **答案提示**

**答案：B**

逐项计算（`a=2, b=4, c=3`，目标值 **9.0**）：

| 选项 | 计算过程                                        | 结果         |
| ---- | ----------------------------------------------- | ------------ |
| A    | `(2+4)*3/2` = `6.0*3/2` = `18.0/2` = **9.0**    | ✓ 一致       |
| B    | `(1/2)*(a+b)*c` = `0*(2+4)*3` = **0.0**         | ✗ **不一致** |
| C    | `(2+4)*3*1/2` = `18.0*1/2` = `18.0/2` = **9.0** | ✓ 一致       |
| D    | `3/2*(2+4)` = `1.5*6.0` = **9.0**               | ✓ 一致       |

**整数除法 vs 浮点除法判断：**

| 表达式                    | 除号两侧类型 | 结果          |
| ------------------------- | ------------ | ------------- |
| `1 / 2`                   | int ÷ int    | **0**（截断） |
| `1.0 / 2`                 | double ÷ int | **0.5**       |
| `c / 2`（c为float）       | float ÷ int  | **1.5**       |
| `(a+b) / 2`（a,b为float） | float ÷ int  | **浮点结果**  |

> 💡 **记忆技巧**：看除号 `/` 的**左右两侧**，只要有一个是浮点数，结果就是浮点；`1/2` 两侧都是整数常量，无论写在哪里都已经等于0了。


---

### 1.5.10 strcmp 返回值 【选择题】

> **考点**：`strcmp` 逐字符比较ASCII值，返回整数
> **注意**：
>
> `strcmp` 比较的是**字符串**，不是数值——`"3.14"` 和 `"3.278"` 是字符序列，不是小数
>
> 逐字符比较：`'3'=='3'` → `'.'=='.'` → `'1'` vs `'2'`，`'1'`的ASCII=49，`'2'`的ASCII=50，49<50，所以返回**负整数**
>
> 返回值只保证：相等→0，前小后大→负整数，前大后小→正整数；**具体数值因编译器而异**，不能假设返回-1或1
>
> 容易误认为比较的是数值大小：数值上 3.14 < 3.278，字符串比较结论相同，但**原因不同**——是因为 `'1'<'2'`，而不是因为数值更小
>
> 需要 `#include <string.h>` 才能使用
>
> `strcmp` 返回值常用于条件判断，应写 `strcmp(s1,s2) == 0` 而非 `strcmp(s1,s2)` 直接当bool用（虽然能跑，但语义不清晰）

表达式 `strcmp("3.14", "3.278")` 的值是一个（  ）

- **A.** 非零整数
- **B.** 浮点数
- **C.** 0
- **D.** 字符

💡 **答案提示**

**答案：A**

```
"3.14"  逐字符：'3'  '.'  '1'  '4'  '\0'
"3.278" 逐字符：'3'  '.'  '2'  '7'  '8'  '\0'
                 ↓    ↓    ↓
                相等  相等  不等！
               '1'(49) < '2'(50) → 返回负整数
```

**strcmp 返回值总结：**

| 情况               | 返回值     |
| ------------------ | ---------- |
| 两字符串完全相等   | **0**      |
| 前者字典序小于后者 | **负整数** |
| 前者字典序大于后者 | **正整数** |

**常见错误用法对比：**

| 写法                        | 问题                               |
| --------------------------- | ---------------------------------- |
| `if (strcmp(s1, s2))`       | 非零为真，能判断不相等，但语义不清 |
| `if (strcmp(s1, s2) == 0)`  | ✓ 推荐，明确判断相等               |
| `if (strcmp(s1, s2) == -1)` | ✗ 错误，返回值不保证是-1           |

> 💡 **记忆技巧**：`strcmp` 返回值可以理解为"前减后"的方向——前者小则负，前者大则正，相等则零。但只是方向参考，不代表具体差值。

---

### 1.5.12 int/bool/float/指针与零值比较 【问答题】

> **考点**：浮点数**不能用 `==` 和 `0` 比较**，必须用精度范围判断；布尔值用 `if(!b)` 更规范
> **注意**：
>
> `int` 与零比较直接用 `== 0` 即可，但 `0 == a` 的**防御性写法**可避免误写成 `a = 0`（赋值），推荐养成习惯
>
> `bool` 变量本身就代表真假，直接用 `if (b)` / `if (!b)`，写 `if (b == true)` 或 `if (b == 1)` 虽然能跑但不规范
>
> `float` 不能用 `==` 与任何值比较——因为浮点数在内存中是近似表示，`0.1 + 0.2 != 0.3`，必须用误差范围判断
>
> `EPSILON` 的大小需根据场景选择：`float` 用 `1e-6`，`double` 用 `1e-9`，不是固定的
>
> 指针写 `if (!p)` 和 `if (p == NULL)` 均正确，但 `if (p == NULL)` **语义更清晰**，推荐在指针判断中使用
>
> `NULL` 必须大写，`null` 在C中不存在（C++/Java才有小写）

写出 `int`、`bool`、`float`、指针变量与"零值"比较的 `if` 语句。

💡 **答案提示**

```c
// int 与零值比较
int a = 0;
if (a == 0)       // 标准写法
if (0 == a)       // 防御性写法，防止误写成 a = 0

// bool 与零值比较
bool b = true;
if (!b)           // ✓ 推荐

// float 与零值比较
#include <math.h>
#define EPSILON 1e-6
float f = 0.1f;
if (fabs(f) < EPSILON)    // ✓ 正确，用误差范围判断
if (f == 0.0f)            // ✗ 错误！浮点数不能用==比较

// 指针与零值比较
int *p = NULL;
if (p == NULL)    // ✓ 推荐，语义清晰
```

**浮点精度问题示例（为什么不能用==）：**

```c
float x = 0.1f + 0.2f;
if (x == 0.3f)           // 结果为假！x实际为0.30000001...
if (fabs(x - 0.3f) < 1e-6)  // ✓ 正确判断方式
```

> 💡 **记忆技巧**：四种类型记忆口诀——整数直接比，布尔用逻辑非，浮点用误差，指针判NULL。

## 1.6 流程控制

### 1.6.1 switch 语句的 fall-through 【分析题】

> **考点**：`switch` 中没有 `break` 会贯穿执行到下一个 `case`
> **注意**：
>
> `switch` 匹配后从对应 `case` 开始执行，**没有 `break` 就继续向下贯穿**，不会再判断下面的 `case` 条件
>
> `default` 不一定在最后，但本题在最后，贯穿时同样会执行
>
> `case 0:` 后面没有任何语句直接接 `case 1:`，这是**有意的 fall-through**，两个case共享同一段代码，是合法且常见的写法
>
> 第(2)题核心是字符运算：`c` 是字符，`c - '2'` 得到的是**相对偏移**，用于匹配case；输出时 `c + 4` 是在原字符ASCII值上加4
>
> `getchar()` 每次读一个字符，`while` 循环对输入串 `2473` 逐字符处理，`'\n'` 作为终止条件

**(1)** 分析以下程序的输出结果：

````c
#include <stdio.h>
int main() {
    int i = 10;
    switch (i) {
        case 9:  i++;
        case 10: i++;
        case 11: i++;
        default: i++;
    }
    printf("result= %d\n", i);
    return 0;
}
```
💡 **答案提示**
```
i = 10，匹配 case 10，从此处开始执行：
case 10: i++ → i = 11
case 11: i++ → i = 12   // 无break，继续贯穿
default: i++ → i = 13   // 无break，继续贯穿
输出：result= 13
````


---

**(2)** 下述程序运行时，如果输入为 `2473`，则输出结果是（  ）

```c
#include <stdio.h>
void main() {
    int c;
    while ((c = getchar()) != '\n')
        switch (c - '2') {
            case 0:
            case 1: putchar(c + 4); break;
            case 2: putchar(c + 4); break;
            case 3: putchar(c + 3); break;
            default: putchar(c + 2); break;
        }
    printf("\n");
}
```

- **A.** 6885
- **B.** 6685
- **C.** 6887
- **D.** 4665
- **E.** 2468

**逐字符推算：**

| 输入字符 c | c的ASCII | c-'2' | 匹配case                       | 操作  | 输出ASCII | 输出字符 |
| ---------- | -------- | ----- | ------------------------------ | ----- | --------- | -------- |
| `'2'`      | 50       | 0     | case 0 → fall-through → case 1 | `c+4` | 54        | `'6'`    |
| `'4'`      | 52       | 2     | case 2                         | `c+4` | 56        | `'8'`    |
| `'7'`      | 55       | 5     | default                        | `c+2` | 57        | `'9'`    |
| `'3'`      | 51       | 1     | case 1                         | `c+4` | 55        | `'7'`    |

输出结果为 `6897`，**选项A（6885）与实际计算不符**，题目选项有误。

------

建议将选项修正为：

- A. 6897 ✓
- B. 6885
- C. 6877
- D. 6997

------

💡 **答案提示**

**答案：A（6897）**

**解题步骤模板：** ① 确定 `c` 的ASCII值 → ② 算 `c-'2'` 匹配哪个case → ③ 注意 case 0 无语句直接fall-through到 case 1 → ④ 用对应操作算输出ASCII → ⑤ 转回字符


---

### 1.6.2 条件判断执行流程 【选择题】

> **考点**：`!`运算符、前缀自减 `--a`、`if-else` 分支执行
> **注意**：
>
> `--a` 是**前缀自减**，先将 `a` 减 1，再将减后的值用于判断，而非先判断再减；
>
> `!0` 为**真**（非零取反为假，零取反为真）；
>
> `if-else` 中 `else` 始终与**最近的未配对 `if`** 结合，本题两个 `if` 各自独立，互不影响；
>
> `x--` 是**后缀自减**，此处直接对 `x` 减 1，结果立即生效（容易与前缀混淆）；
>
> 两个 `if` 是**顺序执行**的独立语句，第一个 `if` 的结果会影响第二个 `if` 的初始值。

下列程序段运行后，`x` 的值是（  ）

```c
a = 1; b = 2; x = 0;
if (!(--a)) x--;
if (!b) x = 7; else ++x;
```

- **A.** 0
- **B.** 3
- **C.** 6
- **D.** 7

**解析：**

第一步：`--a` → `a` 变为 `0`，`!(0)` 为真，执行 `x--`，`x = -1`

第二步：`!b` → `!(2)` 为假，走 `else` 分支，执行 `++x`，`x = 0`

- A. **0** ✓
- B. 3
- C. 6
- D. 7

**答案：A**


---

### 1.6.3 for 循环特殊写法 【问答题】

> **考点**：`for` 语句三部分的省略写法、永真条件、无限循环
> **注意**：
>
> `for` 的三个部分（初始化、条件、迭代）**都可以省略**，但两个分号 `;` **不能省略**；
>
> 条件部分省略时，C语言默认视为**永真**，与显式写 `1` 效果相同；
>
> `for(;1;)` 与 `for(;;)` 与 `while(1)` **三者完全等价**，都是无限循环；
>
> 无限循环本身**不是语法错误**，编译器不会报错，是逻辑层面的问题；
>
> 无限循环并非一定有害，嵌入式/操作系统中主循环常用此写法，但需要内部有 `break` 或 `return` 等退出机制，否则程序永远无法终止。

语句 `for(;1;)` 有什么问题？它是什么意思？

**参考答案：**

`for(;1;)` 是一个**无限循环**语句。

结构分析上，`for` 的初始化部分和迭代部分均被省略，条件部分写的是常量 `1`，在C语言中非零值恒为真，因此循环条件永远成立，循环体会被**无限次执行**，程序无法自然退出该循环。

它等价于以下几种写法：

```c
for(;;)      // 条件省略，默认永真
while(1)     // 最常见的无限循环写法
while(true)  // C99/C++中可用
```

**存在的问题：**

- 这条语句本身**没有语法错误**，可以正常编译；
- 问题在于**逻辑层面**：若循环体内没有 `break`、`return` 或 `exit()` 等退出手段，程序将陷入死循环，无法终止，导致程序"假死"或资源耗尽；
- 在一般应用程序中，这通常是一个**逻辑设计缺陷**。

**补充易错点：**

- 容易误认为省略条件就是"条件为假"从而不执行——实际上恰恰相反，省略条件默认为**真**；
- 容易误认为这是语法错误而认为编译不通过——实际上编译器只检查语法，逻辑问题需要人工判断。

---

### 1.6.4 do...while 与 while的区别 【问答题】

> **考点**：`do...while` 的执行特性、与 `while` 的区别
> **注意**：
>
> `do...while` 是**先执行循环体，再判断条件**，因此至少执行**一次**；
>
> `while` 是**先判断条件，再执行循环体**，条件一开始为假则**一次都不执行**；
>
> `do...while` 末尾的 **分号 `;` 不能省略**，这是语法要求，容易遗漏；
>
> ⚠️ **最重要的陷阱：`while...do` 在C语言中根本不存在！** 这是一个**非法语法**，C语言只有 `do...while`，没有 `while...do`；
>
> 题目中出现 `while...do` 是一个**干扰性的错误概念**，考查学生是否会被表面相似的写法混淆；
>
> `while...do` 是部分伪代码或其他语言（如Pascal）中的写法，不能套用到C语言中。

`do...while` 和 `while...do` 有什么区别？

**对比示例：**

```c
int a = 0;

// while：条件为假，一次不执行
while (a > 0) {
    printf("while执行\n");   // 不会输出
}

// do...while：先执行一次再判断
do {
    printf("do执行\n");      // 输出一次
} while (a > 0);
```

**补充易错点总结：**

- 误以为 `while...do` 是合法的C语法——它**不存在**，不要被题目表述带偏；
- 忘记 `do...while` 末尾的分号，导致编译错误；
- 两种循环条件**相同**时，`do...while` 比 `while` 多执行一次循环体（仅在初始条件为假时体现差异）。

---

## 1.7 函数

### 1.7.1 函数参数传递方式 【选择题】

> **考点**：值传递、指针传递、数组传递（退化为指针）
> **注意**：
>
> 数组名作为参数传递时退化为指针，函数内 `sizeof(a)` 得到的是指针本身大小（32位系统为4字节，64位系统为8字节），而非原数组大小
>
> `void fun(int a[])` 与 `void fun(int *a)` 对编译器完全等价，写成数组形式仅是语义提示，不改变退化为指针的本质；从调用形式看是"数组传递"，从机制本质看是"指针传递"，两者描述同一件事，并不互斥
>
> 指针传递可以在函数内通过解引用修改原变量的值，值传递只修改副本，不影响原变量
>
> 数组传递后可以在函数内修改原数组的元素值，因为本质上操作的是原数组的地址
>
> 要在函数内获取传入数组的长度，必须通过额外手段，不能依赖 `sizeof`

**(1)** 参数传递方式判断：

```c
int fun(int a[], short *ptr, int c) {
    /* ... */
}

int main() {
    int arr[10];
    short val = 100;
    int x = 200;
    fun(arr, &val, x);
    return 0;
}
```

- 请选择所有正确的传递方式描述：（  ）

  - A. `a` 是数组传递（语义形式）
  - B. `a` 的本质是指针传递
  - C. `ptr` 是指针传递
  - D. `c` 是值传递

  **答案：ABCD**

**解析：**

- A和B同时成立且不互斥，`int a[]` 写法在语义上表达"传入数组"，但编译器将其等价处理为 `int *a`，本质是指针传递
- `ptr` 接收 `&val`，直接传入地址，是典型的指针传递
- `c` 接收 `x` 的值的副本，函数内修改 `c` 不影响 `x`，是值传递


---

**(2)** 数组作为函数参数以地址形式传入函数，要在函数内部计算出传入数组的大小；数组作为函数参数怎样传入，有几种方法？ 【问答题】

1. 额外传递长度参数（最常用）

```c
void fun(int a[], int len) { /* 用 len 表示元素个数 */ }
```

2. 传入首尾指针

```c
void fun(int *begin, int *end) { int len = end - begin; }
```

调用时：`fun(arr, arr + 10);`

3. **哨兵值** 约定数组以某个特殊值结尾（如字符串以 `\0` 结尾），函数内遍历直到遇到哨兵值为止。适用于元素值域有限、可划出特殊值的场景。

#### 总结

**① 本质：所有参数传递都是值传递（栈上复制）**

函数调用时所有参数都在栈上创建副本，区别只在于复制的是什么：

| 传递方式 | 栈上复制的内容           | 能否影响外部变量                                 |
| -------- | ------------------------ | ------------------------------------------------ |
| 值传递   | 变量的值本身             | ❌ 只修改副本，不影响外部                         |
| 指针传递 | 指针的值（地址）         | ⚠️ 改指针指向不影响外部，解引用 `*ptr` 可影响外部 |
| 数组传递 | 首元素地址（退化为指针） | ⚠️ 同指针传递，见③                                |

**② 数组传递退化为指针**

- `void fun(int a[])` 与 `void fun(int *a)` 对编译器完全等价，数组形式仅是语义提示
- 从调用形式看是"数组传递"，从机制本质看是"指针传递"，两者描述同一件事，并不互斥
- 退化后 `sizeof(a)` 得到的是**指针本身的大小**（32位系统4字节，64位系统8字节），而非原数组大小，因此不能在函数内用 `sizeof` 获取数组长度

**③ 数组下标是解引用的语法糖**

函数内能通过 `a[i]` 修改原数组元素，原因链条是：

> 数组名退化为指针 → 复制的是首元素地址 → `a[i]` 等价于 `*(a+i)`，本质是解引用 → 操作的是原内存

同理，函数内让 `a` 指向别处不影响外部数组，只有通过下标或解引用操作元素才影响外部。

**④ 函数内获取数组长度必须依赖额外手段**

由于退化后 `sizeof` 失效，常用方法有：额外传递长度参数、传首尾指针、约定哨兵值。`sizeof(a)/sizeof(a[0])` 这类宏只能在数组名**尚未退化前**（与数组定义同作用域处）使用。[跳转使用宏获取数组元素个数](###1.3.1 宏定义求数组元素个数 【编程题】)。

---

### 1.7.2 main 函数参数 【选择题】

> **考点**：`main(int argc, char *argv[])` 的参数含义与规范
> **注意**：
>
> `argc` 统计的是**包含程序名在内**的参数总个数，执行 `./program hello world` 时 `argc = 3`，`argv[0]` 是程序名，`argv[1]` 起才是用户传入的参数
>
> `argv[argc]` 固定为 `NULL`，是参数数组的哨兵值
>
> `char *argv[]` 作为函数参数同样退化为 `char **argv`，与数组传递退化规则一致

**(1)** 若 `main()` 函数带参数，参数个数最多是（  ）

- **A.** 0
- **B.** 1
- **C.** 2
- **D.** 3

**解析：** C标准规定 `main` 函数的带参形式为 `int main(int argc, char *argv[])`，最多两个形参。部分编译器扩展支持第三个参数 `char *envp[]` 用于接收环境变量，但这不属于C标准，考试按标准答C。

**(2) 执行以下命令时，`argc` 的值是（  ）**

```
./program foo bar baz
```

- A. 3
- B. 4
- C. 2
- D. 1

**答案：B**

**解析：** `argc` 统计包含程序名在内的所有参数，`argv[0] = "./program"`，`argv[1] = "foo"`，`argv[2] = "bar"`，`argv[3] = "baz"`，共4个，所以 `argc = 4`。`argv[4] = NULL` 为哨兵值。

**(3) 以下关于 `argv` 的说法正确的是（  ）**

- A. `argv` 是一个字符串
- B. `argv[0]` 是用户传入的第一个参数
- C. `argv[argc]` 的值为 `NULL`
- D. `char *argv[]` 与 `char argv[][]` 等价

**答案：C**

**解析：**

- A错，`argv` 是字符串数组（指针数组）
- B错，`argv[0]` 是程序名本身，用户参数从 `argv[1]` 开始
- C对，`argv[argc]` 固定为 `NULL`，是标准规定的哨兵值
- D错，`char *argv[]` 作为参数退化为 `char **argv`，而 `char argv[][]` 是二维字符数组，两者类型不同


---

### 1.7.3 函数缺省返回类型 【选择题】

> **考点**：C89中未声明返回类型的函数默认返回 `int`
> **注意**：
>
> 本规则属于**C89/C90标准**，C99及之后的标准已取消隐式 `int`，不写返回类型会报错，现代编译器下可能看到警告或错误
>
> 隐式 `int` 规则同样适用于**函数调用前未声明**的情况：C89中调用一个未提前声明的函数，编译器隐式假设其返回 `int`
>
> 缺省返回类型是 `int` 不等于可以省略 `return`，函数体内若没有返回语句或返回了不兼容的类型，行为是未定义的

**(1) 在C89标准中，定义函数时缺省返回类型声明，则函数默认返回类型是（  ）**

- A. void
- B. char
- C. float
- D. int

**答案：D**

**解析：** C89标准规定，函数定义或声明时若省略返回类型，编译器默认其返回类型为 `int`，即 `fun(){}` 等价于 `int fun(){}`。C99之后此规则被取消，省略返回类型会导致编译错误。

------

**(2) 在C89标准中，以下代码的输出结果是（  ）**

c

```c
fun() {
    return 100;
}

int main() {
    printf("%d\n", fun());
    return 0;
}
```

- A. 编译错误
- B. 运行时错误
- C. 100
- D. 0

**答案：C**

**解析：** C89中 `fun()` 缺省返回类型默认为 `int`，`return 100` 合法，输出100。若在C99/C11编译器下编译则会报错。

------

**(3) 在C89标准中，以下关于隐式 `int` 规则说法正确的是（  ）**

- A. 缺省返回类型的函数默认返回 `void`
- B. 调用未声明的函数，编译器隐式假设其返回 `int`
- C. 缺省返回类型的函数可以不写 `return` 语句
- D. C99标准保留了隐式 `int` 规则

**答案：B**

**解析：**

- A错，默认是 `int` 不是 `void`
- B对，C89中调用未声明函数时编译器同样隐式假设返回 `int`，这是隐式int规则的另一个体现
- C错，缺省返回类型是int不代表可以省略return，省略return或返回不兼容类型属于未定义行为
- D错，C99已明确废除隐式int规则


---

## 1.8 字符串与内存操作

### 1.8.1 转义字符 【选择题】

> **考点**：八进制转义 `\ddd`（1-3位，每位只能是0-7）、十六进制转义 `\xhh`（`\x` 后跟1位以上十六进制数字，但值不能溢出char范围）
> **注意**：
>
> 八进制转义每一位只能是 `0-7`，出现 `8` 或 `9` 则非法，如 `'\9'` 是错误的转义字符
>
> 八进制转义最多3位，如 `'\0000'` 四位是错误的
>
> `\x` 后的十六进制位数C标准无硬性上限，但值超出 `char` 可表示范围时行为未定义，考试通常以"超出范围"作为出错依据
>
> `'\000'` 与 `'\0'` 等价，均表示空字符NUL，值为0，是合法的
>
> `'\14'` 是合法的八进制转义，值为十进制12，即换行符 `'\n'`

**(1) 下列转义字符中错误的是（  ）**

- A. `'\000'`
- B. `'\14'`
- C. `'\x1F'`
- D. `'\89'`

**答案：D**

**解析：** `'\89'` 中 `8` 和 `9` 不是合法的八进制数字（八进制只有0-7），因此是非法转义。A是合法八进制，值为0；B是合法八进制，值为12；C是合法十六进制，值为31。

------

**(2) 下列关于转义字符的说法正确的是（  ）**

- A. `'\0000'` 是合法的八进制转义字符
- B. `'\000'` 与 `'\0'` 表示不同的字符
- C. 八进制转义字符每一位可以是 `0-9` 中的任意数字
- D. `'\14'` 的十进制值为12

**答案：D**

**解析：**

- A错，八进制转义最多3位，`'\0000'` 四位非法
- B错，两者均表示空字符NUL，值都是0
- C错，八进制只能用 `0-7`，出现8或9即非法
- D对，`\14` 是八进制14，转十进制为 1×8+4=12

**二进制 / 八进制 / 十六进制转十进制快速方法**

[位运算的对照](###1.5.4 位运算——右移 【选择题】)

**核心公式：从右往左，每一位乘以对应进制的次幂后求和（权值展开法）**

**二进制转十进制：** 每位乘以2的对应次幂

```
1101 → 1×2³ + 1×2² + 0×2¹ + 1×2⁰
     = 8 + 4 + 0 + 1 = 13
```

**八进制转十进制：** 每位乘以8的对应次幂

```
\14 → 1×8¹ + 4×8⁰ = 8 + 4 = 12
```

**十六进制转十进制：** 每位乘以16的对应次幂，A-F对应10-15

```
\x1F → 1×16¹ + 15×16⁰ = 16 + 15 = 31
```


---

### 1.8.2 字符指针与偏移 【选择题】

> **考点**：运算符优先级、`*p+4` 与 `*(p+4)` 的区别、ASCII偏移计算
> **注意**：
>
> 解引用 `*` 的优先级高于加法 `+`，所以 `*p+4` 等价于 `(*p)+4`，是先取值再加4，而非 `*(p+4)`（先偏移指针再取值）
>
> `'a'` 的ASCII值为97，字母 `a-z` 在ASCII表中连续排列，`'a'+n` 就是字母表中第n个之后的字母，如 `'a'+4='e'`
>
> 字符数组 `{"abc\0def"}` 中 `\0` 后面的 `def` 依然存在于内存中，`\0` 只是字符串函数（如 `strlen`、`printf("%s")`）的终止标志，不影响直接下标或指针访问
>
> `printf("%c")` 只输出单个字符，不受 `\0` 影响

**两种读法对比：**

| 表达式   | 含义                    | 计算过程                      | 结果  |
| -------- | ----------------------- | ----------------------------- | ----- |
| `*p+4`   | 先取 `*p` 的值，再加4   | `'a'+4=101`                   | `'e'` |
| `*(p+4)` | 先将指针偏移4位，再取值 | 跳过`a` `b` `c` `\0`，取到`d` | `'d'` |

**(1) 若定义了 `char ch[] = {"abc\0def"}, \*p = ch;`，则执行 `printf("%c", \*p+4);` 的输出结果是（  ）**

- A. def
- B. d
- C. e
- D. 0

**答案：C**

**解析：** `*p` 解引用得到 `ch[0]` 即 `'a'`（ASCII 97），加4得101，对应字符 `'e'`。A错，`%c` 只输出单个字符；B是 `*(p+4)` 的结果，混淆了运算符优先级；D是误以为 `p+4` 指向 `\0`（实际 `\0` 在下标3处）。

------

**(2) 同样条件下，`printf("%c", \*(p+4));` 的输出结果是（  ）**

- A. e
- B. d
- C. \0
- D. 0

**答案：B**

**解析：** `p+4` 将指针偏移4位，`ch` 的内存布局为 `a(0) b(1) c(2) \0(3) d(4) e(5) f(6)`，下标4处是 `'d'`，所以输出 `'d'`。C和D是误以为 `\0` 在下标4处。

------

**(3) 以下关于 `"abc\0def"` 的说法正确的是（  ）**

- A. 该字符串长度为7，`strlen` 返回7
- B. `\0` 后面的 `def` 不存在于内存中
- C. `strlen(ch)` 返回3
- D. `sizeof(ch)` 返回3

**答案：C**

**解析：** `strlen` 遇到 `\0` 停止计数，所以返回3；`\0` 后的 `def` 依然存在于内存中，B错；`sizeof(ch)` 返回数组总字节数，包含所有字符和结尾的 `\0`，共8字节，D错。


---

### 1.8.3 字符串遍历与步长 【分析题】

> **考点**：指针步长、`%s` 打印子串、循环终止条件
> **注意**：
>
> `*bp` 作为循环条件等价于 `*bp != '\0'`，是判断当前字符是否为空字符，而非判断指针是否为NULL
>
> `printf("%s", bp)` 从 `bp` 当前位置打印**直到遇到 `\0`**，是打印子串而非单个字符，与 `printf("%c", *bp)` 完全不同
>
> `bp+=2` 每次跳过2个字符，不是逐字符遍历，可能跳过某些字符但不影响 `%s` 的打印终点
>
> 遇到此类题目，务必手动画出内存布局逐步追踪指针位置

执行下述程序的输出结果：

```c
#include <stdio.h>
char b[] = "ABCDEF";
main() {
    char *bp;
    for (bp = b; *bp; bp += 2)
        printf("%s", bp);
    printf("\n");
}
```

**内存布局：**

```
下标:  0    1    2    3    4    5    6
内容:  A    B    C    D    E    F    \0
```

**逐步追踪：**

| 循环次数 | bp指向下标 | `*bp`                      | 打印内容 |
| -------- | ---------- | -------------------------- | -------- |
| 第1次    | 0          | `'A'`，非`\0`，进入循环    | `ABCDEF` |
| 第2次    | 2          | `'C'`，非`\0`，进入循环    | `CDEF`   |
| 第3次    | 4          | `'E'`，非`\0`，进入循环    | `EF`     |
| 第4次    | 6          | `'\0'`，条件为假，退出循环 | —        |

**最终输出：**

```
ABCDEFCDEFE F
```

注意三次输出之间没有空格或换行，连续拼接在同一行，最后 `printf("\n")` 换行。

------

**(1) 执行上述程序的输出结果是（  ）**

- A. `ABCDEF`
- B. `ACE`
- C. `ABCDEFCDEF EF`
- D. `ABCDEFCDEFEF`

**答案：D**

**解析：** 每次 `printf("%s", bp)` 从当前位置打印到 `\0`，三次分别输出 `ABCDEF`、`CDEF`、`EF`，连续拼接无间隔，共输出 `ABCDEFCDEFEF`。B是误用 `%c` 的结果，C多了空格。

------

**(2) 若将 `bp+=2` 改为 `bp+=3`，输出结果是（  ）**

- A. `ABCDEFDEF`
- B. `ABCDEDEF`
- C. `ABCDEFDEF F`
- D. `ACF`

**答案：A**

**解析：** 步长改为3，逐步追踪：

| 循环次数 | bp指向下标 | `*bp`            | 打印内容 |
| -------- | ---------- | ---------------- | -------- |
| 第1次    | 0          | `'A'`，进入循环  | `ABCDEF` |
| 第2次    | 3          | `'D'`，进入循环  | `DEF`    |
| 第3次    | 6          | `'\0'`，退出循环 | —        |

最终输出 `ABCDEFDEF`。

------

**(3) 若将 `printf("%s", bp)` 改为 `printf("%c", *bp)`，输出结果是（  ）**

- A. `ABCDEF`
- B. `ACE`
- C. `ABCDEFCDEFEF`
- D. `ACD`

**答案：B**

**解析：** `%c` 只打印当前指针指向的单个字符，步长2依次指向下标0、2、4，对应字符 `A`、`C`、`E`，输出 `ACE`。这与 `%s` 打印子串形成鲜明对比。


---

### 1.8.4 memcpy 重叠拷贝行为分析 【分析题】

> **考点**：`memcpy` 重叠行为、逐字节拷贝过程追踪、`memmove` 对比
> **注意**：源和目标重叠时，`memcpy` 的行为是未定义的；实际结果取决于实现

请分析下列程序执行后，数组 `data` 的最终内容是什么：

```c
#include <stdio.h>
#include <string.h>

#define MAX_DATA_SIZE (10)

int main() {
    unsigned int i = 0;
    unsigned char data[MAX_DATA_SIZE] = {1,2,3,4,5,6,7,8,9,0};
    memcpy(&data[2], data, MAX_DATA_SIZE / 2);
    return 0;
}
```

- `memcpy` 源与目标内存区域重叠时行为是**未定义的**，C标准不保证结果正确，实际结果取决于编译器实现
- 本题在**从低地址向高地址逐字节拷贝**的典型实现下分析，这是考试中的约定前提
- 判断是否重叠：源范围 `[src, src+n)`，目标范围 `[dst, dst+n)`，两者有交集即为重叠
- 目标在源**右边**时，从低到高拷贝会先覆盖重叠区域，导致后续读到已被污染的值
  - 有重叠的话，原来的值会被新拷贝的值覆盖了，导致后面从源拷贝的值已经不是原来的值了。
- 目标在源**左边**时，从低到高拷贝不会产生覆盖问题，结果与预期一致
  - 只要读取不被污染，就不会产生问题。
- `memmove` 会检测重叠方向，目标在源右边时改为从高地址向低地址拷贝，结果始终正确
  - 怎么确定高地址的边界呢？通过字节个数和源地址去算高地址，然后从最后一个字节开始往前拷贝

**重叠区域判断：**

```
下标:   0  1  2  3  4  5  6  7  8  9
初始:   1  2  3  4  5  6  7  8  9  0
源:     [---- 5字节 ----]
             src[0..4]
目标:         [---- 5字节 ----]
                  dst[2..6]
重叠:         [--]
               [2..4]
```

**逐字节拷贝过程追踪（低到高）：**

| 步骤  | 操作              | 读取值            | 写入位置  | 数组状态              |
| ----- | ----------------- | ----------------- | --------- | --------------------- |
| 初始  | —                 | —                 | —         | `1 2 3 4 5 6 7 8 9 0` |
| 第1步 | `data[2]=data[0]` | 1                 | `data[2]` | `1 2 1 4 5 6 7 8 9 0` |
| 第2步 | `data[3]=data[1]` | 2                 | `data[3]` | `1 2 1 2 5 6 7 8 9 0` |
| 第3步 | `data[4]=data[2]` | **1（已被污染）** | `data[4]` | `1 2 1 2 1 6 7 8 9 0` |
| 第4步 | `data[5]=data[3]` | **2（已被污染）** | `data[5]` | `1 2 1 2 1 2 7 8 9 0` |
| 第5步 | `data[6]=data[4]` | **1（已被污染）** | `data[6]` | `1 2 1 2 1 2 1 8 9 0` |

**最终结果（典型实现）：** `{1, 2, 1, 2, 1, 2, 1, 8, 9, 0}`

**若改用 `memmove`（从高地址向低地址拷贝）：**

| 步骤  | 操作              | 读取值 | 写入位置  | 数组状态              |
| ----- | ----------------- | ------ | --------- | --------------------- |
| 初始  | —                 | —      | —         | `1 2 3 4 5 6 7 8 9 0` |
| 第1步 | `data[6]=data[4]` | 5      | `data[6]` | `1 2 3 4 5 6 5 8 9 0` |
| 第2步 | `data[5]=data[3]` | 4      | `data[5]` | `1 2 3 4 5 4 5 8 9 0` |
| 第3步 | `data[4]=data[2]` | 3      | `data[4]` | `1 2 3 4 3 4 5 8 9 0` |
| 第4步 | `data[3]=data[1]` | 2      | `data[3]` | `1 2 3 2 3 4 5 8 9 0` |
| 第5步 | `data[2]=data[0]` | 1      | `data[2]` | `1 2 1 2 3 4 5 8 9 0` |

**最终结果（memmove）：** `{1, 2, 1, 2, 3, 4, 5, 8, 9, 0}`

------

**(1) 在从低地址向高地址逐字节拷贝的典型实现下，程序执行后 `data` 的内容是（  ）**

- A. `{1, 2, 1, 2, 3, 4, 5, 8, 9, 0}`
- B. `{1, 2, 1, 2, 1, 2, 1, 8, 9, 0}`
- C. `{1, 2, 3, 4, 5, 6, 7, 8, 9, 0}`
- D. `{1, 2, 1, 2, 1, 8, 9, 0}`

**答案：B**

**解析：** 源和目标重叠，从低到高拷贝时重叠区域的值被提前覆盖，后续步骤读到的是已被污染的值，导致出现循环重复的 `1 2 1 2 1 2 1` 模式。A是使用 `memmove` 的正确结果。

------

**(2) 若将 `memcpy` 改为 `memmove`，`data` 的最终内容是（  ）**

- A. `{1, 2, 1, 2, 1, 2, 1, 8, 9, 0}`
- B. `{1, 2, 1, 2, 3, 4, 5, 8, 9, 0}`
- C. `{1, 2, 3, 4, 5, 4, 5, 8, 9, 0}`
- D. `{1, 2, 3, 4, 5, 6, 7, 8, 9, 0}`

**答案：B**

**解析：** `memmove` 检测到目标在源右边，改为从高地址向低地址拷贝，避免了覆盖问题，结果是预期的 `{1, 2, 1, 2, 3, 4, 5, 8, 9, 0}`。

------

**(3) 以下关于 `memcpy` 和 `memmove` 的说法正确的是（  ）**

- A. `memcpy` 和 `memmove` 在任何情况下结果都相同
- B. 源和目标不重叠时，`memcpy` 和 `memmove` 结果相同
- C. `memcpy` 在重叠时会自动检测方向，保证正确性
- D. `memmove` 比 `memcpy` 慢，任何情况下都应优先使用 `memcpy`

**答案：B**

**解析：** 不重叠时两者行为一致，结果相同；A错，重叠时结果可能不同；C错，自动检测方向的是 `memmove` 而非 `memcpy`；D的说法方向正确（`memmove` 因需判断方向略慢）但结论错误，重叠场景必须用 `memmove`。

#### 总结

**① 数组元素的存储方向与大小端无关**

数组元素**始终从低地址向高地址连续存储**，这是C标准规定的，与大小端无关。

大小端影响的是**单个多字节数据内部的字节排列顺序**：

| 概念         | 影响对象                     | 示例                                      |
| ------------ | ---------------------------- | ----------------------------------------- |
| 数组存储方向 | 元素与元素之间的地址顺序     | `data[0]` 地址 < `data[1]` 地址，永远成立 |
| 大小端       | 单个多字节元素内部的字节顺序 | `int x = 0x12345678`，占4字节，见下表     |

```
内存地址:      低地址 → 高地址
大端存储:      12  34  56  78   （高位字节在低地址）
小端存储:      78  56  34  12   （低位字节在低地址）
```

本题 `data` 是 `unsigned char` 数组，每个元素只占1字节，**不存在多字节内部排列问题**，大小端对本题完全没有影响。`data[0]` 一定在最低地址，`data[9]` 一定在最高地址。

------

**② `memcpy` 与 `memmove` 的参数含义**

两者函数签名完全相同：

```c
void *memcpy (void *dst, const void *src, size_t n);
void *memmove(void *dst, const void *src, size_t n);
```

| 参数   | 含义                   |
| ------ | ---------------------- |
| `dst`  | 目标地址，拷贝到哪里   |
| `src`  | 源地址，从哪里读数据   |
| `n`    | 拷贝的**字节数**       |
| 返回值 | 返回 `dst`，一般不使用 |

注意点：

- 参数顺序是**dst在前，src在后**，与赋值语句 `dst = src` 的书写习惯一致，但容易和 `strcpy(dst, src)` 混淆记反
- 第三个参数是**字节数**而非元素个数，拷贝 `int` 数组时需要乘以 `sizeof(int)`，如 `memcpy(dst, src, 5 * sizeof(int))`
- 本题 `memcpy(&data[2], data, MAX_DATA_SIZE / 2)` 中，`dst=&data[2]`，`src=data`（即`&data[0]`），`n=5`字节

## 1.9 内存管理

### 1.9.1 栈与堆的区别 【问答题】

> **考点**：栈与堆的管理方式、生命周期、典型用法及堆上分配的注意事项
> **注意**：
>
> 栈由系统自动管理，但空间有限（通常几MB），局部数组过大或递归过深会导致**栈溢出**（stack overflow），并非无限安全
>
> `free(p)` 释放内存后 `p` 变为**悬空指针**（dangling pointer），仍指向原地址，再次访问是未定义行为；习惯上应在 `free` 后立即执行 `p = NULL`
>
> `malloc` 返回 `void*`，C语言中会自动隐式转换为任意指针类型，**不需要强制类型转换**；
>
> 内存模型中的"堆"与数据结构中的"堆（二叉堆/优先队列）"**名字相同但概念无关**

"栈 stack"和"堆 heap"有什么区别？写两个函数分别在栈上和堆上分配内存，在堆上分配内存应注意哪些问题？

**栈与堆对比：**

| 对比项   | 栈（Stack）       | 堆（Heap）                   |
| -------- | ----------------- | ---------------------------- |
| 管理方式 | 系统自动分配/回收 | 程序员手动 `malloc/free`     |
| 空间大小 | 较小（通常几MB）  | 较大（取决于系统内存）       |
| 分配速度 | 快（移动栈指针）  | 慢（查找空闲块）             |
| 碎片     | 无                | 有                           |
| 生命周期 | 函数结束自动释放  | 手动释放前一直存在           |
| 风险     | 栈溢出            | 内存泄漏、悬空指针、重复释放 |

**栈上分配示例：**

```c
void stack_alloc() {
    int a = 10;              /* 基本类型，栈上 */
    int arr[100];            /* 数组，栈上，函数返回后自动释放 */
    /* 注意：不能返回局部变量的地址，函数结束后栈帧销毁 */
}
```

**堆上分配示例：**

```c
void heap_alloc() {
    int *p = malloc(sizeof(int) * 100);  /* 堆上分配100个int */
    if (p == NULL) {                      /* ① 必须检查返回值 */
        /* 处理分配失败 */
        return;
    }
    /* 使用内存 */
    p[0] = 1;
    free(p);       /* ② 用完必须释放，否则内存泄漏 */
    p = NULL;      /* ③ free后置NULL，避免悬空指针 */
    /* free(p);    ④ 重复释放是未定义行为，置NULL后再free是安全的 */
}
```

**堆上分配的注意事项：**

① **检查返回值：** `malloc` 分配失败时返回 `NULL`，不检查直接使用会导致空指针解引用崩溃

② **用完必须释放：** 不调用 `free` 会导致内存泄漏，长期运行的程序会耗尽内存

③ **free后置NULL：** 避免悬空指针，置NULL后即使误操作也会触发可排查的空指针错误而非未定义行为

④ **避免重复释放：** 对同一指针调用两次 `free` 是未定义行为，可能导致程序崩溃；`free(NULL)` 是安全的无操作

⑤ **分配与释放配对：** `malloc` 和 `free` 必须成对出现，在同一层级管理，避免所有权混乱


---

### 1.9.2 结构体的使用场景 【问答题】

> **考点**：结构体的封装思想、与全局变量的对比、使用注意事项
> **注意**：
>
> 结构体作为函数参数时是**整体值拷贝**，结构体较大时应传指针 `struct Point *p` 而非直接传值，避免拷贝开销
>
> 全局变量的核心问题不只是风格，而是**任何地方都可以修改**，数据流向难以追踪，多线程下还存在竞态条件风险
>
> 结构体可以**嵌套**其他结构体，也可以包含指向自身的**指针**（用于链表、树等），但不能包含自身类型的**值**（大小无限递归，编译报错）
>
> 结构体存在**内存对齐**，实际大小不等于各成员大小之和，编译器会插入填充字节（padding），`sizeof(struct)` 结果可能超出预期

结构体的使用场景，为啥不用全局变量？

**结构体的使用场景：**

结构体将描述同一事物的相关数据封装在一起，适用于以下场景：

**描述一个实体的多个相关属性**

```c
struct Student {
    int id;
    char name[32];
    float score;
};
```

**函数间传递多个相关数据**

```c
/* 不用结构体：参数列表冗长，容易传错顺序 */
void print_student(int id, char *name, float score);

/* 用结构体：清晰，扩展方便 */
void print_student(struct Student *s);
```

**函数返回多个值**

```c
struct MinMax {
    int min;
    int max;
};

struct MinMax find_minmax(int arr[], int len) {
    struct MinMax result;
    /* ... */
    return result;
}
```

------

**为什么不用全局变量：**

全局变量谁都能改、难追踪、难维护；结构体把数据封装起来跟着调用走，可控、清晰、安全。

**传参方式选择：**

```c
/* 小结构体（几个基本类型成员）：直接传值 */
void move(struct Point p, int dx, int dy);

/* 大结构体：传指针，避免拷贝开销 */
void process(struct BigData *data);

/* 只读时加 const，明确语义 */
void print_student(const struct Student *s);
```


---

## 1.11 编译与链接

### 1.11.1 编译错误 vs 运行时错误 【选择题】

> **考点**：三类错误的区分——编译错误、运行时错误、逻辑错误
> **注意**：
>
> - 三类错误的本质区别：
>
> | 错误类型   | 发现时机   | 典型表现                                     |
> | ---------- | ---------- | -------------------------------------------- |
> | 编译错误   | 编译阶段   | 语法违规，编译器报错，无法生成可执行文件     |
> | 运行时错误 | 程序运行中 | 程序崩溃，如**除零、空指针解引用、栈溢出**   |
> | 逻辑错误   | 程序运行后 | 程序正常运行但结果不符合预期，编译器无法检测 |
>
> - `x==5;` 语法合法，是比较表达式作为语句，编译通过；但本意是赋值却写成比较，属于**逻辑错误**，不要误认为是运行时错误
> - 现代编译器对 `x==5;` 加 `-Wall` 会产生**警告**，但警告不是错误，不影响编译通过，不要把警告误认为编译错误
> - C语言每条语句都必须以分号结尾，**没有例外**，复合语句最后一条语句同样需要分号

**(1) 下列各个错误中，哪一个不属于编译错误（  ）**

- A. 改变 `x` 原值为5，写作 `x==5;`
- B. 花括号不配对
- C. 复合语句中的最后一条语句后未加分号
- D. 变量有引用、无定义

**答案：A**

**解析：** `x==5;` 语法上合法，编译器不会报错，属于逻辑错误。B是典型语法错误；C中每条语句都必须有分号，缺少分号是编译错误；D中使用未定义的变量编译器会报"未声明的标识符"错误。

------

**(2) 以下哪种错误属于运行时错误（  ）**

- A. 缺少头文件
- B. 变量未声明就使用
- C. 对空指针进行解引用
- D. 将 `==` 误写成 `=` 导致判断逻辑错误

**答案：C**

**解析：** 空指针解引用在运行时触发段错误（Segmentation Fault），是典型的运行时错误。A和B是编译错误；D是逻辑错误，程序能正常运行但结果不符合预期。

------

**(3) 以下关于 `x==5;` 的说法正确的是（  ）**

- A. 是编译错误，因为比较结果没有被使用
- B. 是运行时错误，程序会崩溃
- C. 语法合法，编译通过，但属于逻辑错误
- D. 加 `-Wall` 编译后会报编译错误

**答案：C**

**解析：** `x==5;` 是合法的表达式语句，编译通过；加 `-Wall` 只会产生警告而非错误，D错；程序不会崩溃，B错；属于逻辑错误而非编译错误，A错。


---

### 1.11.2 静态库和动态库的区别 【问答题】

> **考点**：静态库与动态库的链接方式、优缺点及适用场景
> **注意**：
>
> 动态库分两种加载方式：**隐式链接**（程序启动时由OS自动加载）和**显式链接**（运行中手动调用 `dlopen`/`LoadLibrary`），不只是笼统的"运行时加载"
>
> 动态库"更新无需重新编译"的前提是**接口不变**，若函数签名改变仍需重新编译调用方
>
> 静态库无外部库依赖，但其内部若调用了系统函数，这些系统依赖仍然存在，只是被打包进了可执行文件
>
> 多个静态库中若有同名函数会产生**符号冲突**，动态库有独立命名空间，冲突风险更低

静态库和动态库的区别。

**核心区别对比：**

| 对比项         | 静态库（`.a`/`.lib`）            | 动态库（`.so`/`.dll`）                    |
| -------------- | -------------------------------- | ----------------------------------------- |
| 链接时机       | 编译时链接，代码打包进可执行文件 | 运行时加载（启动自动或手动 `dlopen`）     |
| 可执行文件体积 | 大（库代码被复制进去）           | 小（只保存引用）                          |
| 内存占用       | 多个进程各自持有一份             | 多个进程共享同一份                        |
| 依赖关系       | 无外部库依赖，独立运行           | 需要运行环境中存在对应的库文件            |
| 更新方式       | 需重新编译链接                   | 接口不变时替换库文件即可，无需重新编译    |
| 符号冲突       | 多库同名函数易冲突               | 独立命名空间，冲突风险低                  |
| 适用场景       | 嵌入式、对依赖敏感的发布环境     | 桌面/服务器应用、插件系统、频繁更新的模块 |

**动态库两种加载方式：**

```c
/* 隐式链接：编译时指定，程序启动时OS自动加载 */
/* gcc main.c -lmylib -o main */
#include "mylib.h"
mylib_func();   /* 直接调用，OS负责加载 */
```

**静态库：**

```makefile
# Makefile 中链接静态库
gcc main.c -L./lib -lmylib -o main
# -L 指定库文件搜索路径
# -l 指定库名（libmylib.a 去掉 lib 前缀和 .a 后缀）
```

**动态库：**

```makefile
# 编译时指定（隐式链接），和静态库写法一样
gcc main.c -L./lib -lmylib -o main

# 但运行时还需要能找到 .so 文件，有三种方式：
# ① 设置环境变量（临时，常用于开发调试）
export LD_LIBRARY_PATH=./lib:$LD_LIBRARY_PATH

# ② 把库拷贝到系统目录（全局生效）
cp libmylib.so /usr/lib/

# ③ 在 /etc/ld.so.conf 中添加路径后执行 ldconfig（全局生效）
ldconfig
```

**Makefile 完整示例：**

```makefile
CC = gcc
CFLAGS = -Wall
LDFLAGS = -L./lib        # 库搜索路径
LIBS = -lmylib           # 链接的库

main: main.c
    $(CC) $(CFLAGS) main.c $(LDFLAGS) $(LIBS) -o main
```

**编译时如何决定链接静态还是动态：**

```makefile
# 强制静态链接
gcc main.c -L./lib -static -lmylib -o main

# 默认优先动态库，没有 .so 才用 .a
gcc main.c -L./lib -lmylib -o main
```

**一句话总结（适合面试）：**

> 静态库编译时把代码直接打包进可执行文件，独立性强但体积大、每次改库都要重新编译；动态库运行时才加载，多个进程可以共享同一份，体积小，只要接口不变替换库文件就能热更新，但部署时要确保运行环境里有对应的库文件

## 1.12 编程题（C语言基础类）

### 1.12.1 用指针方法对 N 个整数由大到小排序 【编程题】

> **考点**：指针遍历数组、排序算法（冒泡/选择排序）
> **注意**：通过指针操作数组元素，注意指针运算和解引用

---

### 1.12.2 解二次方程 【编程题】

> **考点**：判别式 `Δ = b²-4ac` 的计算、浮点数处理、引用参数返回多值
> **注意**：需处理 `a=0`、`Δ<0`、`Δ=0`、`Δ>0` 四种情况

```c
int Quadratic(double a, double b, double c, double& x1, double& x2);
// 返回值：解的个数
```

---

### 1.12.3 斐波那契数列（递归与循环）【编程题】

> **考点**：递归实现简洁但效率低（指数级时间复杂度）；循环实现高效（O(n)）
> **注意**：递归实现需注意栈溢出风险；可用尾递归或记忆化优化

请用C语言实现斐波那契数列（使用递归与循环两种方式）。

---

### 2.1 内存管理经典题 【分析题】

#### 2.1.1 指针值传递问题

```c
void GetMemory(char *p)
{
    p = (char *)malloc(100);
}

void Test(void)
{
    char *str = NULL;
    GetMemory(str);
    strcpy(str, "hello world");
    printf(str);
}
```

请问运行 `Test` 函数会有什么样的结果？

<details><summary>💡 答案提示</summary>
<p><b>结果：崩溃（段错误）</b></p>
<ol>
<li><code>GetMemory(str)</code> 传的是指针的<b>值拷贝</b>（值传递），函数内 <code>p = malloc(100)</code> 只修改了局部变量 <code>p</code>，<b>str 仍然是 NULL</b></li>
<li><code>strcpy(str, "hello world")</code> 向 NULL 指针写入 → <b>程序崩溃</b></li>
<li>同时存在内存泄漏：<code>malloc</code> 分配的内存无法被外部访问，也没有 <code>free</code></li>
</ol>
<p><b>正确写法：</b>使用二级指针 <code>void GetMemory(char **p)</code>，传入 <code>&str</code></p>
</details>

---

#### 2.1.2 返回局部数组问题

```c
char *GetMemory(void)
{
    char p[] = "hello world";
    return p;
}

void Test(void)
{
    char *str = NULL;
    str = GetMemory();
    printf(str);
}
```

请问运行 `Test` 函数会有什么样的结果？

<details><summary>💡 答案提示</summary>
<p><b>结果：输出乱码（未定义行为）</b></p>
<ol>
<li><code>p[]</code> 是<b>局部数组</b>，存储在<b>栈</b>上。函数返回后栈帧被销毁，<code>p</code> 的内存被回收</li>
<li><code>return p</code> 返回的是一个<b>悬空指针（dangling pointer）</b>，指向已被释放的栈内存</li>
<li><code>printf(str)</code> 读取该地址 → <b>输出乱码</b></li>
</ol>
<p><b>注意：</b>如果改为 <code>char *p = "hello world"</code>（字符串字面量存储在常量区），则返回是合法的</p>
</details>

---

#### 2.1.3 二级指针正确用法

```c
void GetMemory2(char **p, int num)
{
    *p = (char *)malloc(num);
}

void Test(void)
{
    char *str = NULL;
    GetMemory2(&str, 100);
    strcpy(str, "hello");
    printf(str);
}
```

请问运行 `Test` 函数会有什么样的结果？

<details><summary>💡 答案提示</summary>
<p><b>结果：能正确输出 "hello"，但存在内存泄漏</b></p>
<ol>
<li>这里用了<b>二级指针</b> <code>char **p</code>，传入 <code>&str</code>，通过 <code>*p = malloc(num)</code> <b>成功修改了外部的 str</b></li>
<li><code>strcpy</code> 和 <code>printf</code> 都能正常执行</li>
<li>问题：最后没有 <code>free(str)</code>，造成<b>内存泄漏</b></li>
</ol>
<p><b>关键区别（对比第1题）：</b>第1题是值传递，第3题是地址传递，这是第1题的<b>正确写法</b></p>
</details>

---

#### 2.1.4 free后未置NULL问题

```c
void Test(void)
{
    char *str = (char *)malloc(100);
    strcpy(str, "hello");
    free(str);

    if (str != NULL)
    {
        strcpy(str, "world");
        printf(str);
    }
}
```

请问运行 `Test` 函数会有什么样的结果？

<details><summary>💡 答案提示</summary>
<p><b>结果：未定义行为（野指针/悬空指针操作）</b></p>
<ol>
<li><code>free(str)</code> 释放了内存，但 <b>str 指针的值没有被置为 NULL</b></li>
<li><code>free</code> 不会自动将指针设为 NULL，所以 <code>str != NULL</code> 判断为 <b>true</b></li>
<li><code>strcpy(str, "world")</code> 向<b>已释放的内存</b>写入 → <b>未定义行为</b>，可能崩溃或破坏其他数据</li>
</ol>
<p><b>正确写法：</b></p>
<pre><code>free(str);
str = NULL;  // 关键！释放后立即置空</code></pre>
</details>

---

### 2.2 for循环优化 【问答题】

请简述以下两个for循环的优缺点：

```c
// 第一种：循环内判断
for (i = 0; i < N; i++)
{
    if (condition)
        DoSomething();
    else
        DoOtherThing();
}

// 第二种：循环外判断
if (condition)
{
    for (i = 0; i < N; i++)
        DoSomething();
}
else
{
    for (i = 0; i < N; i++)
        DoOtherThing();
}
```

<details><summary>💡 答案提示</summary>
<p><b>第一种（循环内判断）：</b></p>
<ul>
<li>优点：代码简洁，逻辑清晰，容易理解</li>
<li>缺点：每次循环都要做一次 <code>condition</code> 判断，<b>多了 N 次判断开销</b></li>
</ul>
<p><b>第二种（循环外判断）：</b></p>
<ul>
<li>优点：<code>condition</code> 只判断一次，循环体内无分支，<b>运行效率高</b></li>
<li>缺点：代码冗余，两个 for 循环重复，不易维护</li>
</ul>
<p><b>选择建议：</b></p>
<ul>
<li>如果 N 较小，优先选第一种（可读性优先）</li>
<li>如果 N 很大且 condition 与循环无关（循环不变量），优先选第二种（性能优先）</li>
<li>现代编译器优化可能会自动将第一种优化为第二种（循环不变量外提）</li>
</ul>
</details>

---

### 2.3 #include区别 【问答题】

`#include <filename.h>` 和 `#include "filename.h"` 有什么区别？

<details><summary>💡 答案提示</summary>
<table>
<tr><th>写法</th><th>搜索顺序</th></tr>
<tr><td><code><filename.h></code></td><td>编译器<b>只在</b>标准库/系统头文件目录中搜索（如 <code>/usr/include</code>、编译器自带的 <code>include</code> 目录）</td></tr>
<tr><td><code>"filename.h"</code></td><td>编译器<b>先在</b>当前源文件所在目录（或项目目录）搜索，<b>找不到再去</b>标准库路径搜索</td></tr>
</table>
<p><b>示例：</b></p>
<ul>
<li><code><stdio.h></code> → 搜索 <code>/usr/include/stdio.h</code>（系统路径）</li>
<li><code>"myheader.h"</code> → 先搜索 <code>./myheader.h</code>（当前目录），找不到再去系统路径</li>
</ul>
</details>

---

### 2.4 sizeof计算 【计算题】

以下为Windows NT下的32位C++程序，请计算sizeof的值：

```c
char str[] = "Hello";
char *p = str;
int n = 10;

1. sizeof(str) = 
2. sizeof(p) = 
3. sizeof(n) = 

void Func(char str[100])
{
4. sizeof(str) = 
}

void *p = malloc(100);
5. sizeof(p) = 
```

<details><summary>💡 答案提示</summary>
<ol>
<li><code>sizeof(str) = 6</code> — 字符串 <code>"Hello"</code> 有5个字符 + 1个 <code>'\0'</code> 结尾符 = 6字节</li>
<li><code>sizeof(p) = 4</code> — 32位系统下，任何类型的指针大小都是4字节</li>
<li><code>sizeof(n) = 4</code> — 32位系统下 <code>int</code> 为4字节</li>
<li><code>sizeof(str) = 4</code> — 数组作为函数参数时<b>退化为指针</b>，不再保留数组长度信息</li>
<li><code>sizeof(p) = 4</code> — <code>void*</code> 也是指针，32位下为4字节</li>
</ol>
<p><b>注意：</b>如果是64位系统，第2、4、5题答案变为 <b>8</b></p>
</details>

---

### 2.5 结构体赋值 【选择题】

对于以下stTest结构体赋值，正确的说法是？

```c
typedef struct
{
    u8 Bass;
    u8 Treble;
    u16 eq[3];
    u8 *pPEQTable;   
} stSoundModeSeting;

stSoundModeSeting stTest;
stSoundModeSeting stDefault = {50, 50, {10, 10, 10}, NULL};
```

- A：所有逐一成员赋值
- B：可使用如下赋值 `memcpy(&stTest, &stDefault, sizeof(stTest));`
- C：可使用如下赋值 `stTest = stDefault;`

<details><summary>💡 答案提示</summary>
<p><b>答案：B、C</b></p>
<ul>
<li>B：<code>memcpy</code>整体拷贝 —— 正确，按内存逐字节复制</li>
<li>C：<b>C语言支持同类型结构体之间直接用<code>=</code>赋值！</b> 这是合法操作，编译器会自动进行成员逐一拷贝</li>
</ul>
<p><b>考点：</b>C语言结构体赋值的三种方式：①逐一成员赋值 ②<code>memcpy</code>整体拷贝 ③直接<code>=</code>赋值</p>
</details>

---

### 2.6 const指针 【选择题】

如下哪个表示一个指向整数型的常指针?

```c
A: int *const a;
B: int const *a;
C: 以上都不对
D: const int *a;
```

<details><summary>💡 答案提示</summary>
<p><b>答案：A <code>int *const a;</code></b></p>
<p>口诀：<b>const在<code>*</code>左修饰指向的值，const在<code>*</code>右修饰指针本身</b></p>
<table>
<tr><th>声明</th><th>含义</th></tr>
<tr><td><code>int *const a</code></td><td>指针本身不可变（常指针），指向的值可变 ✓</td></tr>
<tr><td><code>const int *a</code> 或 <code>int const *a</code></td><td>指向的值不可变（常量指针），指针本身可变</td></tr>
</table>
</details>

---

### 2.7 字符串赋值 【选择题】

下面各语句中，能正确进行赋字符串操作的语句是？

```c
A: char s[5] = {'a','b','c','d','e','\0'};
B: char *s; s = "abcde";
C: char *s; scanf("%s", &s);
D: char s[5] = {"abcde"};
```

<details><summary>💡 答案提示</summary>
<p><b>答案：B <code>char *s; s = "abcde";</code></b></p>
<table>
<tr><th>选项</th><th>分析</th></tr>
<tr><td>A</td><td><code>char s[5]</code> 数组大小为5，但初始化列表有6个元素，<b>数组越界</b>，编译器会报错</td></tr>
<tr><td>B</td><td>正确，指针指向字符串字面量首地址 ✓</td></tr>
<tr><td>C</td><td>试图通过一个<b>未初始化的指针</b>来接收输入数据。指针没有指向合法缓冲区</td></tr>
<tr><td>D</td><td><code>"abcde"</code>含隐含的<code>\0</code>共6字节，数组只有5字节，<b><code>\0</code>被截断</b>，结果不是合法的C字符串</td></tr>
</table>
</details>

---

### 2.8 malloc存储位置 【选择题】

C语言中，malloc函数申请到的空间储存在哪个位置？

```c
A: BSS段
B: 栈区
C: 堆区
D: data段
```

<details><summary>💡 答案提示</summary>
<p><b>答案：C 堆区</b></p>
<table>
<tr><th>内存区域</th><th>存储内容</th></tr>
<tr><td>BSS段</td><td>未初始化的全局变量和静态变量</td></tr>
<tr><td>栈区</td><td>局部变量、函数参数、返回地址</td></tr>
<tr><td><b>堆区</b></td><td><b>动态分配的内存（malloc/calloc/realloc申请）</b></td></tr>
<tr><td>data段</td><td>已初始化的全局变量和静态变量</td></tr>
</table>
</details>

---

### 2.9 函数类型题 【选择题】

以下不正确的说法是？

```c
A: 如果函数值的类型与返回值类型不一致，以函数值类型为准
B: return后边的值不能为表达式
C: 如果形参与实参类型不一致，以实参类型为准
D: 定义函数时，形参的类型说明可以放在函数体内
```

<details><summary>💡 答案提示</summary>
<p><b>答案：B、C、D</b></p>
<table>
<tr><th>选项</th><th>分析</th></tr>
<tr><td>A</td><td>正确说法：函数声明的返回类型与实际return值类型不一致时，以<b>函数声明的返回类型为准</b>（隐式类型转换）</td></tr>
<tr><td>B</td><td><b>不正确</b>：return后面当然可以接表达式，如<code>return a + b;</code>、<code>return x > 0 ? x : -x;</code></td></tr>
<tr><td>C</td><td><b>不正确</b>：形参与实参类型不一致时，以<b>形参类型为准</b>（实参被隐式转换为形参类型），不是以实参类型为准</td></tr>
<tr><td>D</td><td><b>不正确</b>：形参类型说明应写在函数头部的参数列表中，不能放在函数体内</td></tr>
</table>
<p><b>考点：</b>C语言函数的类型转换规则——无论是返回值还是参数传递，都是<b>被调用方的声明类型为准</b>（函数返回类型、形参类型）</p>
</details>

---

# 二、算法与数据结构

## 2.1 排序算法

### 2.1.1 快速排序 【编程题】

> **考点**：分治思想、基准选择、时间复杂度（最佳/平均 O(nlogn)，最差 O(n²)）
> **注意**：快排不稳定——相等元素的相对顺序可能改变；最差情况出现在已排序数组

1. 用自己的思路介绍快速排序。
2. 实现快速排序。
3. 如果一个数组中的元素表示VIP等级，顺序是按申请VIP的时间先后排序，快速排序能否将高等级的VIP排在前面且保持原有时间顺序？

<details><summary>💡 答案提示</summary>
<p><b>不能。</b>快排是<b>不稳定</b>排序，无法保证相等元素的原有顺序。需要使用归并排序等稳定排序算法。</p>
</details>

---

### 2.1.2 排序算法时间复杂度 【选择题】

> **考点**：各排序算法最好/平均/最差时间复杂度对比
> **注意**：冒泡和插入的最差复杂度都是 O(n²)

**(1)** 使用快速排序对n个数进行排序，其在最佳情况、平均情况、最差情况下的时间复杂度分别是（  ）。

<details><summary>💡 答案提示</summary>
<table>
<tr><th>情况</th><th>时间复杂度</th></tr>
<tr><td>最佳</td><td>O(nlogn)</td></tr>
<tr><td>平均</td><td>O(nlogn)</td></tr>
<tr><td>最差</td><td>O(n²)</td></tr>
</table>
</details>

---

**(2)** 若有8个待排序元素，采用冒泡排序和插入排序最大时间复杂度分别是（  ）。

<details><summary>💡 答案提示</summary>
<p>两者最差时间复杂度均为 <b>O(n²)</b>，即 8² = <b>64次比较</b>。</p>
</details>

---

### 2.1.3 二分查找 【问答题】

> **考点**：有序数组中查找元素，每次将搜索范围减半，O(logn)
> **注意**：前提是数组有序；注意中间值计算防溢出：`mid = left + (right - left) / 2`

用自己的思路介绍二分查找，以及快排和二分法的区别。

---

## 2.2 链表

### 2.2.1 单链表基本操作 【编程题】

> **考点**：链表节点定义、插入、删除操作
> **注意**：注意头节点处理、空链表处理、内存申请失败处理

**(1)** 单链表结构定义及指定位置插入节点：

```c
typedef struct Node {
    int data;
    struct Node *next;
} Node;

int insert_node(Node *head, int pos, int value);
```

功能说明：
- 在链表的第 `pos` 个位置插入值为 `value` 的新节点
- 插入成功返回 1，失败返回 0
- 位置从 0 开始，假设链表带头结点

边界情况：①头部插入 ②尾部插入 ③位置越界 ④空链表 ⑤内存申请失败

---

**(2)** 单链表插入一个新的节点。 【编程题】

---

**(3)** 链表的有序插入。 【编程题】

---

### 2.2.2 链表倒序/反转 【编程题】

> **考点**：三指针法（prev/curr/next）逐个翻转指针方向
> **注意**：注意处理空链表和单节点链表

1. 如何实现链表的倒序？
2. 将一个链表倒序。

<details><summary>💡 答案提示</summary>
<p>三指针迭代法：</p>
<pre><code>Node* reverse(Node* head) {
    Node *prev = NULL, *curr = head, *next;
    while (curr) {
        next = curr->next;
        curr->next = prev;
        prev = curr;
        curr = next;
    }
    return prev;
}</code></pre>
</details>

---

### 2.2.3 链表判环 【问答题】

> **考点**：快慢指针法——快指针每次走2步，慢指针走1步，相遇则有环
> **注意**：还可进一步求环的入口点和环的长度

怎么判断链表中是否有环？

<details><summary>💡 答案提示</summary>
<p><b>快慢指针法（Floyd 判环算法）：</b></p>
<ul>
<li>慢指针每次走 1 步，快指针每次走 2 步</li>
<li>若有环，两者必在环内相遇</li>
<li>若快指针到达 NULL，则无环</li>
</ul>
<p>进阶：相遇后，将一个指针移回头节点，两个指针都每次走1步，再次相遇点即为<b>环入口</b>。</p>
</details>

---

### 2.2.4 链表元素互换位置 【编程题】

> **考点**：交换链表中两个节点需同时修改前驱节点的指针
> **注意**：注意相邻节点交换的特殊情况

---

### 2.2.5 双向链表操作 【编程题】

> **考点**：双向链表的插入和删除需同时维护 `prev` 和 `next` 指针
> **注意**：什么时候用双向链表——需要双向遍历、频繁删除指定节点时

1. 什么时候用双向链表？
2. 编程实现一个双向链表的删除过程。

---

### 2.2.6 链表按值三路划分（分区问题）【编程题】

> **考点**：使用三对头尾指针分别收集小于/等于/大于目标值的节点，最后拼接
> **注意**：要求保持每个分区内节点的原有相对顺序不变；O(n) 时间，O(1) 额外空间

给定单链表头指针 `head` 和整数 `val`，对链表进行重排：

- `data < val` 排在左侧
- `data == val` 排在中间
- `data > val` 排在右侧

```c
typedef struct Linklist {
    int data;
    struct Linklist *next;
} Linklist;
```

要求：不修改数据域、不使用数组、O(n) 时间。

---

### 2.2.7 求取单链表中间位置的值 【编程题】

> **考点**：快慢指针法——快指针走2步、慢指针走1步，快指针到末尾时慢指针在中间
> **注意**：偶数个节点时返回第一个中间节点

---

### 2.2.8 链表与数组的区别 【问答题】+【选择题】

> **考点**：数组连续内存、随机访问O(1)、插入删除O(n)；链表非连续、顺序访问、插入删除O(1)
> **注意**：链表额外开销大（指针域），缓存不友好

**(1)** 链表与数组的区别。 【问答题】

<details><summary>💡 答案提示</summary>
<table>
<tr><th>对比项</th><th>数组</th><th>链表</th></tr>
<tr><td>内存布局</td><td>连续</td><td>非连续</td></tr>
<tr><td>随机访问</td><td>O(1)</td><td>O(n)</td></tr>
<tr><td>插入/删除</td><td>O(n)</td><td>O(1)（已知位置）</td></tr>
<tr><td>空间开销</td><td>无额外开销</td><td>每节点多一个指针域</td></tr>
<tr><td>缓存友好</td><td>是</td><td>否</td></tr>
<tr><td>大小</td><td>固定（静态数组）</td><td>动态伸缩</td></tr>
</table>
</details>

---

**(2)** 关于链表，描述正确的选项有（  ） 【选择题】

- **A.** 在运行时可以动态添加
- **B.** 物理空间不连续，空间开销更大
- **C.** 查找元素不需要顺序查找
- **D.** 可在任意节点位置插入元素

<details><summary>💡 答案提示</summary>
<p><b>答案：A、B、D</b></p>
<p>C 错误：单链表查找只能<b>顺序遍历</b>，时间复杂度 O(n)。</p>
</details>

---

## 2.3 栈与队列

### 2.3.1 栈的使用场景 【问答题】

> **考点**：函数调用栈、表达式求值、括号匹配、DFS等
> **注意**：后进先出（LIFO）特性决定了其适用场景

什么时候用栈？

---

### 2.3.2 用两个栈实现队列 【编程题】

> **考点**：一个栈做入队栈，一个栈做出队栈；出队栈为空时将入队栈全部倒入
> **注意**：均摊时间复杂度为 O(1)

用两个栈实现一个队列的功能。要求实现进队、出队、判断队为空。

<details><summary>💡 答案提示</summary>
<p>思路：</p>
<ul>
<li><b>入队</b>：直接压入栈A</li>
<li><b>出队</b>：若栈B非空则弹出栈B；若栈B为空则将栈A全部倒入栈B再弹出</li>
<li><b>判空</b>：栈A和栈B都为空</li>
</ul>
</details>

---

### 2.3.3 堆、栈、队列的描述判断 【选择题】

> **考点**：数据结构中的堆（优先队列）vs 内存中的堆；栈和队列的特性
> **注意**：堆是完全二叉树；"堆"的数据类型与"队列"**不**相似

对于堆、栈、队列描述**错误**的是（  ）

- **A.** 队列空间缓冲由进程申请，栈的空间缓冲由OS分配
- **B.** 堆总是一棵完全二叉树
- **C.** 堆的数据类型和队列相似
- **D.** 队列先进先出，栈后进先出

<details><summary>💡 答案提示</summary>
<p><b>答案：C</b></p>
<p>堆是完全二叉树结构，支持高效的最大/最小值查询；队列是线性FIFO结构。两者数据类型和操作方式完全不同。</p>
</details>

---

### 2.3.4 队列与栈的异同 【问答题】

> **考点**：LIFO vs FIFO；典型应用场景（函数调用栈/DFS vs 消息队列/BFS）
> **注意**：两者都是操作受限的线性结构；变体包括循环队列、双端队列、优先队列

简述队列和栈的异同。

<details><summary>💡 答案提示</summary>
<p><b>相同点：</b></p>
<ul>
<li>都是<b>线性数据结构</b>，操作受限（不允许随机访问中间元素）</li>
<li>都可以用数组或链表实现</li>
</ul>
<p><b>不同点：</b></p>
<table>
<tr><th>区别</th><th>栈（Stack）</th><th>队列（Queue）</th></tr>
<tr><td>原则</td><td><b>LIFO</b>（后进先出）</td><td><b>FIFO</b>（先进先出）</td></tr>
<tr><td>操作</td><td><code>push</code>（入栈）/ <code>pop</code>（出栈），同一端</td><td><code>enqueue</code>（入队尾）/ <code>dequeue</code>（出队头）</td></tr>
<tr><td>典型应用</td><td>函数调用栈、DFS</td><td>消息队列、BFS</td></tr>
</table>
</details>

---

## 2.4 字符串算法

### 2.4.1 实现 strcpy 函数 【编程题】

> **考点**：逐字符复制直到 `\0`；注意目标缓冲区大小、返回目标字符串首地址
> **注意**：经典面试题——需处理 `NULL` 指针、重叠区域等边界情况

不使用库函数，编写 `strcpy` 函数：

```c
char *strcpy(char *strDest, const char *strSrc);
```

<details><summary>💡 答案提示</summary>
<pre><code>char *strcpy(char *strDest, const char *strSrc) {
    assert(strDest != NULL && strSrc != NULL);
    char *ret = strDest;
    while ((*strDest++ = *strSrc++) != '\0');
    return ret;
}</code></pre>
<p>得分要点：①assert 检查 ②返回目的地址（支持链式调用）③循环条件含赋值和判断</p>
</details>

---

### 2.4.2 实现 memcpy 函数 【编程题】

> **考点**：按字节逐个复制指定长度的内存内容
> **注意**：需处理源和目标内存重叠的情况（此时应从后往前复制）

```c
void *memcpy(void *dst, const void *src, int size);
```

<details><summary>💡 答案提示</summary>
<p>处理重叠的关键：当 <code>dst > src</code> 且有重叠时，从<b>后往前</b>复制；否则从前往后。</p>
</details>

---

### 2.4.3 字符串反转 【编程题】

> **考点**：首尾双指针交换，O(n) 时间，O(1) 空间
> **注意**：不使用任何系统函数

```c
char* reverse_str(char* str);
```

---

### 2.4.4 最大连续子串长度 【编程题】

> **考点**：遍历字符串，区分字母和数字段，记录最大长度
> **注意**：注意"子串"的定义——连续的同类字符（字母或数字）

**(1)** 将一个字符串中最大连续子串中的长度和子串返回（主要区分字母和数字）。

**(2)** 计算一个字符串中最大的子串的长度并返回。如 `"abcdefg123456789asdfgagfafg"` 中最大子串是 `"asdfgagfafg"`。

---

### 2.4.5 最长不重复子串 【编程题】

> **考点**：滑动窗口法，维护窗口内字符不重复
> **注意**：可用哈希表/数组记录字符最近出现位置

找出字符串的最长不重复子串，输出长度。

---

### 2.4.6 字符串去除重复字符 【编程题】

> **考点**：使用布尔数组标记已出现字符，保留首次出现
> **注意**：ASCII 字符集共128/256个字符，可用数组做哈希

输入 `"abcabcdeffg"`，输出 `"abcdefg"`。

---

### 2.4.7 字符串形式的大整数相加 【编程题】

> **考点**：模拟竖式加法——从末尾逐位相加并处理进位
> **注意**：两字符串长度可能不同；最高位可能产生进位

```c
char a[] = "1111";
char b[] = "9999";
// 输出: "11110"
```

要求：逐位相加 + 进位处理，不能转换为整数类型。

---

### 2.4.8 计算字符串中单词个数 【编程题】

> **考点**：遍历字符串，识别空格与非空格的边界转换
> **注意**：需处理连续空格、首尾空格等边界情况

---

### 2.4.9 消除嵌套括号 【编程题】

> **考点**：栈的应用——遇左括号压栈（或标记），遇右括号弹栈，只保留数字和逗号
> **注意**：需检测格式错误（括号不匹配等）

给定字符串 `(1,(2,3),(4,(5,6),7))`，消除嵌套括号输出 `(1,2,3,4,5,6,7)`。

---

### 2.4.10 数字字符串转化为数字（my_atoi）【编程题】

> **考点**：字符与数字的 ASCII 转换（`- '0'`）；逐位累乘10相加的核心公式
> **注意**：完整实现需考虑前导空格、正负号、溢出检测（超出 `INT_MAX`/`INT_MIN`），面试中提一嘴加分

编码实现将数字字符串转化为数字（实现 `atoi`）。

<details><summary>💡 答案提示</summary>
<pre><code>int my_atoi(const char *str) {
    int sign = 1, result = 0;
    // 1. 跳过前导空格
	while (*str == ' ') str++;
	// 2. 处理正负号
    if (*str == '-' || *str == '+') {
        if (*str == '-') sign = -1;
        str++;
    }

    // 3. 逐位转换：字符 - '0' 得到数字，累乘10相加
    while (*str >= '0' && *str <= '9') {
        result = result * 10 + (*str - '0');
        str++;
    }
    
    return sign * result;
    }</code></pre>
    <p>核心原理：<code>字符 - '0'</code> 得到对应数字值，通过 <code>result = result * 10 + digit</code> 逐位累加。</p>
</details>

---

## 2.5 数组算法

### 2.5.1 4位二进制分组求和 【编程题】

> **考点**：位运算——每次取低4位、右移4位，循环8次
> **注意**：掩码 `& 0xF` 提取低4位

给定32位无符号整数，将其二进制每4位一组，每组转为十进制后求和。

> **示例**：`0xFFFFFFFF` → 每组都是 `1111`(=15) × 8组 = **120**

<details><summary>💡 答案提示</summary>
<pre><code>int nibble_sum(unsigned int n) {
    int sum = 0;
    for (int i = 0; i < 8; i++) {
        sum += (n & 0xF);
        n >>= 4;
    }
    return sum;
}</code></pre>
</details>

---

### 2.5.2 找出两个数组的差集 【编程题】

> **考点**：对每个第一数组元素检查是否在第二数组中存在
> **注意**：可用排序+双指针优化为 O(nlogn)；也可用哈希表优化为 O(n)

---

### 2.5.3 求数组中出现次数最多的元素 【编程题】

> **考点**：遍历统计频次，记录最大值
> **注意**：不允许修改原数组；多个并列最多时返回第一次出现的元素

```c
int a[] = {1, 3, 2, 3, 4, 3, 2, 1};
// 输出: 3（出现3次）
```

---

### 2.5.4 返回数组第二大的数 【编程题】

> **考点**：一次遍历维护最大值和次大值
> **注意**：需处理所有元素相同、数组只有一个元素等边界情况

---

### 2.5.5 二维数组中最大值及其位置 【编程题】

> **考点**：双重循环遍历，记录最大值及其行列索引
> **注意**：注意行列编号从0开始

```c
#define ROW 3
#define COL 4
int arr[ROW][COL] = {
    {12, 7,  9,  15},
    {3,  22, 8,  6},
    {14, 5,  18, 10}
};
```

---

### 2.5.6 打印 N×N 方阵 【编程题】

> **考点**：多层嵌套循环，根据元素到边界的最小距离决定打印内容
> **注意**：距离0打印X，距离1打印Y，距离≥2打印 `距离-2`

```
N=5 时：
X X X X X
X Y Y Y X
X Y 0 Y X
X Y Y Y X
X X X X X
```

---

## 2.6 数学与递归

### 2.6.1 递归求和（1到N）【编程题】

> **考点**：递归函数定义、终止条件（`n==1` 返回1）、函数调用栈
> **注意**：递归深度过大会导致栈溢出

```c
int sum(int n);  // 计算 1+2+...+n
```

<details><summary>💡 答案提示</summary>
<pre><code>int sum(int n) {
    if (n == 1) return 1;      // 递归终止条件
    return n + sum(n - 1);     // 递归调用
}</code></pre>
</details>

---

### 2.6.2 N! 末尾零的个数 【编程题】

> **考点**：末尾零由因子10产生，10=2×5，因子5的个数决定零的个数
> **注意**：`count = N/5 + N/25 + N/125 + ...`

<details><summary>💡 答案提示</summary>
<pre><code>int trailing_zeros(int n) {
    int count = 0;
    while (n >= 5) {
        count += n / 5;
        n /= 5;
    }
    return count;
}</code></pre>
</details>

---

### 2.6.3 最小公倍数 【编程题】

> **考点**：`LCM(a,b) = a*b / GCD(a,b)`；GCD 用辗转相除法求
> **注意**：先求最大公约数再求最小公倍数；注意乘法溢出

---

### 2.6.4 集合中求最大元素 C = A + B 【编程题】

> **考点**：遍历集合找最大元素，再遍历找是否存在两个元素之和等于它
> **注意**：A和B可以是同一个元素（需看题目要求）

---

## 2.7 树

### 2.7.1 非递归实现中序遍历二叉树 【编程题】

> **考点**：使用栈模拟递归——先沿左子树一路入栈，弹出时访问节点再转向右子树
> **注意**：中序遍历顺序为 左→根→右

---

## 2.8 趣味算法

### 2.8.1 牌序还原问题 【编程题】

> **考点**：模拟/逆向推导——已知取牌顺序为A到K，反推初始排列
> **注意**：操作是"放一张到底部，取一张出来"，需用队列模拟逆过程

一副牌从A到K共13张，取牌顺序：
1. 将第一张放到最下面
2. 取出最上面的一张牌

依次操作1、2，最后取出牌的顺序是从A到K，求13张牌的最初顺序。

<details><summary>💡 答案提示</summary>
<p>逆向模拟：从结果反推。将 K~A 逆序依次"放回"：</p>
<ol>
<li>将当前牌放到队列顶部</li>
<li>将队列底部的牌移到顶部</li>
</ol>
<p>用双端队列（deque）模拟。</p>
</details>

---

### 4.1 大整数乘法算法 【选择题】

实现大整数乘法是利用什么算法？

```c
A: 动态规划算法
B: 贪心算法
C: 分治算法
D: 回溯算法
```

<details><summary>💡 答案提示</summary>
<p><b>答案：C（分治算法）</b></p>
<p>经典的<b>Karatsuba算法</b>就是用分治思想实现大整数乘法：</p>
<ol>
<li>将大整数拆分为高位和低位两部分</li>
<li>递归地对较小的部分做乘法</li>
<li>合并结果</li>
<li>时间复杂度从朴素的O(n²)降到O(n^1.585)</li>
</ol>
<p><b>考点：</b>分治算法的经典应用——大整数乘法(Karatsuba)、归并排序、快速排序、Strassen矩阵乘法</p>
</details>

---

### 4.2 链表删除重复项 【选择题】

以下代码实现了从表中删除重复项的功能，请选择其中空白行应填入的正确代码。

```c
template <class T>
void removeDuplicates(list<T> &aList)
    list<T>::iterator cur, p;

    cur = aList.begin();
    while (cur != aList.end())
    {
        curValue = *cur;

        // 空白行①

        while (p != aList.end())
        {
            if (*p == curValue)
            {
                // 空白行②
            }
            else
            {
                p++;
            }
        }

        cur++;
    }
}

A:
p = ++cur;
aList.erase(p++);

B:
p = cur + 1;
aList.erase(p);

C:
p = cur + 1;
aList.erase(p++);

D:
p = ++cur;
aList.erase(p);
```

<details><summary>💡 答案提示</summary>
<p><b>答案：A</b></p>
<p><b>关键错误：<code>std::list</code>的迭代器不支持<code>+</code>运算符！</b></p>
<ul>
<li><code>list</code>是双向链表，迭代器是<b>BidirectionalIterator</b>，只支持<code>++</code>和<code>--</code></li>
<li><code>cur + 1</code>无法通过编译，<b>B和C直接排除</b></li>
<li>只有<code>++cur</code>（自增）才是合法的迭代器操作</li>
</ul>
<p><b>分析A选项：</b></p>
<ul>
<li>空白行①：<code>p = ++cur;</code> —— cur先自增指向下一个元素，p也指向该位置</li>
<li>空白行②：<code>aList.erase(p++);</code> —— <b>先保存p当前位置用于erase，再将p自增指向下一个元素</b>。这是STL中删除元素的标准写法，避免迭代器失效</li>
</ul>
</details>

---

### 4.3 进制转换 【编程题】

给定一个整数，将其转化为7进制，并以字符串形式输出。

示例1:
输入: 100
输出: "202"

示例2:
输入: -7
输出: "-10"

注意: 输入范围是[-1e7, 1e7]。

<details><summary>💡 答案提示</summary>
<p><b>思路：短除法（辗转取余）</b></p>
<p>不断对7取余得到每一位，再对7整除缩小数值，最后将结果反转。负数先转正数处理，最后加负号。</p>
<pre><code>char* toBase7(int num)
{
    // 静态缓冲区足够容纳范围 [-1e7, 1e7]
    // 7^9 = 40353607 > 1e7
    // 最多 9 位 + 负号 + '\0'
    static char buf[12];

    if (num == 0) {
        buf[0] = '0';
        buf[1] = '\0';
        return buf;
    }
    
    int isNegative = 0;
    if (num < 0) {
        isNegative = 1;
        num = -num;
    }
    
    int i = 0;
    while (num > 0) {
        int digit = num % 7;
        buf[i++] = digit + '0';  // 数字转字符：加上'0'即可
        num /= 7;
    }
    
    if (isNegative) {
        buf[i++] = '-';
    }
    
    buf[i] = '\0';
    
    // 反转字符串
    int left = 0, right = i - 1;
    while (left < right) {
        char temp = buf[left];
        buf[left] = buf[right];
        buf[right] = temp;
        left++;
        right--;
    }
    
    return buf;
}</code></pre>
<p><b>示例: 100 → 100%7=6,100/7=14 → 14%7=0,14/7=2 → 2%7=2,2/7=0 → 逆序"202"</b></p>
</details>

---

### 4.4 括号匹配 【编程题】

输入一个字符串，其中包含 ()、[]、{} 六种括号，请判断该字符串中的括号是否合法。

| 输入       | 输出    |
| ---------- | ------- |
| `"()[]{}"` | `true`  |
| `"(]"`     | `false` |
| `"(["`     | `false` |

**判定规则**
1. 左括号必须由相同类型的右括号闭合。
2. 左括号必须按正确的顺序闭合（后开先闭）。
3. 每个右括号都必须有对应的左括号。
4. 所有括号最终都必须完全匹配。

<details><summary>💡 答案提示</summary>
<p><b>思路：栈（后进先出，天然匹配"后开先闭"规则）</b></p>
<pre><code>bool isValid(const char* s)
{
    int len = strlen(s);

    // 最大栈深度不超过字符串长度
    char stack[len];
    int top = -1;
    
    for (int i = 0; i < len; i++)
    {
        char c = s[i];
        
        // 左括号入栈
        if (c == '(' || c == '[' || c == '{')
        {
            stack[++top] = c;
        }
        else
        {
            // 右括号时，栈必须非空
            if (top < 0)
                return false;
            
            char t = stack[top--];  // 出栈
            
            // 检查是否匹配
            if ((c == ')' && t != '(') ||
                (c == ']' && t != '[') ||
                (c == '}' && t != '{'))
            {
                return false;
            }
        }
    }
    
    // 所有括号必须匹配完成
    return top == -1;
}</code></pre>
<p><b>考点：</b>栈的经典应用——括号匹配。三个容易遗漏的边界：①右括号多余（栈空时遇到右括号）②左括号多余（遍历结束栈不空）③类型不匹配（<code>(</code>遇到<code>]</code>）</p>
</details>

# 三、通信总线

## 3.1 常见通信协议对比

### 3.1.1 五种通信协议的工作原理与特点 【问答题】

> **考点**：各总线的线数、速率、拓扑结构、全/半双工、同步/异步等特性对比
> **注意**：串口可以是全双工也可以是半双工或单工，**不要一律说全双工**

请简述以下通信协议的工作原理以及特点：

| 协议 | 线数 | 同步/异步 | 双工模式 | 关键特性 |
|------|------|----------|---------|---------|
| **RS-485** | 2线（A/B差分） | 异步 | 半双工 | 差分信号、多点通信、长距离（1200m） |
| **UART** | 2线（TX/RX） | 异步 | **全/半/单工均可** | 起始位/停止位、波特率匹配 |
| **CAN** | 2线（CANH/CANL） | 异步 | 半双工 | 差分信号、多主仲裁、错误检测完善 |
| **I2C** | 2线（SDA+SCL） | 同步 | 半双工 | 多主多从、7/10位地址寻址 |
| **SPI** | 4线（MOSI/MISO/SCK/CS） | 同步 | 全双工 | 高速、无地址寻址、主从架构 |

---

### 3.1.2 串口、IIC、SPI 深入理解 【问答题】

> **考点**：三种协议的时序图、数据格式、应用场景选择
> **注意**：串口是异步通信（无时钟线），I2C和SPI是同步通信（有时钟线）

<details><summary>💡 答案提示</summary>
<p>选型参考：</p>
<ul>
<li><b>低速、少量设备、省引脚</b> → I2C</li>
<li><b>高速、实时数据传输</b> → SPI</li>
<li><b>长距离、调试打印</b> → UART</li>
</ul>
</details>

---

## 3.2 GPIO 与 I2C 设备驱动 【问答题】

> **考点**：GPIO的输入/输出/复用模式；I2C设备驱动流程（起始→地址→读写→停止）
> **注意**：I2C需要注意从机地址（7位/10位）、ACK/NACK应答机制

GPIO 功能，驱动一个 I2C 设备的流程。

<details><summary>💡 答案提示</summary>
<p>I2C 通信流程：</p>
<pre><code>主机发送起始信号(START)
    → 发送从机地址 + 读/写位
    → 等待从机 ACK
    → 发送/接收数据字节
    → 每字节后等待 ACK/NACK
    → 发送停止信号(STOP)</code></pre>
</details>

---

# 四、嵌入式操作系统

## 4.1 进程与线程

### 4.1.1 进程与线程的区别 【问答题】

> **考点**：进程是资源分配的基本单位；线程是CPU调度的基本单位；线程共享进程资源
> **注意**：线程切换开销小于进程切换；同进程的线程共享地址空间、文件描述符等
> ⚠️ **此题出现频率极高**

进程与线程的区别。

<details><summary>💡 答案提示</summary>
<table>
<tr><th>对比项</th><th>进程</th><th>线程</th></tr>
<tr><td>定义</td><td>资源分配的基本单位</td><td>CPU调度的基本单位</td></tr>
<tr><td>地址空间</td><td>独立</td><td>共享所属进程的地址空间</td></tr>
<tr><td>通信</td><td>IPC（管道、消息队列、共享内存等）</td><td>直接读写共享变量</td></tr>
<tr><td>切换开销</td><td>大（需切换页表等）</td><td>小（共享地址空间）</td></tr>
<tr><td>崩溃影响</td><td>不影响其他进程</td><td>可能导致整个进程崩溃</td></tr>
</table>
</details>

---

### 4.1.2 线程同步 【问答题】

> **考点**：互斥锁、信号量、条件变量、读写锁等同步机制
> **注意**：同步强调执行顺序，互斥强调资源排他访问

简单描述线程同步。

---

### 4.1.3 同步与互斥的问题 【问答题】

> **考点**：同步——协调多个线程的执行顺序；互斥——保证共享资源同一时刻只被一个线程访问
> **注意**：互斥是一种特殊的同步关系

同步与互斥的区别。

<details><summary>💡 答案提示</summary>
<ul>
<li><b>同步</b>：多个线程按<b>约定的顺序</b>协调执行（如生产者-消费者）</li>
<li><b>互斥</b>：多个线程对共享资源<b>排他性访问</b>（如同时只有一个线程能写数据）</li>
<li>互斥是同步的一种特殊情况</li>
</ul>
</details>

---

### 4.1.4 互斥锁（Mutex）概念 【选择题】

> **考点**：互斥锁的加解锁规则、使用约束
> **注意**：解锁顺序在嵌套锁场景中很重要（必须逆序解锁）

关于互斥锁（Mutex）的如下表述，**错误的是（  ）**

- **A.** 互斥锁的加锁和解锁必须由同一线程分别对应使用
- **B.** 互斥锁只能为 0/1 两种状态
- **C.** 互斥锁的解锁过程不需要关心顺序，只需要成对使用即可
- **D.** 互斥锁用于线程之间的互斥访问

<details><summary>💡 答案提示</summary>
<p><b>答案：C</b></p>
<p>嵌套加锁时，解锁必须<b>逆序</b>（后加的锁先解），否则可能导致死锁。不能"不关心顺序"。</p>
</details>

---

### 4.1.5 多线程编程实践 【编程题】

> **考点**：线程创建、临界区保护、共享资源访问
> **注意**：购票场景需保证余票数的原子性操作，防止超卖
> 💡 此题同时考察**编程能力**和**操作系统概念**

写一个购买火车票的多线程伪代码。

<details><summary>💡 答案提示</summary>
<pre><code>int tickets = 100;
pthread_mutex_t lock;

void* buy_ticket(void* arg) {
    while (1) {
        pthread_mutex_lock(&lock);
        if (tickets > 0) {
            tickets--;
            printf("买到票，剩余 %d\n", tickets);
        } else {
            pthread_mutex_unlock(&lock);
            break;
        }
        pthread_mutex_unlock(&lock);
    }
    return NULL;
}</code></pre>
<p>关键：对 <code>tickets</code> 的读写必须在<b>互斥锁保护</b>下进行。</p>
</details>

---

## 4.2 进程调度

### 4.2.1 进程间制约关系 【选择题】

> **考点**：多个进程按顺序逐一访问资源属于"同步"关系
> **注意**：区分同步（有序访问）、互斥（排他访问）、调度（CPU分配策略）

多个进程按照顺序逐一访问某个资源，这种制约关系称之为（  ）

- **A.** 调度
- **B.** 协同
- **C.** 互斥
- **D.** 同步

<details><summary>💡 答案提示</summary>
<p><b>答案：D</b></p>
<p>"按顺序逐一访问"强调的是<b>执行顺序的约束</b>，这是同步的定义。互斥只要求排他，不要求顺序。</p>
</details>

---

### 4.2.2 进程调度触发条件 【选择题】

> **考点**：进程等待事件、时间片用完、进程出错都会触发调度；新进程就绪不一定立即调度
> **注意**：选项C不是**直接**原因（取决于调度算法是否为抢占式）

下列选项中，**不是引起操作系统选择新进程运行的直接原因**的是（  ）

- **A.** 当前运行进程需要等待某一事件发生
- **B.** 当前运行进程的时间片用完
- **C.** 有新进程进入就绪状态
- **D.** 当前运行进程发生错误

<details><summary>💡 答案提示</summary>
<p><b>答案：C</b></p>
<p>新进程进入就绪状态只是排队等候，不一定引起当前进程让出CPU（除非是抢占式调度且新进程优先级更高）。</p>
</details>

---

## 4.3 内存管理

### 4.3.1 内存管理淘汰算法 【问答题】

> **考点**：FIFO（先进先出）、LRU（最近最少使用）、LFU（最不经常使用）、OPT（最优置换）
> **注意**：LRU是实际中最常用的近似最优算法

内存管理淘汰算法有哪些？并分别简述。

<details><summary>💡 答案提示</summary>
<table>
<tr><th>算法</th><th>策略</th><th>特点</th></tr>
<tr><td><b>FIFO</b></td><td>淘汰最早进入的页面</td><td>简单但可能淘汰常用页（Belady异常）</td></tr>
<tr><td><b>LRU</b></td><td>淘汰最近最久未使用的页面</td><td>效果好，实现复杂（需记录访问时间）</td></tr>
<tr><td><b>LFU</b></td><td>淘汰使用频率最低的页面</td><td>需维护计数器</td></tr>
<tr><td><b>OPT</b></td><td>淘汰未来最久不使用的页面</td><td>理论最优，实际无法实现</td></tr>
</table>
</details>

---

## 4.4 中断机制

### 4.4.1 中断下半段处理机制 【选择题】

> **考点**：Linux 中断下半段的三种机制：软中断（softirq）、tasklet、工作队列（workqueue）
> **注意**：双向链表是数据结构，不是中断处理机制

可用于中断下半段处理的处理机制有（  ）

- **A.** tasklet ✓
- **B.** 工作队列 ✓
- **C.** 软中断 ✓
- **D.** 双向链表 ✗

<details><summary>💡 答案提示</summary>
<p><b>答案：A、B、C</b></p>
<table>
<tr><th>机制</th><th>执行上下文</th><th>能否睡眠</th></tr>
<tr><td>软中断</td><td>中断上下文</td><td>不能</td></tr>
<tr><td>tasklet</td><td>中断上下文（基于软中断）</td><td>不能</td></tr>
<tr><td>工作队列</td><td>进程上下文</td><td>能</td></tr>
</table>
<p>双向链表是数据结构，不是中断处理机制。</p>
</details>

---

## 4.5 I/O 多路复用

### 4.5.1 I/O 多路复用方式 【问答题】

> **考点**：`select`（跨平台，fd数量有限）、`poll`（无fd数量限制）、`epoll`（Linux高性能）
> **注意**：嵌入式Linux中 `epoll` 最常用；select/poll 每次调用需要重新传递fd集合

1. 嵌入式中 I/O 多路复用的方式。
2. I/O 多路复用的几种实现方法。

<details><summary>💡 答案提示</summary>
<table>
<tr><th>方法</th><th>fd上限</th><th>性能</th><th>内核实现</th></tr>
<tr><td><b>select</b></td><td>1024（FD_SETSIZE）</td><td>O(n) 轮询</td><td>所有平台</td></tr>
<tr><td><b>poll</b></td><td>无硬限制</td><td>O(n) 轮询</td><td>Linux/Unix</td></tr>
<tr><td><b>epoll</b></td><td>无硬限制</td><td>O(1) 事件驱动</td><td>仅Linux</td></tr>
</table>
</details>

---

### 3.1 嵌入式任务状态 【选择题】

嵌入式系统中，一个任务被唤醒就意味着？

```c
A: 该任务重新占有了CPU
B: 他的优先级变为最高
C: 任务变为就绪态
D: 其任务移至等待队列的队首
```

<details><summary>💡 答案提示</summary>
<p><b>答案：C（任务变为就绪态）</b></p>
<ul>
<li>唤醒 ≠ 立刻执行，唤醒只是从<b>阻塞态→就绪态</b>，等待调度器分配CPU</li>
<li>A错：占有CPU需要调度器调度，唤醒不等于立刻获得CPU</li>
<li>B错：优先级不会因唤醒而改变</li>
<li>D错：是移至<b>就绪队列</b>，不是等待队列</li>
</ul>
<p><b>考点：</b>RTOS任务状态机（运行态、就绪态、阻塞态）。唤醒 = 阻塞→就绪，调度 = 就绪→运行</p>
</details>

---

### 3.2 线程共享资源 【选择题】

属于线程之间共享资源的是？

```c
A: 全局变量
B: 线程栈
C: 地址空间
D: 堆
```

<details><summary>💡 答案提示</summary>
<p><b>答案：A、C、D</b></p>
<p><b>线程共享的资源：</b></p>
<ul>
<li>全局变量 ✓（A）</li>
<li>地址空间 ✓（C）</li>
<li>堆 ✓（D）</li>
<li>还有：代码段、打开的文件描述符、信号处理函数等</li>
</ul>
<p><b>线程私有的资源：</b></p>
<ul>
<li><b>线程栈</b>（B）—— 每个线程有自己独立的栈</li>
<li>寄存器组、程序计数器(PC)、线程ID、errno</li>
</ul>
</details>

---

### 3.3 volatile用途 【选择题】

在单循环的嵌入式系统中，使用一个全局变量在中断函数和main函数之间传递数据，为了避免数据错误，可以采用如下做法？

```c
A: 可以用const修饰此全局变量
B: 可以用volatile修饰此全局变量
C: 可以用static修饰此全局变量
D: 可以用static const修饰此全局变量
```

<details><summary>💡 答案提示</summary>
<p><b>答案：B（volatile）</b></p>
<table>
<tr><th>修饰符</th><th>分析</th></tr>
<tr><td><code>const</code></td><td>变量不可修改，无法用于传递数据 ✗</td></tr>
<tr><td><b><code>volatile</code></b></td><td>告诉编译器<b>不要优化</b>此变量的读取，每次都从内存取值 ✓</td></tr>
<tr><td><code>static</code></td><td>限制作用域，与防止数据错误无关 ✗</td></tr>
<tr><td><code>static const</code></td><td>既不可修改又限制作用域，更不行 ✗</td></tr>
</table>
<p><b>考点：</b>volatile的核心作用——<b>防止编译器优化</b>。中断中修改的变量如果没有volatile修饰，编译器可能将其缓存到寄存器中，main函数读到的是旧值</p>
</details>

---

### 3.4 UART通信 【选择题】

下列关于UART通信描述正确的是？

A: 收发两端可以不工作在同一个速率上
B: 异步通讯方式
C: 传输速度固定不可变
D: 不可以实现全双工模式

<details><summary>💡 答案提示</summary>
<p><b>答案：B（异步通讯方式）</b></p>
<table>
<tr><th>选项</th><th>分析</th></tr>
<tr><td>A</td><td>错：收发两端<b>必须</b>工作在相同波特率上，否则无法正确解码</td></tr>
<tr><td>B</td><td>对：UART = Universal <b>Asynchronous</b> Receiver/Transmitter，无时钟线，靠波特率约定同步 ✓</td></tr>
<tr><td>C</td><td>错：波特率是<b>可配置</b>的（9600、115200等），不是固定的</td></tr>
<tr><td>D</td><td>错：UART有TX和RX两根线，<b>可以实现全双工</b></td></tr>
</table>
</details>

---

### 3.5 SPI和IIC对比 【选择题】

关于SPI和IIC总线的描述，正确的是？

```c
A: IIC可以实现全双工，SPI不能实现全双工
B: IIC的数据输入输出用的是一根线，SPI则分为数据输入和数据输出两根线
C: IIC的抗干扰能力比SPI强
D: SPI适合长距离传播
```

<details><summary>💡 答案提示</summary>
<p><b>答案：B</b></p>
<table>
<tr><th>选项</th><th>分析</th></tr>
<tr><td>A</td><td>错：恰好说反了。<b>IIC是半双工</b>（SDA一根数据线），<b>SPI才能实现全双工</b>（MOSI+MISO两根数据线）</td></tr>
<tr><td>B</td><td>对：<b>IIC用SDA一根线</b>收发数据（半双工）；<b>SPI用MOSI（主→从）和MISO（从→主）两根线</b>分别负责输入输出 ✓</td></tr>
<tr><td>C</td><td>错：SPI的抗干扰能力比IIC强（SPI速度更快、信号更稳定）</td></tr>
<tr><td>D</td><td>错：SPI适合<b>短距离、高速</b>板级通信，不适合长距离</td></tr>
</table>
</details>

---

# 五、综合

## 5.1 嵌入式硬件与体系结构

### 5.1.1 ARM 架构 【问答题】

> **考点**：ARM 核心架构（Cortex-M/A/R系列）、流水线、工作模式、寄存器组
> **注意**：嵌入式常用 Cortex-M 系列（M0/M3/M4/M7），注意中断处理和低功耗特性

讲述 ARM 架构的了解。

<details><summary>💡 答案提示</summary>
<table>
<tr><th>系列</th><th>定位</th><th>典型应用</th></tr>
<tr><td><b>Cortex-M</b></td><td>微控制器</td><td>STM32、物联网终端</td></tr>
<tr><td><b>Cortex-R</b></td><td>实时处理</td><td>汽车ECU、硬盘控制器</td></tr>
<tr><td><b>Cortex-A</b></td><td>应用处理</td><td>手机、平板、Linux设备</td></tr>
</table>
<p>关键特性：RISC架构、Thumb指令集、低功耗设计、丰富的中断处理机制(NVIC)</p>
</details>

---

### 5.1.2 单片机的通用启动过程 【问答题】

> **考点**：上电复位→初始化栈指针→初始化时钟→初始化外设→跳转 main
> **注意**：启动文件（startup.s）、向量表、系统时钟配置（HSE/HSI/PLL）是关键步骤

单片机的通用启动过程。

<details><summary>💡 答案提示</summary>
<pre><code>上电/复位
  → ① 从向量表读取初始栈指针(MSP)
  → ② 从向量表读取复位向量(Reset_Handler地址)
  → ③ 执行 Reset_Handler（启动文件 startup.s）
      → 初始化 .data 段（从Flash拷贝到RAM）
      → 清零 .bss 段
      → 配置系统时钟（HSE/PLL）
      → 调用 C 库初始化
  → ④ 跳转到 main()</code></pre>
</details>

---

### 5.1.3 U-Boot 引导启动流程 【问答题】

> **考点**：BL1→BL2→加载内核→传参→启动Linux
> **注意**：U-Boot 分为 SPL 和完整 U-Boot 两个阶段

<details><summary>💡 答案提示</summary>
<pre><code>ROM Bootloader
  → SPL (Secondary Program Loader)
      → 初始化DDR、时钟
      → 加载完整 U-Boot 到 DDR
  → U-Boot
      → 初始化外设（串口、网络、存储）
      → 加载内核镜像(zImage/uImage)到内存
      → 传递设备树(DTB)和启动参数
      → 跳转到内核入口
  → Linux Kernel 启动</code></pre>
</details>

---

### 5.1.4 STM32 软件中断与外设实现 【问答题】

> **考点**：NVIC 中断控制器、中断优先级分组、中断向量表、软件触发中断
> **注意**：包含模拟量采集的ADC中断、DMA传输完成中断等

请基于 STM32 描述：
1. 软件中断的实现机制
2. 模拟量采集的数字化实现过程
3. PWM 功能的实现过程

---

### 5.1.5 大小端（字节序）【编程题】

> **考点**：通过联合体（`union`）或指针强转检查整数低字节内容
> **注意**：大端——高位字节在低地址；小端——低位字节在低地址；ARM一般是小端，网络字节序是大端

编写程序判断当前系统的字节序类型：

```c
int x = 0x12345678;
// 若低地址存储 0x78 → 小端（Little Endian）
// 若低地址存储 0x12 → 大端（Big Endian）
```

<details><summary>💡 答案提示</summary>
<p><b>方法一：指针法</b></p>
<pre><code>int x = 1;
if (*(char*)&x == 1)
    printf("Little Endian\n");
else
    printf("Big Endian\n");</code></pre>
<p><b>方法二：联合体法</b></p>
<pre><code>union {
    int i;
    char c;
} u;
u.i = 1;
if (u.c == 1)
    printf("Little Endian\n");
else
    printf("Big Endian\n");</code></pre>
</details>

---

## 5.2 综合知识

### 5.2.1 单位换算 【计算题】

> **考点**：存储单位换算（1MB = 1024KB = 1024×1024B），位(bit)与字节(Byte)的关系（1Byte = 8bit）
> **注意**：颜色深度24位表示每个像素占24bit，计算时别忘了除以8转字节

某相机内置256MB存储空间，拍摄照片的分辨率为1600x1200像素，颜色深度为24位，若不采用压缩存储技术，使用内部储存最多可以拍多少张照片？

<details><summary>💡 答案提示</summary>
<p><b>计算过程：</b></p>
<ol>
<li>256MB = 256 × 1024 × 1024 = 268,435,456 字节(Byte)</li>
<li>一张照片大小 = 1600 × 1200 × 24 / 8 = 5,760,000 字节（注意24位是bit，要除以8换算成Byte）</li>
<li>268,435,456 ÷ 5,760,000 ≈ 46.6 → <b>最多拍46张</b></li>
</ol>
</details>

---

### 5.2.2 Shell命令行基础 【选择题】

#### 5.2.2.1 Shell特殊变量

在 Shell 中，用于表示传入参数个数的特殊变量是？

```c
A. $#
B. $*
C. $?
D. 0
```

<details><summary>💡 答案提示</summary>
<p><b>答案：A <code>$#</code></b></p>
<table>
<tr><th>变量</th><th>含义</th></tr>
<tr><td><code>$#</code></td><td>传入参数的<b>个数</b></td></tr>
<tr><td><code>$*</code></td><td>所有参数作为一个整体字符串</td></tr>
<tr><td><code>$?</code></td><td>上一条命令的<b>退出状态码</b>（0成功，非0失败）</td></tr>
<tr><td><code>$0</code></td><td>脚本自身的名称</td></tr>
</table>
</details>

---

#### 5.2.2.2 Shell逻辑运算符

下面哪种写法表示：如果 `cmd1` 成功执行，则执行 `cmd2` 命令？

A. `cmd1 cmd2`
B. `cmd1; cmd2`
C. `cmd1 && cmd2`
D. `cmd1 || cmd2`

<details><summary>💡 答案提示</summary>
<p><b>答案：C <code>cmd1 && cmd2</code></b></p>
<table>
<tr><th>写法</th><th>含义</th></tr>
<tr><td><code>cmd1 cmd2</code></td><td>语法错误/cmd2被当成cmd1的参数</td></tr>
<tr><td><code>cmd1; cmd2</code></td><td>无论cmd1成功与否，都执行cmd2（两个独立语句）</td></tr>
<tr><td><code>cmd1 && cmd2</code></td><td>cmd1<b>成功（返回0）</b>才执行cmd2</td></tr>
<tr><td><code>cmd1 || cmd2</code></td><td>cmd1<b>失败（返回非0）</b>才执行cmd2</td></tr>
</table>
</details>

---

### 5.2.3 Linux知识 【选择题】

#### 5.2.3.1 Linux设备类型

下面哪种不是Linux的设备类型？

```c
A: 块设备
B: 字符设备
C: 网络设备
D: 虚拟设备
```

<details><summary>💡 答案提示</summary>
<p><b>答案：D（虚拟设备）</b></p>
<p>Linux三大设备类型：</p>
<ol>
<li><b>块设备(Block Device)</b> —— 按数据块访问，如硬盘、SD卡</li>
<li><b>字符设备(Char Device)</b> —— 按字节流顺序访问，如串口、键盘</li>
<li><b>网络设备(Network Device)</b> —— 网络通信，如网卡eth0</li>
</ol>
<p><b>"虚拟设备"不是Linux标准设备分类。</b>网络设备是Linux三大设备类型之一。</p>
</details>

---

#### 5.2.3.2 Linux目录结构

在Linux系统中，用来存放系统所需要的配置文件和子目录是？

```c
A: /var
B: /root
C: /etc
D: /home
```

<details><summary>💡 答案提示</summary>
<p><b>答案：C <code>/etc</code></b></p>
<table>
<tr><th>目录</th><th>用途</th></tr>
<tr><td><code>/var</code></td><td>可变数据文件（日志、缓存、邮件等）</td></tr>
<tr><td><code>/root</code></td><td><b>root用户的家目录</b>，不是存放系统配置的地方</td></tr>
<tr><td><code>/etc</code></td><td><b>系统配置文件目录</b>（如<code>/etc/passwd</code>、<code>/etc/fstab</code>、<code>/etc/nginx/</code>等）</td></tr>
<tr><td><code>/home</code></td><td>普通用户的家目录</td></tr>
</table>
</details>

---

#### 5.2.3.3 Linux文本处理命令

当需要从文本文件的每一行中截取指定内容的数据时，下面那个命令可以提供帮助？

```c
A: cp
B: dd
C: fmt
D: cut
```

<details><summary>💡 答案提示</summary>
<p><b>答案：D <code>cut</code></b></p>
<table>
<tr><th>命令</th><th>用途</th></tr>
<tr><td><code>cp</code></td><td>复制文件</td></tr>
<tr><td><code>dd</code></td><td>低级数据复制/转换</td></tr>
<tr><td><code>fmt</code></td><td>文本格式化（调整行宽）</td></tr>
<tr><td><code>cut</code></td><td>按列/字段<b>截取</b>每行指定内容，如 <code>cut -d':' -f1 /etc/passwd</code></td></tr>
</table>
</details>

---

## 5.3 逻辑推理题 ⚠️ 非技术题

> **考点**：逻辑推理、矛盾法、假设排除法
> **注意**：面试中偶尔出现，考察**逻辑思维能力**而非技术知识

甲、乙、丙、丁四人各说了一句话，已知四句话中有两句为真，两句为假：

- **甲**：乙和丙说的都是真话。
- **乙**：丁说的是假话。
- **丙**：甲和丁说的都是假话。
- **丁**：乙说的是真话。

请判断谁说的是真话，谁说的是假话，并写出推理过程。

<details><summary>💡 答案提示</summary>
<p><b>关键突破口：乙和丁互相评价</b></p>
<p>乙说"丁假" ↔ 丁说"乙真"，两者互为否命题，必一真一假。</p>
<p><b>假设乙真、丁假：</b></p>
<ul>
<li>乙真 + 丁假 → 已用1真1假 → 甲丙中1真1假</li>
<li>甲说"乙丙都真" → 需丙真才能让甲为真</li>
<li>丙说"甲丁都假" → 丁假 ✓，甲假 → 那甲就是假的</li>
<li>验证：甲假、乙真、丙真、丁假 → 2真2假 ✓</li>
</ul>
<p><b>答案：乙、丙说真话；甲、丁说假话</b></p>
</details>

---

# 附录：高频考点速查表

| 考点 | 频率 | 核心知识 | 题型 |
|------|------|---------|------|
| **指针与数组** | ★★★★★ | 指针运算、数组名退化、指针步长 | 选择/分析 |
| **宏定义陷阱** | ★★★★★ | 文本替换无括号保护、优先级问题 | 选择 |
| **链表操作** | ★★★★★ | 插入、删除、反转、判环、分区 | 编程 |
| **排序算法** | ★★★★☆ | 快排实现、稳定性、时间复杂度 | 编程/选择 |
| **内存对齐** | ★★★★☆ | 结构体大小计算、对齐规则 | 选择 |
| **关键字** | ★★★★☆ | static/const/volatile/extern | 问答 |
| **进程与线程** | ★★★★☆ | 区别、同步互斥、调度 | 问答/选择 |
| **通信协议** | ★★★★☆ | UART/I2C/SPI/CAN 原理与对比 | 问答 |
| **位运算** | ★★★☆☆ | 置位/清零/判断2的幂/移位 | 选择/编程 |
| **字符串操作** | ★★★☆☆ | strcpy/memcpy 实现、反转、去重 | 编程 |
| **栈与队列** | ★★★☆☆ | 两栈实现队列、括号匹配 | 编程 |
| **大小端** | ★★★☆☆ | 判断方法、网络字节序 | 编程 |
| **嵌入式硬件** | ★★★☆☆ | ARM架构、启动流程、中断机制 | 问答 |
| **Linux知识** | ★★★☆☆ | 文件系统、设备分类、Shell命令 | 选择/问答 |
| **单位换算** | ★★☆☆☆ | 存储单位、位与字节转换、颜色深度计算 | 计算 |
| **Shell命令** | ★★☆☆☆ | 特殊变量、逻辑运算符、文本处理 | 选择 |
| **逻辑推理** | ★★☆☆☆ | 矛盾法、假设排除法、真值判断 | 推理 |
| **递归** | ★★☆☆☆ | 斐波那契、求和、递归终止条件 | 编程 |
