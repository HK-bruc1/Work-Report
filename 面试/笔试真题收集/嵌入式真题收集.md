# 嵌入式C语言笔试真题分类整理

## 1.11 编程题（C语言基础类）

### 1.11.1 用指针方法对 N 个整数由大到小排序 【编程题】

> **考点**：指针遍历数组、排序算法（冒泡/选择排序）
> **注意**：通过指针操作数组元素，注意指针运算和解引用
>
> **由大到小**是降序，容易习惯性写成升序（`<` 写成 `>`，或反之），排序条件判断方向要特别留意
>
> 交换的是指针所指向的**值**（`*p` 的内容），而非交换指针本身的地址
>
> 指针偏移边界：外层循环控制到 `p + n - 1`，内层到 `p + n - 1 - i`，防止越界访问
>
> N 若作为变量传入，注意用 `int arr[N]` 时 N 须为编译期常量，动态数组建议用 `malloc` 分配
>
> 函数传参时数组退化为指针，`sizeof(arr)/sizeof(arr[0])` 在函数内部**失效**，需额外传入 n 值

```c
#include <stdio.h>

/* 
 * 函数：指针+冒泡排序（降序）
 * 参数：arr - 数组首地址指针，n - 元素个数
 * 注意：数组传入函数后退化为指针，sizeof失效，必须额外传n
 */
void sort_desc(int *arr, int n) {
    int i, j, tmp;
    
    for (i = 0; i < n - 1; i++) {              // 外层：共n-1轮
        for (j = 0; j < n - 1 - i; j++) {      // 内层：每轮少比一次
            
            if (*(arr + j) < *(arr + j + 1)) {  // 降序：前<后就交换
            /* 升序改为：*(arr+j) > *(arr+j+1) */
                tmp        = *(arr + j);
                *(arr + j)     = *(arr + j + 1);
                *(arr + j + 1) = tmp;            // 交换的是值，不是指针
            }
        }
    }
}

int main() {
    int arr[] = {3, 1, 4, 1, 5, 9, 2, 6};
    
    int n = sizeof(arr) / sizeof(arr[0]);  // sizeof只在main里有效！
    
    sort_desc(arr, n);                     // 数组名即首地址，直接传入
    
    int *p;
    for (p = arr; p < arr + n; p++) {      // 指针遍历：p从首地址走到末尾
        printf("%d ", *p);                 // 解引用取值
    }
    
    return 0;
}
```

**易错速查：**

| 易错点            | 正确做法                          |
| ----------------- | --------------------------------- |
| 降序/升序写反     | 降序用 `<`，升序用 `>`            |
| 交换了指针而非值  | 操作 `*(arr+j)`，不要操作 `arr+j` |
| 函数内用sizeof算n | 必须从main传n进来                 |
| 内层循环越界      | 上限写 `n-1-i`，不是 `n-1`        |

### 1.11.3 斐波那契数列（递归与循环）【编程题】

> **考点**：递归实现简洁但效率低（指数级时间复杂度）；循环实现高效（O(n)）
> **注意**：
>
> 递归实现需注意栈溢出风险；可用尾递归或记忆化优化
>
> **边界条件**：F(0)=0，F(1)=1，部分题目定义F(1)=1，F(2)=1，下标起点不同会导致结果差一位，**务必看清题目定义**
>
> 递归版本 n 稍大（如n>40）就会明显卡顿，考试中递归只用于演示，**不要用递归处理大n**
>
> 循环版本注意初始化：`a=0, b=1`，每轮用临时变量 `tmp` 保存旧值再更新，否则覆盖问题导致结果错误
>
> 返回值类型：n 较大时 `int` 会溢出，严格场合应用 `long long`
>
> 循环版 n=0 和 n=1 需要单独处理，否则循环体可能不执行或出错

请用C语言实现斐波那契数列（使用递归与循环两种方式）。

```c
#include <stdio.h>

/* ============================================
 * 方法一：递归（简洁，仅用于演示，n>40会卡）
 * ============================================ */
long long fib_recursive(int n) {
    if (n == 0) return 0;   // 边界：F(0)=0
    if (n == 1) return 1;   // 边界：F(1)=1
    return fib_recursive(n-1) + fib_recursive(n-2);  // 递归公式
}

/* ============================================
 * 方法二：循环（高效，实际首选）
 * ============================================ */
long long fib_loop(int n) {
    if (n == 0) return 0;   // 单独处理边界，防止循环不执行
    if (n == 1) return 1;   // 单独处理边界

    long long a = 0, b = 1, tmp;  // a=F(0), b=F(1)
    int i;
    for (i = 2; i <= n; i++) {
        tmp = a + b;   // 第一步：算新值，存入tmp
        a = b;         // 第二步：a往前移
        b = tmp;       // 第三步：b=新值，不能直接b=a+b再a=b！
    }
    return b;          // 循环结束后b就是F(n)
}

int main() {
    int n = 10;
    printf("递归：F(%d) = %lld\n", n, fib_recursive(n));
    printf("循环：F(%d) = %lld\n", n, fib_loop(n));
    return 0;
}
```

**背板记忆口诀：**

```c
递归版：
  n=0返回0，n=1返回1
  否则 return f(n-1)+f(n-2)

循环版：
  先处理n=0返回0，n=1返回1
  a=0, b=1 从i=2循环到n
  tmp=a+b → a=b → b=tmp
  返回b
```

**循环版核心：三步不能乱序**

```c
tmp = a + b;  // ① 先保存新值
a = b;        // ② a往前移
b = tmp;      // ③ b=新值
// 不能写成 b=a+b; a=b; 因为a+b算完b变了，a=b就错了
```

**易错速查：**

| 易错点            | 正确做法                    |
| ----------------- | --------------------------- |
| 边界少写n=0       | 递归和循环都要写n=0和n=1    |
| 直接 `b=a+b; a=b` | 必须用tmp中转，三步不乱     |
| 用int存结果       | n稍大就溢出，用 `long long` |
| 递归用于大n       | 递归只做演示，大n用循环     |

---

### 2.1 内存管理经典题 【分析题】

#### 2.1.1 指针值传递问题

```c
void GetMemory(char *p)
{
    p = (char *)malloc(100);
}

void Test(void)
{
    char *str = NULL;
    GetMemory(str);
    strcpy(str, "hello world");
    printf(str);
}
```

请问运行 `Test` 函数会有什么样的结果？

运行结果：程序崩溃（段错误）

```c
原因分析：
① GetMemory 无法将地址传回
C语言所有函数参数本质都是值传递。str 传入 GetMemory 时，p 是 str 的副本，两者独立。函数内 p = malloc(100) 只改变了副本 p 的指向，str 仍然是 NULL。
② malloc 申请的内存泄漏
p 指向的那块100字节内存，函数返回后没有任何指针持有它，既无法使用也无法释放，造成内存泄漏。
③ 对空指针写入，程序崩溃
str 为 NULL，strcpy(str, "hello world") 等于向地址0写入数据，触发段错误，程序直接崩溃，printf 永远执行不到。
```


---

#### 2.1.2 返回局部数组问题

```c
char *GetMemory(void)
{
    char p[] = "hello world";
    return p;
}

void Test(void)
{
    char *str = NULL;
    str = GetMemory();
    printf(str);
}
```

请问运行 `Test` 函数会有什么样的结果？

**运行结果：不确定（乱码 / 侥幸输出 / 崩溃）**

**原因分析：**

**① 返回栈上局部数组的地址，产生野指针**

`p[]` 是栈上的局部数组，函数返回后栈帧销毁，`p` 指向的内存已经是未定义区域。`str` 拿到的是一个**野指针**，指向已释放的栈内存。

**② printf 结果不确定**

此时栈内存虽然释放但内容不一定立刻被覆盖，所以结果取决于运行时栈的状态，有三种可能：输出乱码、侥幸输出"hello world"（栈内存恰好未被覆盖）、直接崩溃。

`printf(str)` 语法上没有错误。`printf` 第一个参数本身就是格式字符串，当字符串内容不含 `%` 时，`printf(str)` 和 `printf("%s", str)` 效果完全一样。虽然 `printf("%s", str)` 是更规范的写法，但这不是本题的核心问题。


---

#### 2.1.3 二级指针正确用法

```c
void GetMemory2(char **p, int num)
{
    *p = (char *)malloc(num);
}

void Test(void)
{
    char *str = NULL;
    GetMemory2(&str, 100);
    strcpy(str, "hello");
    printf(str);
}
```

请问运行 `Test` 函数会有什么样的结果？

- `&str` 传入二级指针，`*p = malloc(num)` 成功修改了外部 `str` 的指向，`str` 拿到了合法的堆内存地址，`strcpy` 和 `printf` 都能正常执行，输出 `hello`。

- `malloc` 申请的堆内存用完后没有调用 `free(str)`，造成内存泄漏。


---

#### 2.1.4 free后未置NULL问题

```c
void Test(void)
{
    char *str = (char *)malloc(100);
    strcpy(str, "hello");
    free(str);

    if (str != NULL)
    {
        strcpy(str, "world");
        printf(str);
    }
}
```

请问运行 `Test` 函数会有什么样的结果？

- `free(str)` 后 `str` 没有置 `NULL`，`str` 仍然保存着原来的地址，成为**野指针**。
- `if (str != NULL)` 这个判断**完全失效**——因为 `str` 不是 `NULL`，它还存着原地址，所以判断结果是 `true`，直接进入 `if` 块，对已释放的内存执行 `strcpy`，导致**结果不确定（乱码/崩溃）**。


---

### 2.2 for循环优化 【问答题】

请简述以下两个for循环的优缺点：

```c
// 第一种：循环内判断
for (i = 0; i < N; i++)
{
    if (condition)
        DoSomething();
    else
        DoOtherThing();
}

// 第二种：循环外判断
if (condition)
{
    for (i = 0; i < N; i++)
        DoSomething();
}
else
{
    for (i = 0; i < N; i++)
        DoOtherThing();
}
```

<details><summary>💡 答案提示</summary>
<p><b>第一种（循环内判断）：</b></p>
<ul>
<li>优点：代码简洁，逻辑清晰，容易理解</li>
<li>缺点：每次循环都要做一次 <code>condition</code> 判断，<b>多了 N 次判断开销</b></li>
</ul>
<p><b>第二种（循环外判断）：</b></p>
<ul>
<li>优点：<code>condition</code> 只判断一次，循环体内无分支，<b>运行效率高</b></li>
<li>缺点：代码冗余，两个 for 循环重复，不易维护</li>
</ul>
<p><b>选择建议：</b></p>
<ul>
<li>如果 N 较小，优先选第一种（可读性优先）</li>
<li>如果 N 很大且 condition 与循环无关（循环不变量），优先选第二种（性能优先）</li>
<li>现代编译器优化可能会自动将第一种优化为第二种（循环不变量外提）</li>
</ul>
</details>

---

### 2.3 #include区别 【问答题】

`#include <filename.h>` 和 `#include "filename.h"` 有什么区别？

<details><summary>💡 答案提示</summary>
<table>
<tr><th>写法</th><th>搜索顺序</th></tr>
<tr><td><code><filename.h></code></td><td>编译器<b>只在</b>标准库/系统头文件目录中搜索（如 <code>/usr/include</code>、编译器自带的 <code>include</code> 目录）</td></tr>
<tr><td><code>"filename.h"</code></td><td>编译器<b>先在</b>当前源文件所在目录（或项目目录）搜索，<b>找不到再去</b>标准库路径搜索</td></tr>
</table>
<p><b>示例：</b></p>
<ul>
<li><code><stdio.h></code> → 搜索 <code>/usr/include/stdio.h</code>（系统路径）</li>
<li><code>"myheader.h"</code> → 先搜索 <code>./myheader.h</code>（当前目录），找不到再去系统路径</li>
</ul>
</details>

---

### 2.4 sizeof计算 【计算题】

以下为Windows NT下的32位C++程序，请计算sizeof的值：

```c
char str[] = "Hello";
char *p = str;
int n = 10;

1. sizeof(str) = 
2. sizeof(p) = 
3. sizeof(n) = 

void Func(char str[100])
{
4. sizeof(str) = 
}

void *p = malloc(100);
5. sizeof(p) = 
```

<details><summary>💡 答案提示</summary>
<ol>
<li><code>sizeof(str) = 6</code> — 字符串 <code>"Hello"</code> 有5个字符 + 1个 <code>'\0'</code> 结尾符 = 6字节</li>
<li><code>sizeof(p) = 4</code> — 32位系统下，任何类型的指针大小都是4字节</li>
<li><code>sizeof(n) = 4</code> — 32位系统下 <code>int</code> 为4字节</li>
<li><code>sizeof(str) = 4</code> — 数组作为函数参数时<b>退化为指针</b>，不再保留数组长度信息</li>
<li><code>sizeof(p) = 4</code> — <code>void*</code> 也是指针，32位下为4字节</li>
</ol>
<p><b>注意：</b>如果是64位系统，第2、4、5题答案变为 <b>8</b></p>
</details>

---

### 2.5 结构体赋值 【选择题】

对于以下stTest结构体赋值，正确的说法是？

```c
typedef struct
{
    u8 Bass;
    u8 Treble;
    u16 eq[3];
    u8 *pPEQTable;   
} stSoundModeSeting;

stSoundModeSeting stTest;
stSoundModeSeting stDefault = {50, 50, {10, 10, 10}, NULL};
```

- A：所有逐一成员赋值
- B：可使用如下赋值 `memcpy(&stTest, &stDefault, sizeof(stTest));`
- C：可使用如下赋值 `stTest = stDefault;`

<details><summary>💡 答案提示</summary>
<p><b>答案：B、C</b></p>
<ul>
<li>B：<code>memcpy</code>整体拷贝 —— 正确，按内存逐字节复制</li>
<li>C：<b>C语言支持同类型结构体之间直接用<code>=</code>赋值！</b> 这是合法操作，编译器会自动进行成员逐一拷贝</li>
</ul>
<p><b>考点：</b>C语言结构体赋值的三种方式：①逐一成员赋值 ②<code>memcpy</code>整体拷贝 ③直接<code>=</code>赋值</p>
</details>

---

<details><summary>💡 答案提示</summary>
<p><b>答案：B <code>char *s; s = "abcde";</code></b></p>
<table>
<tr><th>选项</th><th>分析</th></tr>
<tr><td>A</td><td><code>char s[5]</code> 数组大小为5，但初始化列表有6个元素，<b>数组越界</b>，编译器会报错</td></tr>
<tr><td>B</td><td>正确，指针指向字符串字面量首地址 ✓</td></tr>
<tr><td>C</td><td>试图通过一个<b>未初始化的指针</b>来接收输入数据。指针没有指向合法缓冲区</td></tr>
<tr><td>D</td><td><code>"abcde"</code>含隐含的<code>\0</code>共6字节，数组只有5字节，<b><code>\0</code>被截断</b>，结果不是合法的C字符串</td></tr>
</table>
</details>

---

### 2.8 malloc存储位置 【选择题】

C语言中，malloc函数申请到的空间储存在哪个位置？

```c
A: BSS段
B: 栈区
C: 堆区
D: data段
```

<details><summary>💡 答案提示</summary>
<p><b>答案：C 堆区</b></p>
<table>
<tr><th>内存区域</th><th>存储内容</th></tr>
<tr><td>BSS段</td><td>未初始化的全局变量和静态变量</td></tr>
<tr><td>栈区</td><td>局部变量、函数参数、返回地址</td></tr>
<tr><td><b>堆区</b></td><td><b>动态分配的内存（malloc/calloc/realloc申请）</b></td></tr>
<tr><td>data段</td><td>已初始化的全局变量和静态变量</td></tr>
</table>
</details>

---

### 2.9 函数类型题 【选择题】

以下不正确的说法是？

```c
A: 如果函数值的类型与返回值类型不一致，以函数值类型为准
B: return后边的值不能为表达式
C: 如果形参与实参类型不一致，以实参类型为准
D: 定义函数时，形参的类型说明可以放在函数体内
```

<details><summary>💡 答案提示</summary>
<p><b>答案：B、C、D</b></p>
<table>
<tr><th>选项</th><th>分析</th></tr>
<tr><td>A</td><td>正确说法：函数声明的返回类型与实际return值类型不一致时，以<b>函数声明的返回类型为准</b>（隐式类型转换）</td></tr>
<tr><td>B</td><td><b>不正确</b>：return后面当然可以接表达式，如<code>return a + b;</code>、<code>return x > 0 ? x : -x;</code></td></tr>
<tr><td>C</td><td><b>不正确</b>：形参与实参类型不一致时，以<b>形参类型为准</b>（实参被隐式转换为形参类型），不是以实参类型为准</td></tr>
<tr><td>D</td><td><b>不正确</b>：形参类型说明应写在函数头部的参数列表中，不能放在函数体内</td></tr>
</table>
<p><b>考点：</b>C语言函数的类型转换规则——无论是返回值还是参数传递，都是<b>被调用方的声明类型为准</b>（函数返回类型、形参类型）</p>
</details>
### 2.10 字符串翻转 【编程题】

内存地址是从低到高的。无论数据是大端还是小端存储。都可以实现翻转。

```c
char *reverseString(char *str) {
    if (str == NULL) {
        return; // 处理空指针的情况
    }

    char *left = str;
    char *right = str;

    // 将 right 指针移动到字符串的末尾
    while (*right != '\0') {
        right++;
    }
    right--; // right 指向最后一个字符

    char temp;
    //这种情况偶数的话，会全部交换完，奇数的话，最中间的那个不会发生交换
    while (left < right) {
        temp = *left;
        *left = *right;
        *right = temp;
        left++;
        right--;
    }
    return str
}
```

### 2.11 字符串拼接 【编程题】

手动实现的strcat函数代码：

```c
char* my_strcat(char* dest, const char* src) {
    char* ptr = dest;
    
    // 找到目标字符串的末尾
    while (*ptr != '\0') {
        ptr++;
    }
    
    // 将源字符串复制到目标字符串的末尾
    while (*src != '\0') {
        *ptr++ = *src++;
    }
    
    // 添加字符串结束符
    *ptr = '\0';
    
    // 返回目标字符串的起始地址
    return dest;
}
```

# 二、算法与数据结构

## 2.2 链表

### 2.2.1 单链表基本操作 【编程题】

> **考点**：链表节点定义、插入、删除操作
> **注意**：注意头节点处理、空链表处理、内存申请失败处理

**(1)** 单链表结构定义及指定位置插入节点：

```c
typedef struct Node {
    int data;
    struct Node *next;
} Node;

int insert_node(Node *head, int pos, int value);
```

功能说明：
- 在链表的第 `pos` 个位置插入值为 `value` 的新节点
- 插入成功返回 1，失败返回 0
- 位置从 0 开始，假设链表带头结点

边界情况：①头部插入 ②尾部插入 ③位置越界 ④空链表 ⑤内存申请失败

---

**(2)** 单链表插入一个新的节点。 【编程题】

---

**(3)** 链表的有序插入。 【编程题】

---

### 2.2.2 链表倒序/反转 【编程题】

> **考点**：三指针法（prev/curr/next）逐个翻转指针方向
> **注意**：注意处理空链表和单节点链表

1. 如何实现链表的倒序？
2. 将一个链表倒序。

<details><summary>💡 答案提示</summary>
<p>三指针迭代法：</p>
<pre><code>Node* reverse(Node* head) {
    Node *prev = NULL, *curr = head, *next;
    while (curr) {
        next = curr->next;
        curr->next = prev;
        prev = curr;
        curr = next;
    }
    return prev;
}</code></pre>
</details>

---

### 2.2.3 链表判环 【问答题】

> **考点**：快慢指针法——快指针每次走2步，慢指针走1步，相遇则有环
> **注意**：还可进一步求环的入口点和环的长度

怎么判断链表中是否有环？

<details><summary>💡 答案提示</summary>
<p><b>快慢指针法（Floyd 判环算法）：</b></p>
<ul>
<li>慢指针每次走 1 步，快指针每次走 2 步</li>
<li>若有环，两者必在环内相遇</li>
<li>若快指针到达 NULL，则无环</li>
</ul>
<p>进阶：相遇后，将一个指针移回头节点，两个指针都每次走1步，再次相遇点即为<b>环入口</b>。</p>
</details>

---

### 2.2.4 链表元素互换位置 【编程题】

> **考点**：交换链表中两个节点需同时修改前驱节点的指针
> **注意**：注意相邻节点交换的特殊情况

---

### 2.2.5 双向链表操作 【编程题】

> **考点**：双向链表的插入和删除需同时维护 `prev` 和 `next` 指针
> **注意**：什么时候用双向链表——需要双向遍历、频繁删除指定节点时

1. 什么时候用双向链表？
2. 编程实现一个双向链表的删除过程。

---

### 2.2.6 链表按值三路划分（分区问题）【编程题】

> **考点**：使用三对头尾指针分别收集小于/等于/大于目标值的节点，最后拼接
> **注意**：要求保持每个分区内节点的原有相对顺序不变；O(n) 时间，O(1) 额外空间

给定单链表头指针 `head` 和整数 `val`，对链表进行重排：

- `data < val` 排在左侧
- `data == val` 排在中间
- `data > val` 排在右侧

```c
typedef struct Linklist {
    int data;
    struct Linklist *next;
} Linklist;
```

要求：不修改数据域、不使用数组、O(n) 时间。

---

### 2.2.7 求取单链表中间位置的值 【编程题】

> **考点**：快慢指针法——快指针走2步、慢指针走1步，快指针到末尾时慢指针在中间
> **注意**：偶数个节点时返回第一个中间节点

---

### 2.2.8 链表与数组的区别 【问答题】+【选择题】

> **考点**：数组连续内存、随机访问O(1)、插入删除O(n)；链表非连续、顺序访问、插入删除O(1)
> **注意**：链表额外开销大（指针域），缓存不友好

**(1)** 链表与数组的区别。 【问答题】

<details><summary>💡 答案提示</summary>
<table>
<tr><th>对比项</th><th>数组</th><th>链表</th></tr>
<tr><td>内存布局</td><td>连续</td><td>非连续</td></tr>
<tr><td>随机访问</td><td>O(1)</td><td>O(n)</td></tr>
<tr><td>插入/删除</td><td>O(n)</td><td>O(1)（已知位置）</td></tr>
<tr><td>空间开销</td><td>无额外开销</td><td>每节点多一个指针域</td></tr>
<tr><td>缓存友好</td><td>是</td><td>否</td></tr>
<tr><td>大小</td><td>固定（静态数组）</td><td>动态伸缩</td></tr>
</table>
</details>

---

**(2)** 关于链表，描述正确的选项有（  ） 【选择题】

- **A.** 在运行时可以动态添加
- **B.** 物理空间不连续，空间开销更大
- **C.** 查找元素不需要顺序查找
- **D.** 可在任意节点位置插入元素

<details><summary>💡 答案提示</summary>
<p><b>答案：A、B、D</b></p>
<p>C 错误：单链表查找只能<b>顺序遍历</b>，时间复杂度 O(n)。</p>
</details>

---

## 2.3 栈与队列

### 2.3.1 栈的使用场景 【问答题】

> **考点**：函数调用栈、表达式求值、括号匹配、DFS等
> **注意**：后进先出（LIFO）特性决定了其适用场景

什么时候用栈？

---

### 2.3.2 用两个栈实现队列 【编程题】

> **考点**：一个栈做入队栈，一个栈做出队栈；出队栈为空时将入队栈全部倒入
> **注意**：均摊时间复杂度为 O(1)

用两个栈实现一个队列的功能。要求实现进队、出队、判断队为空。

<details><summary>💡 答案提示</summary>
<p>思路：</p>
<ul>
<li><b>入队</b>：直接压入栈A</li>
<li><b>出队</b>：若栈B非空则弹出栈B；若栈B为空则将栈A全部倒入栈B再弹出</li>
<li><b>判空</b>：栈A和栈B都为空</li>
</ul>
</details>

---

### 2.3.3 堆、栈、队列的描述判断 【选择题】

> **考点**：数据结构中的堆（优先队列）vs 内存中的堆；栈和队列的特性
> **注意**：堆是完全二叉树；"堆"的数据类型与"队列"**不**相似

对于堆、栈、队列描述**错误**的是（  ）

- **A.** 队列空间缓冲由进程申请，栈的空间缓冲由OS分配
- **B.** 堆总是一棵完全二叉树
- **C.** 堆的数据类型和队列相似
- **D.** 队列先进先出，栈后进先出

<details><summary>💡 答案提示</summary>
<p><b>答案：C</b></p>
<p>堆是完全二叉树结构，支持高效的最大/最小值查询；队列是线性FIFO结构。两者数据类型和操作方式完全不同。</p>
</details>

---

### 2.3.4 队列与栈的异同 【问答题】

> **考点**：LIFO vs FIFO；典型应用场景（函数调用栈/DFS vs 消息队列/BFS）
> **注意**：两者都是操作受限的线性结构；变体包括循环队列、双端队列、优先队列

简述队列和栈的异同。

<details><summary>💡 答案提示</summary>
<p><b>相同点：</b></p>
<ul>
<li>都是<b>线性数据结构</b>，操作受限（不允许随机访问中间元素）</li>
<li>都可以用数组或链表实现</li>
</ul>
<p><b>不同点：</b></p>
<table>
<tr><th>区别</th><th>栈（Stack）</th><th>队列（Queue）</th></tr>
<tr><td>原则</td><td><b>LIFO</b>（后进先出）</td><td><b>FIFO</b>（先进先出）</td></tr>
<tr><td>操作</td><td><code>push</code>（入栈）/ <code>pop</code>（出栈），同一端</td><td><code>enqueue</code>（入队尾）/ <code>dequeue</code>（出队头）</td></tr>
<tr><td>典型应用</td><td>函数调用栈、DFS</td><td>消息队列、BFS</td></tr>
</table>
</details>

---

## 2.4 字符串算法

### 2.4.1 实现 strcpy 函数 【编程题】

> **考点**：逐字符复制直到 `\0`；注意目标缓冲区大小、返回目标字符串首地址
> **注意**：经典面试题——需处理 `NULL` 指针、重叠区域等边界情况

不使用库函数，编写 `strcpy` 函数：

```c
char *strcpy(char *strDest, const char *strSrc);
```

<details><summary>💡 答案提示</summary>
<pre><code>char *strcpy(char *strDest, const char *strSrc) {
    assert(strDest != NULL && strSrc != NULL);
    char *ret = strDest;
    while ((*strDest++ = *strSrc++) != '\0');
    return ret;
}</code></pre>
<p>得分要点：①assert 检查 ②返回目的地址（支持链式调用）③循环条件含赋值和判断</p>
</details>

---

### 2.4.2 实现 memcpy 函数 【编程题】

> **考点**：按字节逐个复制指定长度的内存内容
> **注意**：需处理源和目标内存重叠的情况（此时应从后往前复制）

```c
void *memcpy(void *dst, const void *src, int size);
```

<details><summary>💡 答案提示</summary>
<p>处理重叠的关键：当 <code>dst > src</code> 且有重叠时，从<b>后往前</b>复制；否则从前往后。</p>
</details>

---

### 2.4.3 字符串反转 【编程题】

> **考点**：首尾双指针交换，O(n) 时间，O(1) 空间
> **注意**：不使用任何系统函数

```c
char* reverse_str(char* str);
```

---

### 2.4.4 最大连续子串长度 【编程题】

> **考点**：遍历字符串，区分字母和数字段，记录最大长度
> **注意**：注意"子串"的定义——连续的同类字符（字母或数字）

**(1)** 将一个字符串中最大连续子串中的长度和子串返回（主要区分字母和数字）。

**(2)** 计算一个字符串中最大的子串的长度并返回。如 `"abcdefg123456789asdfgagfafg"` 中最大子串是 `"asdfgagfafg"`。

---

### 2.4.5 最长不重复子串 【编程题】

> **考点**：滑动窗口法，维护窗口内字符不重复
> **注意**：可用哈希表/数组记录字符最近出现位置

找出字符串的最长不重复子串，输出长度。

---

### 2.4.6 字符串去除重复字符 【编程题】

> **考点**：使用布尔数组标记已出现字符，保留首次出现
> **注意**：ASCII 字符集共128/256个字符，可用数组做哈希

输入 `"abcabcdeffg"`，输出 `"abcdefg"`。

---

### 2.4.7 字符串形式的大整数相加 【编程题】

> **考点**：模拟竖式加法——从末尾逐位相加并处理进位
> **注意**：两字符串长度可能不同；最高位可能产生进位

```c
char a[] = "1111";
char b[] = "9999";
// 输出: "11110"
```

要求：逐位相加 + 进位处理，不能转换为整数类型。

---

### 2.4.8 计算字符串中单词个数 【编程题】

> **考点**：遍历字符串，识别空格与非空格的边界转换
> **注意**：需处理连续空格、首尾空格等边界情况

---

### 2.4.9 消除嵌套括号 【编程题】

> **考点**：栈的应用——遇左括号压栈（或标记），遇右括号弹栈，只保留数字和逗号
> **注意**：需检测格式错误（括号不匹配等）

给定字符串 `(1,(2,3),(4,(5,6),7))`，消除嵌套括号输出 `(1,2,3,4,5,6,7)`。

---

### 2.4.10 数字字符串转化为数字（my_atoi）【编程题】

> **考点**：字符与数字的 ASCII 转换（`- '0'`）；逐位累乘10相加的核心公式
> **注意**：完整实现需考虑前导空格、正负号、溢出检测（超出 `INT_MAX`/`INT_MIN`），面试中提一嘴加分

编码实现将数字字符串转化为数字（实现 `atoi`）。

<details><summary>💡 答案提示</summary>
<pre><code>int my_atoi(const char *str) {
    int sign = 1, result = 0;
    // 1. 跳过前导空格
	while (*str == ' ') str++;
	// 2. 处理正负号
    if (*str == '-' || *str == '+') {
        if (*str == '-') sign = -1;
        str++;
    }

    // 3. 逐位转换：字符 - '0' 得到数字，累乘10相加
    while (*str >= '0' && *str <= '9') {
        result = result * 10 + (*str - '0');
        str++;
    }
    
    return sign * result;
    }</code></pre>
    <p>核心原理：<code>字符 - '0'</code> 得到对应数字值，通过 <code>result = result * 10 + digit</code> 逐位累加。</p>
</details>

---

## 2.5 数组算法

### 2.5.1 4位二进制分组求和 【编程题】

> **考点**：位运算——每次取低4位、右移4位，循环8次
> **注意**：掩码 `& 0xF` 提取低4位

给定32位无符号整数，将其二进制每4位一组，每组转为十进制后求和。

> **示例**：`0xFFFFFFFF` → 每组都是 `1111`(=15) × 8组 = **120**

<details><summary>💡 答案提示</summary>
<pre><code>int nibble_sum(unsigned int n) {
    int sum = 0;
    for (int i = 0; i < 8; i++) {
        sum += (n & 0xF);
        n >>= 4;
    }
    return sum;
}</code></pre>
</details>

---

### 2.5.2 找出两个数组的差集 【编程题】

> **考点**：对每个第一数组元素检查是否在第二数组中存在
> **注意**：可用排序+双指针优化为 O(nlogn)；也可用哈希表优化为 O(n)

---

### 2.5.3 求数组中出现次数最多的元素 【编程题】

> **考点**：遍历统计频次，记录最大值
> **注意**：不允许修改原数组；多个并列最多时返回第一次出现的元素

```c
int a[] = {1, 3, 2, 3, 4, 3, 2, 1};
// 输出: 3（出现3次）
```

---

### 2.5.4 返回数组第二大的数 【编程题】

> **考点**：一次遍历维护最大值和次大值
> **注意**：需处理所有元素相同、数组只有一个元素等边界情况

---

### 2.5.5 二维数组中最大值及其位置 【编程题】

> **考点**：双重循环遍历，记录最大值及其行列索引
> **注意**：注意行列编号从0开始

```c
#define ROW 3
#define COL 4
int arr[ROW][COL] = {
    {12, 7,  9,  15},
    {3,  22, 8,  6},
    {14, 5,  18, 10}
};
```

---

### 2.5.6 打印 N×N 方阵 【编程题】

> **考点**：多层嵌套循环，根据元素到边界的最小距离决定打印内容
> **注意**：距离0打印X，距离1打印Y，距离≥2打印 `距离-2`

```
N=5 时：
X X X X X
X Y Y Y X
X Y 0 Y X
X Y Y Y X
X X X X X
```

---

## 2.6 数学与递归

### 2.6.1 递归求和（1到N）【编程题】

> **考点**：递归函数定义、终止条件（`n==1` 返回1）、函数调用栈
> **注意**：递归深度过大会导致栈溢出

```c
int sum(int n);  // 计算 1+2+...+n
```

<details><summary>💡 答案提示</summary>
<pre><code>int sum(int n) {
    if (n == 1) return 1;      // 递归终止条件
    return n + sum(n - 1);     // 递归调用
}</code></pre>
</details>

---

### 2.6.2 N! 末尾零的个数 【编程题】

> **考点**：末尾零由因子10产生，10=2×5，因子5的个数决定零的个数
> **注意**：`count = N/5 + N/25 + N/125 + ...`

<details><summary>💡 答案提示</summary>
<pre><code>int trailing_zeros(int n) {
    int count = 0;
    while (n >= 5) {
        count += n / 5;
        n /= 5;
    }
    return count;
}</code></pre>
</details>

---

### 2.6.3 最小公倍数 【编程题】

> **考点**：`LCM(a,b) = a*b / GCD(a,b)`；GCD 用辗转相除法求
> **注意**：先求最大公约数再求最小公倍数；注意乘法溢出

---

### 2.6.4 集合中求最大元素 C = A + B 【编程题】

> **考点**：遍历集合找最大元素，再遍历找是否存在两个元素之和等于它
> **注意**：A和B可以是同一个元素（需看题目要求）

### 4.1 大整数乘法算法 【选择题】

实现大整数乘法是利用什么算法？

```c
A: 动态规划算法
B: 贪心算法
C: 分治算法
D: 回溯算法
```

<details><summary>💡 答案提示</summary>
<p><b>答案：C（分治算法）</b></p>
<p>经典的<b>Karatsuba算法</b>就是用分治思想实现大整数乘法：</p>
<ol>
<li>将大整数拆分为高位和低位两部分</li>
<li>递归地对较小的部分做乘法</li>
<li>合并结果</li>
<li>时间复杂度从朴素的O(n²)降到O(n^1.585)</li>
</ol>
<p><b>考点：</b>分治算法的经典应用——大整数乘法(Karatsuba)、归并排序、快速排序、Strassen矩阵乘法</p>
</details>

---

### 4.2 链表删除重复项 【选择题】

以下代码实现了从表中删除重复项的功能，请选择其中空白行应填入的正确代码。

```c
template <class T>
void removeDuplicates(list<T> &aList)
    list<T>::iterator cur, p;

    cur = aList.begin();
    while (cur != aList.end())
    {
        curValue = *cur;

        // 空白行①

        while (p != aList.end())
        {
            if (*p == curValue)
            {
                // 空白行②
            }
            else
            {
                p++;
            }
        }

        cur++;
    }
}

A:
p = ++cur;
aList.erase(p++);

B:
p = cur + 1;
aList.erase(p);

C:
p = cur + 1;
aList.erase(p++);

D:
p = ++cur;
aList.erase(p);
```

<details><summary>💡 答案提示</summary>
<p><b>答案：A</b></p>
<p><b>关键错误：<code>std::list</code>的迭代器不支持<code>+</code>运算符！</b></p>
<ul>
<li><code>list</code>是双向链表，迭代器是<b>BidirectionalIterator</b>，只支持<code>++</code>和<code>--</code></li>
<li><code>cur + 1</code>无法通过编译，<b>B和C直接排除</b></li>
<li>只有<code>++cur</code>（自增）才是合法的迭代器操作</li>
</ul>
<p><b>分析A选项：</b></p>
<ul>
<li>空白行①：<code>p = ++cur;</code> —— cur先自增指向下一个元素，p也指向该位置</li>
<li>空白行②：<code>aList.erase(p++);</code> —— <b>先保存p当前位置用于erase，再将p自增指向下一个元素</b>。这是STL中删除元素的标准写法，避免迭代器失效</li>
</ul>
</details>

---

### 4.3 进制转换 【编程题】

给定一个整数，将其转化为7进制，并以字符串形式输出。

示例1:
输入: 100
输出: "202"

示例2:
输入: -7
输出: "-10"

注意: 输入范围是[-1e7, 1e7]。

<details><summary>💡 答案提示</summary>
<p><b>思路：短除法（辗转取余）</b></p>
<p>不断对7取余得到每一位，再对7整除缩小数值，最后将结果反转。负数先转正数处理，最后加负号。</p>
<pre><code>char* toBase7(int num)
{
    // 静态缓冲区足够容纳范围 [-1e7, 1e7]
    // 7^9 = 40353607 > 1e7
    // 最多 9 位 + 负号 + '\0'
    static char buf[12];

    if (num == 0) {
        buf[0] = '0';
        buf[1] = '\0';
        return buf;
    }
    
    int isNegative = 0;
    if (num < 0) {
        isNegative = 1;
        num = -num;
    }
    
    int i = 0;
    while (num > 0) {
        int digit = num % 7;
        buf[i++] = digit + '0';  // 数字转字符：加上'0'即可
        num /= 7;
    }
    
    if (isNegative) {
        buf[i++] = '-';
    }
    
    buf[i] = '\0';
    
    // 反转字符串
    int left = 0, right = i - 1;
    while (left < right) {
        char temp = buf[left];
        buf[left] = buf[right];
        buf[right] = temp;
        left++;
        right--;
    }
    
    return buf;
}</code></pre>
<p><b>示例: 100 → 100%7=6,100/7=14 → 14%7=0,14/7=2 → 2%7=2,2/7=0 → 逆序"202"</b></p>
</details>

---

### 4.4 括号匹配 【编程题】

输入一个字符串，其中包含 ()、[]、{} 六种括号，请判断该字符串中的括号是否合法。

| 输入       | 输出    |
| ---------- | ------- |
| `"()[]{}"` | `true`  |
| `"(]"`     | `false` |
| `"(["`     | `false` |

**判定规则**
1. 左括号必须由相同类型的右括号闭合。
2. 左括号必须按正确的顺序闭合（后开先闭）。
3. 每个右括号都必须有对应的左括号。
4. 所有括号最终都必须完全匹配。

<details><summary>💡 答案提示</summary>
<p><b>思路：栈（后进先出，天然匹配"后开先闭"规则）</b></p>
<pre><code>bool isValid(const char* s)
{
    int len = strlen(s);

    // 最大栈深度不超过字符串长度
    char stack[len];
    int top = -1;
    
    for (int i = 0; i < len; i++)
    {
        char c = s[i];
        
        // 左括号入栈
        if (c == '(' || c == '[' || c == '{')
        {
            stack[++top] = c;
        }
        else
        {
            // 右括号时，栈必须非空
            if (top < 0)
                return false;
            
            char t = stack[top--];  // 出栈
            
            // 检查是否匹配
            if ((c == ')' && t != '(') ||
                (c == ']' && t != '[') ||
                (c == '}' && t != '{'))
            {
                return false;
            }
        }
    }
    
    // 所有括号必须匹配完成
    return top == -1;
}</code></pre>
<p><b>考点：</b>栈的经典应用——括号匹配。三个容易遗漏的边界：①右括号多余（栈空时遇到右括号）②左括号多余（遍历结束栈不空）③类型不匹配（<code>(</code>遇到<code>]</code>）</p>
</details


---

# 五、综合

## 5.1 嵌入式硬件与体系结构

### 5.1.1 ARM 架构 【问答题】

> **考点**：ARM 核心架构（Cortex-M/A/R系列）、流水线、工作模式、寄存器组
> **注意**：嵌入式常用 Cortex-M 系列（M0/M3/M4/M7），注意中断处理和低功耗特性

讲述 ARM 架构的了解。

<details><summary>💡 答案提示</summary>
<table>
<tr><th>系列</th><th>定位</th><th>典型应用</th></tr>
<tr><td><b>Cortex-M</b></td><td>微控制器</td><td>STM32、物联网终端</td></tr>
<tr><td><b>Cortex-R</b></td><td>实时处理</td><td>汽车ECU、硬盘控制器</td></tr>
<tr><td><b>Cortex-A</b></td><td>应用处理</td><td>手机、平板、Linux设备</td></tr>
</table>
<p>关键特性：RISC架构、Thumb指令集、低功耗设计、丰富的中断处理机制(NVIC)</p>
</details>

---

### 5.1.2 单片机的通用启动过程 【问答题】

> **考点**：上电复位→初始化栈指针→初始化时钟→初始化外设→跳转 main
> **注意**：启动文件（startup.s）、向量表、系统时钟配置（HSE/HSI/PLL）是关键步骤

单片机的通用启动过程。

<details><summary>💡 答案提示</summary>
<pre><code>上电/复位
  → ① 从向量表读取初始栈指针(MSP)
  → ② 从向量表读取复位向量(Reset_Handler地址)
  → ③ 执行 Reset_Handler（启动文件 startup.s）
      → 初始化 .data 段（从Flash拷贝到RAM）
      → 清零 .bss 段
      → 配置系统时钟（HSE/PLL）
      → 调用 C 库初始化
  → ④ 跳转到 main()</code></pre>
</details>

---

### 5.1.3 U-Boot 引导启动流程 【问答题】

> **考点**：BL1→BL2→加载内核→传参→启动Linux
> **注意**：U-Boot 分为 SPL 和完整 U-Boot 两个阶段

<details><summary>💡 答案提示</summary>
<pre><code>ROM Bootloader
  → SPL (Secondary Program Loader)
      → 初始化DDR、时钟
      → 加载完整 U-Boot 到 DDR
  → U-Boot
      → 初始化外设（串口、网络、存储）
      → 加载内核镜像(zImage/uImage)到内存
      → 传递设备树(DTB)和启动参数
      → 跳转到内核入口
  → Linux Kernel 启动</code></pre>
</details>

---

### 5.1.4 STM32 软件中断与外设实现 【问答题】

> **考点**：NVIC 中断控制器、中断优先级分组、中断向量表、软件触发中断
> **注意**：包含模拟量采集的ADC中断、DMA传输完成中断等

请基于 STM32 描述：
1. 软件中断的实现机制
2. 模拟量采集的数字化实现过程
3. PWM 功能的实现过程

---

### 5.1.5 大小端（字节序）【编程题】

> **考点**：通过联合体（`union`）或指针强转检查整数低字节内容
> **注意**：大端——高位字节在低地址；小端——低位字节在低地址；ARM一般是小端，网络字节序是大端

编写程序判断当前系统的字节序类型：

```c
int x = 0x12345678;
// 若低地址存储 0x78 → 小端（Little Endian）
// 若低地址存储 0x12 → 大端（Big Endian）
```

<details><summary>💡 答案提示</summary>
<p><b>方法一：指针法</b></p>
<pre><code>int x = 1;
if (*(char*)&x == 1)
    printf("Little Endian\n");
else
    printf("Big Endian\n");</code></pre>
<p><b>方法二：联合体法</b></p>
<pre><code>union {
    int i;
    char c;
} u;
u.i = 1;
if (u.c == 1)
    printf("Little Endian\n");
else
    printf("Big Endian\n");</code></pre>
</details>

---

## 5.2 综合知识

### 5.2.1 单位换算 【计算题】

> **考点**：存储单位换算（1MB = 1024KB = 1024×1024B），位(bit)与字节(Byte)的关系（1Byte = 8bit）
> **注意**：颜色深度24位表示每个像素占24bit，计算时别忘了除以8转字节

某相机内置256MB存储空间，拍摄照片的分辨率为1600x1200像素，颜色深度为24位，若不采用压缩存储技术，使用内部储存最多可以拍多少张照片？

<details><summary>💡 答案提示</summary>
<p><b>计算过程：</b></p>
<ol>
<li>256MB = 256 × 1024 × 1024 = 268,435,456 字节(Byte)</li>
<li>一张照片大小 = 1600 × 1200 × 24 / 8 = 5,760,000 字节（注意24位是bit，要除以8换算成Byte）</li>
<li>268,435,456 ÷ 5,760,000 ≈ 46.6 → <b>最多拍46张</b></li>
</ol>
</details>

---

### 5.2.2 Shell命令行基础 【选择题】

#### 5.2.2.1 Shell特殊变量

在 Shell 中，用于表示传入参数个数的特殊变量是？

```c
A. $#
B. $*
C. $?
D. 0
```

<details><summary>💡 答案提示</summary>
<p><b>答案：A <code>$#</code></b></p>
<table>
<tr><th>变量</th><th>含义</th></tr>
<tr><td><code>$#</code></td><td>传入参数的<b>个数</b></td></tr>
<tr><td><code>$*</code></td><td>所有参数作为一个整体字符串</td></tr>
<tr><td><code>$?</code></td><td>上一条命令的<b>退出状态码</b>（0成功，非0失败）</td></tr>
<tr><td><code>$0</code></td><td>脚本自身的名称</td></tr>
</table>
</details>

---

#### 5.2.2.2 Shell逻辑运算符

下面哪种写法表示：如果 `cmd1` 成功执行，则执行 `cmd2` 命令？

A. `cmd1 cmd2`
B. `cmd1; cmd2`
C. `cmd1 && cmd2`
D. `cmd1 || cmd2`

<details><summary>💡 答案提示</summary>
<p><b>答案：C <code>cmd1 && cmd2</code></b></p>
<table>
<tr><th>写法</th><th>含义</th></tr>
<tr><td><code>cmd1 cmd2</code></td><td>语法错误/cmd2被当成cmd1的参数</td></tr>
<tr><td><code>cmd1; cmd2</code></td><td>无论cmd1成功与否，都执行cmd2（两个独立语句）</td></tr>
<tr><td><code>cmd1 && cmd2</code></td><td>cmd1<b>成功（返回0）</b>才执行cmd2</td></tr>
<tr><td><code>cmd1 || cmd2</code></td><td>cmd1<b>失败（返回非0）</b>才执行cmd2</td></tr>
</table>
</details>

---

### 5.2.3 Linux知识 【选择题】

#### 5.2.3.1 Linux设备类型

下面哪种不是Linux的设备类型？

```c
A: 块设备
B: 字符设备
C: 网络设备
D: 虚拟设备
```

<details><summary>💡 答案提示</summary>
<p><b>答案：D（虚拟设备）</b></p>
<p>Linux三大设备类型：</p>
<ol>
<li><b>块设备(Block Device)</b> —— 按数据块访问，如硬盘、SD卡</li>
<li><b>字符设备(Char Device)</b> —— 按字节流顺序访问，如串口、键盘</li>
<li><b>网络设备(Network Device)</b> —— 网络通信，如网卡eth0</li>
</ol>
<p><b>"虚拟设备"不是Linux标准设备分类。</b>网络设备是Linux三大设备类型之一。</p>
</details>

---

#### 5.2.3.2 Linux目录结构

在Linux系统中，用来存放系统所需要的配置文件和子目录是？

```c
A: /var
B: /root
C: /etc
D: /home
```

<details><summary>💡 答案提示</summary>
<p><b>答案：C <code>/etc</code></b></p>
<table>
<tr><th>目录</th><th>用途</th></tr>
<tr><td><code>/var</code></td><td>可变数据文件（日志、缓存、邮件等）</td></tr>
<tr><td><code>/root</code></td><td><b>root用户的家目录</b>，不是存放系统配置的地方</td></tr>
<tr><td><code>/etc</code></td><td><b>系统配置文件目录</b>（如<code>/etc/passwd</code>、<code>/etc/fstab</code>、<code>/etc/nginx/</code>等）</td></tr>
<tr><td><code>/home</code></td><td>普通用户的家目录</td></tr>
</table>
</details>

---

#### 5.2.3.3 Linux文本处理命令

当需要从文本文件的每一行中截取指定内容的数据时，下面那个命令可以提供帮助？

```c
A: cp
B: dd
C: fmt
D: cut
```

<details><summary>💡 答案提示</summary>
<p><b>答案：D <code>cut</code></b></p>
<table>
<tr><th>命令</th><th>用途</th></tr>
<tr><td><code>cp</code></td><td>复制文件</td></tr>
<tr><td><code>dd</code></td><td>低级数据复制/转换</td></tr>
<tr><td><code>fmt</code></td><td>文本格式化（调整行宽）</td></tr>
<tr><td><code>cut</code></td><td>按列/字段<b>截取</b>每行指定内容，如 <code>cut -d':' -f1 /etc/passwd</code></td></tr>
</table>
</details>

---

## 5.3 逻辑推理题 ⚠️ 非技术题

> **考点**：逻辑推理、矛盾法、假设排除法
> **注意**：面试中偶尔出现，考察**逻辑思维能力**而非技术知识

甲、乙、丙、丁四人各说了一句话，已知四句话中有两句为真，两句为假：

- **甲**：乙和丙说的都是真话。
- **乙**：丁说的是假话。
- **丙**：甲和丁说的都是假话。
- **丁**：乙说的是真话。

请判断谁说的是真话，谁说的是假话，并写出推理过程。

<details><summary>💡 答案提示</summary>
<p><b>关键突破口：乙和丁互相评价</b></p>
<p>乙说"丁假" ↔ 丁说"乙真"，两者互为否命题，必一真一假。</p>
<p><b>假设乙真、丁假：</b></p>
<ul>
<li>乙真 + 丁假 → 已用1真1假 → 甲丙中1真1假</li>
<li>甲说"乙丙都真" → 需丙真才能让甲为真</li>
<li>丙说"甲丁都假" → 丁假 ✓，甲假 → 那甲就是假的</li>
<li>验证：甲假、乙真、丙真、丁假 → 2真2假 ✓</li>
</ul>
<p><b>答案：乙、丙说真话；甲、丁说假话</b></p>
</details>

---

# 附录：高频考点速查表

| 考点 | 频率 | 核心知识 | 题型 |
|------|------|---------|------|
| **指针与数组** | ★★★★★ | 指针运算、数组名退化、指针步长 | 选择/分析 |
| **宏定义陷阱** | ★★★★★ | 文本替换无括号保护、优先级问题 | 选择 |
| **链表操作** | ★★★★★ | 插入、删除、反转、判环、分区 | 编程 |
| **排序算法** | ★★★★☆ | 快排实现、稳定性、时间复杂度 | 编程/选择 |
| **内存对齐** | ★★★★☆ | 结构体大小计算、对齐规则 | 选择 |
| **关键字** | ★★★★☆ | static/const/volatile/extern | 问答 |
| **进程与线程** | ★★★★☆ | 区别、同步互斥、调度 | 问答/选择 |
| **通信协议** | ★★★★☆ | UART/I2C/SPI/CAN 原理与对比 | 问答 |
| **位运算** | ★★★☆☆ | 置位/清零/判断2的幂/移位 | 选择/编程 |
| **字符串操作** | ★★★☆☆ | strcpy/memcpy 实现、反转、去重 | 编程 |
| **栈与队列** | ★★★☆☆ | 两栈实现队列、括号匹配 | 编程 |
| **大小端** | ★★★☆☆ | 判断方法、网络字节序 | 编程 |
| **嵌入式硬件** | ★★★☆☆ | ARM架构、启动流程、中断机制 | 问答 |
| **Linux知识** | ★★★☆☆ | 文件系统、设备分类、Shell命令 | 选择/问答 |
| **单位换算** | ★★☆☆☆ | 存储单位、位与字节转换、颜色深度计算 | 计算 |
| **Shell命令** | ★★☆☆☆ | 特殊变量、逻辑运算符、文本处理 | 选择 |
| **逻辑推理** | ★★☆☆☆ | 矛盾法、假设排除法、真值判断 | 推理 |
| **递归** | ★★☆☆☆ | 斐波那契、求和、递归终止条件 | 编程 |
