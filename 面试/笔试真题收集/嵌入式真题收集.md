# 嵌入式C语言笔试真题分类整理

# 一、C语言基础

## 1.1 数据类型与变量

### 1.1.1 结构体内存对齐 【选择题】

> **考点**：结构体大小计算、内存对齐规则（对齐到最大成员大小的整数倍）
> **注意**：`short` 2字节、`char` 1字节、`float` 4字节，对齐后可能有填充字节

设 `struct{ short a; char b; float c; } cs;` 则 `sizeof(cs)` 的值是（  ）

- **A.** 4
- **B.** 5
- **C.** 6
- **D.** 7

<details><summary>💡 答案提示</summary>
<p><b>答案：不在选项中，实际为 8</b></p>
<table>
<tr><th>成员</th><th>大小</th><th>偏移量</th><th>填充</th></tr>
<tr><td><code>short a</code></td><td>2</td><td>0</td><td>无</td></tr>
<tr><td><code>char b</code></td><td>1</td><td>2</td><td>1字节填充（对齐到4）</td></tr>
<tr><td><code>float c</code></td><td>4</td><td>4</td><td>无</td></tr>
</table>
<p>总大小 = 8，对齐到 <code>float</code>（4字节）的整数倍 → <b>8字节</b></p>
  </details>

---

### 1.1.2 左值和右值的区别 【问答题】

> **考点**：左值（可被赋值、有明确内存地址的表达式）与右值（临时值、不可取地址）的概念
> **注意**：赋值号左边必须是左值；常量、表达式结果通常是右值

请解释左值和右值的区别。

<details><summary>💡 答案提示</summary>
<ul>
<li><b>左值（lvalue）</b>：有确定内存地址、可出现在赋值号左边的表达式。如变量 <code>x</code>、数组元素 <code>a[0]</code>、解引用 <code>*p</code></li>
<li><b>右值（rvalue）</b>：没有持久地址的临时值，只能出现在赋值号右边。如常量 <code>10</code>、表达式 <code>a+b</code>、函数返回值</li>
</ul>
</details>

---

### 1.1.3 浅拷贝与深拷贝的区别 【问答题】

> **考点**：值拷贝 vs 内容拷贝，指针成员的处理方式
> **注意**：浅拷贝仅复制指针值，两个对象共享同一块内存；深拷贝会重新分配内存并复制内容

请解释浅拷贝与深拷贝的区别。

<details><summary>💡 答案提示</summary>
<ul>
<li><b>浅拷贝</b>：逐字节复制，指针成员只复制地址值 → 两个对象指向<b>同一块内存</b>，释放时易造成 double free</li>
<li><b>深拷贝</b>：为指针成员<b>重新分配内存</b>并复制内容 → 两个对象完全独立</li>
</ul>
</details>

---

### 1.1.4 字符串赋值方式判断 【选择题】

> **考点**：字符数组初始化与赋值的合法方式
> **注意**：数组名是常量地址，不能用 `=` 直接赋值字符串；`strcpy` 和逐字符初始化是合法的

以下对字符数组 `test` 赋值方式**错误**的是（  ）

- **A.** `char test[10]; strcpy(test, "test");`
- **B.** `char test[10]; test = "test";`
- **C.** `char test[] = {'t','e','s','t'};`
- **D.** `char test[10] = {'t','e','s','t'};`

<details><summary>💡 答案提示</summary>
<p><b>答案：B</b></p>
<p>数组名 <code>test</code> 是常量地址，不可用 <code>=</code> 赋值。只有在<b>声明时</b>才能用 <code>=</code> 初始化，声明后赋值必须用 <code>strcpy</code>。</p>
</details>

---

### 1.1.5 二维数组的初始化方式判断 【选择题】

> **考点**：二维数组初始化语法——花括号嵌套 vs 逗号表达式、行列匹配
> **注意**：`(0,1,2)` 是逗号表达式而非花括号初始化；行数不能超过声明；元素不足自动补0

以下二维数组初始化方式正确的是（  ）

- **A.** `int a[2][3] = ((0,1,2),(3,4,5));` — 圆括号是逗号表达式，非法
- **B.** `int a[2][3] = {{0,1,2},{3,4,5}};` — 标准写法
- **C.** `int a[2][3] = {{0,1},{2,3},{4,5}};` — 3行但只声明了2行，非法
- **D.** `int a[2][3] = {0,1,2,3,4};` — 线性初始化，合法（不足补0）

<details><summary>💡 答案提示</summary>
<p><b>答案：B 和 D</b></p>
<ul>
<li>A 错在用了圆括号 <code>()</code>，逗号表达式 <code>(0,1,2)</code> 的值只是 <code>2</code></li>
<li>C 错在花括号内有3组，但行数声明为2</li>
</ul>
</details>

---

### 1.1.6 sizeof 与 strlen 的区别 【问答题】

> **考点**：`sizeof` 是运算符（编译期）、`strlen` 是库函数（运行期）；`sizeof` 包含 `\0`，`strlen` 不包含
> **注意**：`sizeof` 对数组名返回整个数组的总字节大小，对指针返回指针本身大小（4/8字节），这是常见陷阱

简述 `sizeof` 和 `strlen` 的区别。

<details><summary>💡 答案提示</summary>
<table>
<tr><th>区别</th><th><code>sizeof</code></th><th><code>strlen</code></th></tr>
<tr><td>性质</td><td><b>运算符</b>，编译期求值</td><td><b>库函数</b>（<code><string.h></code>），运行期求值</td></tr>
<tr><td><code>\0</code></td><td><b>包含</b> <code>\0</code></td><td><b>不包含</b> <code>\0</code></td></tr>
<tr><td>计算对象</td><td>任意类型占用的<b>内存字节数</b></td><td>字符串的<b>有效字符个数</b></td></tr>
<tr><td>参数</td><td>类型或变量</td><td>必须是 <code>char*</code>（以<code>\0</code>结尾）</td></tr>
</table>
<pre><code>char str[] = "hello";
sizeof(str);  // 6（含'\0'）
strlen(str);  // 5（不含'\0'）</code></pre>
</details>

---

## 1.2 指针

### 1.2.1 指向数组的指针 vs 指针数组 【问答题】

> **考点**：`int (*p)[5]` 是指向数组的指针，`int *p[5]` 是指针数组——括号位置决定含义
> **注意**：这是面试必问题，一定要分清两者声明形式和使用场景

```c
int a[5];
int (*p)[5] = &a;   // 指向数组的指针
int *q[5];           // 指针数组（5个int指针组成的数组）
```

写出自己定义的数组指针和指针数组。

---

### 1.2.2 悬空指针 【问答题】

> **考点**：指针指向的内存已被释放或未分配，导致未定义行为
> **注意**：`free` 后应将指针置 `NULL`；函数返回局部变量地址也会产生悬空指针

什么是悬空指针？

<details><summary>💡 答案提示</summary>
<p>悬空指针（Dangling Pointer）是指向<b>已释放</b>或<b>已失效</b>内存的指针。常见场景：</p>
<ol>
<li><code>free(p)</code> 后未置 <code>NULL</code>，继续使用 <code>p</code></li>
<li>函数返回局部变量的地址</li>
<li>指向的栈内存在函数返回后被回收</li>
</ol>
</details>

---

### 1.2.3 空指针系列 【问答题】

> **考点**：空指针常量、空指针的定义、空指针的内部实现
> **注意**：`NULL` 是空指针常量的宏定义；空指针不一定是全0地址（取决于实现）；解引用空指针是未定义行为

1. 什么是空指针常量（null pointer constant）？
2. 什么是空指针（null pointer）？
3. 空指针指向了内存的什么地方（空指针的内部实现）？

---

### 1.2.4 malloc 失败时的返回值 【问答题】

> **考点**：`malloc` 分配失败返回 `NULL`（即空指针），不是数字 0
> **注意**：`NULL` 可以等价于 `(void*)0`，但语义上应检查 `NULL`

`malloc` 函数在分配内存失败时返回 0 还是 `NULL`？

<details><summary>💡 答案提示</summary>
<p>返回 <b><code>NULL</code></b>。虽然 <code>NULL</code> 在大多数实现中就是 <code>(void*)0</code>，但语义上应使用 <code>NULL</code> 进行判断，体现"空指针"的含义。</p>
</details>

---

### 1.2.5 函数指针 【问答题】

> **考点**：函数指针的声明、赋值和调用；回调函数、状态机等应用场景
> **注意**：`void (*fp)(int)` 是函数指针，`void *fp(int)` 是返回指针的函数

函数指针是什么，你用它来干什么？

---

### 1.2.6 指针步长与地址计算 【选择题】

> **考点**：指针类型决定步长——`int*` 步长为4字节，`char*` 步长为1字节
> **注意**：`char` 数组强转为 `int*` 后，`p[1]` 偏移4字节而非1字节

假如 `test` 数组的起始地址为 `0x12345678`，则表达式 `test_p[1]` 的指针地址值是多少？（  ）

```c
char test[8] = { 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08 };
int *test_p = (int *)test;
```

- **A.** 0x12345678
- **B.** 0x1234567C
- **C.** 0x12345679
- **D.** 0x1234567A

<details><summary>💡 答案提示</summary>
<p><b>答案：B</b></p>
<p><code>test_p</code> 是 <code>int*</code>，步长为 <code>sizeof(int)</code> = 4 字节。<code>test_p[1]</code> = <code>test_p + 1</code> = <code>0x12345678 + 4</code> = <b><code>0x1234567C</code></b></p>
</details>

---

### 1.2.7 指针交换函数（值传递 vs 地址修改）【选择题】

> **考点**：C语言函数参数是值传递——交换指针本身不影响调用者的指针
> **注意**：要真正交换两个指针指向的值，需使用二级指针 `int **` 或直接交换 `*a` 和 `*b`

下面程序的输出结果是（  ）

```c
void swap(int *a, int *b) {
    int *t;
    t = a;
    a = b;
    b = t;
}

int main() {
    int x = 1, y = 2;
    int *p = &x, *q = &y;
    swap(p, q);
    printf("%d %d\n", *p, *q);
    return 0;
}
```

- **A.** 1 2
- **B.** 2 1
- **C.** 编译错误
- **D.** 运行时崩溃

<details><summary>💡 答案提示</summary>
<p><b>答案：A</b></p>
<p><code>swap</code> 函数内交换的只是<b>形参（指针的副本）</b>，不影响实参 <code>p</code> 和 <code>q</code>。函数返回后 <code>p</code> 仍指向 <code>x</code>，<code>q</code> 仍指向 <code>y</code>。要真正交换需用二级指针 <code>int **</code> 或交换 <code>*a</code> 和 <code>*b</code> 的值。</p>
</details>

---

### 1.2.8 数组名与指针运算 【选择题】

> **考点**：数组名作为地址常量不可自增；`*a` 等价于 `a[0]`
> **注意**：`a++` 非法，因为数组名不是可修改的左值

数组定义为 `int a[4];`，表达式（  ）是错误的。

- **A.** `*a`
- **B.** `a[0]`
- **C.** `a`
- **D.** `a++`

<details><summary>💡 答案提示</summary>
<p><b>答案：D</b></p>
<p>数组名 <code>a</code> 是地址常量（不可修改的左值），不能执行 <code>++</code> 运算。</p>
</details>

---

### 1.2.9 指针偏移与数组元素访问 【分析题】

> **考点**：指针 `p` 指向 `a[5]`，`p[7]` 等价于 `*(p+7)` 即 `a[12]`
> **注意**：指针下标运算基于指针当前位置，而非数组起始位置

下面程序中 `b` 的值是（  ）

```c
int a[15] = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};
int *p = &a[5];
int b = p[7];
```

<details><summary>💡 答案提示</summary>
<p><b>答案：13</b></p>
<p><code>p</code> 指向 <code>a[5]</code>，<code>p[7]</code> = <code>*(p+7)</code> = <code>a[5+7]</code> = <code>a[12]</code> = <b>13</b></p>
</details>

---

### 1.2.10 使用代码声明各类指针与数组 【编程题】

> **考点**：综合考察指针、数组、函数指针等声明语法
> **注意**：熟练区分变量、变量指针、数组、指针数组、数组指针、函数指针

使用代码声明：变量、变量指针、数组、指针数组、指针数组指针、函数指针、参数。

---

### 1.2.11 复杂声明解析——函数指针调用 【问答题】

> **考点**：C语言复杂声明的阅读能力；函数指针的理解；强制类型转换
> **注意**：从内向外拆解——先找标识符，再看修饰符。嵌入式中常用于跳转到复位向量

请解析 `(*(void(*)())0)()` 的含义。

<details><summary>💡 答案提示</summary>
<p><b>从内向外拆解</b>：</p>
<ol>
<li><code>void (*)()</code> —— 一个<b>函数指针类型</b>，指向无参数、无返回值的函数</li>
<li><code>(void (*)()) 0</code> —— 将整数 <code>0</code> <b>强制转换</b>为该函数指针类型，即地址0处的函数</li>
<li><code>(* (void (*)()) 0)</code> —— <b>解引用</b>该函数指针，得到函数本身</li>
<li><code>(* (void (*)()) 0)()</code> —— <b>调用</b>该函数</li>
</ol>
<p><b>含义：调用位于内存地址 0x0 处的 <code>void func(void)</code> 类型函数。</b>在嵌入式中常用于跳转到复位向量（地址0）执行。</p>
</details>

---

### 1.2.12 通过地址直接赋值 【问答题】

> **考点**：强制类型转换；指针解引用；嵌入式寄存器操作
> **注意**：在嵌入式中常用于直接操作硬件寄存器，普通程序中属于未定义行为

设置地址为 `0x13579` 的整型变量的值为 `0x97351`。

<details><summary>💡 答案提示</summary>
<pre><code>*(int *)0x13579 = 0x97351;</code></pre>
<p>拆解：</p>
<ol>
<li><code>(int *)0x13579</code> —— 将整数地址强制转换为 <code>int</code> 类型指针</li>
<li><code>*(int *)0x13579</code> —— 解引用该指针，访问该地址处的整型变量</li>
<li><code>= 0x97351</code> —— 赋值</li>
</ol>
</details>

---

## 1.3 宏定义与预处理

### 1.3.1 宏定义求数组元素个数 【编程题】

> **考点**：`sizeof(arr)/sizeof(arr[0])` 的经典用法
> **注意**：仅在数组定义的作用域有效，数组退化为指针后失效

已知一个数组 `table`，用一个宏定义，求出数据的元素个数。

<details><summary>💡 答案提示</summary>
<pre><code>#define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]))</code></pre>
</details>

---

### 1.3.2 宏定义展开的陷阱（无括号保护）【选择题】

> **考点**：宏是简单文本替换，参数不加括号会导致运算优先级错误
> **注意**：`#define TEST(a,b) a*b` 展开 `TEST(1+2,3)` 为 `1+2*3=7` 而非 `9`

下面程序的运行结果为？（  ）

```c
#define TEST(a,b) a*b

int main() {
    int a = TEST(1 + 2, 3);
    printf("result= %d\n", a);
    return 0;
}
```

- **A.** result= 9
- **B.** result= 5
- **C.** result= 7
- **D.** result= 3

<details><summary>💡 答案提示</summary>
<p><b>答案：C</b></p>
<p>展开过程：<code>TEST(1+2, 3)</code> → <code>1+2*3</code> → <code>1+6</code> = <b>7</b></p>
<p>正确写法应为 <code>#define TEST(a,b) ((a)*(b))</code></p>
</details>

---

### 1.3.3 宏展开与运算符优先级（综合）【选择题】

> **考点**：宏展开后需注意 `+` 与 `*` 的优先级
> **注意**：`Y(5+1)` 展开为 `((3+1)*5+1)` = 21，而非 `((3+1)*6)` = 24

设 `#define N 3`，`#define Y(n) ((N+1)*n)`，则表达式 `2*(N+Y(5+1))` 的值是（  ）

- **A.** 42
- **B.** 48
- **C.** 54
- **D.** 出错

<details><summary>💡 答案提示</summary>
<p><b>答案：B</b></p>
<p>展开：<code>Y(5+1)</code> → <code>((3+1)*5+1)</code> = <code>(4*5+1)</code> = <b>21</b></p>
<p>整体：<code>2*(3+21)</code> = <code>2*24</code> = <b>48</b></p>
<p>关键：宏参数 <code>n</code> 未加括号，<code>*n</code> 展开为 <code>*5+1</code> 而非 <code>*(5+1)</code>。</p>
</details>

---

### 1.3.4 宏定义取模运算展开 【选择题】

> **考点**：宏参数替换后运算符优先级改变
> **注意**：`MOD(b, a+4)` 展开为 `b%a+4` 而非 `b%(a+4)`

若有宏定义：`#define MOD(x,y) x%y`，则执行以下语句后的输出结果是（  ）

```c
int a = 13, b = 94;
printf("%d\n", MOD(b, a+4));
```

- **A.** 5
- **B.** 7
- **C.** 9
- **D.** 11

<details><summary>💡 答案提示</summary>
<p><b>答案：B</b></p>
<p>展开：<code>MOD(b, a+4)</code> → <code>b%a+4</code> → <code>94%13+4</code> = <code>3+4</code> = <b>7</b></p>
<p>关键：宏参数 <code>y</code> 未加括号，<code>a+4</code> 中的 <code>+4</code> 被拆到 <code>%</code> 外面。</p>
</details>

---

### 1.3.5 宏展开综合题 CALC 【选择题】

> **考点**：多参数宏展开后的运算顺序
> **注意**：需逐步手动展开宏，严格按文本替换规则

下面程序的输出结果正确的是（  ）

```c
#define CALC(x,y) x*y+x

int main() {
    int a = CALC(2 * 3, 3 + 2);
    printf("result = %d\n", a);
    return 0;
}
```

- **A.** result = 12
- **B.** result = 21
- **C.** result = 30
- **D.** result = 60
- **E.** 编译错误

<details><summary>💡 答案提示</summary>
<p>展开：<code>CALC(2*3, 3+2)</code> → <code>2*3*3+2+2*3</code></p>
<p>按优先级计算：<code>(2*3*3) + 2 + (2*3)</code> = <code>18 + 2 + 6</code> = <b>26</b></p>
<p>⚠️ 26 不在选项中，选项本身可能有误。考试中按展开逻辑推导即可。</p>
</details>

---

### 1.3.6 预编译相关问题 【问答题】

> **考点**：编译四阶段（预处理→编译→汇编→链接）；预编译的工作内容
> **注意**：预编译处理 `#include`、`#define`、条件编译等指令，不做语法检查

1. 什么是预编译（Preprocessing）？
2. C 语言编译过程分为哪几个阶段？
3. 预编译阶段主要完成哪些工作？
4. 在实际开发中，何时需要使用预编译？
5. 预编译与编译的本质区别是什么？

---

### 1.3.7 gcc 编译参数 【问答题】

> **考点**：`-c` 只编译不链接、`-o` 指定输出文件名、`-shared` 生成动态库、`-static` 静态链接
> **注意**：区分编译和链接阶段各参数的作用

gcc 编译中 `-c`、`-o`、`-shared`、`-static` 等编译参数的用途。

---

### 1.3.8 条件编译指令 #ifdef/#ifndef/#else/#endif 【问答题】

> **考点**：预处理指令 vs 关键字的区别；条件编译的实际应用场景
> **注意**：它们是**预处理指令**而非"预定义标识符"；`#ifndef` 用于头文件防重复包含（Include Guard）

简述 `#ifdef`、`#else`、`#endif`、`#ifndef` 的作用。

<details><summary>💡 答案提示</summary>
<p>这些是<b>预处理指令</b>，用于<b>条件编译</b>，在预处理阶段决定哪些代码参与编译：</p>
<ul>
<li><code>#ifdef</code>：如果宏已定义，则编译其后的代码</li>
<li><code>#ifndef</code>：如果宏<b>未</b>定义，则编译其后的代码</li>
<li><code>#else</code>：与 <code>#ifdef</code>/<code>#ifndef</code> 配合，提供否定分支</li>
<li><code>#endif</code>：结束条件编译块</li>
</ul>
<p><b>场景一：条件编译（跨平台/调试控制）</b></p>
<pre><code>#ifdef DEBUG
    printf("debug info\n");
#else
    // Release模式不编译调试代码
#endif</code></pre>
<p><b>场景二：头文件防重复包含（Include Guard）</b></p>
<pre><code>#ifndef _MODULE_H_
#define _MODULE_H_
// 头文件内容
#endif</code></pre>
</details>

---

### 1.3.9 宏定义 MIN（返回较小值）【编程题】

> **考点**：三目运算符语法；宏参数务必加括号保护
> **注意**：宏的**双重求值**问题——如 `MIN(i++, j++)` 会导致参数被求值两次产生副作用

写一个宏 `MIN`，返回两个数中较小的那一个。

<details><summary>💡 答案提示</summary>
<pre><code>#define MIN(a, b)  ((a) < (b) ? (a) : (b))</code></pre>
<p>每个参数都要加括号，防止宏展开时运算符优先级导致错误。例如 <code>MIN(x+1, y+2)</code> 如果不加括号会出错。</p>
<p><b>进阶（GCC扩展，避免双重求值）：</b></p>
<pre><code>#define MIN(a, b) ({        \
    typeof(a) _a = (a);     \
    typeof(b) _b = (b);     \
    _a < _b ? _a : _b;     \
})</code></pre>
</details>

---

## 1.4 关键字与修饰符

### 1.4.1 static 关键字 【问答题】

> **考点**：修饰局部变量（延长生命周期）、修饰全局变量/函数（限制作用域到本文件）
> **注意**：static局部变量只初始化一次，后续调用保留上次的值

1. `static` 关键字的作用以及使用场景。
2. C语言中 `static` 函数与普通函数的区别是什么？

<details><summary>💡 答案提示</summary>
<p><code>static</code> 的三种用法：</p>
<table>
<tr><th>用法</th><th>效果</th></tr>
<tr><td>修饰<b>局部变量</b></td><td>生命周期延长到程序结束，但作用域不变</td></tr>
<tr><td>修饰<b>全局变量</b></td><td>作用域限制在本文件（文件级私有）</td></tr>
<tr><td>修饰<b>函数</b></td><td>函数仅在本文件可见（内部链接）</td></tr>
</table>
</details>

---

### 1.4.2 const 关键字 【问答题】

> **考点**：修饰变量为只读、修饰指针（`const int*` vs `int* const`）、修饰函数参数
> **注意**：`const` 在 `*` 左边修饰指向的值，在 `*` 右边修饰指针本身

`const` 关键字的作用以及使用场景。

<details><summary>💡 答案提示</summary>
<table>
<tr><th>声明</th><th>含义</th></tr>
<tr><td><code>const int *p</code></td><td>指向的值不可改，指针可改</td></tr>
<tr><td><code>int * const p</code></td><td>指针不可改，指向的值可改</td></tr>
<tr><td><code>const int * const p</code></td><td>都不可改</td></tr>
</table>
</details>

---

### 1.4.3 extern 关键字 【问答题】

> **考点**：声明外部变量/函数，用于跨文件访问
> **注意**：`extern` 只是声明不是定义，不分配内存

1. `extern` 关键字的作用以及使用场景。
2. 如何引用一个已经定义过的全局变量？
3. 全局变量可不可以定义在可被多个 `.c` 文件包含的头文件中？为什么？

---

### 1.4.4 volatile 关键字 【问答题】

> **考点**：告诉编译器该变量可能被意外修改，禁止优化——每次访问都从内存重新读取
> **注意**：常用于硬件寄存器映射、中断服务程序中的共享变量、多线程共享变量

C语言中，修饰符 `volatile` 含义是什么？其应用场合有哪些？

<details><summary>💡 答案提示</summary>
<p>三大应用场景：</p>
<ol>
<li><b>硬件寄存器</b>：寄存器值可能被硬件改变</li>
<li><b>中断服务程序</b>：ISR 中修改的共享变量</li>
<li><b>多线程共享变量</b>：其他线程可能修改的变量</li>
</ol>
</details>

---

### 1.4.5 静态成员变量和生存周期 【问答题】

> **考点**：静态变量的生命周期为整个程序运行期间；作用域由定义位置决定
> **注意**：区分"生命周期"和"作用域"两个概念

静态成员变量和生存周期。

---

### 1.4.6 const 与 volatile 能否同时修饰一个变量 【问答题】

> **考点**：`const` 表示程序自身不应修改；`volatile` 表示值可能被外部因素改变——两者并不矛盾
> **注意**：`volatile` 是"禁止编译器缓存到CPU寄存器，每次从**内存**读取"，不是"从寄存器读"

一个参数可以既是 `const` 又是 `volatile` 吗？请举例说明。

<details><summary>💡 答案提示</summary>
<p><b>可以。</b>典型场景：只读的硬件状态寄存器。</p>
<pre><code>const volatile uint32_t *status_reg = (const volatile uint32_t *)0x40001000;</code></pre>
<ul>
<li><code>const</code>：告诉编译器<b>程序自身不应修改</b>这个值</li>
<li><code>volatile</code>：告诉编译器<b>每次访问必须从内存重新读取</b>，不要做缓存优化（因为硬件可能随时改变该值）</li>
</ul>
<p>经典例子：嵌入式中的<b>只读状态寄存器</b>——程序不能写它（const），但硬件会更新它（volatile）。</p>
</details>

---

## 1.5 运算符与表达式

### 1.5.1 运算符优先级 【选择题】

> **考点**：优先级从高到低大致为：括号/下标 > 单目 > 算术 > 移位 > 关系 > 位运算 > 逻辑 > 赋值
> **注意**：取余 `%` 和乘除同级，高于加减；逻辑运算低于关系运算

**(1)** 算术运算符、赋值运算符和关系运算符的运算优先级按从高到低依次为（  ）

- **A.** 算术运算、赋值运算、关系运算
- **B.** 算术运算、关系运算、赋值运算
- **C.** 关系运算、赋值运算、算术运算
- **D.** 关系运算、算术运算、赋值运算

<details><summary>💡 答案提示</summary>
<p><b>答案：B</b>　算术 > 关系 > 赋值</p>
</details>

---

**(2)** C语言中，下列运算符优先级最高的是（  ）

- **A.** `!`（逻辑非，单目）
- **B.** `%`（取模，算术）
- **C.** `>>`（右移）
- **D.** `==`（等于，关系）

<details><summary>💡 答案提示</summary>
<p><b>答案：A</b>　单目运算符 <code>!</code> 优先级最高</p>
</details>

---

**(3)** 对运算符优先级的判断，正确的是（  ）

- **A.** 取余运算符 `%` > 加运算符 `+`
- **B.** 逻辑与运算符 `&&` > 赋值运算符 `=`
- **C.** 数组下标 `[]` > 自增运算符 `++`
- **D.** 左移运算符 `<<` > 大于运算符 `>`

<details><summary>💡 答案提示</summary>
<p><b>A、B 正确</b></p>
<ul>
<li>A：<code>%</code> 和 <code>*</code>、<code>/</code> 同级，高于 <code>+</code>、<code>-</code> ✓</li>
<li>B：<code>&&</code> 优先级高于 <code>=</code> ✓</li>
<li>C：<code>[]</code> 和 <code>++</code>（后缀）同级 ✗</li>
<li>D：<code><<</code> 优先级<b>低于</b> <code>></code> ✗（移位低于关系）</li>
</ul>
</details>

---

### 1.5.2 整型专用运算符 【选择题】

> **考点**：取模运算 `%` 要求操作数必须是整型
> **注意**：`/` 可用于浮点数，`!` 可用于任意标量，`%` 只能用于整数

C 语言中运算对象必须是整型的运算符是（  ）

- **A.** `%`
- **B.** `/`
- **C.** `!`
- **D.** `**`

<details><summary>💡 答案提示</summary>
<p><b>答案：A</b>　取模运算 <code>%</code> 只能用于整型操作数</p>
</details>

---

### 1.5.3 逗号表达式 【选择题】

> **考点**：逗号表达式从左到右依次求值，整个表达式的值为最后一个表达式的值
> **注意**：`(j=3, j++)` 中 `j++` 是后缀自增，表达式值为3（自增前的值）

若变量已正确定义，表达式 `(j=3, j++)` 的值是（  ）

- **A.** 3
- **B.** 4
- **C.** 5
- **D.** 0

<details><summary>💡 答案提示</summary>
<p><b>答案：A</b></p>
<ol>
<li><code>j=3</code> → j 赋值为 3</li>
<li><code>j++</code> → 后缀自增，<b>表达式的值为自增前的 3</b>，之后 j 变为 4</li>
<li>逗号表达式取最后一项的值 → <b>3</b></li>
</ol>
</details>

---

### 1.5.4 位运算——右移 【选择题】

> **考点**：右移 `>>` 等价于除以2的幂；`7>>1` = `7/2` = `3`
> **注意**：有符号数右移时高位补符号位（算术右移）

执行语句 `k = 7 >> 1;` 后，变量 `k` 的当前值是（  ）

- **A.** 15
- **B.** 31
- **C.** 3
- **D.** 1

<details><summary>💡 答案提示</summary>
<p><b>答案：C</b>　<code>7</code> = <code>0111</code>，右移1位 → <code>0011</code> = <b>3</b></p>
</details>

---

### 1.5.5 位运算——特定位清零 【选择题】

> **考点**：`&= ~mask` 将指定位清零；`|= mask` 置位；`^= mask` 翻转
> **注意**：`~4` 即 `~0x04` = `0xFFFFFFFB`，与原值 AND 后 bit[2] 变为0

下面哪个操作可以将 `flag` 的 bit[2] 置 0？（  ）

- **A.** `flag |= 4` — 置1
- **B.** `flag ^= 4` — 翻转（不确定结果）
- **C.** `flag &= ~4` — **清零** ✓
- **D.** `flag |= ~4` — 几乎全部置1

<details><summary>💡 答案提示</summary>
<p><b>答案：C</b></p>
<p><code>~4</code> = <code>0xFFFF...FB</code>，<code>flag &amp; 0xFB</code> 只把 bit[2] 清零，其余位不变。</p>
</details>

---

### 1.5.6 位运算——判断2的幂 【编程题】

> **考点**：`x & (x-1) == 0` 且 `x > 0` 则 `x` 是2的幂
> **注意**：2的幂的二进制只有一个1；需排除 `x=0` 的情况

写一语句实现 `x` 是否为2的若干次幂的判断。

<details><summary>💡 答案提示</summary>
<pre><code>(x > 0) && ((x & (x - 1)) == 0)</code></pre>
<p>原理：2的幂的二进制形如 <code>1000...0</code>，减1后变为 <code>0111...1</code>，两者 AND 结果为 0。</p>
</details>

---

### 1.5.7 运算符优先级与结合性（乘法、取模、加法）【选择题】

> **考点**：`*`、`%` 同优先级，左结合；先于 `+` 运算
> **注意**：`4 * f % 3 + 1` = `(4*17) % 3 + 1` = `68 % 3 + 1` = `2 + 1` = `3`

在C语言程序中，下面程序运行后，`n` 的值是多少？（  ）

```c
int n = 0;
int f = 17;
n = 4 * f % 3 + 1;
```

- **A.** 1
- **B.** 2
- **C.** 3
- **D.** 4

<details><summary>💡 答案提示</summary>
<p><b>答案：C</b></p>
<p><code>4 * 17</code> = <code>68</code> → <code>68 % 3</code> = <code>2</code> → <code>2 + 1</code> = <b>3</b></p>
</details>

---

### 1.5.8 字符运算与 ASCII 【选择题】

> **考点**：字符本质是整数（ASCII码），可参与算术运算
> **注意**：`'f' - 'a'` = 5，`'a' + 6` = `'g'`

下述程序执行后的输出结果是（  ）

```c
#include <stdio.h>
int main() {
    int x = 'f';
    printf("%c\n", 'a' + (x - 'a' + 1));
}
```

- **A.** g
- **B.** h
- **C.** i
- **D.** j

<details><summary>💡 答案提示</summary>
<p><b>答案：A</b></p>
<p><code>x - 'a' + 1</code> = <code>'f' - 'a' + 1</code> = <code>5 + 1</code> = <code>6</code>，<code>'a' + 6</code> = <b><code>'g'</code></b></p>
</details>

---

### 1.5.9 整数除法精度丢失 【选择题】

> **考点**：`1/2` 在C中整数除法结果为0，而非0.5
> **注意**：`(1/2) * (a+b) * c` 结果为0，因为 `1/2` 先被截断为0

设 `float a=2, b=4, c=3;`，以下表达式中与代数式 `(a+b)*c/2` 计算结果不一致的是（  ）

- **A.** `(a + b) * c / 2`
- **B.** `(1/2) * (a + b) * c`
- **C.** `(a + b) * c * 1 / 2`
- **D.** `c / 2 * (a + b)`

<details><summary>💡 答案提示</summary>
<p><b>答案：B</b></p>
<p><code>1/2</code> 是<b>整数除法</b>，结果为 <b>0</b>，后续乘任何值都为 0。其他选项中操作数有 <code>float</code> 参与，自动提升为浮点运算。</p>
</details>

---

### 1.5.10 strcmp 返回值 【选择题】

> **考点**：`strcmp` 返回整数——相等返回0，不等返回正/负整数
> **注意**：按字典序逐字符比较，比较的是字符ASCII值而非数值

表达式 `strcmp("3.14", "3.278")` 的值是一个（  ）

- **A.** 非零整数
- **B.** 浮点数
- **C.** 0
- **D.** 字符

<details><summary>💡 答案提示</summary>
<p><b>答案：A</b></p>
<p><code>strcmp</code> 始终返回 <code>int</code>。第3个字符 <code>'1'</code>(ASCII 49) vs <code>'2'</code>(ASCII 50)，<code>'1'</code> < <code>'2'</code>，返回<b>负整数</b>。</p>
</details>

---

### 1.5.11 如何判别一个数是 unsigned 【问答题】

> **考点**：通过检查负值赋值后的行为或使用类型判断技巧
> **注意**：可用 `(val) >= 0 && ~(val) >= 0` 等方式判断；C11可用 `_Generic`

如何判别一个数是 `unsigned`？

---

### 1.5.12 int/bool/float/指针与零值比较 【问答题】

> **考点**：浮点数**不能用 `==` 和 `0` 比较**，必须用精度范围判断；布尔值用 `if(!b)` 更规范
> **注意**：`NULL` 是大写（C语言）；`true` 不是 `ture`；`0 == a` 防御性写法可避免误写赋值

写出 `int`、`bool`、`float`、指针变量与"零值"比较的 `if` 语句。

<details><summary>💡 答案提示</summary>
<pre><code>// int 与零值比较
int a = 1;
if (a == 0)        // 或 if (0 == a) 防止误写成赋值

// bool 与零值比较
bool b = true;
if (!b)            // 不要写 if(b == false)，直接用逻辑非

// float 与零值比较（核心考点！）
float f = 0.1f;
#define EPSILON 1e-6
if (fabs(f) < EPSILON)  // 浮点数不能用 == 比较，必须用精度范围判断

// 指针与零值比较
int *p = NULL;
if (p == NULL)     // 或 if (!p)</code></pre>
<p><b>本题最核心考点</b>：<code>float</code> 不能用 <code>==</code> 直接与 <code>0</code> 比较，因为浮点数存在精度误差。</p>
</details>

---

## 1.6 流程控制

### 1.6.1 switch 语句的 fall-through 【分析题】

> **考点**：`switch` 中没有 `break` 会贯穿执行到下一个 `case`
> **注意**：从匹配的 `case` 开始执行，一直到遇见 `break` 或 `switch` 结束

**(1)** 分析以下程序的输出结果：

```c
#include <stdio.h>
int main() {
    int i = 10;
    switch (i) {
        case 9:  i++;
        case 10: i++;
        case 11: i++;
        default: i++;
    }
    printf("result= %d\n", i);
    return 0;
}
```

<details><summary>💡 答案提示</summary>
<p><b>输出：result= 13</b></p>
<p>从 <code>case 10</code> 匹配进入，无 <code>break</code> 一路贯穿：<br>
<code>i++</code>(→11) → <code>case 11: i++</code>(→12) → <code>default: i++</code>(→13)</p>
</details>

---

**(2)** 下述程序运行时，如果输入为 `2473`，则输出结果是（  ）

```c
#include <stdio.h>
void main() {
    int c;
    while ((c = getchar()) != '\n')
        switch (c - '2') {
            case 0:
            case 1: putchar(c + 4); break;
            case 2: putchar(c + 4); break;
            case 3: putchar(c + 3); break;
            default: putchar(c + 2); break;
        }
    printf("\n");
}
```

- **A.** 6885
- **B.** 6685
- **C.** 6887
- **D.** 4665
- **E.** 2468

<details><summary>💡 答案提示</summary>
<p><b>答案：A</b></p>
<table>
<tr><th>输入字符</th><th><code>c-'2'</code></th><th>匹配 case</th><th>输出</th></tr>
<tr><td><code>'2'</code></td><td>0</td><td>case 0 → fall-through → case 1</td><td><code>'2'+4</code> = <code>'6'</code></td></tr>
<tr><td><code>'4'</code></td><td>2</td><td>case 2</td><td><code>'4'+4</code> = <code>'8'</code></td></tr>
<tr><td><code>'7'</code></td><td>5</td><td>default</td><td><code>'7'+1</code> = <code>'8'</code>（需验证ASCII）</td></tr>
<tr><td><code>'3'</code></td><td>1</td><td>case 1</td><td><code>'3'+4</code> = <code>'7'</code>（需验证ASCII）</td></tr>
</table>
<p>⚠️ 需逐字符仔细推算 ASCII 值。</p>
</details>

---

### 1.6.2 条件判断执行流程 【选择题】

> **考点**：`!`运算符、前缀自减 `--a`、`if-else` 分支执行
> **注意**：`--a` 先自减再判断；`!0` 为真，`!非0` 为假

下列程序段运行后，`x` 的值是（  ）

```c
a = 1; b = 2; x = 0;
if (!(--a)) x--;
if (!b) x = 7; else ++x;
```

- **A.** 0
- **B.** 3
- **C.** 6
- **D.** 7

<details><summary>💡 答案提示</summary>
<p><b>答案：A</b></p>
<ol>
<li><code>--a</code> → a=0，<code>!0</code> 为真 → <code>x--</code> → x=-1</li>
<li><code>!b</code> = <code>!2</code> = 0 为假 → 走 else → <code>++x</code> → x=0</li>
</ol>
</details>

---

### 1.6.3 for 循环特殊写法 【问答题】

> **考点**：`for(;1;)` 等价于 `while(1)`，是无限循环
> **注意**：`for` 三个部分都可以省略；条件为1即永真

语句 `for(;1;)` 有什么问题？它是什么意思？

---

### 1.6.4 do...while 与 while...do 的区别 【问答题】

> **考点**：`do...while` 至少执行一次循环体；`while` 可能一次都不执行
> **注意**：`do...while` 的分号不能遗漏

`do...while` 和 `while...do` 有什么区别？

---

## 1.7 函数

### 1.7.1 函数参数传递方式 【选择题】

> **考点**：数组传递（退化为指针）、指针传递、引用传递（C++特性）、值传递
> **注意**：数组作为参数传递时退化为指针，无法在函数内用 `sizeof` 计算原数组大小

**(1)** 参数传递方式判断：

```c
int fun(int a[], short *ptr, int &c) {
    // ...
}
int main() {
    int arr[10];
    short val = 100;
    int x = 200;
    fun(arr, &val, x);
    return 0;
}
```

请选择所有正确的传递方式：（  ）

- **A.** 数组传递
- **B.** 指针传递
- **C.** 引用传递
- **D.** 值传递

<details><summary>💡 答案提示</summary>
<p><b>答案：A、B、C</b></p>
<table>
<tr><th>参数</th><th>传递方式</th></tr>
<tr><td><code>int a[]</code></td><td>数组传递（本质是指针传递）</td></tr>
<tr><td><code>short *ptr</code></td><td>指针传递</td></tr>
<tr><td><code>int &amp;c</code></td><td>引用传递（C++特性）</td></tr>
</table>
</details>

---

**(2)** 数组作为函数参数以地址形式传入函数，要在函数内部计算出传入数组的大小；数组作为函数参数怎样传入，有几种方法？ 【问答题】

---

### 1.7.2 main 函数参数 【选择题】

> **考点**：`main(int argc, char *argv[])` 最多两个参数
> **注意**：`argc` 是参数个数，`argv` 是参数字符串数组

若 `main()` 函数带参数，参数个数最多是（  ）

- **A.** 0
- **B.** 1
- **C.** 2
- **D.** 3

<details><summary>💡 答案提示</summary>
<p><b>答案：D</b></p>
<p>标准允许：<code>int main(int argc, char *argv[], char *envp[])</code>，第三个参数 <code>envp</code> 是环境变量（非标准但广泛支持），所以最多 <b>3个</b>。</p>
</details>

---

### 1.7.3 函数缺省返回类型 【选择题】

> **考点**：C89中未声明返回类型的函数默认返回 `int`
> **注意**：C99/C11 标准中不再允许隐式 `int`

定义函数时，缺省函数的类型声明，则函数类型取缺省类型（  ）

- **A.** void
- **B.** char
- **C.** float
- **D.** int

<details><summary>💡 答案提示</summary>
<p><b>答案：D</b>　C89 默认返回类型为 <code>int</code></p>
</details>

---

## 1.8 字符串与内存操作

### 1.8.1 转义字符 【选择题】

> **考点**：八进制转义 `\ddd`（最多3位）、十六进制转义 `\xhh`（最多2位）
> **注意**：`\x111` 超过2位十六进制，是错误的转义字符

下列转义字符中错误的是（  ）

- **A.** `'\000'`
- **B.** `'\14'`
- **C.** `'\x111'`
- **D.** `'\2'`

<details><summary>💡 答案提示</summary>
<p><b>答案：C</b></p>
<p><code>\x111</code> 的十六进制值为 <code>0x111</code> = 273，超出 <code>char</code> 范围（0~255），属于错误的转义字符。</p>
</details>

---

### 1.8.2 字符指针与偏移 【选择题】

> **考点**：`*p+4` 是对 `*p` 的值加4（ASCII偏移），不是 `*(p+4)`
> **注意**：`*p` 为 `'a'`（ASCII 97），`'a'+4` = `'e'`

若定义了 `char ch[] = {"abc\0def"}, *p = ch;`，则执行 `printf("%c", *p+4);` 语句的输出结果是（  ）

- **A.** def
- **B.** d
- **C.** e
- **D.** 0

<details><summary>💡 答案提示</summary>
<p><b>答案：C</b></p>
<p><code>*p</code> = <code>'a'</code>（ASCII 97），<code>*p + 4</code> = 97 + 4 = 101 = <b><code>'e'</code></b>。注意是 <code>*p+4</code> 而非 <code>*(p+4)</code>。</p>
</details>

---

### 1.8.3 字符串遍历与步长 【分析题】

> **考点**：`bp+=2` 每次跳2个字符，`%s` 从当前位置打印到 `\0`
> **注意**：注意是 `%s` 格式——打印整个子串，不是单个字符

执行下述程序的输出结果：

```c
#include <stdio.h>
char b[] = "ABCDEF";
main() {
    char *bp;
    for (bp = b; *bp; bp += 2)
        printf("%s", bp);
    printf("\n");
}
```

<details><summary>💡 答案提示</summary>
<p><b>输出：<code>ABCDEFCDEFEF</code></b></p>
<table>
<tr><th>循环</th><th>bp 指向</th><th><code>%s</code> 输出</th></tr>
<tr><td>1</td><td><code>b[0]</code>='A'</td><td><code>ABCDEF</code></td></tr>
<tr><td>2</td><td><code>b[2]</code>='C'</td><td><code>CDEF</code></td></tr>
<tr><td>3</td><td><code>b[4]</code>='E'</td><td><code>EF</code></td></tr>
<tr><td>4</td><td><code>b[6]</code>='\0'</td><td>退出循环</td></tr>
</table>
<p>拼接：<code>ABCDEFCDEFEF</code></p>
</details>

---

### 1.8.4 memcpy 重叠拷贝行为分析 【分析题】

> **考点**：`memcpy` 不保证重叠区域拷贝的正确性（应使用 `memmove`）
> **注意**：源和目标重叠时，`memcpy` 的行为是未定义的；实际结果取决于实现

请分析下列程序执行后，数组 `data` 的最终内容是什么：

```c
#include <stdio.h>
#include <string.h>

#define MAX_DATA_SIZE (10)

int main() {
    unsigned int i = 0;
    unsigned char data[MAX_DATA_SIZE] = {1,2,3,4,5,6,7,8,9,0};
    memcpy(&data[2], data, MAX_DATA_SIZE / 2);
    return 0;
}
```

<details><summary>💡 答案提示</summary>
<p>源区域 <code>data[0..4]</code> = <code>{1,2,3,4,5}</code>，目标区域 <code>data[2..6]</code>。</p>
<p>由于源和目标<b>重叠</b>（data[2]~data[4]），行为是<b>未定义</b>的。</p>
<p>如果实现是从前往后复制，则：<code>{1,2,1,2,1,2,1,8,9,0}</code>（每次读到的可能已被覆盖）</p>
<p>正确做法应使用 <code>memmove</code>。</p>
</details>

---

## 1.9 内存管理

### 1.9.1 栈与堆的区别 【问答题】

> **考点**：栈由系统自动分配回收（局部变量）；堆由程序员手动管理（`malloc/free`）
> **注意**：堆上分配内存需检查返回值、使用后必须释放、避免内存泄漏和重复释放

"栈 stack"和"堆 heap"有什么区别？写两个函数分别在栈上和堆上分配内存，在堆上分配内存应注意哪些问题？

<details><summary>💡 答案提示</summary>
<table>
<tr><th>对比项</th><th>栈（Stack）</th><th>堆（Heap）</th></tr>
<tr><td>管理方式</td><td>系统自动分配/回收</td><td>程序员手动 <code>malloc/free</code></td></tr>
<tr><td>空间大小</td><td>较小（通常几MB）</td><td>较大（取决于系统内存）</td></tr>
<tr><td>分配速度</td><td>快（移动栈指针）</td><td>慢（查找空闲块）</td></tr>
<tr><td>碎片</td><td>无</td><td>有</td></tr>
<tr><td>生命周期</td><td>函数结束自动释放</td><td>手动释放前一直存在</td></tr>
</table>
<p>堆上分配注意：①检查返回值 ②用完 <code>free</code> ③避免重复释放 ④避免内存泄漏</p>
</details>

---

### 1.9.2 结构体的使用场景 【问答题】

> **考点**：结构体将相关数据封装在一起，便于管理和传递
> **注意**：相比全局变量，结构体提供更好的模块化、可读性和数据封装

结构体的使用场景，为啥不用全局变量？

---

## 1.10 静态变量与作用域

### 1.10.1 static 局部变量在多次调用中的行为 【分析题】

> **考点**：`static` 局部变量只初始化一次，值跨函数调用保持
> **注意**：第一次调用后 `SRM_no=3`，第二次调用后 `SRM_no=6`

请写出下列程序的输出结果：

```c
#include <stdio.h>
#define MAX_SRM 256

int get_SRM_no() {
    static int SRM_no = 0;
    int i;
    for (i = 0; i < 3; i++) {
        SRM_no++;
    }
    return SRM_no % MAX_SRM;
}

int main() {
    int a, b;
    a = get_SRM_no();
    b = get_SRM_no();
    printf("%d %d\n", a, b);
    return 0;
}
```

<details><summary>💡 答案提示</summary>
<p><b>输出：3 6</b></p>
<p><code>static int SRM_no = 0</code> 只初始化一次：</p>
<ul>
<li>第1次调用：循环3次 → SRM_no=3 → 返回 3</li>
<li>第2次调用：接着上次的3，循环3次 → SRM_no=6 → 返回 6</li>
</ul>
</details>

---

## 1.11 编译与链接

### 1.11.1 编译错误 vs 运行时错误 【选择题】

> **考点**：`x==5` 是比较表达式（合法语句），不是赋值——属于逻辑错误而非编译错误
> **注意**：花括号不配对、缺分号、未定义变量都是编译错误

下列各个错误中，哪一个不属于编译错误（  ）

- **A.** 改变 x 原值 3 为 5，写作 `x==5;`
- **B.** 花括号不配对
- **C.** 复合语句中的最后一条语句后未加分号
- **D.** 变量有引用、无定义

<details><summary>💡 答案提示</summary>
<p><b>答案：A</b></p>
<p><code>x==5;</code> 语法合法（比较表达式作为语句），编译不报错，但逻辑上错误（应写 <code>x=5;</code>）。属于<b>逻辑错误/运行时错误</b>。</p>
</details>

---

### 1.11.2 静态库和动态库的区别 【问答题】

> **考点**：静态库（`.a`/`.lib`）编译时链接进可执行文件；动态库（`.so`/`.dll`）运行时加载
> **注意**：静态库体积大但无依赖；动态库体积小但需运行时环境支持

静态库和动态库的区别。

<details><summary>💡 答案提示</summary>
<table>
<tr><th>对比项</th><th>静态库（.a / .lib）</th><th>动态库（.so / .dll）</th></tr>
<tr><td>链接时机</td><td>编译时链接</td><td>运行时加载</td></tr>
<tr><td>可执行文件大小</td><td>大（库代码被复制进去）</td><td>小（只记录引用）</td></tr>
<tr><td>部署</td><td>无需额外文件</td><td>需要带上动态库文件</td></tr>
<tr><td>更新</td><td>需重新编译</td><td>替换库文件即可</td></tr>
<tr><td>内存占用</td><td>每个进程各一份</td><td>多进程可共享</td></tr>
</table>
</details>

---

## 1.12 编程题（C语言基础类）

### 1.12.1 用指针方法对 N 个整数由大到小排序 【编程题】

> **考点**：指针遍历数组、排序算法（冒泡/选择排序）
> **注意**：通过指针操作数组元素，注意指针运算和解引用

---

### 1.12.2 解二次方程 【编程题】

> **考点**：判别式 `Δ = b²-4ac` 的计算、浮点数处理、引用参数返回多值
> **注意**：需处理 `a=0`、`Δ<0`、`Δ=0`、`Δ>0` 四种情况

```c
int Quadratic(double a, double b, double c, double& x1, double& x2);
// 返回值：解的个数
```

---

### 1.12.3 斐波那契数列（递归与循环）【编程题】

> **考点**：递归实现简洁但效率低（指数级时间复杂度）；循环实现高效（O(n)）
> **注意**：递归实现需注意栈溢出风险；可用尾递归或记忆化优化

请用C语言实现斐波那契数列（使用递归与循环两种方式）。

---

### 2.1 内存管理经典题 【分析题】

#### 2.1.1 指针值传递问题

```c
void GetMemory(char *p)
{
    p = (char *)malloc(100);
}

void Test(void)
{
    char *str = NULL;
    GetMemory(str);
    strcpy(str, "hello world");
    printf(str);
}
```

请问运行 `Test` 函数会有什么样的结果？

<details><summary>💡 答案提示</summary>
<p><b>结果：崩溃（段错误）</b></p>
<ol>
<li><code>GetMemory(str)</code> 传的是指针的<b>值拷贝</b>（值传递），函数内 <code>p = malloc(100)</code> 只修改了局部变量 <code>p</code>，<b>str 仍然是 NULL</b></li>
<li><code>strcpy(str, "hello world")</code> 向 NULL 指针写入 → <b>程序崩溃</b></li>
<li>同时存在内存泄漏：<code>malloc</code> 分配的内存无法被外部访问，也没有 <code>free</code></li>
</ol>
<p><b>正确写法：</b>使用二级指针 <code>void GetMemory(char **p)</code>，传入 <code>&str</code></p>
</details>

---

#### 2.1.2 返回局部数组问题

```c
char *GetMemory(void)
{
    char p[] = "hello world";
    return p;
}

void Test(void)
{
    char *str = NULL;
    str = GetMemory();
    printf(str);
}
```

请问运行 `Test` 函数会有什么样的结果？

<details><summary>💡 答案提示</summary>
<p><b>结果：输出乱码（未定义行为）</b></p>
<ol>
<li><code>p[]</code> 是<b>局部数组</b>，存储在<b>栈</b>上。函数返回后栈帧被销毁，<code>p</code> 的内存被回收</li>
<li><code>return p</code> 返回的是一个<b>悬空指针（dangling pointer）</b>，指向已被释放的栈内存</li>
<li><code>printf(str)</code> 读取该地址 → <b>输出乱码</b></li>
</ol>
<p><b>注意：</b>如果改为 <code>char *p = "hello world"</code>（字符串字面量存储在常量区），则返回是合法的</p>
</details>

---

#### 2.1.3 二级指针正确用法

```c
void GetMemory2(char **p, int num)
{
    *p = (char *)malloc(num);
}

void Test(void)
{
    char *str = NULL;
    GetMemory2(&str, 100);
    strcpy(str, "hello");
    printf(str);
}
```

请问运行 `Test` 函数会有什么样的结果？

<details><summary>💡 答案提示</summary>
<p><b>结果：能正确输出 "hello"，但存在内存泄漏</b></p>
<ol>
<li>这里用了<b>二级指针</b> <code>char **p</code>，传入 <code>&str</code>，通过 <code>*p = malloc(num)</code> <b>成功修改了外部的 str</b></li>
<li><code>strcpy</code> 和 <code>printf</code> 都能正常执行</li>
<li>问题：最后没有 <code>free(str)</code>，造成<b>内存泄漏</b></li>
</ol>
<p><b>关键区别（对比第1题）：</b>第1题是值传递，第3题是地址传递，这是第1题的<b>正确写法</b></p>
</details>

---

#### 2.1.4 free后未置NULL问题

```c
void Test(void)
{
    char *str = (char *)malloc(100);
    strcpy(str, "hello");
    free(str);

    if (str != NULL)
    {
        strcpy(str, "world");
        printf(str);
    }
}
```

请问运行 `Test` 函数会有什么样的结果？

<details><summary>💡 答案提示</summary>
<p><b>结果：未定义行为（野指针/悬空指针操作）</b></p>
<ol>
<li><code>free(str)</code> 释放了内存，但 <b>str 指针的值没有被置为 NULL</b></li>
<li><code>free</code> 不会自动将指针设为 NULL，所以 <code>str != NULL</code> 判断为 <b>true</b></li>
<li><code>strcpy(str, "world")</code> 向<b>已释放的内存</b>写入 → <b>未定义行为</b>，可能崩溃或破坏其他数据</li>
</ol>
<p><b>正确写法：</b></p>
<pre><code>free(str);
str = NULL;  // 关键！释放后立即置空</code></pre>
</details>

---

### 2.2 for循环优化 【问答题】

请简述以下两个for循环的优缺点：

```c
// 第一种：循环内判断
for (i = 0; i < N; i++)
{
    if (condition)
        DoSomething();
    else
        DoOtherThing();
}

// 第二种：循环外判断
if (condition)
{
    for (i = 0; i < N; i++)
        DoSomething();
}
else
{
    for (i = 0; i < N; i++)
        DoOtherThing();
}
```

<details><summary>💡 答案提示</summary>
<p><b>第一种（循环内判断）：</b></p>
<ul>
<li>优点：代码简洁，逻辑清晰，容易理解</li>
<li>缺点：每次循环都要做一次 <code>condition</code> 判断，<b>多了 N 次判断开销</b></li>
</ul>
<p><b>第二种（循环外判断）：</b></p>
<ul>
<li>优点：<code>condition</code> 只判断一次，循环体内无分支，<b>运行效率高</b></li>
<li>缺点：代码冗余，两个 for 循环重复，不易维护</li>
</ul>
<p><b>选择建议：</b></p>
<ul>
<li>如果 N 较小，优先选第一种（可读性优先）</li>
<li>如果 N 很大且 condition 与循环无关（循环不变量），优先选第二种（性能优先）</li>
<li>现代编译器优化可能会自动将第一种优化为第二种（循环不变量外提）</li>
</ul>
</details>

---

### 2.3 #include区别 【问答题】

`#include <filename.h>` 和 `#include "filename.h"` 有什么区别？

<details><summary>💡 答案提示</summary>
<table>
<tr><th>写法</th><th>搜索顺序</th></tr>
<tr><td><code><filename.h></code></td><td>编译器<b>只在</b>标准库/系统头文件目录中搜索（如 <code>/usr/include</code>、编译器自带的 <code>include</code> 目录）</td></tr>
<tr><td><code>"filename.h"</code></td><td>编译器<b>先在</b>当前源文件所在目录（或项目目录）搜索，<b>找不到再去</b>标准库路径搜索</td></tr>
</table>
<p><b>示例：</b></p>
<ul>
<li><code><stdio.h></code> → 搜索 <code>/usr/include/stdio.h</code>（系统路径）</li>
<li><code>"myheader.h"</code> → 先搜索 <code>./myheader.h</code>（当前目录），找不到再去系统路径</li>
</ul>
</details>

---

### 2.4 sizeof计算 【计算题】

以下为Windows NT下的32位C++程序，请计算sizeof的值：

```c
char str[] = "Hello";
char *p = str;
int n = 10;

1. sizeof(str) = 
2. sizeof(p) = 
3. sizeof(n) = 

void Func(char str[100])
{
4. sizeof(str) = 
}

void *p = malloc(100);
5. sizeof(p) = 
```

<details><summary>💡 答案提示</summary>
<ol>
<li><code>sizeof(str) = 6</code> — 字符串 <code>"Hello"</code> 有5个字符 + 1个 <code>'\0'</code> 结尾符 = 6字节</li>
<li><code>sizeof(p) = 4</code> — 32位系统下，任何类型的指针大小都是4字节</li>
<li><code>sizeof(n) = 4</code> — 32位系统下 <code>int</code> 为4字节</li>
<li><code>sizeof(str) = 4</code> — 数组作为函数参数时<b>退化为指针</b>，不再保留数组长度信息</li>
<li><code>sizeof(p) = 4</code> — <code>void*</code> 也是指针，32位下为4字节</li>
</ol>
<p><b>注意：</b>如果是64位系统，第2、4、5题答案变为 <b>8</b></p>
</details>

---

### 2.5 结构体赋值 【选择题】

对于以下stTest结构体赋值，正确的说法是？

```c
typedef struct
{
    u8 Bass;
    u8 Treble;
    u16 eq[3];
    u8 *pPEQTable;   
} stSoundModeSeting;

stSoundModeSeting stTest;
stSoundModeSeting stDefault = {50, 50, {10, 10, 10}, NULL};
```

- A：所有逐一成员赋值
- B：可使用如下赋值 `memcpy(&stTest, &stDefault, sizeof(stTest));`
- C：可使用如下赋值 `stTest = stDefault;`

<details><summary>💡 答案提示</summary>
<p><b>答案：B、C</b></p>
<ul>
<li>B：<code>memcpy</code>整体拷贝 —— 正确，按内存逐字节复制</li>
<li>C：<b>C语言支持同类型结构体之间直接用<code>=</code>赋值！</b> 这是合法操作，编译器会自动进行成员逐一拷贝</li>
</ul>
<p><b>考点：</b>C语言结构体赋值的三种方式：①逐一成员赋值 ②<code>memcpy</code>整体拷贝 ③直接<code>=</code>赋值</p>
</details>

---

### 2.6 const指针 【选择题】

如下哪个表示一个指向整数型的常指针?

```c
A: int *const a;
B: int const *a;
C: 以上都不对
D: const int *a;
```

<details><summary>💡 答案提示</summary>
<p><b>答案：A <code>int *const a;</code></b></p>
<p>口诀：<b>const在<code>*</code>左修饰指向的值，const在<code>*</code>右修饰指针本身</b></p>
<table>
<tr><th>声明</th><th>含义</th></tr>
<tr><td><code>int *const a</code></td><td>指针本身不可变（常指针），指向的值可变 ✓</td></tr>
<tr><td><code>const int *a</code> 或 <code>int const *a</code></td><td>指向的值不可变（常量指针），指针本身可变</td></tr>
</table>
</details>

---

### 2.7 字符串赋值 【选择题】

下面各语句中，能正确进行赋字符串操作的语句是？

```c
A: char s[5] = {'a','b','c','d','e','\0'};
B: char *s; s = "abcde";
C: char *s; scanf("%s", &s);
D: char s[5] = {"abcde"};
```

<details><summary>💡 答案提示</summary>
<p><b>答案：B <code>char *s; s = "abcde";</code></b></p>
<table>
<tr><th>选项</th><th>分析</th></tr>
<tr><td>A</td><td><code>char s[5]</code> 数组大小为5，但初始化列表有6个元素，<b>数组越界</b>，编译器会报错</td></tr>
<tr><td>B</td><td>正确，指针指向字符串字面量首地址 ✓</td></tr>
<tr><td>C</td><td>试图通过一个<b>未初始化的指针</b>来接收输入数据。指针没有指向合法缓冲区</td></tr>
<tr><td>D</td><td><code>"abcde"</code>含隐含的<code>\0</code>共6字节，数组只有5字节，<b><code>\0</code>被截断</b>，结果不是合法的C字符串</td></tr>
</table>
</details>

---

### 2.8 malloc存储位置 【选择题】

C语言中，malloc函数申请到的空间储存在哪个位置？

```c
A: BSS段
B: 栈区
C: 堆区
D: data段
```

<details><summary>💡 答案提示</summary>
<p><b>答案：C 堆区</b></p>
<table>
<tr><th>内存区域</th><th>存储内容</th></tr>
<tr><td>BSS段</td><td>未初始化的全局变量和静态变量</td></tr>
<tr><td>栈区</td><td>局部变量、函数参数、返回地址</td></tr>
<tr><td><b>堆区</b></td><td><b>动态分配的内存（malloc/calloc/realloc申请）</b></td></tr>
<tr><td>data段</td><td>已初始化的全局变量和静态变量</td></tr>
</table>
</details>

---

### 2.9 函数类型题 【选择题】

以下不正确的说法是？

```c
A: 如果函数值的类型与返回值类型不一致，以函数值类型为准
B: return后边的值不能为表达式
C: 如果形参与实参类型不一致，以实参类型为准
D: 定义函数时，形参的类型说明可以放在函数体内
```

<details><summary>💡 答案提示</summary>
<p><b>答案：B、C、D</b></p>
<table>
<tr><th>选项</th><th>分析</th></tr>
<tr><td>A</td><td>正确说法：函数声明的返回类型与实际return值类型不一致时，以<b>函数声明的返回类型为准</b>（隐式类型转换）</td></tr>
<tr><td>B</td><td><b>不正确</b>：return后面当然可以接表达式，如<code>return a + b;</code>、<code>return x > 0 ? x : -x;</code></td></tr>
<tr><td>C</td><td><b>不正确</b>：形参与实参类型不一致时，以<b>形参类型为准</b>（实参被隐式转换为形参类型），不是以实参类型为准</td></tr>
<tr><td>D</td><td><b>不正确</b>：形参类型说明应写在函数头部的参数列表中，不能放在函数体内</td></tr>
</table>
<p><b>考点：</b>C语言函数的类型转换规则——无论是返回值还是参数传递，都是<b>被调用方的声明类型为准</b>（函数返回类型、形参类型）</p>
</details>

---

# 二、算法与数据结构

## 2.1 排序算法

### 2.1.1 快速排序 【编程题】

> **考点**：分治思想、基准选择、时间复杂度（最佳/平均 O(nlogn)，最差 O(n²)）
> **注意**：快排不稳定——相等元素的相对顺序可能改变；最差情况出现在已排序数组

1. 用自己的思路介绍快速排序。
2. 实现快速排序。
3. 如果一个数组中的元素表示VIP等级，顺序是按申请VIP的时间先后排序，快速排序能否将高等级的VIP排在前面且保持原有时间顺序？

<details><summary>💡 答案提示</summary>
<p><b>不能。</b>快排是<b>不稳定</b>排序，无法保证相等元素的原有顺序。需要使用归并排序等稳定排序算法。</p>
</details>

---

### 2.1.2 排序算法时间复杂度 【选择题】

> **考点**：各排序算法最好/平均/最差时间复杂度对比
> **注意**：冒泡和插入的最差复杂度都是 O(n²)

**(1)** 使用快速排序对n个数进行排序，其在最佳情况、平均情况、最差情况下的时间复杂度分别是（  ）。

<details><summary>💡 答案提示</summary>
<table>
<tr><th>情况</th><th>时间复杂度</th></tr>
<tr><td>最佳</td><td>O(nlogn)</td></tr>
<tr><td>平均</td><td>O(nlogn)</td></tr>
<tr><td>最差</td><td>O(n²)</td></tr>
</table>
</details>

---

**(2)** 若有8个待排序元素，采用冒泡排序和插入排序最大时间复杂度分别是（  ）。

<details><summary>💡 答案提示</summary>
<p>两者最差时间复杂度均为 <b>O(n²)</b>，即 8² = <b>64次比较</b>。</p>
</details>

---

### 2.1.3 二分查找 【问答题】

> **考点**：有序数组中查找元素，每次将搜索范围减半，O(logn)
> **注意**：前提是数组有序；注意中间值计算防溢出：`mid = left + (right - left) / 2`

用自己的思路介绍二分查找，以及快排和二分法的区别。

---

## 2.2 链表

### 2.2.1 单链表基本操作 【编程题】

> **考点**：链表节点定义、插入、删除操作
> **注意**：注意头节点处理、空链表处理、内存申请失败处理

**(1)** 单链表结构定义及指定位置插入节点：

```c
typedef struct Node {
    int data;
    struct Node *next;
} Node;

int insert_node(Node *head, int pos, int value);
```

功能说明：
- 在链表的第 `pos` 个位置插入值为 `value` 的新节点
- 插入成功返回 1，失败返回 0
- 位置从 0 开始，假设链表带头结点

边界情况：①头部插入 ②尾部插入 ③位置越界 ④空链表 ⑤内存申请失败

---

**(2)** 单链表插入一个新的节点。 【编程题】

---

**(3)** 链表的有序插入。 【编程题】

---

### 2.2.2 链表倒序/反转 【编程题】

> **考点**：三指针法（prev/curr/next）逐个翻转指针方向
> **注意**：注意处理空链表和单节点链表

1. 如何实现链表的倒序？
2. 将一个链表倒序。

<details><summary>💡 答案提示</summary>
<p>三指针迭代法：</p>
<pre><code>Node* reverse(Node* head) {
    Node *prev = NULL, *curr = head, *next;
    while (curr) {
        next = curr->next;
        curr->next = prev;
        prev = curr;
        curr = next;
    }
    return prev;
}</code></pre>
</details>

---

### 2.2.3 链表判环 【问答题】

> **考点**：快慢指针法——快指针每次走2步，慢指针走1步，相遇则有环
> **注意**：还可进一步求环的入口点和环的长度

怎么判断链表中是否有环？

<details><summary>💡 答案提示</summary>
<p><b>快慢指针法（Floyd 判环算法）：</b></p>
<ul>
<li>慢指针每次走 1 步，快指针每次走 2 步</li>
<li>若有环，两者必在环内相遇</li>
<li>若快指针到达 NULL，则无环</li>
</ul>
<p>进阶：相遇后，将一个指针移回头节点，两个指针都每次走1步，再次相遇点即为<b>环入口</b>。</p>
</details>

---

### 2.2.4 链表元素互换位置 【编程题】

> **考点**：交换链表中两个节点需同时修改前驱节点的指针
> **注意**：注意相邻节点交换的特殊情况

---

### 2.2.5 双向链表操作 【编程题】

> **考点**：双向链表的插入和删除需同时维护 `prev` 和 `next` 指针
> **注意**：什么时候用双向链表——需要双向遍历、频繁删除指定节点时

1. 什么时候用双向链表？
2. 编程实现一个双向链表的删除过程。

---

### 2.2.6 链表按值三路划分（分区问题）【编程题】

> **考点**：使用三对头尾指针分别收集小于/等于/大于目标值的节点，最后拼接
> **注意**：要求保持每个分区内节点的原有相对顺序不变；O(n) 时间，O(1) 额外空间

给定单链表头指针 `head` 和整数 `val`，对链表进行重排：

- `data < val` 排在左侧
- `data == val` 排在中间
- `data > val` 排在右侧

```c
typedef struct Linklist {
    int data;
    struct Linklist *next;
} Linklist;
```

要求：不修改数据域、不使用数组、O(n) 时间。

---

### 2.2.7 求取单链表中间位置的值 【编程题】

> **考点**：快慢指针法——快指针走2步、慢指针走1步，快指针到末尾时慢指针在中间
> **注意**：偶数个节点时返回第一个中间节点

---

### 2.2.8 链表与数组的区别 【问答题】+【选择题】

> **考点**：数组连续内存、随机访问O(1)、插入删除O(n)；链表非连续、顺序访问、插入删除O(1)
> **注意**：链表额外开销大（指针域），缓存不友好

**(1)** 链表与数组的区别。 【问答题】

<details><summary>💡 答案提示</summary>
<table>
<tr><th>对比项</th><th>数组</th><th>链表</th></tr>
<tr><td>内存布局</td><td>连续</td><td>非连续</td></tr>
<tr><td>随机访问</td><td>O(1)</td><td>O(n)</td></tr>
<tr><td>插入/删除</td><td>O(n)</td><td>O(1)（已知位置）</td></tr>
<tr><td>空间开销</td><td>无额外开销</td><td>每节点多一个指针域</td></tr>
<tr><td>缓存友好</td><td>是</td><td>否</td></tr>
<tr><td>大小</td><td>固定（静态数组）</td><td>动态伸缩</td></tr>
</table>
</details>

---

**(2)** 关于链表，描述正确的选项有（  ） 【选择题】

- **A.** 在运行时可以动态添加
- **B.** 物理空间不连续，空间开销更大
- **C.** 查找元素不需要顺序查找
- **D.** 可在任意节点位置插入元素

<details><summary>💡 答案提示</summary>
<p><b>答案：A、B、D</b></p>
<p>C 错误：单链表查找只能<b>顺序遍历</b>，时间复杂度 O(n)。</p>
</details>

---

## 2.3 栈与队列

### 2.3.1 栈的使用场景 【问答题】

> **考点**：函数调用栈、表达式求值、括号匹配、DFS等
> **注意**：后进先出（LIFO）特性决定了其适用场景

什么时候用栈？

---

### 2.3.2 用两个栈实现队列 【编程题】

> **考点**：一个栈做入队栈，一个栈做出队栈；出队栈为空时将入队栈全部倒入
> **注意**：均摊时间复杂度为 O(1)

用两个栈实现一个队列的功能。要求实现进队、出队、判断队为空。

<details><summary>💡 答案提示</summary>
<p>思路：</p>
<ul>
<li><b>入队</b>：直接压入栈A</li>
<li><b>出队</b>：若栈B非空则弹出栈B；若栈B为空则将栈A全部倒入栈B再弹出</li>
<li><b>判空</b>：栈A和栈B都为空</li>
</ul>
</details>

---

### 2.3.3 堆、栈、队列的描述判断 【选择题】

> **考点**：数据结构中的堆（优先队列）vs 内存中的堆；栈和队列的特性
> **注意**：堆是完全二叉树；"堆"的数据类型与"队列"**不**相似

对于堆、栈、队列描述**错误**的是（  ）

- **A.** 队列空间缓冲由进程申请，栈的空间缓冲由OS分配
- **B.** 堆总是一棵完全二叉树
- **C.** 堆的数据类型和队列相似
- **D.** 队列先进先出，栈后进先出

<details><summary>💡 答案提示</summary>
<p><b>答案：C</b></p>
<p>堆是完全二叉树结构，支持高效的最大/最小值查询；队列是线性FIFO结构。两者数据类型和操作方式完全不同。</p>
</details>

---

### 2.3.4 队列与栈的异同 【问答题】

> **考点**：LIFO vs FIFO；典型应用场景（函数调用栈/DFS vs 消息队列/BFS）
> **注意**：两者都是操作受限的线性结构；变体包括循环队列、双端队列、优先队列

简述队列和栈的异同。

<details><summary>💡 答案提示</summary>
<p><b>相同点：</b></p>
<ul>
<li>都是<b>线性数据结构</b>，操作受限（不允许随机访问中间元素）</li>
<li>都可以用数组或链表实现</li>
</ul>
<p><b>不同点：</b></p>
<table>
<tr><th>区别</th><th>栈（Stack）</th><th>队列（Queue）</th></tr>
<tr><td>原则</td><td><b>LIFO</b>（后进先出）</td><td><b>FIFO</b>（先进先出）</td></tr>
<tr><td>操作</td><td><code>push</code>（入栈）/ <code>pop</code>（出栈），同一端</td><td><code>enqueue</code>（入队尾）/ <code>dequeue</code>（出队头）</td></tr>
<tr><td>典型应用</td><td>函数调用栈、DFS</td><td>消息队列、BFS</td></tr>
</table>
</details>

---

## 2.4 字符串算法

### 2.4.1 实现 strcpy 函数 【编程题】

> **考点**：逐字符复制直到 `\0`；注意目标缓冲区大小、返回目标字符串首地址
> **注意**：经典面试题——需处理 `NULL` 指针、重叠区域等边界情况

不使用库函数，编写 `strcpy` 函数：

```c
char *strcpy(char *strDest, const char *strSrc);
```

<details><summary>💡 答案提示</summary>
<pre><code>char *strcpy(char *strDest, const char *strSrc) {
    assert(strDest != NULL && strSrc != NULL);
    char *ret = strDest;
    while ((*strDest++ = *strSrc++) != '\0');
    return ret;
}</code></pre>
<p>得分要点：①assert 检查 ②返回目的地址（支持链式调用）③循环条件含赋值和判断</p>
</details>

---

### 2.4.2 实现 memcpy 函数 【编程题】

> **考点**：按字节逐个复制指定长度的内存内容
> **注意**：需处理源和目标内存重叠的情况（此时应从后往前复制）

```c
void *memcpy(void *dst, const void *src, int size);
```

<details><summary>💡 答案提示</summary>
<p>处理重叠的关键：当 <code>dst > src</code> 且有重叠时，从<b>后往前</b>复制；否则从前往后。</p>
</details>

---

### 2.4.3 字符串反转 【编程题】

> **考点**：首尾双指针交换，O(n) 时间，O(1) 空间
> **注意**：不使用任何系统函数

```c
char* reverse_str(char* str);
```

---

### 2.4.4 最大连续子串长度 【编程题】

> **考点**：遍历字符串，区分字母和数字段，记录最大长度
> **注意**：注意"子串"的定义——连续的同类字符（字母或数字）

**(1)** 将一个字符串中最大连续子串中的长度和子串返回（主要区分字母和数字）。

**(2)** 计算一个字符串中最大的子串的长度并返回。如 `"abcdefg123456789asdfgagfafg"` 中最大子串是 `"asdfgagfafg"`。

---

### 2.4.5 最长不重复子串 【编程题】

> **考点**：滑动窗口法，维护窗口内字符不重复
> **注意**：可用哈希表/数组记录字符最近出现位置

找出字符串的最长不重复子串，输出长度。

---

### 2.4.6 字符串去除重复字符 【编程题】

> **考点**：使用布尔数组标记已出现字符，保留首次出现
> **注意**：ASCII 字符集共128/256个字符，可用数组做哈希

输入 `"abcabcdeffg"`，输出 `"abcdefg"`。

---

### 2.4.7 字符串形式的大整数相加 【编程题】

> **考点**：模拟竖式加法——从末尾逐位相加并处理进位
> **注意**：两字符串长度可能不同；最高位可能产生进位

```c
char a[] = "1111";
char b[] = "9999";
// 输出: "11110"
```

要求：逐位相加 + 进位处理，不能转换为整数类型。

---

### 2.4.8 计算字符串中单词个数 【编程题】

> **考点**：遍历字符串，识别空格与非空格的边界转换
> **注意**：需处理连续空格、首尾空格等边界情况

---

### 2.4.9 消除嵌套括号 【编程题】

> **考点**：栈的应用——遇左括号压栈（或标记），遇右括号弹栈，只保留数字和逗号
> **注意**：需检测格式错误（括号不匹配等）

给定字符串 `(1,(2,3),(4,(5,6),7))`，消除嵌套括号输出 `(1,2,3,4,5,6,7)`。

---

### 2.4.10 数字字符串转化为数字（my_atoi）【编程题】

> **考点**：字符与数字的 ASCII 转换（`- '0'`）；逐位累乘10相加的核心公式
> **注意**：完整实现需考虑前导空格、正负号、溢出检测（超出 `INT_MAX`/`INT_MIN`），面试中提一嘴加分

编码实现将数字字符串转化为数字（实现 `atoi`）。

<details><summary>💡 答案提示</summary>
<pre><code>int my_atoi(const char *str) {
    int sign = 1, result = 0;
    // 1. 跳过前导空格
	while (*str == ' ') str++;
	// 2. 处理正负号
    if (*str == '-' || *str == '+') {
        if (*str == '-') sign = -1;
        str++;
    }

    // 3. 逐位转换：字符 - '0' 得到数字，累乘10相加
    while (*str >= '0' && *str <= '9') {
        result = result * 10 + (*str - '0');
        str++;
    }
    
    return sign * result;
    }</code></pre>
    <p>核心原理：<code>字符 - '0'</code> 得到对应数字值，通过 <code>result = result * 10 + digit</code> 逐位累加。</p>
</details>

---

## 2.5 数组算法

### 2.5.1 4位二进制分组求和 【编程题】

> **考点**：位运算——每次取低4位、右移4位，循环8次
> **注意**：掩码 `& 0xF` 提取低4位

给定32位无符号整数，将其二进制每4位一组，每组转为十进制后求和。

> **示例**：`0xFFFFFFFF` → 每组都是 `1111`(=15) × 8组 = **120**

<details><summary>💡 答案提示</summary>
<pre><code>int nibble_sum(unsigned int n) {
    int sum = 0;
    for (int i = 0; i < 8; i++) {
        sum += (n & 0xF);
        n >>= 4;
    }
    return sum;
}</code></pre>
</details>

---

### 2.5.2 找出两个数组的差集 【编程题】

> **考点**：对每个第一数组元素检查是否在第二数组中存在
> **注意**：可用排序+双指针优化为 O(nlogn)；也可用哈希表优化为 O(n)

---

### 2.5.3 求数组中出现次数最多的元素 【编程题】

> **考点**：遍历统计频次，记录最大值
> **注意**：不允许修改原数组；多个并列最多时返回第一次出现的元素

```c
int a[] = {1, 3, 2, 3, 4, 3, 2, 1};
// 输出: 3（出现3次）
```

---

### 2.5.4 返回数组第二大的数 【编程题】

> **考点**：一次遍历维护最大值和次大值
> **注意**：需处理所有元素相同、数组只有一个元素等边界情况

---

### 2.5.5 二维数组中最大值及其位置 【编程题】

> **考点**：双重循环遍历，记录最大值及其行列索引
> **注意**：注意行列编号从0开始

```c
#define ROW 3
#define COL 4
int arr[ROW][COL] = {
    {12, 7,  9,  15},
    {3,  22, 8,  6},
    {14, 5,  18, 10}
};
```

---

### 2.5.6 打印 N×N 方阵 【编程题】

> **考点**：多层嵌套循环，根据元素到边界的最小距离决定打印内容
> **注意**：距离0打印X，距离1打印Y，距离≥2打印 `距离-2`

```
N=5 时：
X X X X X
X Y Y Y X
X Y 0 Y X
X Y Y Y X
X X X X X
```

---

## 2.6 数学与递归

### 2.6.1 递归求和（1到N）【编程题】

> **考点**：递归函数定义、终止条件（`n==1` 返回1）、函数调用栈
> **注意**：递归深度过大会导致栈溢出

```c
int sum(int n);  // 计算 1+2+...+n
```

<details><summary>💡 答案提示</summary>
<pre><code>int sum(int n) {
    if (n == 1) return 1;      // 递归终止条件
    return n + sum(n - 1);     // 递归调用
}</code></pre>
</details>

---

### 2.6.2 N! 末尾零的个数 【编程题】

> **考点**：末尾零由因子10产生，10=2×5，因子5的个数决定零的个数
> **注意**：`count = N/5 + N/25 + N/125 + ...`

<details><summary>💡 答案提示</summary>
<pre><code>int trailing_zeros(int n) {
    int count = 0;
    while (n >= 5) {
        count += n / 5;
        n /= 5;
    }
    return count;
}</code></pre>
</details>

---

### 2.6.3 最小公倍数 【编程题】

> **考点**：`LCM(a,b) = a*b / GCD(a,b)`；GCD 用辗转相除法求
> **注意**：先求最大公约数再求最小公倍数；注意乘法溢出

---

### 2.6.4 集合中求最大元素 C = A + B 【编程题】

> **考点**：遍历集合找最大元素，再遍历找是否存在两个元素之和等于它
> **注意**：A和B可以是同一个元素（需看题目要求）

---

## 2.7 树

### 2.7.1 非递归实现中序遍历二叉树 【编程题】

> **考点**：使用栈模拟递归——先沿左子树一路入栈，弹出时访问节点再转向右子树
> **注意**：中序遍历顺序为 左→根→右

---

## 2.8 趣味算法

### 2.8.1 牌序还原问题 【编程题】

> **考点**：模拟/逆向推导——已知取牌顺序为A到K，反推初始排列
> **注意**：操作是"放一张到底部，取一张出来"，需用队列模拟逆过程

一副牌从A到K共13张，取牌顺序：
1. 将第一张放到最下面
2. 取出最上面的一张牌

依次操作1、2，最后取出牌的顺序是从A到K，求13张牌的最初顺序。

<details><summary>💡 答案提示</summary>
<p>逆向模拟：从结果反推。将 K~A 逆序依次"放回"：</p>
<ol>
<li>将当前牌放到队列顶部</li>
<li>将队列底部的牌移到顶部</li>
</ol>
<p>用双端队列（deque）模拟。</p>
</details>

---

### 4.1 大整数乘法算法 【选择题】

实现大整数乘法是利用什么算法？

```c
A: 动态规划算法
B: 贪心算法
C: 分治算法
D: 回溯算法
```

<details><summary>💡 答案提示</summary>
<p><b>答案：C（分治算法）</b></p>
<p>经典的<b>Karatsuba算法</b>就是用分治思想实现大整数乘法：</p>
<ol>
<li>将大整数拆分为高位和低位两部分</li>
<li>递归地对较小的部分做乘法</li>
<li>合并结果</li>
<li>时间复杂度从朴素的O(n²)降到O(n^1.585)</li>
</ol>
<p><b>考点：</b>分治算法的经典应用——大整数乘法(Karatsuba)、归并排序、快速排序、Strassen矩阵乘法</p>
</details>

---

### 4.2 链表删除重复项 【选择题】

以下代码实现了从表中删除重复项的功能，请选择其中空白行应填入的正确代码。

```c
template <class T>
void removeDuplicates(list<T> &aList)
    list<T>::iterator cur, p;

    cur = aList.begin();
    while (cur != aList.end())
    {
        curValue = *cur;

        // 空白行①

        while (p != aList.end())
        {
            if (*p == curValue)
            {
                // 空白行②
            }
            else
            {
                p++;
            }
        }

        cur++;
    }
}

A:
p = ++cur;
aList.erase(p++);

B:
p = cur + 1;
aList.erase(p);

C:
p = cur + 1;
aList.erase(p++);

D:
p = ++cur;
aList.erase(p);
```

<details><summary>💡 答案提示</summary>
<p><b>答案：A</b></p>
<p><b>关键错误：<code>std::list</code>的迭代器不支持<code>+</code>运算符！</b></p>
<ul>
<li><code>list</code>是双向链表，迭代器是<b>BidirectionalIterator</b>，只支持<code>++</code>和<code>--</code></li>
<li><code>cur + 1</code>无法通过编译，<b>B和C直接排除</b></li>
<li>只有<code>++cur</code>（自增）才是合法的迭代器操作</li>
</ul>
<p><b>分析A选项：</b></p>
<ul>
<li>空白行①：<code>p = ++cur;</code> —— cur先自增指向下一个元素，p也指向该位置</li>
<li>空白行②：<code>aList.erase(p++);</code> —— <b>先保存p当前位置用于erase，再将p自增指向下一个元素</b>。这是STL中删除元素的标准写法，避免迭代器失效</li>
</ul>
</details>

---

### 4.3 进制转换 【编程题】

给定一个整数，将其转化为7进制，并以字符串形式输出。

示例1:
输入: 100
输出: "202"

示例2:
输入: -7
输出: "-10"

注意: 输入范围是[-1e7, 1e7]。

<details><summary>💡 答案提示</summary>
<p><b>思路：短除法（辗转取余）</b></p>
<p>不断对7取余得到每一位，再对7整除缩小数值，最后将结果反转。负数先转正数处理，最后加负号。</p>
<pre><code>char* toBase7(int num)
{
    // 静态缓冲区足够容纳范围 [-1e7, 1e7]
    // 7^9 = 40353607 > 1e7
    // 最多 9 位 + 负号 + '\0'
    static char buf[12];
    
    if (num == 0) {
        buf[0] = '0';
        buf[1] = '\0';
        return buf;
    }

    int isNegative = 0;
    if (num < 0) {
        isNegative = 1;
        num = -num;
    }

    int i = 0;
    while (num > 0) {
        int digit = num % 7;
        buf[i++] = digit + '0';  // 数字转字符：加上'0'即可
        num /= 7;
    }

    if (isNegative) {
        buf[i++] = '-';
    }

    buf[i] = '\0';

    // 反转字符串
    int left = 0, right = i - 1;
    while (left < right) {
        char temp = buf[left];
        buf[left] = buf[right];
        buf[right] = temp;
        left++;
        right--;
    }

    return buf;
}</code></pre>
<p><b>示例: 100 → 100%7=6,100/7=14 → 14%7=0,14/7=2 → 2%7=2,2/7=0 → 逆序"202"</b></p>
</details>

---

### 4.4 括号匹配 【编程题】

输入一个字符串，其中包含 ()、[]、{} 六种括号，请判断该字符串中的括号是否合法。

| 输入       | 输出    |
| ---------- | ------- |
| `"()[]{}"` | `true`  |
| `"(]"`     | `false` |
| `"(["`     | `false` |

**判定规则**
1. 左括号必须由相同类型的右括号闭合。
2. 左括号必须按正确的顺序闭合（后开先闭）。
3. 每个右括号都必须有对应的左括号。
4. 所有括号最终都必须完全匹配。

<details><summary>💡 答案提示</summary>
<p><b>思路：栈（后进先出，天然匹配"后开先闭"规则）</b></p>
<pre><code>bool isValid(const char* s)
{
    int len = strlen(s);
    
    // 最大栈深度不超过字符串长度
    char stack[len];
    int top = -1;
    
    for (int i = 0; i < len; i++)
    {
        char c = s[i];
        
        // 左括号入栈
        if (c == '(' || c == '[' || c == '{')
        {
            stack[++top] = c;
        }
        else
        {
            // 右括号时，栈必须非空
            if (top < 0)
                return false;
            
            char t = stack[top--];  // 出栈
            
            // 检查是否匹配
            if ((c == ')' && t != '(') ||
                (c == ']' && t != '[') ||
                (c == '}' && t != '{'))
            {
                return false;
            }
        }
    }
    
    // 所有括号必须匹配完成
    return top == -1;
}</code></pre>
<p><b>考点：</b>栈的经典应用——括号匹配。三个容易遗漏的边界：①右括号多余（栈空时遇到右括号）②左括号多余（遍历结束栈不空）③类型不匹配（<code>(</code>遇到<code>]</code>）</p>
</details>

# 三、通信总线

## 3.1 常见通信协议对比

### 3.1.1 五种通信协议的工作原理与特点 【问答题】

> **考点**：各总线的线数、速率、拓扑结构、全/半双工、同步/异步等特性对比
> **注意**：串口可以是全双工也可以是半双工或单工，**不要一律说全双工**

请简述以下通信协议的工作原理以及特点：

| 协议 | 线数 | 同步/异步 | 双工模式 | 关键特性 |
|------|------|----------|---------|---------|
| **RS-485** | 2线（A/B差分） | 异步 | 半双工 | 差分信号、多点通信、长距离（1200m） |
| **UART** | 2线（TX/RX） | 异步 | **全/半/单工均可** | 起始位/停止位、波特率匹配 |
| **CAN** | 2线（CANH/CANL） | 异步 | 半双工 | 差分信号、多主仲裁、错误检测完善 |
| **I2C** | 2线（SDA+SCL） | 同步 | 半双工 | 多主多从、7/10位地址寻址 |
| **SPI** | 4线（MOSI/MISO/SCK/CS） | 同步 | 全双工 | 高速、无地址寻址、主从架构 |

---

### 3.1.2 串口、IIC、SPI 深入理解 【问答题】

> **考点**：三种协议的时序图、数据格式、应用场景选择
> **注意**：串口是异步通信（无时钟线），I2C和SPI是同步通信（有时钟线）

<details><summary>💡 答案提示</summary>
<p>选型参考：</p>
<ul>
<li><b>低速、少量设备、省引脚</b> → I2C</li>
<li><b>高速、实时数据传输</b> → SPI</li>
<li><b>长距离、调试打印</b> → UART</li>
</ul>
</details>

---

## 3.2 GPIO 与 I2C 设备驱动 【问答题】

> **考点**：GPIO的输入/输出/复用模式；I2C设备驱动流程（起始→地址→读写→停止）
> **注意**：I2C需要注意从机地址（7位/10位）、ACK/NACK应答机制

GPIO 功能，驱动一个 I2C 设备的流程。

<details><summary>💡 答案提示</summary>
<p>I2C 通信流程：</p>
<pre><code>主机发送起始信号(START)
    → 发送从机地址 + 读/写位
    → 等待从机 ACK
    → 发送/接收数据字节
    → 每字节后等待 ACK/NACK
    → 发送停止信号(STOP)</code></pre>
</details>

---

# 四、嵌入式操作系统

## 4.1 进程与线程

### 4.1.1 进程与线程的区别 【问答题】

> **考点**：进程是资源分配的基本单位；线程是CPU调度的基本单位；线程共享进程资源
> **注意**：线程切换开销小于进程切换；同进程的线程共享地址空间、文件描述符等
> ⚠️ **此题出现频率极高**

进程与线程的区别。

<details><summary>💡 答案提示</summary>
<table>
<tr><th>对比项</th><th>进程</th><th>线程</th></tr>
<tr><td>定义</td><td>资源分配的基本单位</td><td>CPU调度的基本单位</td></tr>
<tr><td>地址空间</td><td>独立</td><td>共享所属进程的地址空间</td></tr>
<tr><td>通信</td><td>IPC（管道、消息队列、共享内存等）</td><td>直接读写共享变量</td></tr>
<tr><td>切换开销</td><td>大（需切换页表等）</td><td>小（共享地址空间）</td></tr>
<tr><td>崩溃影响</td><td>不影响其他进程</td><td>可能导致整个进程崩溃</td></tr>
</table>
</details>

---

### 4.1.2 线程同步 【问答题】

> **考点**：互斥锁、信号量、条件变量、读写锁等同步机制
> **注意**：同步强调执行顺序，互斥强调资源排他访问

简单描述线程同步。

---

### 4.1.3 同步与互斥的问题 【问答题】

> **考点**：同步——协调多个线程的执行顺序；互斥——保证共享资源同一时刻只被一个线程访问
> **注意**：互斥是一种特殊的同步关系

同步与互斥的区别。

<details><summary>💡 答案提示</summary>
<ul>
<li><b>同步</b>：多个线程按<b>约定的顺序</b>协调执行（如生产者-消费者）</li>
<li><b>互斥</b>：多个线程对共享资源<b>排他性访问</b>（如同时只有一个线程能写数据）</li>
<li>互斥是同步的一种特殊情况</li>
</ul>
</details>

---

### 4.1.4 互斥锁（Mutex）概念 【选择题】

> **考点**：互斥锁的加解锁规则、使用约束
> **注意**：解锁顺序在嵌套锁场景中很重要（必须逆序解锁）

关于互斥锁（Mutex）的如下表述，**错误的是（  ）**

- **A.** 互斥锁的加锁和解锁必须由同一线程分别对应使用
- **B.** 互斥锁只能为 0/1 两种状态
- **C.** 互斥锁的解锁过程不需要关心顺序，只需要成对使用即可
- **D.** 互斥锁用于线程之间的互斥访问

<details><summary>💡 答案提示</summary>
<p><b>答案：C</b></p>
<p>嵌套加锁时，解锁必须<b>逆序</b>（后加的锁先解），否则可能导致死锁。不能"不关心顺序"。</p>
</details>

---

### 4.1.5 多线程编程实践 【编程题】

> **考点**：线程创建、临界区保护、共享资源访问
> **注意**：购票场景需保证余票数的原子性操作，防止超卖
> 💡 此题同时考察**编程能力**和**操作系统概念**

写一个购买火车票的多线程伪代码。

<details><summary>💡 答案提示</summary>
<pre><code>int tickets = 100;
pthread_mutex_t lock;

void* buy_ticket(void* arg) {
    while (1) {
        pthread_mutex_lock(&lock);
        if (tickets > 0) {
            tickets--;
            printf("买到票，剩余 %d\n", tickets);
        } else {
            pthread_mutex_unlock(&lock);
            break;
        }
        pthread_mutex_unlock(&lock);
    }
    return NULL;
}</code></pre>
<p>关键：对 <code>tickets</code> 的读写必须在<b>互斥锁保护</b>下进行。</p>
</details>

---

## 4.2 进程调度

### 4.2.1 进程间制约关系 【选择题】

> **考点**：多个进程按顺序逐一访问资源属于"同步"关系
> **注意**：区分同步（有序访问）、互斥（排他访问）、调度（CPU分配策略）

多个进程按照顺序逐一访问某个资源，这种制约关系称之为（  ）

- **A.** 调度
- **B.** 协同
- **C.** 互斥
- **D.** 同步

<details><summary>💡 答案提示</summary>
<p><b>答案：D</b></p>
<p>"按顺序逐一访问"强调的是<b>执行顺序的约束</b>，这是同步的定义。互斥只要求排他，不要求顺序。</p>
</details>

---

### 4.2.2 进程调度触发条件 【选择题】

> **考点**：进程等待事件、时间片用完、进程出错都会触发调度；新进程就绪不一定立即调度
> **注意**：选项C不是**直接**原因（取决于调度算法是否为抢占式）

下列选项中，**不是引起操作系统选择新进程运行的直接原因**的是（  ）

- **A.** 当前运行进程需要等待某一事件发生
- **B.** 当前运行进程的时间片用完
- **C.** 有新进程进入就绪状态
- **D.** 当前运行进程发生错误

<details><summary>💡 答案提示</summary>
<p><b>答案：C</b></p>
<p>新进程进入就绪状态只是排队等候，不一定引起当前进程让出CPU（除非是抢占式调度且新进程优先级更高）。</p>
</details>

---

## 4.3 内存管理

### 4.3.1 内存管理淘汰算法 【问答题】

> **考点**：FIFO（先进先出）、LRU（最近最少使用）、LFU（最不经常使用）、OPT（最优置换）
> **注意**：LRU是实际中最常用的近似最优算法

内存管理淘汰算法有哪些？并分别简述。

<details><summary>💡 答案提示</summary>
<table>
<tr><th>算法</th><th>策略</th><th>特点</th></tr>
<tr><td><b>FIFO</b></td><td>淘汰最早进入的页面</td><td>简单但可能淘汰常用页（Belady异常）</td></tr>
<tr><td><b>LRU</b></td><td>淘汰最近最久未使用的页面</td><td>效果好，实现复杂（需记录访问时间）</td></tr>
<tr><td><b>LFU</b></td><td>淘汰使用频率最低的页面</td><td>需维护计数器</td></tr>
<tr><td><b>OPT</b></td><td>淘汰未来最久不使用的页面</td><td>理论最优，实际无法实现</td></tr>
</table>
</details>

---

## 4.4 中断机制

### 4.4.1 中断下半段处理机制 【选择题】

> **考点**：Linux 中断下半段的三种机制：软中断（softirq）、tasklet、工作队列（workqueue）
> **注意**：双向链表是数据结构，不是中断处理机制

可用于中断下半段处理的处理机制有（  ）

- **A.** tasklet ✓
- **B.** 工作队列 ✓
- **C.** 软中断 ✓
- **D.** 双向链表 ✗

<details><summary>💡 答案提示</summary>
<p><b>答案：A、B、C</b></p>
<table>
<tr><th>机制</th><th>执行上下文</th><th>能否睡眠</th></tr>
<tr><td>软中断</td><td>中断上下文</td><td>不能</td></tr>
<tr><td>tasklet</td><td>中断上下文（基于软中断）</td><td>不能</td></tr>
<tr><td>工作队列</td><td>进程上下文</td><td>能</td></tr>
</table>
<p>双向链表是数据结构，不是中断处理机制。</p>
</details>

---

## 4.5 I/O 多路复用

### 4.5.1 I/O 多路复用方式 【问答题】

> **考点**：`select`（跨平台，fd数量有限）、`poll`（无fd数量限制）、`epoll`（Linux高性能）
> **注意**：嵌入式Linux中 `epoll` 最常用；select/poll 每次调用需要重新传递fd集合

1. 嵌入式中 I/O 多路复用的方式。
2. I/O 多路复用的几种实现方法。

<details><summary>💡 答案提示</summary>
<table>
<tr><th>方法</th><th>fd上限</th><th>性能</th><th>内核实现</th></tr>
<tr><td><b>select</b></td><td>1024（FD_SETSIZE）</td><td>O(n) 轮询</td><td>所有平台</td></tr>
<tr><td><b>poll</b></td><td>无硬限制</td><td>O(n) 轮询</td><td>Linux/Unix</td></tr>
<tr><td><b>epoll</b></td><td>无硬限制</td><td>O(1) 事件驱动</td><td>仅Linux</td></tr>
</table>
</details>

---

### 3.1 嵌入式任务状态 【选择题】

嵌入式系统中，一个任务被唤醒就意味着？

```c
A: 该任务重新占有了CPU
B: 他的优先级变为最高
C: 任务变为就绪态
D: 其任务移至等待队列的队首
```

<details><summary>💡 答案提示</summary>
<p><b>答案：C（任务变为就绪态）</b></p>
<ul>
<li>唤醒 ≠ 立刻执行，唤醒只是从<b>阻塞态→就绪态</b>，等待调度器分配CPU</li>
<li>A错：占有CPU需要调度器调度，唤醒不等于立刻获得CPU</li>
<li>B错：优先级不会因唤醒而改变</li>
<li>D错：是移至<b>就绪队列</b>，不是等待队列</li>
</ul>
<p><b>考点：</b>RTOS任务状态机（运行态、就绪态、阻塞态）。唤醒 = 阻塞→就绪，调度 = 就绪→运行</p>
</details>

---

### 3.2 线程共享资源 【选择题】

属于线程之间共享资源的是？

```c
A: 全局变量
B: 线程栈
C: 地址空间
D: 堆
```

<details><summary>💡 答案提示</summary>
<p><b>答案：A、C、D</b></p>
<p><b>线程共享的资源：</b></p>
<ul>
<li>全局变量 ✓（A）</li>
<li>地址空间 ✓（C）</li>
<li>堆 ✓（D）</li>
<li>还有：代码段、打开的文件描述符、信号处理函数等</li>
</ul>
<p><b>线程私有的资源：</b></p>
<ul>
<li><b>线程栈</b>（B）—— 每个线程有自己独立的栈</li>
<li>寄存器组、程序计数器(PC)、线程ID、errno</li>
</ul>
</details>

---

### 3.3 volatile用途 【选择题】

在单循环的嵌入式系统中，使用一个全局变量在中断函数和main函数之间传递数据，为了避免数据错误，可以采用如下做法？

```c
A: 可以用const修饰此全局变量
B: 可以用volatile修饰此全局变量
C: 可以用static修饰此全局变量
D: 可以用static const修饰此全局变量
```

<details><summary>💡 答案提示</summary>
<p><b>答案：B（volatile）</b></p>
<table>
<tr><th>修饰符</th><th>分析</th></tr>
<tr><td><code>const</code></td><td>变量不可修改，无法用于传递数据 ✗</td></tr>
<tr><td><b><code>volatile</code></b></td><td>告诉编译器<b>不要优化</b>此变量的读取，每次都从内存取值 ✓</td></tr>
<tr><td><code>static</code></td><td>限制作用域，与防止数据错误无关 ✗</td></tr>
<tr><td><code>static const</code></td><td>既不可修改又限制作用域，更不行 ✗</td></tr>
</table>
<p><b>考点：</b>volatile的核心作用——<b>防止编译器优化</b>。中断中修改的变量如果没有volatile修饰，编译器可能将其缓存到寄存器中，main函数读到的是旧值</p>
</details>

---

### 3.4 UART通信 【选择题】

下列关于UART通信描述正确的是？

A: 收发两端可以不工作在同一个速率上
B: 异步通讯方式
C: 传输速度固定不可变
D: 不可以实现全双工模式

<details><summary>💡 答案提示</summary>
<p><b>答案：B（异步通讯方式）</b></p>
<table>
<tr><th>选项</th><th>分析</th></tr>
<tr><td>A</td><td>错：收发两端<b>必须</b>工作在相同波特率上，否则无法正确解码</td></tr>
<tr><td>B</td><td>对：UART = Universal <b>Asynchronous</b> Receiver/Transmitter，无时钟线，靠波特率约定同步 ✓</td></tr>
<tr><td>C</td><td>错：波特率是<b>可配置</b>的（9600、115200等），不是固定的</td></tr>
<tr><td>D</td><td>错：UART有TX和RX两根线，<b>可以实现全双工</b></td></tr>
</table>
</details>

---

### 3.5 SPI和IIC对比 【选择题】

关于SPI和IIC总线的描述，正确的是？

```c
A: IIC可以实现全双工，SPI不能实现全双工
B: IIC的数据输入输出用的是一根线，SPI则分为数据输入和数据输出两根线
C: IIC的抗干扰能力比SPI强
D: SPI适合长距离传播
```

<details><summary>💡 答案提示</summary>
<p><b>答案：B</b></p>
<table>
<tr><th>选项</th><th>分析</th></tr>
<tr><td>A</td><td>错：恰好说反了。<b>IIC是半双工</b>（SDA一根数据线），<b>SPI才能实现全双工</b>（MOSI+MISO两根数据线）</td></tr>
<tr><td>B</td><td>对：<b>IIC用SDA一根线</b>收发数据（半双工）；<b>SPI用MOSI（主→从）和MISO（从→主）两根线</b>分别负责输入输出 ✓</td></tr>
<tr><td>C</td><td>错：SPI的抗干扰能力比IIC强（SPI速度更快、信号更稳定）</td></tr>
<tr><td>D</td><td>错：SPI适合<b>短距离、高速</b>板级通信，不适合长距离</td></tr>
</table>
</details>

---

# 五、综合

## 5.1 嵌入式硬件与体系结构

### 5.1.1 ARM 架构 【问答题】

> **考点**：ARM 核心架构（Cortex-M/A/R系列）、流水线、工作模式、寄存器组
> **注意**：嵌入式常用 Cortex-M 系列（M0/M3/M4/M7），注意中断处理和低功耗特性

讲述 ARM 架构的了解。

<details><summary>💡 答案提示</summary>
<table>
<tr><th>系列</th><th>定位</th><th>典型应用</th></tr>
<tr><td><b>Cortex-M</b></td><td>微控制器</td><td>STM32、物联网终端</td></tr>
<tr><td><b>Cortex-R</b></td><td>实时处理</td><td>汽车ECU、硬盘控制器</td></tr>
<tr><td><b>Cortex-A</b></td><td>应用处理</td><td>手机、平板、Linux设备</td></tr>
</table>
<p>关键特性：RISC架构、Thumb指令集、低功耗设计、丰富的中断处理机制(NVIC)</p>
</details>

---

### 5.1.2 单片机的通用启动过程 【问答题】

> **考点**：上电复位→初始化栈指针→初始化时钟→初始化外设→跳转 main
> **注意**：启动文件（startup.s）、向量表、系统时钟配置（HSE/HSI/PLL）是关键步骤

单片机的通用启动过程。

<details><summary>💡 答案提示</summary>
<pre><code>上电/复位
  → ① 从向量表读取初始栈指针(MSP)
  → ② 从向量表读取复位向量(Reset_Handler地址)
  → ③ 执行 Reset_Handler（启动文件 startup.s）
      → 初始化 .data 段（从Flash拷贝到RAM）
      → 清零 .bss 段
      → 配置系统时钟（HSE/PLL）
      → 调用 C 库初始化
  → ④ 跳转到 main()</code></pre>
</details>

---

### 5.1.3 U-Boot 引导启动流程 【问答题】

> **考点**：BL1→BL2→加载内核→传参→启动Linux
> **注意**：U-Boot 分为 SPL 和完整 U-Boot 两个阶段

<details><summary>💡 答案提示</summary>
<pre><code>ROM Bootloader
  → SPL (Secondary Program Loader)
      → 初始化DDR、时钟
      → 加载完整 U-Boot 到 DDR
  → U-Boot
      → 初始化外设（串口、网络、存储）
      → 加载内核镜像(zImage/uImage)到内存
      → 传递设备树(DTB)和启动参数
      → 跳转到内核入口
  → Linux Kernel 启动</code></pre>
</details>

---

### 5.1.4 STM32 软件中断与外设实现 【问答题】

> **考点**：NVIC 中断控制器、中断优先级分组、中断向量表、软件触发中断
> **注意**：包含模拟量采集的ADC中断、DMA传输完成中断等

请基于 STM32 描述：
1. 软件中断的实现机制
2. 模拟量采集的数字化实现过程
3. PWM 功能的实现过程

---

### 5.1.5 大小端（字节序）【编程题】

> **考点**：通过联合体（`union`）或指针强转检查整数低字节内容
> **注意**：大端——高位字节在低地址；小端——低位字节在低地址；ARM一般是小端，网络字节序是大端

编写程序判断当前系统的字节序类型：

```c
int x = 0x12345678;
// 若低地址存储 0x78 → 小端（Little Endian）
// 若低地址存储 0x12 → 大端（Big Endian）
```

<details><summary>💡 答案提示</summary>
<p><b>方法一：指针法</b></p>
<pre><code>int x = 1;
if (*(char*)&x == 1)
    printf("Little Endian\n");
else
    printf("Big Endian\n");</code></pre>
<p><b>方法二：联合体法</b></p>
<pre><code>union {
    int i;
    char c;
} u;
u.i = 1;
if (u.c == 1)
    printf("Little Endian\n");
else
    printf("Big Endian\n");</code></pre>
</details>

---

## 5.2 综合知识

### 5.2.1 单位换算 【计算题】

> **考点**：存储单位换算（1MB = 1024KB = 1024×1024B），位(bit)与字节(Byte)的关系（1Byte = 8bit）
> **注意**：颜色深度24位表示每个像素占24bit，计算时别忘了除以8转字节

某相机内置256MB存储空间，拍摄照片的分辨率为1600x1200像素，颜色深度为24位，若不采用压缩存储技术，使用内部储存最多可以拍多少张照片？

<details><summary>💡 答案提示</summary>
<p><b>计算过程：</b></p>
<ol>
<li>256MB = 256 × 1024 × 1024 = 268,435,456 字节(Byte)</li>
<li>一张照片大小 = 1600 × 1200 × 24 / 8 = 5,760,000 字节（注意24位是bit，要除以8换算成Byte）</li>
<li>268,435,456 ÷ 5,760,000 ≈ 46.6 → <b>最多拍46张</b></li>
</ol>
</details>

---

### 5.2.2 Shell命令行基础 【选择题】

#### 5.2.2.1 Shell特殊变量

在 Shell 中，用于表示传入参数个数的特殊变量是？

```c
A. $#
B. $*
C. $?
D. 0
```

<details><summary>💡 答案提示</summary>
<p><b>答案：A <code>$#</code></b></p>
<table>
<tr><th>变量</th><th>含义</th></tr>
<tr><td><code>$#</code></td><td>传入参数的<b>个数</b></td></tr>
<tr><td><code>$*</code></td><td>所有参数作为一个整体字符串</td></tr>
<tr><td><code>$?</code></td><td>上一条命令的<b>退出状态码</b>（0成功，非0失败）</td></tr>
<tr><td><code>$0</code></td><td>脚本自身的名称</td></tr>
</table>
</details>

---

#### 5.2.2.2 Shell逻辑运算符

下面哪种写法表示：如果 `cmd1` 成功执行，则执行 `cmd2` 命令？

A. `cmd1 cmd2`
B. `cmd1; cmd2`
C. `cmd1 && cmd2`
D. `cmd1 || cmd2`

<details><summary>💡 答案提示</summary>
<p><b>答案：C <code>cmd1 && cmd2</code></b></p>
<table>
<tr><th>写法</th><th>含义</th></tr>
<tr><td><code>cmd1 cmd2</code></td><td>语法错误/cmd2被当成cmd1的参数</td></tr>
<tr><td><code>cmd1; cmd2</code></td><td>无论cmd1成功与否，都执行cmd2（两个独立语句）</td></tr>
<tr><td><code>cmd1 && cmd2</code></td><td>cmd1<b>成功（返回0）</b>才执行cmd2</td></tr>
<tr><td><code>cmd1 || cmd2</code></td><td>cmd1<b>失败（返回非0）</b>才执行cmd2</td></tr>
</table>
</details>

---

### 5.2.3 Linux知识 【选择题】

#### 5.2.3.1 Linux设备类型

下面哪种不是Linux的设备类型？

```c
A: 块设备
B: 字符设备
C: 网络设备
D: 虚拟设备
```

<details><summary>💡 答案提示</summary>
<p><b>答案：D（虚拟设备）</b></p>
<p>Linux三大设备类型：</p>
<ol>
<li><b>块设备(Block Device)</b> —— 按数据块访问，如硬盘、SD卡</li>
<li><b>字符设备(Char Device)</b> —— 按字节流顺序访问，如串口、键盘</li>
<li><b>网络设备(Network Device)</b> —— 网络通信，如网卡eth0</li>
</ol>
<p><b>"虚拟设备"不是Linux标准设备分类。</b>网络设备是Linux三大设备类型之一。</p>
</details>

---

#### 5.2.3.2 Linux目录结构

在Linux系统中，用来存放系统所需要的配置文件和子目录是？

```c
A: /var
B: /root
C: /etc
D: /home
```

<details><summary>💡 答案提示</summary>
<p><b>答案：C <code>/etc</code></b></p>
<table>
<tr><th>目录</th><th>用途</th></tr>
<tr><td><code>/var</code></td><td>可变数据文件（日志、缓存、邮件等）</td></tr>
<tr><td><code>/root</code></td><td><b>root用户的家目录</b>，不是存放系统配置的地方</td></tr>
<tr><td><code>/etc</code></td><td><b>系统配置文件目录</b>（如<code>/etc/passwd</code>、<code>/etc/fstab</code>、<code>/etc/nginx/</code>等）</td></tr>
<tr><td><code>/home</code></td><td>普通用户的家目录</td></tr>
</table>
</details>

---

#### 5.2.3.3 Linux文本处理命令

当需要从文本文件的每一行中截取指定内容的数据时，下面那个命令可以提供帮助？

```c
A: cp
B: dd
C: fmt
D: cut
```

<details><summary>💡 答案提示</summary>
<p><b>答案：D <code>cut</code></b></p>
<table>
<tr><th>命令</th><th>用途</th></tr>
<tr><td><code>cp</code></td><td>复制文件</td></tr>
<tr><td><code>dd</code></td><td>低级数据复制/转换</td></tr>
<tr><td><code>fmt</code></td><td>文本格式化（调整行宽）</td></tr>
<tr><td><code>cut</code></td><td>按列/字段<b>截取</b>每行指定内容，如 <code>cut -d':' -f1 /etc/passwd</code></td></tr>
</table>
</details>

---

## 5.3 逻辑推理题 ⚠️ 非技术题

> **考点**：逻辑推理、矛盾法、假设排除法
> **注意**：面试中偶尔出现，考察**逻辑思维能力**而非技术知识

甲、乙、丙、丁四人各说了一句话，已知四句话中有两句为真，两句为假：

- **甲**：乙和丙说的都是真话。
- **乙**：丁说的是假话。
- **丙**：甲和丁说的都是假话。
- **丁**：乙说的是真话。

请判断谁说的是真话，谁说的是假话，并写出推理过程。

<details><summary>💡 答案提示</summary>
<p><b>关键突破口：乙和丁互相评价</b></p>
<p>乙说"丁假" ↔ 丁说"乙真"，两者互为否命题，必一真一假。</p>
<p><b>假设乙真、丁假：</b></p>
<ul>
<li>乙真 + 丁假 → 已用1真1假 → 甲丙中1真1假</li>
<li>甲说"乙丙都真" → 需丙真才能让甲为真</li>
<li>丙说"甲丁都假" → 丁假 ✓，甲假 → 那甲就是假的</li>
<li>验证：甲假、乙真、丙真、丁假 → 2真2假 ✓</li>
</ul>
<p><b>答案：乙、丙说真话；甲、丁说假话</b></p>
</details>

---

# 附录：高频考点速查表

| 考点 | 频率 | 核心知识 | 题型 |
|------|------|---------|------|
| **指针与数组** | ★★★★★ | 指针运算、数组名退化、指针步长 | 选择/分析 |
| **宏定义陷阱** | ★★★★★ | 文本替换无括号保护、优先级问题 | 选择 |
| **链表操作** | ★★★★★ | 插入、删除、反转、判环、分区 | 编程 |
| **排序算法** | ★★★★☆ | 快排实现、稳定性、时间复杂度 | 编程/选择 |
| **内存对齐** | ★★★★☆ | 结构体大小计算、对齐规则 | 选择 |
| **关键字** | ★★★★☆ | static/const/volatile/extern | 问答 |
| **进程与线程** | ★★★★☆ | 区别、同步互斥、调度 | 问答/选择 |
| **通信协议** | ★★★★☆ | UART/I2C/SPI/CAN 原理与对比 | 问答 |
| **位运算** | ★★★☆☆ | 置位/清零/判断2的幂/移位 | 选择/编程 |
| **字符串操作** | ★★★☆☆ | strcpy/memcpy 实现、反转、去重 | 编程 |
| **栈与队列** | ★★★☆☆ | 两栈实现队列、括号匹配 | 编程 |
| **大小端** | ★★★☆☆ | 判断方法、网络字节序 | 编程 |
| **嵌入式硬件** | ★★★☆☆ | ARM架构、启动流程、中断机制 | 问答 |
| **Linux知识** | ★★★☆☆ | 文件系统、设备分类、Shell命令 | 选择/问答 |
| **单位换算** | ★★☆☆☆ | 存储单位、位与字节转换、颜色深度计算 | 计算 |
| **Shell命令** | ★★☆☆☆ | 特殊变量、逻辑运算符、文本处理 | 选择 |
| **逻辑推理** | ★★☆☆☆ | 矛盾法、假设排除法、真值判断 | 推理 |
| **递归** | ★★☆☆☆ | 斐波那契、求和、递归终止条件 | 编程 |
