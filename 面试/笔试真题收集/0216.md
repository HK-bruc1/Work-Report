# 嵌入式笔试题收集 - 0216（已批改）

---

## 一、C 语言基础

### 1.1 sizeof 求值

```c
char a[] = "hello";
int b[100] = {0};
void *p = malloc(sizeof(int) * 100);

const char *strstr(char str[100])
{
}

sizeof(a)   = ?
sizeof(b)   = ?
sizeof(p)   = ?
sizeof(str) = ?
```

**【我的答案】**

1. sizeof如果给的是数组名的话，就会计算整个数组的大小，所以答案是6
2. 还是数组名同理，答案是100
3. 如果给的是指针的话，就是指针的类型大小，答案是4/8
4. 数组作为函数参数时，会退化为指针。所以这里还是计算指针的类型大小，答案是4/8

**【批改】**

1. **正确。** `"hello"` = 5个字符 + 1个 `'\0'` = 6字节。
2. **错误。** `int b[100]`，一个 `int` 占4字节，`sizeof(b) = 100 * 4 = 400`。你漏乘了元素类型的大小。
3. **正确。** 指针大小取决于平台，32位系统为4，64位系统为8。嵌入式笔试一般答4（32位MCU）。
4. **正确。** 数组做形参退化为指针，答案同上。

**【最优解】**

```
sizeof(a)   = 6       // 字符串字面量含 '\0'，共6字节
sizeof(b)   = 400     // 100 * sizeof(int) = 100 * 4
sizeof(p)   = 4 或 8  // 指针大小，取决于平台位宽
sizeof(str) = 4 或 8  // 数组形参退化为指针
```

> **考点：** sizeof 对数组名求值 vs 对指针求值；字符串字面量隐含 `'\0'`；数组形参退化为指针。
> **注意：** `sizeof(数组名)` = 元素个数 × 单个元素大小，不是元素个数！这是本题最常见的坑。

---

### 1.2 堆和栈的区别

**【我的答案】**

- 从C语言的程序内存布局中来说：
  - 栈一般都是用来存储函数内的临时变量的并且是自动管理的。
  - 堆一般都是工程师使用malloc函数主动申请的内存空间需要手动管理释放。
- 栈是先进后出的，从数据结构方面来说，两者都可以使用数组实现。

**【批改】**

基本方向正确，但**不够全面**，笔试题需要多维度对比。"两者都可以使用数组实现"这句跑题了，题目问的是内存区域的堆栈，不是数据结构。

**【最优解】**

| 对比项 | 栈 (Stack) | 堆 (Heap) |
|--------|-----------|-----------|
| 管理方式 | 编译器自动分配/释放 | 程序员手动 malloc/free |
| 增长方向 | 高地址 → 低地址 | 低地址 → 高地址 |
| 空间大小 | 较小（嵌入式中通常几KB） | 较大，受限于系统可用内存 |
| 分配速度 | 快（仅移动栈指针） | 慢（需要遍历空闲链表） |
| 碎片问题 | 无碎片（连续分配/释放） | 频繁malloc/free会产生内存碎片 |
| 存储内容 | 局部变量、函数参数、返回地址 | 动态申请的内存 |
| 生命周期 | 函数结束自动回收 | 手动free或程序退出才释放 |

> **考点：** 内存布局中堆和栈的本质区别；嵌入式场景下要强调栈空间有限和堆碎片风险。
> **注意：** 别把"数据结构的栈/堆"和"内存区域的栈/堆"混淆，面试官问的是后者。

---

### 1.3 C 语言变量的生命周期和可见性

#### 相同题目: 简述静态变量、全局变量、局部变量的异同

**【我的答案】**

变量类型可以大致分为常量，局部变量，全局变量。

- 常量的生命周期伴随整个程序的运行直到程序结束，是全局可见的。
- 局部变量的生命周期一般就是当声明该局部变量的函数结束时，就会被销毁。函数内可见，函数外不可见。
- 全局变量的生命周期也是伴随整个程序的运行直到程序结束，可见性一般都是全局可见的，如果被static修饰，可见性就会被限制到当前源文件。

**【批改】**

题目明确问的是**静态变量、全局变量、局部变量**三者，你漏答了**静态变量 (static)**，却多答了常量（常量不是变量分类的范畴）。局部变量和全局变量的描述基本正确。

**【最优解】**

| 变量类型 | 存储位置 | 生命周期 | 可见性（作用域） |
|---------|---------|---------|----------------|
| 局部变量 | 栈 | 函数执行期间 | 仅函数/块内 |
| 静态局部变量 (`static` 修饰局部) | .bss/.data段 | 整个程序运行期间 | 仅函数/块内 |
| 全局变量 | .bss/.data段 | 整个程序运行期间 | 所有文件（可extern） |
| 静态全局变量 (`static` 修饰全局) | .bss/.data段 | 整个程序运行期间 | 仅当前文件（内部链接） |

**关键点：** `static` 的两种用法——
1. 修饰局部变量：延长生命周期（不改变作用域）
2. 修饰全局变量/函数：限制作用域到当前文件（不改变生命周期）

> **考点：** `static` 关键字的双重语义；变量的存储区域（栈 vs 静态存储区）。
> **注意：** 静态局部变量只初始化一次，后续调用保留上一次的值，这是笔试常考点。

---

### 1.5 const int \*p 和 int \*const p 的区别

**【我的答案】**

- 前者是指针常量，也就是指针指向的值是常量，不能被程序修改。而指针的指向可以修改，比如换一个指针指向相同地址。
- 后者是常量指针，也就是指针的指向不能被修改。指针指向的值可以被修改比如可以通过这个指针去修改地址中的值。

**【批改】**

**理解正确，但术语反了！** 这是一个非常常见的混淆点：

- `const int *p` → **指向常量的指针**（底层const）— 你错误地叫它"指针常量"
- `int *const p` → **常量指针/指针常量**（顶层const）— 你错误地叫它"常量指针"

中文术语容易混乱，建议直接用"指向的值不可改 / 指向不可改"来描述，避免术语纠纷。

**【最优解】**

```c
const int *p;    // p可以指向别处，但不能通过p修改所指的值  (*p = 10 ✗, p = &x ✓)
int *const p;    // p不能指向别处，但可以通过p修改所指的值  (*p = 10 ✓, p = &x ✗)
const int *const p; // 都不能改
```

**记忆口诀：** `const` 在 `*` 左边 → 值不可改；`const` 在 `*` 右边 → 指针不可改。**看 const 和 \* 的相对位置。**

> **考点：** 顶层const vs 底层const。
> **注意：** 笔试建议不要纠结中文术语"指针常量""常量指针"，直接说"指向的内容不可修改"或"指针本身不可修改"更清晰、不会失分。

---

### 1.6 volatile 的作用

**【我的答案】**

volatile修饰就是告诉编译器不要优化此变量，变量可能随时会被外部因素修改，读取时应该从内存中获取而不是使用缓存。当变量时刻都有可能被改变，不是程序主动掌控的。比如某变量是获取一个只读的状态寄存器。那么该变量就不能被编译器优化，必须从内存中获取以保证数据的实时性和准确性。

**【批改】**

**正确，回答质量不错。** 可以补充更完整的使用场景以拿满分。

**【最优解】**

`volatile` 告诉编译器：**每次访问该变量都必须从内存重新读取，禁止优化掉对该变量的读写操作。**

**必须使用 volatile 的三种典型场景：**

1. **硬件寄存器映射** — 寄存器值由硬件改变，如状态寄存器、数据寄存器
2. **中断服务程序(ISR)中修改的全局变量** — 如本题的 `Sys_Tick`，在定时器中断中自增，主循环中读取
3. **多线程/RTOS 共享变量** — 如本题的 `System_Error`、`System_Status`，可能被不同任务修改

本题中 `Sys_Tick` 在定时器中断中更新，`System_Error/System_Status` 可能在中断或多任务中被修改，所以需要 `volatile`；其他变量仅在主逻辑中使用，不需要。

> **考点：** 编译器优化行为；volatile 的语义和典型应用场景。
> **注意：** `volatile` 不保证原子性！多线程场景中 volatile 不能替代互斥锁。

---

## 二、指针专题

### 2.1 空指针和野指针的区别

**【我的答案】**

- 空指针
  - 就是被赋值为NULL的指针
- 野指针
  - 就是指向了错误地址的指针。比如指针接收了一个malloc分配的地址，空间free掉以后，没有把指针赋值为空的话，那么此时该指针就是野指针。

**【批改】**

**基本正确**，但野指针的产生不仅仅是 free 后未置 NULL，还有其他情况。

**【最优解】**

- **空指针 (NULL Pointer)：** 明确指向地址 0（NULL）的指针，表示"不指向任何有效对象"，是一种安全的初始化状态。
- **野指针 (Dangling Pointer)：** 指向不确定/非法内存区域的指针。

**野指针的三种典型产生方式：**
1. **指针未初始化** — 声明后未赋值，值为随机地址
2. **free/delete 后未置 NULL** — 内存已释放，指针仍保存原地址
3. **指针指向的栈内存已被回收** — 如返回局部变量的地址

> **考点：** 指针安全意识，野指针的危害和防范。

---

### 2.2 访问野指针会发生什么状况，访问空指针会发生什么情况

**【我的答案】**

访问野指针可能导致数据访问是不正确的。访问空指针应该没有啥关系。

**【批改】**

**前半句不够严重，后半句错误！**

- 访问野指针：不仅仅是"数据不正确"，严重得多
- 访问空指针：**绝对不是没关系**，会导致段错误(Segmentation Fault)或硬件异常(HardFault)

**【最优解】**

**访问野指针：** 行为是**未定义的(Undefined Behavior)**——
- 可能读到垃圾数据（看似正常但数据错误，最危险）
- 可能破坏其他变量的数据（写操作踩了别人的内存）
- 可能触发段错误/HardFault 导致程序崩溃
- 嵌入式中可能导致系统跑飞、看门狗复位

**访问空指针：** 行为也是**未定义的**，但通常表现更确定——
- 在 Linux/Windows 等有 MMU 的系统上 → **段错误 (Segmentation Fault)**，因为地址 0 所在页面被标记为不可访问
- 在无 MMU 的嵌入式系统（如 Cortex-M）上 → 可能触发 **HardFault**，也可能访问到地址 0 处的实际内容（中断向量表），导致不可预测的行为

> **考点：** Undefined Behavior 的概念；MMU 保护机制与嵌入式裸机的差异。
> **注意：** 空指针不是"安全的"，只是比野指针更容易被检测和调试。

---

### 2.3 释放之后的指针再次调用会发生什么状况，如何避免

**【我的答案】**

这种情况就是访问野指针了，异常未知。最好是free时，就将指针赋值为NULL。

**【批改】**

**正确。** 可以更规范地表述。

**【最优解】**

**发生什么：** 即 Use-After-Free，属于未定义行为。可能读到垃圾值、破坏堆管理结构、导致程序崩溃，也可能被利用进行安全攻击。如果对同一指针 `free` 两次（Double Free），还会破坏堆的内部数据结构。

**如何避免：**
```c
free(p);
p = NULL;  // 释放后立即置空，后续误访问会触发空指针异常，易于定位
```

> **考点：** Use-After-Free / Double-Free 漏洞；防御性编程习惯。

---

### 2.4 指针运算

```c
int32_t var[7] = {2, 4, 6, 8, 10, 12, 14};

int32_t *var_ptr = (int32_t *)(&var + 1);

*(var_ptr - 1) = *(var + 1);
```

上述代码执行后，`var` 数组的值是什么？

**【我的答案】**

首先&var是取整个数组的地址，(int32_t *)(&var + 1)的结果就是var_ptr指针指向var[7]的元素地址。

var是数组首元素地址，(var + 1)就是往后面移动一个int32_t长度的地址，也就是指向了var[1]元素首地址。然后再取地址*(var + 1)的结果是元素4，*(var_ptr - 1) = *(var + 1);的结果相当于var[6]的值被替换为4，所以最终结果是2，4，6，8，10，12，4

**【批改】**

**完全正确！** 分析过程清晰，结论准确。

- `&var + 1` 跳过整个数组（7 × 4 = 28字节），指向数组末尾之后
- `var_ptr - 1` 回退一个 `int32_t`（4字节），即指向 `var[6]`
- `*(var + 1)` = `var[1]` = 4
- 最终 `var[6]` 从 14 变为 4

**结果：** `{2, 4, 6, 8, 10, 12, 4}`

> **考点：** `&数组名` vs `数组名` 的指针算术步长区别；`&var` 的类型是 `int32_t (*)[7]`，+1 跳过整个数组。
> **注意：** 这类题的核心是搞清楚指针 +1 到底移动多少字节——取决于指针所指类型的大小。

---

### 2.5 指针函数与函数指针分别是什么？给出程序语句示例

**【我的答案】**

这个不会

**【最优解】**

**指针函数：** 返回值为指针的函数。本质是**函数**。

```c
int *func(int a, int b);  // 返回 int* 的函数
```

**函数指针：** 指向函数的指针变量。本质是**指针**。

```c
int (*pfunc)(int, int);    // 指向 "参数为(int,int)、返回int" 的函数的指针
pfunc = add;               // 假设 int add(int a, int b) 已定义
int result = pfunc(1, 2);  // 通过函数指针调用函数
```

**记忆技巧：** 看 `*` 和函数名的结合方式——
- `int *func(...)` → `*` 修饰返回值，func 是函数 → **指针函数**
- `int (*pfunc)(...)` → `*` 和 pfunc 结合在括号里，pfunc 是指针 → **函数指针**

**实际应用：** 函数指针在嵌入式中大量使用，如回调函数注册、状态机跳转表、驱动接口抽象等。

> **考点：** C 声明的解读规则（右左法则）；函数指针在嵌入式中的实际用途。

---

## 三、字符串与内存操作

### 3.1 strcpy 为什么要用 char\* 做返回值

**【我的答案】**

字符串拷贝函数，返回一个指针(地址),可以让外部通过这个地址访问。如果返回其他的值，会是一个临时变量，外部无法接收和访问。

**【批改】**

**方向对但表述不准确。** "返回其他值会是临时变量"这个说法不对，任何函数返回值都是临时值。关键原因没有说到位。

**【最优解】**

`strcpy` 返回目标字符串的首地址（`char *dest`），核心目的是**支持链式调用（链式表达式）**：

```c
// 链式调用示例：
printf("%s", strcpy(dest, src));          // 拷贝后直接打印
strlen(strcpy(dest, src));                // 拷贝后直接求长度
strcpy(dest2, strcpy(dest1, src));        // 连续拷贝
```

如果返回 `void`，上述写法都不可能，必须分成多条语句完成。

> **考点：** C 标准库的 API 设计思想——返回值支持链式调用。
> **注意：** 这是一道考 API 设计理念的题，不是考指针基础。

---

### 3.2 如果 strcpy 的目标长度小于源长度呢

**【我的答案】**

不会

**【最优解】**

**会发生缓冲区溢出 (Buffer Overflow)。**

`strcpy` 不检查目标缓冲区大小，它会一直拷贝直到遇到源字符串的 `'\0'`。如果目标空间不够：

1. 源字符串的多余部分会**覆盖目标缓冲区之后的内存**
2. 可能破坏栈帧中的其他局部变量、返回地址等
3. 导致程序崩溃、数据损坏，甚至被利用进行**栈溢出攻击**

**安全替代方案：**
```c
strncpy(dest, src, sizeof(dest) - 1);   // 限制最大拷贝长度
dest[sizeof(dest) - 1] = '\0';          // strncpy 不保证末尾有 '\0'，需手动补
```

> **考点：** 缓冲区溢出漏洞；安全编码意识；`strcpy` vs `strncpy` 的区别。
> **注意：** `strncpy` 也有坑——当 src 长度 >= n 时不会自动追加 `'\0'`，必须手动补。

---

## 四、C++ 相关

### 4.1 extern "C" 的作用

C 编译过的代码用 C++ 调用时为什么要在前面加 `extern "C"`？

**【我的答案】**

（未作答）

**【最优解】**

**原因：** C 和 C++ 的**函数名修饰规则 (Name Mangling)** 不同。

- C 编译器：函数 `void foo(int x)` 编译后符号名就是 `_foo`
- C++ 编译器：为了支持函数重载，会将参数类型编码进符号名，如 `_Z3fooi`

如果不加 `extern "C"`，C++ 编译器会按 C++ 的规则去查找符号名，链接时找不到 C 编译出来的符号，**报 undefined reference 错误**。

```c
#ifdef __cplusplus
extern "C" {
#endif

void foo(int x);   // 告诉C++编译器：按C的方式处理这个函数名

#ifdef __cplusplus
}
#endif
```

> **考点：** Name Mangling 机制；C/C++ 混合编程；`extern "C"` 的本质。
> **注意：** 在嵌入式开发中，大量底层驱动和库用 C 编写，在 C++ 项目中调用时必须用 `extern "C"` 包裹头文件。

---

### 4.2 C++ 中引用和指针的区别

**【我的答案】**

类引用类中的成员与使用结构体指针访问结构体成员没有区别吧？

**【批改】**

**完全跑题了。** 题目问的是 C++ "引用 (reference)" 和 "指针 (pointer)" 这两个语言特性的区别，不是类成员的访问方式。

**【最优解】**

| 对比项 | 引用 (`int &r = a`) | 指针 (`int *p = &a`) |
|--------|---------------------|----------------------|
| 本质 | 变量的别名，不占独立内存 | 存储地址的变量，占内存 |
| 初始化 | 声明时**必须**初始化 | 可以先声明后赋值 |
| 可否为空 | 不可以（无 NULL 引用） | 可以为 NULL |
| 可否改变指向 | 不可以（绑定后终身不变） | 可以随时指向其他对象 |
| 多级 | 没有"引用的引用" | 有二级指针 `int **pp` |
| 使用语法 | 直接用变量名，如 `r = 10` | 需要解引用，如 `*p = 10` |
| sizeof | 等于所引用对象的大小 | 等于指针本身大小（4/8） |

```cpp
int a = 10;
int &r = a;    // r 是 a 的别名，操作 r 就是操作 a
int *p = &a;   // p 存储 a 的地址，通过 *p 操作 a
```

> **考点：** 引用的本质；引用 vs 指针的语义差异。
> **注意：** 底层实现上引用通常就是用指针实现的，但语义层面有严格区别。

---

### 4.3 class 与 struct 的区别，malloc 和 new 的区别

**【我的答案】**

不会

**【最优解】**

**class 与 struct 的区别（C++ 中）：**

| 对比项 | struct | class |
|--------|--------|-------|
| 默认访问权限 | public | private |
| 默认继承方式 | public 继承 | private 继承 |
| 其他 | 完全相同，都可以有成员函数、构造函数、继承等 | |

> 在 C++ 中两者几乎等价，区别仅在默认访问权限。

**malloc 与 new 的区别：**

| 对比项 | malloc | new |
|--------|--------|-----|
| 本质 | C 库函数 | C++ 运算符 |
| 类型安全 | 返回 `void*`，需强制转换 | 返回对应类型指针，无需转换 |
| 构造函数 | 不调用 | 自动调用构造函数 |
| 释放 | `free()` | `delete`（调用析构函数） |
| 失败处理 | 返回 NULL | 抛出 `std::bad_alloc` 异常 |
| 大小计算 | 需手动 `sizeof` | 自动计算 |

> **考点：** C/C++ 内存管理的异同；构造/析构函数的调用时机。

---

## 五、嵌入式系统与 RTOS

### 5.1 heap 和 stack 的大小分配

嵌入式系统开发时，如何合理的分配 heap 和 stack 的大小？这两者的作用分别是什么？

**【我的答案】**

（未作答）

**【最优解】**

**作用：**
- **Stack（栈）：** 存放局部变量、函数参数、返回地址、中断现场（上下文保存）
- **Heap（堆）：** 动态内存分配（malloc/free），RTOS 中任务创建、队列创建等也可能从堆分配

**如何合理分配：**
1. **Stack：** 分析最深函数调用链的局部变量总量 + 中断嵌套层数 × 每层上下文保存开销 + 安全余量（通常多留 20%~30%）。可借助编译器的 stack usage 分析功能（如 Keil 的 Call Graph）或在栈底部填充特征值运行时检测水位。
2. **Heap：** 统计所有 malloc 的峰值总量。嵌入式中**建议尽量避免使用动态内存分配**，改用静态分配或内存池，以避免碎片和不确定性。
3. 在链接脚本（.ld）或启动文件（startup_xxx.s）中配置 `Stack_Size` 和 `Heap_Size`。

> **考点：** 嵌入式内存管理意识；栈溢出的风险和检测方法。
> **注意：** RTOS 中每个任务有独立的栈，分配时要考虑每个任务的需求，不仅仅是主栈。

---

### 5.2 回调函数

请简述回调函数以及使用场合。

**【我的答案】**

我使用的比较多的场景就是利用软件定时器实现的定时回调，超时回调。以及注册到OS的特定事件触发的回调。

**【批改】**

只说了使用场景，**没有解释什么是回调函数**，概念定义缺失会扣分。

**【最优解】**

**什么是回调函数：** 通过**函数指针**将一个函数作为参数传递给另一个函数，在特定条件满足时由被调用方"回过头来调用"传入的函数。核心是**控制反转**——调用时机由框架/底层决定，而非调用者。

```c
// 注册回调
void Timer_RegisterCallback(void (*callback)(void));

// 使用
void onTimeout(void) { /* 处理超时 */ }
Timer_RegisterCallback(onTimeout);  // 定时器到期时自动调用 onTimeout
```

**典型使用场景：**
1. **中断回调** — HAL 库中的中断处理（如 `HAL_UART_RxCpltCallback`）
2. **定时器回调** — 软件定时器到期回调、超时回调
3. **事件驱动** — 按键事件、通信数据接收完成、状态变化通知
4. **驱动抽象** — 上层注册处理函数，底层在合适时机调用

> **考点：** 函数指针的实际应用；控制反转思想；解耦设计。

---

### 5.3 中断的上下半部与硬中断、软中断

**【我的答案】**

比如在 FreeRTOS 中使用硬件定时器去实现定时任务时，触发中断回调的处理为硬中断，任务中使用了阻塞 API 因此被唤醒而继续往下处理为软中断？

**【批改】**

**理解有偏差。** 上下半部和硬/软中断是 Linux 内核的概念体系，不能简单等同于 FreeRTOS 的中断回调和任务唤醒。

**【最优解】**

**上半部 (Top Half) / 硬中断：**
- 硬件中断触发后立即执行的部分
- 要求**快进快出**，只做最紧急的事（如读寄存器清标志、拷贝数据到缓冲区）
- 执行期间会屏蔽同级/低级中断

**下半部 (Bottom Half) / 软中断：**
- 上半部中不紧急的、耗时的处理延后执行
- Linux 中实现机制包括：softirq、tasklet、workqueue
- 可以被中断打断，延迟不影响系统实时性

**FreeRTOS 中的类比（非严格对应）：**
- ISR 中做最少的事 → 类似上半部
- 通过信号量/队列/任务通知唤醒高优先级任务来处理 → 类似下半部（但不叫软中断）

> **考点：** Linux 中断处理架构；为什么要拆分上下半部（减少中断关闭时间）。
> **注意：** FreeRTOS 没有严格的上下半部概念，但"ISR中尽量少做事，通过通知机制交给任务处理"是相同思想。

---

### 5.4 中断的响应执行流程

**【我的答案】**

（未作答）

**【最优解（以 ARM Cortex-M 为例）】**

1. **中断请求** — 外设/事件触发中断信号，NVIC 接收并判断优先级
2. **优先级仲裁** — 若新中断优先级高于当前执行的，则抢占；否则挂起等待
3. **硬件自动压栈** — CPU 自动将 xPSR、PC、LR、R12、R3-R0 共 8 个寄存器压入当前栈（Cortex-M 硬件完成）
4. **取向量跳转** — 从向量表中取出对应 ISR 地址，跳转执行
5. **执行 ISR** — 运行中断服务程序
6. **硬件自动出栈** — ISR 返回时（BX LR），硬件自动恢复之前保存的寄存器
7. **恢复执行** — 继续执行被打断的程序

> **考点：** Cortex-M 的中断响应机制（硬件自动压栈是一大特点）；NVIC 优先级管理。
> **注意：** Cortex-M 支持**尾链 (Tail-Chaining)** 优化——连续中断之间不需要反复压栈出栈。

---

### 5.5 自旋锁和信号量

自旋锁和信号量在互斥使用时需要注意哪些？在中断服务程序里面的互斥是使用自旋锁还是信号量？

**【我的答案】**

（未作答）

**【最优解】**

| 对比项 | 自旋锁 (Spinlock) | 信号量 (Semaphore) |
|--------|-------------------|-------------------|
| 等待方式 | 忙等（CPU 空转轮询） | 阻塞等待（让出 CPU） |
| 适用场景 | 临界区非常短、多核环境 | 临界区较长、允许睡眠的上下文 |
| 能否在 ISR 中使用 | **可以**（不会睡眠） | **不可以**（会导致睡眠，ISR 中禁止睡眠） |
| 持有时能否睡眠 | 不能 | 能 |

**注意事项：**
- 自旋锁持有期间**不能睡眠/阻塞**，否则其他核会永远空转
- 自旋锁在**单核系统**中通常退化为关中断（否则自旋无意义）
- 信号量可能导致**优先级反转**，需使用优先级继承协议

**ISR 中互斥 → 使用自旋锁**（配合关中断）。因为 ISR 不能睡眠，不能使用会导致阻塞的信号量。

> **考点：** 同步机制的选择依据；ISR 的约束条件。

---

## 六、寄存器与外设

### 6.1 STM32 定时器寄存器映射

```c
#define D2_APB2PERIPH_BASE          ((uint32_t)0x40000000)
#define TIM1_BASE                   (D2_APB2PERIPH_BASE + 0x0000)

typedef struct
{
  __IO uint16_t CR1;
  uint16_t      RESERVED0;
  __IO uint32_t CR2;
  __IO uint32_t SMCR;
  __IO uint32_t DIER;
  __IO uint32_t SR;
  __IO uint32_t EGR;
  __IO uint32_t CCMR1;
  __IO uint32_t CCMR2;
  __IO uint32_t CCER;
  __IO uint32_t CNT;
  __IO uint16_t PSC;
  uint16_t      RESERVED9;
  __IO uint32_t ARR;
  __IO uint16_t RCR;
  uint16_t      RESERVED10;
  __IO uint32_t CCR1;
  __IO uint32_t CCR2;
  __IO uint32_t CCR3;
  __IO uint32_t CCR4;
  __IO uint32_t BDTR;
  __IO uint16_t DCR;
  uint16_t      RESERVED12;
  __IO uint16_t DMAR;
  uint16_t      RESERVED13;
  uint16_t      RESERVED14;
  __IO uint32_t CCMR3;
  __IO uint32_t CCR5;
  __IO uint32_t CCR6;
  __IO uint32_t AF1;
  __IO uint32_t AF2;
  __IO uint32_t TISEL;
} TIM_TypeDef;

#define TIM1 ((TIM_TypeDef *) TIM1_BASE)

// 程序段 B
TIM1->BDTR |= (1 << 11);
*(int *)(TIM1_BASE + 0x20) = 0xF0010;
```

- 程序段 A 一般位于什么文件或模块中？
- 程序段 B 中两条语句的执行效果分别是什么？

**【我的答案】**

（未作答）

**【最优解】**

**程序段 A（宏定义 + 结构体定义）位于：**
芯片厂商提供的**设备头文件**中，如 `stm32h7xx.h` 或 `stm32f4xx.h`。属于 CMSIS 设备层。

**程序段 B 分析：**

**第一条：** `TIM1->BDTR |= (1 << 11);`

计算 BDTR 的偏移量（从结构体起始逐一累加成员大小）：
- CR1(2) + RESERVED0(2) = 4
- CR2(4) = 8, SMCR(4) = 12, DIER(4) = 16, SR(4) = 20, EGR(4) = 24
- CCMR1(4) = 28, CCMR2(4) = 32, CCER(4) = 36, CNT(4) = 40
- PSC(2) + RESERVED9(2) = 44, ARR(4) = 48
- RCR(2) + RESERVED10(2) = 52
- CCR1(4) = 56, CCR2(4) = 60, CCR3(4) = 64, CCR4(4) = 68
- **BDTR 偏移 = 0x44 (68)**

效果：将 TIM1 的 BDTR 寄存器的 **bit11 置1**（即设置 MOE 位 — Main Output Enable，使能定时器主输出）。这是使用高级定时器 PWM 输出前的必要操作。

**第二条：** `*(int *)(TIM1_BASE + 0x20) = 0xF0010;`

`0x40000000 + 0x20 = 0x40000020`，偏移 0x20 = 32，对应结构体中偏移32处的成员：
- 偏移 28 = CCMR1(4字节)，偏移 32 = **CCMR2**

效果：直接将 TIM1 的 **CCMR2 寄存器**写入值 `0xF0010`，用于配置捕获/比较模式（通道3和通道4的模式设置）。

> **考点：** 寄存器映射的实现原理（基地址 + 结构体偏移）；位操作；结构体内存布局计算。
> **注意：** `|=` 是读-改-写操作（保留其他位），直接 `=` 是全量覆盖写入。两种操作在寄存器编程中含义完全不同。

---

### 6.2 Nand Flash 的基本原理

**【我的答案】**

（未作答）

**【最优解】**

- **存储单元：** 基于浮栅晶体管，通过隧道效应注入/释放电子改变阈值电压来存储数据
- **组织结构：** Device → Die → Plane → Block → Page → Cell
- **操作粒度：** 读/写以 **Page**（通常 2KB/4KB）为最小单位；擦除以 **Block**（通常 64/128 Pages）为最小单位
- **特性：** 写前必须擦除（擦除后全为 1）；有擦写寿命限制（SLC ~10万次, MLC ~1万次, TLC ~3千次）
- **接口：** 通过命令/地址/数据复用 I/O 总线访问，需要 FTL（Flash Translation Layer）管理坏块和磨损均衡

---

### 6.3 如何从初始化 Nand Flash 到使用

**【我的答案】**

（未作答）

**【最优解】**

1. **硬件初始化** — 配置 GPIO、FSMC/FMC 控制器时序参数（tWP, tRP, tCLS等）
2. **复位** — 发送 Reset 命令 (0xFF)
3. **读取 ID** — 发送 Read ID 命令 (0x90)，确认器件型号和容量
4. **坏块扫描** — 扫描每个 Block 的 Spare Area，建立坏块表 (BBT)
5. **建立映射** — 初始化 FTL，建立逻辑地址到物理地址的映射表
6. **正常使用** — 通过 FTL 进行读(0x00)/写(0x80)/擦除(0x60) 操作，FTL 自动处理坏块管理和磨损均衡

---

### 6.4 通过 UART 发送 float 数据

如果下位机有一个 float 数，如何通过 UART 发送给上位机？请给出至少两种实现方式。

**【我的答案】**

（未作答）

**【最优解】**

**方式一：二进制直传（推荐嵌入式场景）**

```c
float value = 3.14f;
// float 占 4 字节，直接按字节发送
uint8_t *p = (uint8_t *)&value;
UART_Send(p, 4);  // 发送 4 个字节

// 上位机接收后按相同字节序还原为 float
```
优点：高效、无精度损失。缺点：需约定字节序（大小端）。

**方式二：转字符串发送**

```c
float value = 3.14f;
char buf[32];
sprintf(buf, "%.4f", value);   // 转为字符串 "3.1400"
UART_SendString(buf);          // 发送 ASCII 字符串
```
优点：可读性好，调试方便，无字节序问题。缺点：占用带宽大、有精度损失、sprintf 开销大。

**方式三：联合体 (union) 拆分**

```c
union { float f; uint8_t bytes[4]; } data;
data.f = 3.14f;
UART_Send(data.bytes, 4);
```
本质同方式一，但用 union 替代指针强转，代码更清晰。

> **考点：** 数据的内存表示与传输；大小端问题；嵌入式通信协议设计。
> **注意：** 二进制传输时上下位机必须约定**字节序**和**协议帧格式**（帧头 + 数据 + 校验），否则容易解析错误。

---

## 七、数据结构与内存布局

### 7.1 union 与 struct 综合题

```c
typedef struct
{
    union
    {
        int D_int[16384];
        u8  D_char[16384<<2];
    } Data;

    unsigned short  Index;
    unsigned char   Sample_CTRL;
    unsigned short  Data_Interleaved;
    unsigned short  Sample_Interval;
    unsigned short  Sample_Counter;
    int             Trig_OverSpeed;
    int             Trig_OverIPhase;
    int             Trig_OverIq;

} SampledData_Buffer_Str;

SampledData_Buffer_Str SampledData_Handle;

// 程序段 B：
SampledData_Handle.Data.D_int[0] = 0x1234;
```

- 请具体描述程序段 A 的作用。

程序段 B 执行后，下列变量的值是多少？是否可以确定？

**【我的答案】**

（未作答）

**【最优解】**

**程序段 A 的作用：**

定义了一个采样数据缓冲区结构体 `SampledData_Buffer_Str`：
- `union Data`：共用体，`D_int[16384]` 和 `D_char[16384<<2]`（即 `D_char[65536]`）共享同一块 64KB 内存。可以按 `int`（4字节）或 `u8`（1字节）两种粒度访问同一块数据缓冲区。
- 后续成员为采样控制参数：索引、采样控制、数据交织、采样间隔、采样计数器、过速/过流/过Iq 触发阈值。
- 最后声明了一个全局实例 `SampledData_Handle`。

**程序段 B 执行后的值（假设小端序，ARM 均为小端）：**

`D_int[0] = 0x1234`，即 `0x00001234`。在小端系统中，低字节存放在低地址：

```
地址偏移:  [0]    [1]    [2]    [3]
存储内容:  0x34   0x12   0x00   0x00
```

因为 `union` 中 `D_int` 和 `D_char` 共享同一块内存：

```
SampledData_Handle.Data.D_char[0] = 0x34  ✓ 可以确定
SampledData_Handle.Data.D_char[1] = 0x12  ✓ 可以确定
SampledData_Handle.Data.D_char[2] = 0x00  ✓ 可以确定
SampledData_Handle.Data.D_char[3] = 0x00  ✓ 可以确定
SampledData_Handle.Data.D_char[4] = ?     ✗ 不确定（未被赋值，取决于初始化情况）
```

> **考点：** union 的内存共享本质；大小端字节序；结构体内存布局。
> **注意：** ARM Cortex-M 默认小端序。如果题目未指明平台，应答"取决于字节序"并分别给出大/小端的结果。D_char[4] 如果是全局变量则初始化为 0，如果是局部变量则不确定。

---

## 八、操作系统

### 8.1 进程间通信方式

**【我的答案】**

（未作答）

**【最优解】**

Linux 常见的 IPC（进程间通信）方式共 7 种：

| 方式 | 特点 | 典型场景 |
|------|------|---------|
| **管道 (Pipe)** | 半双工，父子进程间，内核缓冲区 | `cmd1 \| cmd2` |
| **命名管道 (FIFO)** | 半双工，无亲缘关系进程间 | 进程间单向数据流 |
| **信号 (Signal)** | 异步通知，开销小 | `kill`, `SIGINT`, 异常处理 |
| **消息队列 (Message Queue)** | 按消息类型收发，内核管理 | 结构化数据传递 |
| **共享内存 (Shared Memory)** | 最快的 IPC，无需拷贝 | 大数据量共享（需配合同步机制） |
| **信号量 (Semaphore)** | 用于同步/互斥，不传数据 | 共享资源的访问控制 |
| **Socket** | 可跨网络，全双工 | 网络通信、本地进程间通信 |

> **考点：** 常规八股，必须能列出至少 5 种并说明各自特点。
> **注意：** 面试可能追问"共享内存为什么最快"——因为数据不需要在用户态和内核态之间拷贝。

---

## 九、算法与智力题

### 9.1 金币称量问题

13 枚金币，有一枚重量不同，轻重不知，用一个天平用最少的次数称出来。

**【我的答案】**

（未作答）

**【最优解】**

**答案：最少 3 次。**

**思路：三分法 + 逐步缩小范围。**

**第一次称量：** 将 13 枚分成三组：4-4-5
- 取任意 4 枚放左盘，4 枚放右盘，剩余 5 枚不上秤
- **平衡** → 异常币在剩余 5 枚中
- **不平衡** → 异常币在天平上的 8 枚中（并记录轻重关系）

**第二次称量：** 根据第一次结果缩小到 4~5 枚中继续三分
- 利用已知的"某组偏重/偏轻"的信息，结合已知正常的金币做参照
- 可将嫌疑范围缩小到 2~3 枚，并进一步确定异常币是偏重还是偏轻

**第三次称量：** 在剩余 2~3 枚嫌疑币中，用已知正常币做参照，一次确定异常币

**数学原理：** 天平每次称量有三种结果（左倾/平衡/右倾），n 次称量最多区分 3^n 种状态。13 枚金币 × 2 种可能（偏重或偏轻）= 26 种状态，3^3 = 27 ≥ 26，所以理论下限是 3 次。

> **考点：** 信息论思维；三分法策略。
> **注意：** 如果题目说"已知偏重"（或偏轻），那 3 次可以处理 27 枚。正因为"轻重不知"，状态数翻倍，所以 3 次只能处理 13 枚。

---

## 总评

| 题目 | 评价 | 得分情况 |
|------|------|---------|
| 1.1 sizeof | **第2题错误**（漏乘sizeof(int)），其余正确 | 75% |
| 1.2 堆栈区别 | 基本正确但不全面，混淆了数据结构和内存区域 | 60% |
| 1.3 变量生命周期 | **漏答 static 变量**，多答了常量 | 50% |
| 1.5 const指针 | 理解正确但**术语用反** | 70% |
| 1.6 volatile | **回答较好** | 85% |
| 2.1 空/野指针 | 基本正确，可补充更多产生方式 | 75% |
| 2.2 访问空/野指针 | **空指针部分错误**（"没啥关系"是错的） | 40% |
| 2.3 释放后指针 | 正确 | 80% |
| 2.4 指针运算 | **完全正确，分析清晰** | 100% |
| 2.5 指针函数/函数指针 | 未作答 | 0% |
| 3.1 strcpy返回值 | 方向对但没说到"链式调用" | 50% |
| 3.2 strcpy溢出 | 未作答 | 0% |
| 4.1~4.3 C++题 | 基本未作答或跑题 | 10% |
| 5.1~5.5 RTOS题 | 回调函数有部分回答，其余不完整 | 25% |
| 6.x 寄存器/外设 | 未作答 | 0% |
| 7.1 union/struct | 未作答 | 0% |
| 8.1 进程间通信 | 未作答 | 0% |
| 9.1 智力题 | 未作答 | 0% |

### 主要问题总结

1. **C 基础有一定底子**，但细节不够扎实（sizeof 漏乘类型大小、const 术语反了、空指针认知错误）
2. **C++ 部分是明显短板**，extern "C"、引用、class/struct/new/malloc 需要系统补习
3. **RTOS 和操作系统概念偏弱**，中断机制、同步原语、进程间通信需要重点加强
4. **寄存器操作和硬件相关题完全空白**，这在嵌入式岗位面试中是核心考点，必须补上
5. **回答习惯：** 未作答的题太多，笔试中即使不确定也应尽量写出已知的部分，不留空白
