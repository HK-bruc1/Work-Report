# C语言的编译过程

```c
源文件(.c) + 头文件(.h)
    ↓
【1. 预处理】 (Preprocessing) 主要是宏替换和头文件插入
    ↓
预处理后的文件(.i)
    ↓
【2. 编译】 (Compilation) 主要是语法以及语义检查
    ↓
汇编代码(.s)   这里已经是汇编语言代码了 已经与具体 CPU 指令集（如 ARM / RISC-V / x86）绑定
    ↓
【3. 汇编】 (Assembly)   
    ↓
目标文件(.o)    机器码（目标文件） 这里将汇编语言转成了机器码
    ↓
【4. 链接】 (Linking)
    ↓
可执行文件(ELF/bin)
```

## 既然已经是机器码，为什么还要“链接”？

**目标文件 `.o` 不是一个“完整的程序”**
 **它是“未解决引用 + 未确定地址”的机器码碎片**

### 目标文件中的地址是“未确定的”

```c
// main.c
extern void foo(void);

int main(void) {
    foo();
}
编译并汇编后：
main.o    
```

每个目标文件：

- **只知道自己定义了什么**
- **不知道别人定义了什么**
- 通过“符号名”进行逻辑引用

```c
main.o  →  foo
foo.o   →  foo 的实现
```

但：

- `main.o` **并不知道 `foo.o` 是否存在**
- 也不知道 `foo.o` 最终会被放到内存的哪个地址

### 链接器主要做：

#### 符号解析（Symbol Resolution）

- 找到：
  - `main.o` 中引用的 `foo`
  - 对应哪一个 `.o` 或 `.a` 提供了 `foo`
- 如果找不到 → **链接错误**
- 如果找到多个 → **重复定义错误**

### 链接后生成的文件

```c
.c
 ↓
.o
 ↓  ← 链接器在这里工作
.elf   ← 真正的“链接结果”
 ↓  ← 工具转换（objcopy）
.bin / .hex / ufw

```

## 怎么变成固件的

**嵌入式烧录用的所有固件文件，本质上都来源于链接生成的 `.elf`**
 **`.hex / .bin / .ufw / .fw` 都是由 `.elf` 经工具转换、封装后的结果**

几乎所有厂商的 `.fw / .ufw / .img / .pack`
 都是：`.elf` →（提取段）→（加头）→（加校验 / 加密 / 签名）→ 私有格式.

# 静态库和动态库的区别

**静态库（Static Library）**

- 在**编译链接时**，库代码被**完整复制**到可执行文件中
- 生成的可执行文件**包含**所有需要的代码
- 运行时**不依赖**库文件

**动态库（Dynamic Library）**

- 在**编译链接时**，只记录库的**引用信息**
- 生成的可执行文件**不包含**库代码
- 运行时**需要加载**库文件

## .a文件中都有什么？

静态库（`.a`文件）本质上是**一堆目标文件（.o）的打包集合**，类似一个"归档文件"。

```c
libmath.a = {
    add.o      (编译后的机器码)
    subtract.o (编译后的机器码)
    multiply.o (编译后的机器码)
}
```

### 静态库里包含什么？

**1.编译后的机器码**

- **不是**源代码（`.c`文件）
- **不是**中间代码
- **是**已经编译好的**机器指令**（二进制）

**2. 符号表**

- 函数名、变量名等符号信息
- 用于链接时查找和匹配

**3. 重定位信息**

- 地址还未最终确定
- 链接时会被"填充"到正确的地址

### 使用静态库

```c
sdk/
├── include/
│   └── sdk_api.h      ← 专门声明库函数的头文件
└── lib/
    └── libsdk.a       ← 对应的静态库实现
```

在makefile中添加静态库的路径与对应头文件的路径。

# C语言中定义与声明的区别是什么？

**核心区别：**

- **声明（Declaration）**：告诉编译器"有这个东西存在"，不分配内存
- **定义（Definition）**：不仅声明，还要"创建这个东西"，会分配内存

**关键原则：**

- 声明可以**多次**
- 定义只能**一次**（同一作用域内）

## 结构体的声明与定义

它的声明和定义都可以放在头文件或源文件中，这和变量、函数不太一样。

**结构体的特殊性：**

结构体的**定义**（包含成员的完整定义）实际上**不分配内存**，它只是定义了一个**类型模板**。真正分配内存的是**创建结构体变量**的时候。

**结构体定义**（完整类型）：既可以在头文件，也可以在源文件 ✅

**结构体声明**（不完整类型）：既可以在头文件，也可以在源文件 ✅

**创建结构体变量**：

- **定义变量**：通常在源文件 ✅
- **声明变量**：可以在头文件（用`extern`）⚠️

# JL芯片是什么架构？



## 指令集就是CPU架构吗？

当我们说"芯片架构"或"CPU架构"时，通常确实是指处理器基于什么**指令集架构**（ISA，Instruction Set Architecture）。

常见的指令集架构包括：

- **x86/x86-64**：Intel和AMD的桌面和服务器处理器使用，如Intel Core系列、AMD Ryzen系列
- **ARM**：广泛用于移动设备、嵌入式系统，近年也进入桌面和服务器领域，如Apple M系列芯片、高通骁龙
- **RISC-V**：开源指令集，日益受到关注
- **MIPS**、**PowerPC**等：在特定领域使用

处理器架构确实是一切的起点，不同架构需要不同的编译器后端来生成相应的机器码。

**核心要点：**

1. **同一份C语言源代码** → 在不同架构上编译 → **生成完全不同的机器码**
2. **原因就是指令集不同**：
   - x86架构的处理器只能理解x86指令
   - ARM架构的处理器只能理解ARM指令
   - RISC-V架构的处理器只能理解RISC-V指令
3. **机器码是处理器直接执行的二进制指令**，必须符合该处理器的指令集规范

## GCC跨平台的本质

```c
C语言源代码
    ↓
【前端】统一解析C语言语法 ← 这部分所有平台相同
    ↓
【中间层】优化，生成中间表示(IR)
    ↓
【后端】根据目标架构选择不同的代码生成器 ← 关键在这里
    ↓
├─ x86后端 → 生成x86指令集的机器码
├─ ARM后端 → 生成ARM指令集的机器码
├─ RISC-V后端 → 生成RISC-V指令集的机器码
└─ MIPS后端 → 生成MIPS指令集的机器码
```

**所以GCC的"跨平台"本质是：**

- **前端**：只需要写一次（理解C语言）
- **后端**：针对每种架构都要单独实现（生成该架构的机器码）

## 移植操作系统

现在的操作系统一般都采用分层设计，架构相关层的代码使用不同的架构指令集实现，其他架构无关代码都是使用同一的抽象接口对外提供。以通用操作系统为例，内核大致分为三部分，架构无关层，硬件抽象层，架构相关层。

1. 架构相关层针对不同指令集分别实现
2. 使用统一的抽象接口向上提供。

```c
┌─────────────────────────────────────┐
│      应用程序 (用户空间)              │ ← 统一接口，架构无关
├─────────────────────────────────────┤
│  系统调用接口 (POSIX/Win32 API)      │ ← 统一接口
├─────────────────────────────────────┤
│                                     │
│         操作系统内核                 │
│  ┌─────────────────────────────┐   │
│  │ 架构无关层                   │   │ ← 进程调度、文件系统、
│  │ (通用内核代码)               │   │   网络协议栈等
│  └─────────────────────────────┘   │
│  ┌─────────────────────────────┐   │
│  │ 硬件抽象层 (HAL)             │   │ ← 统一抽象接口
│  └─────────────────────────────┘   │
│  ┌─────────────────────────────┐   │
│  │ 架构相关层                   │   │ ← 针对不同指令集的实现
│  │ arch/x86/ | arch/arm/ 等    │   │
│  └─────────────────────────────┘   │
└─────────────────────────────────────┘
         ↓
      硬件 (CPU)
```



## JL芯片的flash布局

### JL709N的编译日志

```bash
+POST-BUILD
********************************************************************************
cpu\br52\tools\download.bat
2026/01/30 周五
********************************************************************************
use dict text.bin 
compress data_code_z.bin (7292) ----> (5745) diff -1547 ratio=78.8% run_addr 0
compress init.bin (11400) ----> (8441) diff -2959 ratio=74.0% run_addr 0
compress aec.bin (32664) ----> (30983) diff -1681 ratio=94.9% run_addr 0

sdk.elf:        file format ELF32-pi32v2

Sections:
Idx Name          Size      Address          Type
  0               00000000 0000000000000000
  1 .boot_info    00000080 0000000000100580 DATA
  2 .irq_stack    00001800 0000000000100600 DATA
  3 .mmu_tlb      00000780 0000000000102000 DATA
  4 .data_code    0000164c 0000000000102780 TEXT DATA
  5 .data_code_z  00001c7c 0000000000103de0 TEXT DATA
  6 .overlay_init 00002c88 0000000000105a5c TEXT DATA
  7 .overlay_aec  00007f98 0000000000105a5c TEXT DATA
  8 .overlay_aac  00000000 0000000000105a5c DATA 
  9 .data         0000072c 000000000010da00 DATA
 10 .bss          00001e4c 000000000010e140 BSS
 11 .text         0008f428 0000000004000100 TEXT DATA
 12 .dlog_data    00000100 0000000020000000 DATA
 13 .debug_str    000821a3 0000000000000000
 14 .debug_loc    00052586 0000000000000000
 15 .debug_abbrev 00001629 0000000000000000
 16 .debug_info   001e79a3 0000000000000000
 17 .debug_ranges 0000b6b8 0000000000000000
 18 .debug_macinfo 00000001 0000000000000000
 19 .debug_pubnames 0004241f 0000000000000000
 20 .debug_pubtypes 00027b9f 0000000000000000
 21 .debug_frame  00016780 0000000000000000
 22 .debug_line   000ac651 0000000000000000
 23 .debug_aranges 00000048 0000000000000000
 24 .shstrtab     0000012b 0000000000000000
 25 .symtab       0014fd20 0000000000000000
 26 .strtab       0001d3d3 0000000000000000
text.bin
data.bin
data_code.bin
compress.bin
已复制         1 个文件。
找不到 D:\work_project\JL\AC709N\SDK\cpu\br52\tools\download\earphone\ALIGN_DIR\anc_ext.bin
********************************************************************************
earphone\download.bat DB47 41C3 JL7096D6 "e9c1458a54501103cbd832b0d71607871aa92d1b"
2026/01/30 周五
********************************************************************************
已复制         1 个文件。
已复制         1 个文件。
已复制         1 个文件。
已复制         1 个文件。
----chipkey=41C3----
已复制         1 个文件。

D:\work_project\JL\AC709N\SDK\cpu\br52\tools\download\earphone>..\..\isd_download.exe ..\..\isd_config.ini -tonorflash -dev br52 -boot 0x102600 -div8 -wait 300 -uboot ..\..\uboot.boot -app ..\..\app.bin  -tone tone_en.cfg -res ALIGN_DIR cfg_tool.bin ..\..\p11_code.bin stream.bin    -output-ufw update.ufw -key 141-AMW-AC690X-41C3.key
INI PATH: D:\work_project\JL\AC709N\SDK\cpu\br52\tools\isd_config.ini

SPI nor flash online.
Online flash id: 856015
Online flash size: 2M
Erase Flash Size is 4096
ota.bin: D:/work_project/JL/AC709N/SDK/cpu/br52/tools/download/earphone/ota.bin
--------------------------- OTA UPDATE INFO ---------------------------
| VM大小 = 0x56000
|        PASS:    测试盒串口升级（大小=0x6920）需要最小空间为 0x0
|        PASS:  测试盒经典蓝牙升级（大小=0x9573）需要最小空间为 0xa000
|        PASS:      SD卡升级（大小=0x1736）需要最小空间为 0x2000
|        PASS:      USB升级（大小=0x1d98）需要最小空间为 0x2000
|        PASS:   测试盒BLE升级（大小=0xdfb7）需要最小空间为 0xf000
| 提示：ota.bin中有未知的升级文件uart_ota2.bin（大小=0xc5d），忽略
| 提示：ota.bin中有未知的升级文件ut2_sec_ota.bin（大小=0x67a0），忽略
| 提示：ota.bin中有未知的升级文件diff_ota.bin（大小=0x7929），忽略
| 提示：ota.bin中有未知的升级文件com_ota.bin（大小=0x66fc），忽略
| 提示：ota.bin中有未知的升级文件sd_sec_ota.bin（大小=0x7340），忽略
| 提示：ota.bin中有未知的升级文件usb_sec_ota.bin（大小=0x7da0），忽略
| 此VM空间支持升级方式有：
| * 测试盒串口升级
| * 测试盒经典蓝牙升级
| * SD卡升级
| * USB升级
| * 测试盒BLE升级
-----------------------------------------------------------------------
-----------------------------------FLASH INFO------------------------------------
|  PID : JL709N                                                                 |
|  VID : 0.01                                                                   |
|  FLASH_BIN_SIZE : 0xa8000                                                     |
|  FLASH_NEED_SIZE : 0xff000                                                    |
|  FLASH_REAL_SIZE : 0x200000                                                   |
|  VM_REAL_SIZE : 0x56000                                                       |
|  VM_START_ADDR : 0xa8000                                                      |
|  VM_END_ADDR : 0xfe000                                                        |
|  BTIF_RESERVED_SIZE : 0x1000                                                  |
|  BTIF_RESERVED_START : 0xfe000                                                |
|  BTIF_RESERVED_END : 0xff000                                                  |
|  LAVE_SIZE : 0x4c000                                                          |
|  ENTRY_ADDR : 0x4000100                                                       |
|  ERASE MODE : NONE                                                            |
|  UBOOT VERSION : 2024-09-18 10:32:36,uboot-$-@20240918-$415752f               |
|  OTA VERSION : 2025-06-23 09:37:59,OTA_LOADER-$-@20250623-$a474984f           |
|  LOADER VERSION : 2024-09-18 10:40:27,loader-$-@20240918-$26605d0             |
---------------------------------------------------------------------------------
ISDdownload
开始下载……
Write sector:167 .166 .165 .164 .163 .162 .161 .160 .
Write block:9 .8 .7 .6 .5 .4 .3 .2 .1 .0 .
下载完毕。
子目录或文件 ..\..\..\..\..\output\DB47_JL7096D6_git_e9c1458a_2026_01_30  已经存在。
已复制         1 个文件。
已复制         1 个文件。
已复制         1 个文件。
已复制         1 个文件。
已复制         1 个文件。
已复制         1 个文件。
make[1]: Leaving directory 'D:/work_project/JL/AC709N/SDK'
Build completed: all.
 *  终端将被任务重用，按任意键关闭。 
```

#### 从日志提取的核心 Flash 布局信息

| 项目                | 值                | 说明                                                         |
| ------------------- | ----------------- | ------------------------------------------------------------ |
| 在线 Flash ID       | 856015            | 通常是 8Mbit 或 16Mbit 的 NOR Flash（常见 85 系列是兆易创新的） |
| 在线 Flash 实际大小 | **2M** (0x200000) | 芯片焊的是 **2MB** Flash                                     |
| FLASH_BIN_SIZE      | 0xa8000           | 当前固件主体（app + uboot + tone + res 等）打包占用的大小 ≈ **672KB** |
| FLASH_NEED_SIZE     | 0xff000           | 工具认为需要的最小 Flash 空间（几乎填满 1MB）                |
| VM_REAL_SIZE        | **0x56000**       | **VM（掉电存储区）** 大小 = **344KB**                        |
| VM_START_ADDR       | **0xa8000**       | VM 起始地址 = **672KB** 位置                                 |
| VM_END_ADDR         | **0xfe000**       | VM 结束地址 = **1016KB** 位置                                |
| BTIF_RESERVED_SIZE  | 0x1000            | BTIF（蓝牙配对信息等保留区）大小 = **4KB**                   |
| BTIF_RESERVED_START | **0xfe000**       | BTIF 起始 = **1016KB**                                       |
| BTIF_RESERVED_END   | **0xff000**       | BTIF 结束 ≈ **1020KB**                                       |
| LAVE_SIZE           | **0x4c000**       | 剩余空间 ≈ **304KB**（从 0xff000 到 0x1fffff）               |
| ENTRY_ADDR          | 0x4000100         | 程序入口地址（code 运行起始地址，通常固化在 0x4000000 区域） |

推导出的完整 Flash 布局（2MB 版本）

| 地址范围            | 大小                     | 内容说明                                                 | 备注                   |
| ------------------- | ------------------------ | -------------------------------------------------------- | ---------------------- |
| 0x000000 ~ 0x102600 | ~64KB+                   | uboot.boot + boot info / vector                          | 由 -boot 0x102600 指定 |
| 0x102600 ~ 0xa8000  | ≈ 672KB– bootloader 部分 | app.bin 主程序 + tone + resource + p11 + stream 等打包区 |                        |
| 0xa8000 ~ 0xfe000   | **0x56000 (344KB)**      | **VM区**（配对信息、音量、EQ、自定义配置等掉电保存）     | 最重要用户数据区       |
| 0xfe000 ~ 0xff000   | **0x1000 (4KB)**         | **BTIF 蓝牙保留区**（经典蓝牙 + BLE 配对信息等）         |                        |
| 0xff000 ~ 0x1fffff  | **0x4c000 (304KB)**      | **空闲 / 可用于 OTA / 差分包 / 扩展数据**                | 目前没用               |

这份日志已经把最重要的几个分界点都告诉你了：

- 固件主体结束于 **0xa8000 - 1**
- VM 从 **0xa8000** 开始，占 **0x56000**
- 最后 4KB 预留给 BTIF
- 总 Flash 是 **2MB**

如果你想进一步确认：

1. 看 sdk 里的 isd_config.ini 文件（里面通常有更详细的 [FLASH] 和 [VM] 配置）
2. 看 post_build 阶段生成的 update.ufw 或 app.bin 的 map 文件（如果有生成）
3. 用 isd_download.exe 的 -info 参数单独读取 Flash 信息

## flash布局与通用布局

### 当前工程的 Flash 布局详解

这个布局由 uboot + 固件打包 + isd_download 工具动态生成，VM/BTIF 等数据区会自动后移对齐（ini 中 VM_ADR=0 表示自动计算）。核心是**保护用户数据区**，避免升级覆盖配置。

- 0x000000 ~ 0x102600（约 65KB，uboot + boot info）：
  - **作用**：启动引导区。包含 uboot.boot（引导加载器）和 boot_info（中断向量、栈、MMU TLB 等）。芯片上电后先从这里运行，初始化硬件、加载主程序。
  - **为什么重要**：确保系统启动稳定。日志中 -boot 0x102600 指定结束地址。
- 0x102600 ~ 0xa7fff（约 672KB，固件主体：app + overlays + resources）：
  - **作用**：主程序代码和数据区。包括 .text（核心函数，如蓝牙 HCI、SDP）、.data_code/.data_code_z（压缩代码/数据，如 power_app.c）、.overlay_*（动态模块，如 overlay_aec 为回声消除、overlay_init 为初始化）、tone（提示音）、res（资源文件）、p11/stream（协处理器/流数据）。
  - **为什么重要**：运行时主体。日志 sections 显示 .text 占 0x8f428（~572KB），overlays 独立加载到 RAM，支持热更新。压缩（如 data_code_z 压缩率 78.8%）节省空间。
- 0xa8000 ~ 0xfdfff（0x56000 = 344KB，VM 区）：
  - **作用**：掉电存储区（Volatile Memory 的非易失模拟）。用 Key-Value 方式存用户配置，如音量、EQ 参数、LED 模式、配对标志、自定义数据。支持双备份 + 磨损均衡（wear leveling），防止 Flash 擦写次数过多损坏。
  - **为什么重要**：用户数据核心。ini 中 VM_LEN=40K 是默认，实际扩到 344KB 因为工程 VM 条目多（日志 OTA INFO 显示 VM=0x56000）。读写用 JL API（如 vm_write/read）。
- 0xfe000 ~ 0xfefff（0x1000 = 4KB，BTIF 保留区）：
  - **作用**：蓝牙专用保留区。存经典蓝牙/BLE 配对信息、设备地址、链路密钥等。ini 中 BTIF_ADR=AUTO + BTIF_LEN=0x1000，自动放 VM 后。
  - **为什么重要**：蓝牙重连依赖它。升级时保护不擦除，避免重新配对。
- 0xff000 ~ 0x1fffff（0x4c000 = 304KB，剩余空闲区）：
  - **作用**：未用空间。可自定义存储大文件（如 OTA 差分包、日志、厂商数据）、扩展 OTA、或未来固件升级缓冲。
  - **为什么重要**：灵活性。日志 FLASH_NEED_SIZE=0xff000 表示当前只需 ~1MB，剩余防碎片。

**总体特点**：工具自动计算（VM/BTIF 后移），支持 OTA 保护（ERASE MODE=NONE）。总占用 ~1MB，剩余 1MB 空闲。

### 与通用嵌入式 Flash 布局比较

通用嵌入式 MCU（如 STM32、ESP32、Nordic nRF）Flash 布局更**静态/固定**（由链接脚本 .lds 定义，烧录工具如 OpenOCD/J-Link 不自动调整），强调**代码 + 只读数据 + 配置**分离。而 JL 的布局**动态 + 用户数据导向**，适合消费电子（如耳机/TWS）的频繁配置变更。

- 相似点：
  - **引导区**：通用也有 bootloader（0x000000 ~ 几KB/几十KB），作用同（初始化 + 跳转 app）。
  - **代码区**：通用主 Flash 前半部放 .text/.rodata（代码 + 常量），类似 JL 的 0x102600 ~ 0xa8000。大小依固件而定。
  - **数据区**：通用用后半部或单独 EEPROM/Flash 分区存 NVM（如配置），类似 VM/BTIF。
  - **空闲/OTA**：通用常留尾部给 OTA（如 ESP32 的 OTA 分区 0xE0000 ~），JL 剩余区也支持 diff_ota。
- 不同点：
  - **动态 vs 静态**：JL 用工具动态后移 VM/BTIF（基于固件大小），防覆盖；通用固定地址（如 STM32 VM 在 0x080E0000），改固件易冲突。
  - **数据管理**：JL VM 是**结构化 KV 存储 + 磨损均衡**（自动处理擦写寿命），通用多用 raw Flash 或外部 EEPROM，需手动管理。
  - **模块化**：JL 重 overlays（动态加载，节省 RAM/Flash），通用少见（多静态链接）。
  - **大小/用途**：JL 偏消费（大 VM 存音频/蓝牙配置），通用（如汽车 MCU）更重安全（加密分区）；JL 2MB 常见，通用从 128KB 到 16MB 不等。
  - **升级友好**：JL OTA 内置多模式（BLE/SD/USB）+ 保护数据；通用需自定义 bootloader 支持 DFU/OTA。

**总结比较**：JL 布局更“智能/用户友好”（自动调整 + 数据保护），适合量产耳机；通用更“底层/灵活”，但需开发者手动规划。实际项目中，JL 的 VM 设计大大简化了配置持久化。

## 结合工作

**那一部分是随着代码修改生成的固件而修改的？OTA的单备份与双备份在那一部分？什么作用？那一部分是厂商固定的？我在代码里可以选择是否擦除VM？这又会影响那一部分？产生什么影响？**

### 哪一部分随着代码修改生成的固件而修改的？

**最主要变化的是固件主体区**（日志中从 0x102600 开始，到 ≈0xa8000 结束，约 672KB）

- 包括：.text（核心代码）、overlays（如 overlay_aec、overlay_init）、.data_code / .data_code_z（压缩代码/数据）、tone（提示音）、res（资源）、p11/stream 等。
- **任何改动**（改 C 文件、加函数、改宏、调整资源文件、改 overlay 分配）都会导致这个区域的内容、大小、符号地址、checksum 变化。
- VM 区、BTIF 区、剩余空闲区 **通常不直接变化**（除非你在新代码里主动调用 vm_write() 写入新值，或打包工具把新数据塞进剩余区）。

### OTA 的单备份与双备份在哪一部分？什么作用？

| 区域             | 地址范围           | 大小   | 备份类型                 | 作用与机制                                                   |
| ---------------- | ------------------ | ------ | ------------------------ | ------------------------------------------------------------ |
| 固件主体         | 0x102600 ~ 0xa7fff | ≈672KB | **单备份**               | OTA 升级直接覆盖或差分 patch 这里。没有内置双份，失败靠 loader/uboot 回滚（如果有旧版本缓冲）。目的是节省 Flash 空间，效率优先。 |
| VM（用户配置）   | 0xa8000 ~ 0xfdfff  | 344KB  | **双备份**（默认）       | JL VM 内部实现**两份 KV 数据 + 标记 + 版本号**。写入：先写备份份 → 成功再更新主份并切换标记。读取：优先主份，失败读备份份。同时带磨损均衡。**作用**：防止升级/写入/断电导致用户所有配置彻底丢失（EQ、音量、按键、语言等）。 |
| BTIF（蓝牙配对） | 0xfe000 ~ 0xfefff  | 4KB    | **单备份**（但升级保护） | 存放经典蓝牙/BLE 链路密钥、地址等。没有双备份，但升级时默认不擦除。**作用**：保证升级后不用重新配对所有设备。 |

一句话总结：VM 是唯一内置双备份的高可靠性区；固件主体是单备份 + OTA 回滚；BTIF 靠“不擦除”间接保护。

### 哪一部分是厂商固定的？

**基本固定、不建议/很难改动的部分**（量产后几乎不动）：

- **uboot + boot info 区**（0x000000 ~ 0x1025ff，约65KB）：启动代码、中断向量、MMU TLB、Flash ID 检测、烧录参数等。厂商锁死，改动极易变砖。
- **BTIF 区的保护机制**：布局固定 + 升级不擦除的策略（BTIF_OPT=1）。
- **VM 的整体机制**：双备份 + 磨损均衡 + “VM 自动放在固件后对齐”的逻辑，由 SDK 底层实现，厂商一般不改。
- **Flash 总容量检测、SPI 时序参数、芯片版本校验**：这些在 uboot 和 isd_download 工具里硬编码。

厂商最在意的是 **uboot 不动** + **VM/BTIF 保护机制不动**，因为这直接决定量产良率和用户体验。

### 在代码里可以选择是否擦除 VM？这会影响哪一部分？产生什么影响？

```bash
#define CONFIG_VM_OPT     1    // 1 = 升级时**不擦除** VM   0 = 擦除 VM
#define CONFIG_BTIF_OPT   1    // 1 = 升级时**不擦除** BTIF  0 = 擦除 BTIF
```

- **最终生效的是固件里编译进去的宏值**（优先级高于 ini 文件的 VM_OPT / BTIF_OPT）。

#### 如果把 CONFIG_VM_OPT 改为 0：

- **影响的区域**：整个 VM 区（0xa8000 ~ 0xfdfff，344KB）在**每次固件升级（全量/OTA）时会被整块擦除**。

- 产生的影响

  （非常严重，通常强烈不推荐）：

  1. 用户所有掉电保存的配置**瞬间清零**：EQ 设置、音量、LED 模式、按键自定义、闹钟、语言选择、一些标志位等全部丢失。
  2. 升级后设备像出厂新机，用户需要重新设置一切 → 体验极差，投诉率高。
  3. VM 双备份机制也没用了，因为整块被擦。

- **极少数会设 0 的场景**：重大协议/结构变更需要强制重置所有 VM 条目、调试阶段、出厂第一版烧录。但正常量产/升级包都保持 1。

#### 如果把 CONFIG_BTIF_OPT 改为 0：

- **影响**：升级时擦除 BTIF 区 → 所有蓝牙配对信息清空。
- **后果**：升级后必须重新配对所有手机/设备，用户很烦。
- **几乎所有项目都保持 1**，这是蓝牙体验的核心保护。

### 擦除VM的现象

#### 为什么重新烧录后蓝牙还能直接连接（无需重新配对）？

因为你当前设置下，**isd_download 工具在烧录时没有擦除 VM 和 BTIF 区**：

- BTIF 区（0xfe000 ~ 0xfefff，4KB）

  ： 存放经典蓝牙 + BLE 的配对信息（链路密钥、设备地址、绑定标志等）。 当 CONFIG_BTIF_OPT = 1（默认/推荐值）时：

  - 烧录/OTA 时**不擦除、不覆盖**这个区。
  - 所以旧配对记录完整保留，手机/电脑看到耳机还是“已配对设备”，直接连上（可能秒连）。

- **VM 区（0xa8000 ~ 0xfdfff，344KB）**： 虽然主要存用户配置（音量、EQ、LED 等），但有些项目也会在 VM 里存部分**蓝牙相关标志**（如 TWS 角色、最近连接设备 ID 等）。 CONFIG_VM_OPT = 1 时：升级不擦 VM → 这些标志也保留。 → 结合 BTIF 完整，整体表现为“蓝牙直接连上”。

- 烧录流程实际做了什么

  （当两个 OPT 都为 1）：

  1. 擦除/覆盖 **uboot + 固件主体区**（0x000000 ~ 0xa7fff）。
  2. **跳过** VM 和 BTIF 的擦除/写入（或只写保护标记）。
  3. 剩余空闲区通常也不动。 → 结果：新固件运行起来，但“用户侧数据”几乎没变 → 蓝牙像没升级一样直接连。

#### 这就是“没烧录成功”的错觉来源

- 视觉/听觉上：耳机提示音、LED 行为、音量默认值等如果没大改，升级前后几乎一样。
- 蓝牙直接连：最明显的“没变”信号。
- 但其实固件已经更新了（你可以验证版本号、改动功能、新增日志、改 power_app.c 后的功耗等）。

#### 如何确认“真的烧录成功了”？

1. 改一个小明显功能测试：
   - 改提示音（tone 文件）、改 LED 闪烁模式、加个串口 log 输出版本号。
   - 重新烧录 → 如果这些变了，就证明主体区更新成功了（蓝牙连上不代表没更新）。
2. **读回 Flash 比对**： 用 isd_download.exe -read flash.bin（或类似命令）读出整片 Flash。 对比旧/新 flash.bin 的 0x102600 ~ 0xa8000 部分（用 Beyond Compare 或 hex 编辑器），主体区应该不同。
3. **看版本字符串**： 如果固件有显示版本的 UI/语音/APP 支持，升级后查版本。
4. **临时改 OPT 测试**： 把 CONFIG_BTIF_OPT 改成 0，重新编译烧录 → 蓝牙必须重新配对 → 证明之前确实是保护了 BTIF。

### OTA是否擦除VM

远程 OTA 升级时是否擦除 VM（以及 BTIF），最终取决于上传的固件（新固件）中编译进去的 CONFIG_VM_OPT / CONFIG_BTIF_OPT 值。

#### 为什么这么说？（JL SDK OTA 机制的核心逻辑）

1. 这些宏是编译时嵌入固件的：
   - \#define CONFIG_VM_OPT 1 和 #define CONFIG_BTIF_OPT 1 通常在 app_config.h、board_xxx_cfg.h 或类似配置文件中定义。
   - 它们会被编译进**主固件（app.bin）**，具体存放在固件主体区（0x102600 ~ 0xa8000 左右）的某个配置表或 header 中。
   - OTA loader（或 uboot/loader）在升级流程中会**先读取新固件里携带的这些 OPT 值**，然后据此决定行为。
2. OTA 升级流程中擦除决策的实际顺序：
   - 用户端发起 OTA（测试盒 BLE/经典、APP、SD/USB 等）。
   - 设备进入升级模式 → loader 接收新固件（ota.bin 或 diff_ota.bin）。
   - loader 解析新固件的 header / 配置区 → 读取其中的 CONFIG_VM_OPT 和 CONFIG_BTIF_OPT。
   - 根据值决定：
     - 如果新固件里是 **1** → **不擦除** VM / BTIF（保留用户配置和蓝牙配对）。
     - 如果新固件里是 **0** → **擦除** VM / BTIF（相当于强制重置用户数据/配对）。
   - 擦除/不擦除后，才写入新固件主体区。
   - VM 和 BTIF 的擦除操作由 loader 执行（不是旧固件决定）。
3. isd_config.ini 的 VM_OPT / BTIF_OPT 是次要的：
   - ini 文件里的值只是**默认/模板**（用于 USB 烧录或某些 loader 行为）。
   - 但在**远程 OTA** 中，**优先级是新固件里的宏**（因为 ini 不随 OTA 包上传）。
   - 所以如果你上传一个 CONFIG_VM_OPT=0 的固件，即使旧固件和 ini 都是 1，也会擦除 VM。
4. 你之前观察到的现象（重新 USB 烧录后蓝牙直接连）：
   - USB 烧录（isd_download.exe）会同时参考 ini 和固件里的宏，但通常**以固件宏为主**。
   - 只要你上传的固件保持 CONFIG_VM_OPT=1 和 CONFIG_BTIF_OPT=1，VM/BTIF 就不会被擦 → 蓝牙配对保留 → “像没升级一样”的感觉。
   - 这正是 OTA 设计的目标：让大多数升级“无缝”，用户不用重新配对或重设 EQ/音量。

# JL芯片的选型与性能

## 以JL708为基准，逐步裁剪

| 项目               | JL708（全功能） | JL709N（裁剪） | JL710X（再裁剪） |
| ------------------ | --------------- | -------------- | ---------------- |
| **处理器**         | 双核 192MHz     | 双核 192MHz    | ❌ 单核           |
| **SRAM**           | 384KB           | ❌ 320KB        | ❌ 240KB          |
| **NPU**            | ✅ 有            | ❌ 无           | ❌ 无             |
| **Long Range BLE** | ✅ 有            | ❌ 无           | ❌ 无             |
| **接收灵敏度@BR**  | -98dBm          | ❌ -97dBm       | ❌ -94dBm         |
| **AoD**            | ✅ 有            | ✅ 有           | ❌ 无             |
| **DAC SNR**        | 119dB           | ❌ 113dB        | ❌ 未明确         |
| **SPDIF接口**      | ❌ 无            | ✅ 有           | ❌ 无             |
| **CAN控制器**      | ❌ 无            | ✅ 有           | ❌ 无             |
| **PMU充电**        | 220mA           | ❌ 180mA        | ❌ 无             |
| **Buck DC-DC**     | 2~3路           | ❌ 2路          | ❌ 无             |
| **灯带控制器**     | ✅ 有            | ✅ 有           | ❌ 无             |

------

**裁剪逻辑总结：**

- **709N** = 708去掉NPU、降低SRAM和灵敏度，但保留双核和PMU，并独有SPDIF和CAN
- **710X** = 709N再去掉双核、PMU、灯带，进一步缩减SRAM，主打轻量低成本

> 值得注意的是**SPDIF和CAN是709N独有的**，708反而没有，说明不是纯粹的裁剪关系，各系列针对不同场景有一定差异化设计。

## NPU（神经网络处理单元）

专门用于AI推理加速，在耳机场景中可用于：

- **智能降噪**：AI识别环境声并精准消除
- **语音唤醒**：低功耗识别"嘿Siri"类指令
- **声纹识别**：识别用户身份
- **自适应音效**：根据用户习惯自动调整EQ

## Long Range BLE

蓝牙长距离模式，牺牲速率换取更远连接距离：

- 标准BLE约10米，Long Range可达**100米以上**
- 适合**运动场景**（跑步、骑行）防止信号断连
- 也适合**工业/定位**应用场景

## AoA / AoD（蓝牙定位）

- **AoA**（到达角）：接收端测量信号角度定位
- **AoD**（出发角）：发射端控制定位
- 两者结合可实现**厘米级精度室内定位**
- 耳机应用：防丢失定位、寻找功能

## SPDIF接口

- 索尼/飞利浦数字音频接口
- 支持无损数字音频传输
- 709N独有，说明**更偏向高端音频设备**，如DAC、功放对接场景

## CAN控制器

- 原本是**汽车总线协议**
- 709N独有，说明可能针对**车载音频**场景设计
- 抗干扰能力强，适合复杂电磁环境

------

## PMU（电源管理单元）

集成在芯片内部，减少外围器件：

- **充电管理**：直接管理锂电池充电
- **Buck DC-DC**：高效降压，延长续航
- **LDO**：稳压供电
- 708/709有PMU，710X没有，意味着**710X需要外接PMU芯片**，增加BOM成本

------

## DAC SNR（信噪比）

- 衡量音频输出纯净度，越高越好
- 710X未明确 < 709N 113dB < 708 **119dB**
- 119dB已达到**专业音频级别**，人耳极限约120dB

