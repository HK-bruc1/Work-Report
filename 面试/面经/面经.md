# C语言的编译过程

```c
源文件(.c) + 头文件(.h)
    ↓
【1. 预处理】 (Preprocessing) 主要是宏替换和头文件插入
    ↓
预处理后的文件(.i)
    ↓
【2. 编译】 (Compilation) 主要是语法以及语义检查
    ↓
汇编代码(.s)   这里已经是汇编语言代码了 已经与具体 CPU 指令集（如 ARM / RISC-V / x86）绑定
    ↓
【3. 汇编】 (Assembly)   
    ↓
目标文件(.o)    机器码（目标文件） 这里将汇编语言转成了机器码
    ↓
【4. 链接】 (Linking)
    ↓
可执行文件(ELF/bin)
```

## 既然已经是机器码，为什么还要“链接”？

**目标文件 `.o` 不是一个“完整的程序”**
 **它是“未解决引用 + 未确定地址”的机器码碎片**

### 目标文件中的地址是“未确定的”

```c
// main.c
extern void foo(void);

int main(void) {
    foo();
}
编译并汇编后：
main.o    
```

每个目标文件：

- **只知道自己定义了什么**
- **不知道别人定义了什么**
- 通过“符号名”进行逻辑引用

```c
main.o  →  foo
foo.o   →  foo 的实现
```

但：

- `main.o` **并不知道 `foo.o` 是否存在**
- 也不知道 `foo.o` 最终会被放到内存的哪个地址

### 链接器主要做：

#### 符号解析（Symbol Resolution）

- 找到：
  - `main.o` 中引用的 `foo`
  - 对应哪一个 `.o` 或 `.a` 提供了 `foo`
- 如果找不到 → **链接错误**
- 如果找到多个 → **重复定义错误**

### 链接后生成的文件

```c
.c
 ↓
.o
 ↓  ← 链接器在这里工作
.elf   ← 真正的“链接结果”
 ↓  ← 工具转换（objcopy）
.bin / .hex / ufw

```

## 怎么变成固件的

**嵌入式烧录用的所有固件文件，本质上都来源于链接生成的 `.elf`**
 **`.hex / .bin / .ufw / .fw` 都是由 `.elf` 经工具转换、封装后的结果**

几乎所有厂商的 `.fw / .ufw / .img / .pack`
 都是：`.elf` →（提取段）→（加头）→（加校验 / 加密 / 签名）→ 私有格式.

# 静态库和动态库的区别

**静态库（Static Library）**

- 在**编译链接时**，库代码被**完整复制**到可执行文件中
- 生成的可执行文件**包含**所有需要的代码
- 运行时**不依赖**库文件

**动态库（Dynamic Library）**

- 在**编译链接时**，只记录库的**引用信息**
- 生成的可执行文件**不包含**库代码
- 运行时**需要加载**库文件

## .a文件中都有什么？

静态库（`.a`文件）本质上是**一堆目标文件（.o）的打包集合**，类似一个"归档文件"。

```c
libmath.a = {
    add.o      (编译后的机器码)
    subtract.o (编译后的机器码)
    multiply.o (编译后的机器码)
}
```

### 静态库里包含什么？

**1.编译后的机器码**

- **不是**源代码（`.c`文件）
- **不是**中间代码
- **是**已经编译好的**机器指令**（二进制）

**2. 符号表**

- 函数名、变量名等符号信息
- 用于链接时查找和匹配

**3. 重定位信息**

- 地址还未最终确定
- 链接时会被"填充"到正确的地址

### 使用静态库

```c
sdk/
├── include/
│   └── sdk_api.h      ← 专门声明库函数的头文件
└── lib/
    └── libsdk.a       ← 对应的静态库实现
```

在makefile中添加静态库的路径与对应头文件的路径。

# C语言中定义与声明的区别是什么？

**核心区别：**

- **声明（Declaration）**：告诉编译器"有这个东西存在"，不分配内存
- **定义（Definition）**：不仅声明，还要"创建这个东西"，会分配内存

**关键原则：**

- 声明可以**多次**
- 定义只能**一次**（同一作用域内）

## 结构体的声明与定义

它的声明和定义都可以放在头文件或源文件中，这和变量、函数不太一样。

**结构体的特殊性：**

结构体的**定义**（包含成员的完整定义）实际上**不分配内存**，它只是定义了一个**类型模板**。真正分配内存的是**创建结构体变量**的时候。

**结构体定义**（完整类型）：既可以在头文件，也可以在源文件 ✅

**结构体声明**（不完整类型）：既可以在头文件，也可以在源文件 ✅

**创建结构体变量**：

- **定义变量**：通常在源文件 ✅
- **声明变量**：可以在头文件（用`extern`）⚠️

# JL芯片是什么架构？



## 指令集就是CPU架构吗？

当我们说"芯片架构"或"CPU架构"时，通常确实是指处理器基于什么**指令集架构**（ISA，Instruction Set Architecture）。

常见的指令集架构包括：

- **x86/x86-64**：Intel和AMD的桌面和服务器处理器使用，如Intel Core系列、AMD Ryzen系列
- **ARM**：广泛用于移动设备、嵌入式系统，近年也进入桌面和服务器领域，如Apple M系列芯片、高通骁龙
- **RISC-V**：开源指令集，日益受到关注
- **MIPS**、**PowerPC**等：在特定领域使用

处理器架构确实是一切的起点，不同架构需要不同的编译器后端来生成相应的机器码。

**核心要点：**

1. **同一份C语言源代码** → 在不同架构上编译 → **生成完全不同的机器码**
2. **原因就是指令集不同**：
   - x86架构的处理器只能理解x86指令
   - ARM架构的处理器只能理解ARM指令
   - RISC-V架构的处理器只能理解RISC-V指令
3. **机器码是处理器直接执行的二进制指令**，必须符合该处理器的指令集规范

## GCC跨平台的本质

```c
C语言源代码
    ↓
【前端】统一解析C语言语法 ← 这部分所有平台相同
    ↓
【中间层】优化，生成中间表示(IR)
    ↓
【后端】根据目标架构选择不同的代码生成器 ← 关键在这里
    ↓
├─ x86后端 → 生成x86指令集的机器码
├─ ARM后端 → 生成ARM指令集的机器码
├─ RISC-V后端 → 生成RISC-V指令集的机器码
└─ MIPS后端 → 生成MIPS指令集的机器码
```

**所以GCC的"跨平台"本质是：**

- **前端**：只需要写一次（理解C语言）
- **后端**：针对每种架构都要单独实现（生成该架构的机器码）

## 移植操作系统

现在的操作系统一般都采用分层设计，架构相关层的代码使用不同的架构指令集实现，其他架构无关代码都是使用同一的抽象接口对外提供。以通用操作系统为例，内核大致分为三部分，架构无关层，硬件抽象层，架构相关层。

1. 架构相关层针对不同指令集分别实现
2. 使用统一的抽象接口向上提供。

```c
┌─────────────────────────────────────┐
│      应用程序 (用户空间)              │ ← 统一接口，架构无关
├─────────────────────────────────────┤
│  系统调用接口 (POSIX/Win32 API)      │ ← 统一接口
├─────────────────────────────────────┤
│                                     │
│         操作系统内核                 │
│  ┌─────────────────────────────┐   │
│  │ 架构无关层                   │   │ ← 进程调度、文件系统、
│  │ (通用内核代码)               │   │   网络协议栈等
│  └─────────────────────────────┘   │
│  ┌─────────────────────────────┐   │
│  │ 硬件抽象层 (HAL)             │   │ ← 统一抽象接口
│  └─────────────────────────────┘   │
│  ┌─────────────────────────────┐   │
│  │ 架构相关层                   │   │ ← 针对不同指令集的实现
│  │ arch/x86/ | arch/arm/ 等    │   │
│  └─────────────────────────────┘   │
└─────────────────────────────────────┘
         ↓
      硬件 (CPU)
```



## JL芯片的flash布局

### 锁定生态（最常见）

- 布局写死在：

  - 私有链接脚本
  - 私有打包工具

- 用户：

  - 只能用 SDK
  - 不能改启动流程
  - 不能做自定义 Bootloader

  ### 降低支持成本

  公开布局意味着：

  - 用户会：
    - 改布局
    - 问“为什么起不来”
  - 厂商要：
    - 解答
    - 维护兼容性

  不公开 = 少背锅。



