# 拉取主分支会一起更新所有分支吗？

不会，使用 Git 拉取远端主分支（如 `git pull origin main`）时，**只会更新当前所在分支（如本地的 `main` 分支）及其对应的远程分支（如 `origin/main`）**，**不会自动更新所有本地分支或远程分支的引用**。

## `git pull origin main` 会做什么？

该命令相当于：

```bash
git fetch origin main
git merge origin/main
```

也就是说，它会：

- 从远程仓库 `origin` 拉取 `main` 分支的最新提交；
- 将远程的 `origin/main` 合并到当前所在的本地分支。

## 不会更新哪些分支？

- 其他本地分支（如 `dev`, `feature/test` 等）不会被更新；
- 其他远程分支（如 `origin/dev`, `origin/feature/test` 等）也不会更新。

## 如果想更新所有远程分支引用怎么办？

```bash
git fetch --all
```

该命令会从远程仓库拉取**所有分支的最新引用信息**，但不会合并到本地分支，只是更新 `origin/*` 的引用。

执行完后，远程分支的最新状态就都同步到了本地的 `origin/*` 分支，例如：

- `origin/main`
- `origin/dev`
- `origin/feature/xxx`

但你本地的实际分支（如 `main`, `dev` 等）不会被修改。

# 撤销本地提交

我本地领先远程两个提交，现在这两个领先的提交我想丢弃掉

## 先fetch再reset

为了确保远程信息是最新的：

```bash
# 获取最新的远程信息
git fetch origin

# 重置到远程分支
git reset --hard origin/main
```

### 验证结果

执行后可以检查状态：

```bash
# 查看当前状态
git status

# 查看提交历史
git log --oneline -5
```

你应该看到类似这样的输出：

```bash
Your branch is up to date with 'origin/main'.
nothing to commit, working tree clean
```

### 注意事项

- `--hard` 参数会**完全删除**这两个提交的所有更改，包括工作区的修改
- 如果你想保留这些更改到工作区，可以使用 `--mixed`（默认）或 `--soft`
- 执行前确保没有重要的未保存工作
- 如果需要，可以先创建一个备份分支：`git branch backup-branch`

这样操作后，你的本地分支就会与远程分支完全同步，那两个领先的提交会被丢弃。

## 使用undo commit

可以把最新的本地提交撤销，所有更改都暂存在工作区中，提交信息也在输入框。

**适用场景：**

- 本地开发，提交还未推送到远程仓库
- 需要完全清除某个提交的痕迹
- 重新整理提交历史

## 使用revert commit

使用 `git revert` 后，被覆盖的原始提交依然存在于 Git 历史中。

**revert 的工作原理：**

- 原始提交：完全保留，仍在提交历史中
- revert 提交：创建一个新的提交，其内容是原始提交的"逆操作"
- 最终效果：代码状态回到原始提交之前，但历史记录包含了两个提交

举个例子：

```
A --- B --- C --- D
```

如果 revert 提交 B：

```
A --- B --- C --- D --- E(revert B)
```

- 提交 B 还在历史中
- 提交 E 是新创建的 revert 提交
- 代码状态相当于 A --- C --- D

**这样设计的好处：**

1. **完整的历史记录** - 可以看到发生了什么、何时撤销的
2. **可以再次 revert** - 如果后来发现撤销是错误的，可以 revert revert 提交来恢复
3. **安全性** - 不会丢失任何信息
4. **协作友好** - 其他开发者的历史不会被破坏

这就是为什么 revert 适合已推送的提交，而 reset 适合本地未推送的提交的原因。

**它也不会影响最新的提交？**

`git revert` 不会影响最新的提交或其他任何现有提交

假设当前提交历史是：

```
A --- B --- C --- D (HEAD)
```

如果你 revert 提交 B：

```
A --- B --- C --- D --- E(revert B) (HEAD)
```

**结果：**

- 提交 A、B、C、D 都完全不受影响，内容和历史完全保持原样
- 只是新增了一个提交 E，它包含了撤销提交 B 所做更改的代码
- HEAD 指向新的 revert 提交 E

**代码状态：**

- 工作区的最终代码效果 = A + C + D 的累积效果
- 就像提交 B 从未应用过一样，但 B 的历史记录依然存在

**关键点：**

- revert 是"增量操作"，只添加新提交
- 不修改、不删除、不移动任何现有提交
- 其他分支、标签、引用都不受影响
- 完全安全，可以随时撤销 revert 操作

这就是为什么 revert 被称为"安全的撤销方式"——它通过前进来后退，而不是真正地后退。

### 总结

**E 提交本身只包含：**

- 专门用来"撤销 B 的更改"的代码
- 比如 B 添加了一行代码，E 就删除那一行
- 比如 B 删除了一个函数，E 就重新添加那个函数

**当前工作区的最终代码状态：**

- 包含：A + B + C + D + E 的累积效果
- 由于 B 和 E 互相抵消，实际效果等于：A + C + D
- 但这不是说 E 包含了 A、C、D 的功能

**更准确的理解：**

- A：添加了功能 α
- B：添加了功能 β
- C：添加了功能 γ
- D：添加了功能 δ
- E：移除功能 β（revert B）

**最终结果：**

- 工作区有功能：α + γ + δ
- 但各个提交依然独立存在，E 只负责"抵消 B"

所以 E 不是"取代"B，而是"抵消"B。B 依然存在，只是它的效果被 E 中和了。
